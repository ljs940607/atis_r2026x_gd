define("DS/VisuLoaders/ParticlesLoader",["DS/Visualization/ThreeJS_DS","DS/Visualization/Node3D","DS/Mesh/Mesh","DS/Visualization/GeometryHelper","DS/Visualization/Utils","DS/Visualization/ProxyAbstraction","DS/Animation/PropertyAnimation","DS/Visualization/SceneGraphFactory","DS/ShaderBuilders/ShaderUtils/FunctionUtils"],(function(t,e,n,a,r,o,i,s,l){"use strict";return function(e,n){var m=void 0!==n?n:null,p=[],c=null;this.load=function(e,n,u,$){var x=new o;r.setProxyFromSpec(e,x);var d=e.serverurl?e.serverurl:"";d+=e.filename?e.filename:"",x.executeGetHttpRequest(d,"text",null,(function(e){var r=JSON.parse(e),o=new t.MeshBasicMaterial({side:t.FrontSide,transparent:!0,blending:t.NormalBlending});o.activatePDSFX("PDSFXParticlesLoader");var u={nbCol:{type:"f",value:0},map0:{type:"t2",value:null},mapDim:{type:"v3",value:new t.Vector3},uTMK:{type:"f",value:16},modelMatrixInv:{type:"m4",value:new t.Matrix4}};o.setPDSFXUniforms(u);o.setPDSFXVaryings({worldPos:{type:"v3"},objPos:{type:"v3"},camPosLocal:{type:"v3"}});var x=function(t){const e=t.variableHandler,n=t=>e.floatC(t);return`\n                                ${a="MAX_STEPS",e.intC(a)} = 256;\n                                ${n("MAX_STEPS_F")} = 256.0;\n                                ${n("TM_MIN")} = 0.05;\n                                ${n("EPS")} = 0.0001;\n                                ${n("PI")} = 3.14159265;\n                                ${n("HALFPI")} = 1.57079633;\n                                ${n("ROOTTHREE")} = 1.73205081;\n                            `;var a},d={ComputeVaryingValues:function(t,e){const n=t.variableHandler,a=t.functionHandler,r=e=>t.getVarying(e);return`              \n\t\t\t\t\t\t\t\t\t${r("objPos")} = ${t.vGetAttribPosition()};\n\t\t\t\t\t\t\t\t\t${r("worldPos")} = ${o="getModelTransformation",i="v4",s=[a.prmV3("objPos")],l.FunctionHandler.callFunction(o,i,s)}.xyz;\n\t\t\t\t\t\t\t\t\t${(t=>n.vec3(t))("camPos")}  = ${t.vGetWorldEyePos()};\n\t\t\t\t\t\t\t\t\t${r("camPosLocal")} = (${(e=>t.getUniform(e))("modelMatrixInv")} * ${(t=>n.vec4(t))()}(camPos, 1.0)).xyz;\n                                `;var o,i,s}},f=x;o.setPDSFXGlobalShaderCode(f,(function(t){const e=t.variableHandler,n=t.functionHandler,a=t.bridgeFunctions,r=(t.pdsfxDefines,t.userDefines,e=>t.getTextureUniform(e)),o=e=>t.getUniform(e),i=t=>e.float(t),s=t=>e.vec2(t),l=t=>e.vec3(t),m=t=>e.vec4(t);return`\n                                ${x(t)}\n                                ${i("stepSize")} ;\n                                ${i("nbTexelsX")} ;\n                                ${i("nbTexelsY")} ;\n                                ${p="weight",e.vec3C(p)} = ${l()}(1.0, 0.04, 0.01) ;\n\n                                ${n.dF("sampleVolTex","v4",[n.prmV3("pos")])} {\n\n                                  ${i("rowID")}  = floor(pos.z / ${o("nbCol")});\n                                  ${i("rowID2")}  = rowID;\n                                  ${i("colID")}  = ${a.modulo("floor(pos.z)",o("nbCol"))};\n                                  ${i("colID2")}  = ${a.modulo("ceil(pos.z)",o("nbCol"))};\n                                  if (colID2 == 0.0) { \n                                    rowID2 = rowID2 + 1.0; \n                                  }\n\n                                  // + 0.5 ?\n                                  ${i("x1")}  = colID  * ${o("mapDim")}.x + pos.x; \n                                  ${i("x2")}  = colID2 * ${o("mapDim")}.x + pos.x;\n                                  ${i("y1")}  = rowID  * ${o("mapDim")}.y + pos.y;\n                                  ${i("y2")}  = rowID2 * ${o("mapDim")}.y + pos.y;\n                                  ${s("mapUV")}   = ${s()}(x1 / nbTexelsX, 1.0 - y1 / nbTexelsY);\n                                  ${s("mapUV2")}  = ${s()}(x2 / nbTexelsX, 1.0 - y2 / nbTexelsY);\n                                  ${m("alpha1")} = ${a.sample2DTexture(r("map0"),"mapUV")};\n                                  ${m("alpha2")} = ${a.sample2DTexture(r("map0"),"mapUV2")};\n                                  return mix(alpha1, alpha2, fract(pos.z));\n                                  //float zSlice = (1.0 - pos.y) * (mapDim.z - 1.0);\n\n                                  //float fromTopPixels = floor(zSlice) * mapDim.y + pos.z * (mapDim.y - 1.0) + 0.5;\n\n                                  //float y0 = min(fromTopPixels / (mapDim.y * mapDim.z), 1.0);\n                                  //float y1 = min((fromTopPixels + mapDim.y) / (mapDim.y * mapDim.z), 1.0);\n\n                                  //float z0 = texture2D(map0, vec2(pos.x, y0)).g;\n                                  //float z1 = texture2D(map0, vec2(pos.x, y1)).g;\n                                  \n                                  //return mix(z0, z1, fract(zSlice));/\n                                }\n\n                                ${n.dF("raymarchNoLight","v4",[n.prmV3("ro"),n.prmV3("rd")])} {\n                                  \n                                  ${l("step")}  = rd * stepSize;\n                                  ${l("pos")}  = ro;\n                                  \n                                  ${l("col")}  = vec3(0.0);\n                                  ${i("tm")}  = 1.0;\n                                  \n                                  for (${(t=>e.int(t))("i")} =0; i<MAX_STEPS; ++i) {\n\n                                    ${m("rgba")}  = ${n.cF("sampleVolTex","v4",[n.prmV3("pos")])};\n\n                                    ${i("dtm")}  = exp( -${o("uTMK")} * stepSize * dot(rgba.rgb, weight) * 0.01 );\n                                    tm *= dtm;\n                                    \n                                    col += (1.0 - 0.995*dtm) * rgba.rgb * rgba.rgb * tm;\n                                    \n                                    pos += step;\n                                    \n                                    if (tm < 0.0 || pos.x > ${o("mapDim")}.x - 1.0 || pos.x < 0.0 || pos.y > ${o("mapDim")}.y - 1.0 || pos.y < 0.0 || pos.z > ${o("mapDim")}.z - 1.0 || pos.z < 0.0) {\n                                      break;\n                                    }\n                                  }\n                                  \n                                  ${i("alpha")}  = 1.0 - tm;\n                                  return ${m()}(col / alpha, alpha);\n                                }\n                            `;var p})),o.setPDSFXOverridableFunctions(d,{ProcessFinalColor:function(t,e){const n=t.variableHandler,a=t.functionHandler,r=e=>t.getUniform(e),o=e=>t.getVarying(e),i=t=>n.vec3(t),s=n.dereference(e[0]);return`       \n\t\t\t\t\t\t\t\t\t${i("ro")}  = ${o("objPos")};\n\t\t\t\t\t\t\t\t\t${i("rd")}  = normalize(ro - ${o("camPosLocal")});\n\t\t\t\t\t\t\t\t\t\t  \n\t\t\t\t\t\t\t\t\tstepSize = max(${r("mapDim")}.x, max(${r("mapDim")}.y, ${r("mapDim")}.z)) * ROOTTHREE / MAX_STEPS_F;\n\t\t\t\t\t\t\t\t\tnbTexelsX = ${r("nbCol")} * ${r("mapDim")}.x;\n\t\t\t\t\t\t\t\t\tnbTexelsY = ${r("nbCol")} * ${r("mapDim")}.y;\n\t\t\t\t\t\t\t\t\t\t  \n\t\t\t\t\t\t\t\t\t${s} = ${a.cF("raymarchNoLight","v4",[a.prmV3("ro"),a.prmV3("rd")])};\n                                `}}),o.force=!0;for(var D=r.results.length,y=new t.Vector3(1e4,1e4,1e4),v=new t.Vector3(-1e4,-1e4,-1e4),S=0;S<D;S++)for(var h=r.results[S].positions,b=0;b<h.length;b++)h[b].X<y.x&&(y.x=h[b].X),h[b].Y<y.y&&(y.y=h[b].Y),h[b].Z<y.z&&(y.z=h[b].Z),h[b].X>v.x&&(v.x=h[b].X),h[b].Y>v.y&&(v.y=h[b].Y),h[b].Z>v.z&&(v.z=h[b].Z);var z=new t.Vector3(v.x-y.x+1,v.y-y.y+1,v.z-y.z+1),g=Math.ceil(Math.sqrt(z.z));p=[];for(S=0;S<D;S++){p[S]=new Uint8Array(4*g*g*z.x*z.y);for(b=0;b<g*g*z.x*z.y;b++)p[S][4*b]=0,p[S][4*b+1]=0,p[S][4*b+2]=0,p[S][4*b+3]=0;for(h=r.results[S].positions,b=0;b<h.length;b++){var P=h[b].X-y.x,V=h[b].Y-y.y,T=h[b].Z-y.z,w=T%g,M=(Math.floor(T/g)*z.y+V)*(g*z.x)+w*z.x+P;p[S][4*M]=255*h[b].R,p[S][4*M+1]=255*h[b].G,p[S][4*M+2]=255*h[b].B,p[S][4*M+3]=Math.min(128,255*Math.pow(2*h[b].V,.8))}}(c=new t.DataTexture(p[0],g*z.x,g*z.y,t.RGBAFormat,t.UnsignedByteType,new t.LatLongReflectionMapping,t.ClampToEdgeWrapping,t.ClampToEdgeWrapping,t.LinearFilter,t.LinearFilter)).generateMipmaps=!1,c.needsUpdate=!0;var F=null,X=new function(){this._nbLoops=5,this._duration=5e4,this.duration=function(){return this._duration},this.valueAt=function(t){var e=this._duration/this._nbLoops;return t%e/e}},U=new i({map:c,buffer:p,animate:function(e){var n=Math.floor(e*this.buffer.length);if(this.map.image.data=this.buffer[n],this.map.needsUpdate=!0,F){var a=new t.Matrix4;a.getInverse(F._occurrences[0].renderable.matrixWorld),o.updatePDSFXUniform("modelMatrixInv",a)}null!==m&&m()}},"animate",X);U.setLoop(1),U.start(),o.updatePDSFXUniform("nbCol",g),o.updatePDSFXUniform("map0",c),o.updatePDSFXUniform("mapDim",(new t.Vector3).copy(z));var I=(new a).CreateVis3DCuboid({cornerPoint:new t.Vector3,firstAxis:new t.Vector3(z.x-1,0,0),secondAxis:new t.Vector3(0,z.y-1,0),thirdAxis:new t.Vector3(0,0,z.z-1)});F=s.createMeshNode(I);var C=(new t.Matrix4).makeTranslation(y.x,y.y,y.z);return F.setSSAO(!1),F.setMatrix(C),F.setMaterial(o),n&&n(F),void($&&$())}))}}}));