define("DS/Shaders/CATCrDImageTextureShader",["DS/Visualization/ThreeJS_DS"],(function(t){"use strict";return function(e,n){e.force=!0,e.useLighting=!1,e.activatePDSFX("CATCrDImageTexture"),e.transparent=!0,e.side=t.DoubleSide;e.setPDSFXGlobalShaderCode(null,(function(t){const e=t.variableHandler;return`\n                        ${n="commonFinalColor",e.vec4G(n)};\n                    `;var n}));var r={CrD_Image_UniformColor:{type:"v4",value:n.Color},CrD_Image_UniformOpacity:{type:"f",value:n.Opacity},RefImage2DMap:{type:"t2",value:n.RefImage2DMap.map}};e.setPDSFXUniforms(r);e.setPDSFXVaryings({vTexCoord:{type:"v3"}});return e.setPDSFXOverridableFunctions({ComputeObjectPosition:function(t,e){return`\n                            return ${t.vGetAttribPosition()};\n                        `},ComputeVaryingValues:function(t,e){return`\n                            ${n="vTexCoord",t.getVarying(n)} = ${t.vGetAttribTexCoord0()}.xyz;\n                        `;var n}},{ComputeCommonValues:function(t,e){const n=t.variableHandler,r=e=>t.getUniform(e),o=e=>t.getVarying(e),a=t=>n.float(t);return`\n\t\t\t\t\t\tcommonFinalColor = ${t.bridgeFunctions.sample2DTexture((i="RefImage2DMap",t.getTextureUniform(i)),`${o("vTexCoord")}.xy`)};\n\n\t\t\t\t\t\tcommonFinalColor.a = commonFinalColor.a * ${r("CrD_Image_UniformOpacity")};\n\n\t\t\t\t\t\tcommonFinalColor.a = clamp(commonFinalColor.a, 0.0, 1.0);\n\n\t\t\t\t\t\t${a("rangeMin")}  = 0.03;\n\t\t\t\t\t\t${a("rangeMax")}  = 0.97;\n\t\t\t\t\t\t${a("factor")}  = 0.0;\n\n\t\t\t\t\t\tif(${r("CrD_Image_UniformColor")}.a > 0.0)\n\t\t\t\t\t\t{\n                            ${(t=>n.vec2(t))("texCoord")} = ${o("vTexCoord")};\n\t\t\t\t\t\t    if (texCoord.x < rangeMin) {\n\t\t\t\t\t\t        if (texCoord.y < rangeMin && texCoord.x > texCoord.y) {\n\t\t\t\t\t\t            factor = 1.0 - (texCoord.y / rangeMin);\n\t\t\t\t\t\t        }\n\t\t\t\t\t\t        else if (texCoord.y > rangeMax && texCoord.y > texCoord.x * ((rangeMax - 1.0) / rangeMin) + 1.0) {\n\t\t\t\t\t\t            factor = (texCoord.y - rangeMax) / (1.0 - rangeMax);\n\t\t\t\t\t\t        }\n\t\t\t\t\t\t        else {\n\t\t\t\t\t\t            factor = 1.0 - (texCoord.x / rangeMin);\n\t\t\t\t\t\t        }\n\t\t\t\t\t\t    }\n\t\t\t\t\t\t    else if (texCoord.x > rangeMax) {\n\t\t\t\t\t\t        if (texCoord.y < rangeMin && texCoord.y < (rangeMin / (1.0 - rangeMax)) * (1.0 - texCoord.x)) {\n\t\t\t\t\t\t            factor = 1.0 - (texCoord.y / rangeMin);\n\t\t\t\t\t\t        }\n\t\t\t\t\t\t        else if (texCoord.y > rangeMax && texCoord.x < texCoord.y) {\n\t\t\t\t\t\t            factor = (texCoord.y - rangeMax) / (1.0 - rangeMax);\n\t\t\t\t\t\t        }\n\t\t\t\t\t\t        else {\n\t\t\t\t\t\t            factor = (texCoord.x - rangeMax) / (1.0 - rangeMax);\n\t\t\t\t\t\t        }\n\t\t\t\t\t\t    }\n\t\t\t\t\t\t    else if (texCoord.y < rangeMin) {\n\t\t\t\t\t\t        factor = 1.0 - (texCoord.y / rangeMin);\n\t\t\t\t\t\t    }\n\t\t\t\t\t\t    else if (texCoord.y > rangeMax) {\n\t\t\t\t\t\t        factor = (texCoord.y - rangeMax) / (1.0 - rangeMax);\n\t\t\t\t\t\t    }\n\t\t\t\t\t\t    \n\t\t\t\t\t\t    if ((commonFinalColor.a < 10e-3) && factor > 0.0) {\n\t\t\t\t\t\t        commonFinalColor = ${(t=>n.vec4(t))()}(1.0, 1.0, 1.0, 1.0);\n\t\t\t\t\t\t        factor = (factor * 0.6) + 0.4;\n\t\t\t\t\t\t    }\n\t\t\t\t\t\t    \n\t\t\t\t\t\t    commonFinalColor = mix(commonFinalColor, ${r("CrD_Image_UniformColor")}, factor);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (commonFinalColor.a < 10e-3) {\n\t\t\t\t\t\t    discard;\n\t\t\t\t\t\t}\n                        \n                        `;var i},ComputeAlbedo:function(t,e){return"\n                            return commonFinalColor.xyz;\n                        "},ComputeOpacity:function(t,e){return"\n                            return commonFinalColor.a;\n                        "}}),e.needsUpdate=!0,e}})),define("DS/Shaders/DeferredShaders",[],(function(t){"use strict";return{}})),define("DS/Shaders/CATCrDFeltPenShader",["DS/Visualization/ThreeJS_DS"],(function(t){"use strict";return function(e,n){e.force=!0,e.useLighting=!1,e.activatePDSFX("CATCrDFeltPen"),e.transparent=!0,e.side=t.DoubleSide,e.setPDSFXPolygonOffset("Frontward1");e.setPDSFXGlobalShaderCode(null,(function(t){const e=t.variableHandler;return`\n                        ${n="commonFinalColor",e.vec4G(n)};\n                    `;var n}));var r={CrD_Base_UniformColor:{type:"v4",value:new t.Vector4(n.Color[0],n.Color[1],n.Color[2],n.Color[3])},CrD_Base_UniformCutByPlane:{type:"f",value:n.CutByPlane},CrD_Base_UniformScreenPlane:{type:"f",value:n.ScreenPlane},CrD_Base_UniformPlanePosition:{type:"v3",value:new t.Vector3(n.PlanePosition[0],n.PlanePosition[1],n.PlanePosition[2])},CrD_Base_UniformPlaneNormal:{type:"v3",value:new t.Vector3(n.PlaneNormal[0],n.PlaneNormal[1],n.PlaneNormal[2])},CrD_FeltPen_UniformThickness:{type:"f",value:n.Thickness},CrD_FeltPen_UniformLength:{type:"f",value:n.Length},CrD_FeltPen_UniformResizeUMode:{type:"f",value:n.ResizeUMode},CrD_FeltPen_UniformUMin:{type:"f",value:n.UMin},CrD_FeltPen_UniformUMax:{type:"f",value:n.UMax},CrD_FeltPen_UniformClosedWire:{type:"f",value:n.ClosedWire}};e.setPDSFXUniforms(r);e.setPDSFXVaryings({vTexCoord:{type:"v3"}});return e.setPDSFXOverridableFunctions({ComputeObjectPosition:function(t,e){return`\n                            return ${t.vGetAttribPosition()};\n                        `},ComputeVaryingValues:function(t,e){return`\n                            ${n="vTexCoord",t.getVarying(n)} = ${t.vGetAttribTexCoord0()}.xyz;\n                        `;var n}},{ComputeCommonValues:function(t,e){const n=t.variableHandler,r=e=>t.getUniform(e),o=e=>t.getVarying(e),a=t=>n.float(t),i=t=>n.vec4(t);return`\n                        \n\t\t\t\t\t\t${a("isOpenedWire")} = 1.0 - clamp(sign(${r("CrD_FeltPen_UniformClosedWire")}), 0.0, 1.0);\n\n\t\t\t\t\t\t// Pen handles pressure, we must take it into account when computing pen thickness\n\t\t\t\t\t\t//float pressure = clamp(1.02 * vTexCoord.z, 0.0, 1.0); // if pressure > 0.98 => pressure = 1.0\n\t\t\t\t\t\t// YS9 - when openning a CGR, the z value of vTextCoord is always 0?\n\t\t\t\t\t\t// see documentation: vGetAttribTexCoord0 : Returns the first texture coordinates (only up to the first two components for WebVisu).\n                        // if pressure > 0.98 => pressure = 1.0\n\t\t\t\t\t\t${a("pressure")}  = clamp(1.02 * 1.0, 0.0, 1.0); \n\t\t\t\t\t\t${a("thickness")}  = ${r("CrD_FeltPen_UniformThickness")} * pressure;\n\n\t\t\t\t\t\t${a("adjustedLength")}  = max(thickness, ${r("CrD_FeltPen_UniformLength")});\n\t\t\t\t\t\t${a("thicknessUV")}  = 0.5 * thickness / adjustedLength;\n\n\t\t\t\t\t\t${l="cornerUV",n.vec2(l)}  = ${o("vTexCoord")}.xy;\n\t\t\t\t\t\tcornerUV.y = 2.0 * (cornerUV.y - 0.5);\n                        // if cornerUV.x<thicknessUV\n\t\t\t\t\t\t${a("xUVTest1")}  = clamp(sign(thicknessUV - cornerUV.x), 0.0, 1.0);\n                        // if cornerUV.x>1.0f - thicknessUV\n\t\t\t\t\t\t${a("xUVTest2")}  = clamp(sign(cornerUV.x - (1.0 - thicknessUV)), 0.0, 1.0); \n                        // if cornerUV.x<thicknessUV => cornerUV.x = 1.0f - cornerUV.x/thicknessUV\n\t\t\t\t\t\tcornerUV.x = mix(cornerUV.x, 1.0 - cornerUV.x / thicknessUV, xUVTest1);\n                        // if cornerUV.x > 1.0f - thicknessUV => (cornerUV.x - (1.0f - thicknessUV))/thicknessUV\n\t\t\t\t\t\tcornerUV.x = mix(cornerUV.x, (cornerUV.x - (1.0 - thicknessUV)) / thicknessUV, xUVTest2);\n                        // xUVTest1 || xUVTest2\n\t\t\t\t\t\t${a("inTheCorner")} = xUVTest1 + xUVTest2; \n\t\t\t\t\t\t${a("corner")} = cornerUV.x * cornerUV.x + cornerUV.y * cornerUV.y;\n                        // true only if isOpenedWire == 1 and inTheCorner == 1 and corner > 1 as isOpenedWire and inTheCorner can only be 0 or 1\n\t\t\t\t\t\tif(isOpenedWire * inTheCorner * corner > 1.0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t    discard;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//-----------------------------------------------------------------------------------------------\n\t\t\t\t\t\t// Handle cut by plane\n\t\t\t\t\t\t//-----------------------------------------------------------------------------------------------\n                        // 0 if CutByPlane <= 0, 1 if CutByPlane > 0 \n\t\t\t\t\t\t${a("cutByPlaneActivated")}  = clamp(sign(${r("CrD_Base_UniformCutByPlane")}), 0.0, 1.0);        \n                        // 0 if ScreenPlane <= 0, 1 if ScreenPlane > 0\n\t\t\t\t\t\t${a("screenActivated")}  = clamp(sign(${r("CrD_Base_UniformScreenPlane")}), 0.0, 1.0); \n\n\t\t\t\t\t\t// We do the work in the view space\n\t\t\t\t\t\t// We compute the plane's equation: ax + by + cz + d = 0   => Normal(a, b, c), d = -dot(CrD_Base_UniformPlaneNormal, CrD_Base_UniformPlanePosition)\n\t\t\t\t\t\t${i("viewPlaneEq")}  = ${t.vGetWorldViewInvTranspMatrix()} * ${i()}(${r("CrD_Base_UniformPlaneNormal")}, -dot(${r("CrD_Base_UniformPlaneNormal")}, ${r("CrD_Base_UniformPlanePosition")}));\n\n\t\t\t\t\t\t// eye and Fragment position\n\t\t\t\t\t\t${i("fragPos")}  = ${i()}(${t.vGetViewPosition()}, 1.0);\n\t\t\t\t\t\t${i("eyePos")}  = ${i()}(0.0, 0.0, 0.0, 1.0);\n\n\t\t\t\t\t\t// The sign of the plane's equation applied to the previous position gives the side of each point\n                        // => d\n\t\t\t\t\t\t${a("eyeClip")}  = dot(viewPlaneEq, eyePos);\n\t\t\t\t\t\t${a("fragClip")}  = dot(viewPlaneEq, fragPos) + sign(eyeClip) * 10e-2;\n\n\t\t\t\t\t\t// cutByPlaneActivated == 0 => hide = 0.0\n\t\t\t\t\t\t// If both values have the same sign, they are on the same side => hide = 0.0\n\t\t\t\t\t\t// If there signs are different, they are on opposite side      => hide = 1.0\n\t\t\t\t\t\t${a("hide")}  = mix(0.0, clamp(-1.0 * sign(fragClip * eyeClip), 0.0, 1.0), cutByPlaneActivated);\n\n\t\t\t\t\t\t//-----------------------------------------------------------------------------------------------\n\t\t\t\t\t\t// Handle Resize UV\n\t\t\t\t\t\t//-----------------------------------------------------------------------------------------------\n\t\t\t\t\t\t${a("resizeMode")}  = clamp(sign(${r("CrD_FeltPen_UniformResizeUMode")}), 0.0, 1.0);\n\t\t\t\t\t\t${a("outsideLimit")}  = clamp(sign(${r("CrD_FeltPen_UniformUMin")} -  ${o("vTexCoord")}.x), 0.0, 1.0) + clamp(sign( ${o("vTexCoord")}.x - ${r("CrD_FeltPen_UniformUMax")}), 0.0, 1.0); //if((uv.x < UMin) || (uv.x > UMax)) \n\n\t\t\t\t\t\t${a("alpha")}  = mix(${r("CrD_Base_UniformColor")}.a, 0.0625 * ${r("CrD_Base_UniformColor")}.a, resizeMode * outsideLimit);\n\n\t\t\t\t\t\tcommonFinalColor = vec4(${r("CrD_Base_UniformColor")}.xyz, pressure * alpha * mix(1.0, 0.25, hide));\n                        `;var l},ComputeAlbedo:function(t,e){return"\n                            return commonFinalColor.xyz;\n                        "},ComputeOpacity:function(t,e){return"\n                            return commonFinalColor.a;\n                        "}}),e.needsUpdate=!0,e}})),define("DS/Shaders/CATCrDBallPointShader",["DS/Visualization/ThreeJS_DS"],(function(t){"use strict";return function(e,n){e.activatePDSFX("CATCrDBallPoint"),e.transparent=!0,e.side=t.DoubleSide,e.setPDSFXPolygonOffset("Frontward1");e.setPDSFXGlobalShaderCode(null,(function(t){const e=t.variableHandler,n=t.functionHandler;return`                 \n\t\t\t\t\t${r="commonFinalColor",e.vec4G(r)} ;\n\t\t\t\t\t${(t=>e.vec3G(t))("selectorColor")}  = ${(t=>e.vec3(t))()}(0., 0.45, 0.75);\n                    ${n.dF("bezierBlend","f",[n.prmF("t")])}{\n\t\t\t\t\t    return clamp((3.0 * t * t * (1.0 - t) + t * t * t), 0.0, 1.0);\n\t\t\t\t\t}\n                    `;var r}));var r={CrD_Base_UniformColor:{type:"v4",value:new t.Vector4(n.Color[0],n.Color[1],n.Color[2],n.Color[3])},CrD_Base_UniformCutByPlane:{type:"f",value:n.CutByPlane},CrD_Base_UniformScreenPlane:{type:"f",value:n.ScreenPlane},CrD_Base_UniformPlanePosition:{type:"v3",value:new t.Vector3(n.PlanePosition[0],n.PlanePosition[1],n.PlanePosition[2])},CrD_Base_UniformPlaneNormal:{type:"v3",value:new t.Vector3(n.PlaneNormal[0],n.PlaneNormal[1],n.PlaneNormal[2])},CrD_BallPoint_UniformCircleSelection:{type:"f",value:0},CrD_BallPoint_UniformRadius:{type:"v2",value:new t.Vector2(0,0)},CrD_BallPoint_UniformCenter:{type:"v2",value:new t.Vector2(0,0)}};e.setPDSFXUniforms(r);e.setPDSFXVaryings({vTexCoord:{type:"v3"}});return e.setPDSFXOverridableFunctions({ComputeObjectPosition:function(t,e){return`\n                            return ${t.vGetAttribPosition()};\n                        `},ComputeVaryingValues:function(t,e){return`\n                            ${n="vTexCoord",t.getVarying(n)} = ${t.vGetAttribTexCoord0()}.xyz;\n                        `;var n}},{ComputeCommonValues:function(t,e){const n=t.variableHandler,r=t.functionHandler,o=e=>t.getUniform(e),a=t=>n.float(t),i=t=>n.vec2(t),l=t=>n.vec4(t);return`\n                            \n\t\t\t\t\t\t${i("cornerUV")}  = ${s="vTexCoord",t.getVarying(s)}.xy;\n\n\t\t\t\t\t\t${a("alpha")}     = ${o("CrD_Base_UniformColor")}.a;\n\t\t\t\t\t\t//float pressure = clamp(1.02 * vTexCoord.z, 0.0, 1.0); // if pressure > 0.98 => pressure = 1.0\n\t\t\t\t\t\t// YS9 - when openning a CGR, the z value of vTextCoord is always 0\n\t\t\t\t\t\t// see documentation: vGetAttribTexCoord0 : Returns the first texture coordinates (only up to the first two components for WebVisu).\n                        // if pressure > 0.98 => pressure = 1.0\n\t\t\t\t\t\t${a("pressure")}  = clamp(1.02 * 1.0, 0.0, 1.0);\n\n\t\t\t\t\t\tcornerUV.y = 2.0 * (cornerUV.y - 0.5);\n\n                        // if cornerUV.x<0.25f\n\t\t\t\t\t\t${a("xUVTest1")}  = clamp(sign(0.25 - cornerUV.x), 0.0, 1.0);\n                        // if cornerUV.x>0.75f\n\t\t\t\t\t\t${a("xUVTest2")}  = clamp(sign(cornerUV.x - 0.75), 0.0, 1.0); \n                        // if cornerUV.x<0.25f => cornerUV.x = 1.0 - cornerUV.x * 4.0\n\t\t\t\t\t\tcornerUV.x = mix(cornerUV.x, 1.0 - cornerUV.x * 4.0, xUVTest1); \n                        // if cornerUV.x>0.75f => cornerUV.x = (cornerUV.x - 0.75) * 4.0\n\t\t\t\t\t\tcornerUV.x = mix(cornerUV.x, (cornerUV.x - 0.75) * 4.0, xUVTest2); \n                        // 0 if 0.25 < u < 0.75, else 1        \n\t\t\t\t\t\t${a("inTheCorner")}  = xUVTest1 + xUVTest2; \n\t\t\t\t\t\t${a("corner")}  = cornerUV.x * cornerUV.x + cornerUV.y * cornerUV.y;\n\n                        // true only if inTheCorner = 1 and corner > 1 as inTheCorner can only be 0 or 1\n\t\t\t\t\t\tif(inTheCorner * corner > 1.0) {\n\t\t\t\t\t\t    discard;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t${a("falloffU")}  = ${r.cF("bezierBlend","f",[r.prmF("cornerUV.x")])};\n\n\t\t\t\t\t\t// if inTheCorner is 1. then corner is <= 1.0 else we would have already discarded the fragment, so next line is equivalent to:\n\n\t\t\t\t\t\t// if(inTheCorner>0.0 && corner <= 1.0) => alpha = mix(0.7 * alpha, alpha, (1.0 - falloffU) * 1.0 - falloffU * bezierBlend(corner))\n\t\t\t\t\t\t// else alpha = alpha\n\t\t\t\t\t\talpha = mix(alpha, mix(0.7 * alpha, alpha, (1.0 - falloffU) * 1.0 - falloffU * ${r.cF("bezierBlend","f",[r.prmF("corner")])}), inTheCorner);\n\n\t\t\t\t\t\t//-----------------------------------------------------------------------------------------------\n\t\t\t\t\t\t// Handle cut by plane\n\t\t\t\t\t\t//-----------------------------------------------------------------------------------------------\n                        // 0 if CutByPlane <= 0, 1 if CutByPlane > 0      \n\t\t\t\t\t\t${a("cutByPlaneActivated")}  = clamp(sign(${o("CrD_Base_UniformCutByPlane")}), 0.0, 1.0);  \n                        // 0 if ScreenPlane <= 0, 1 if ScreenPlane > 0\n\t\t\t\t\t\t${a("screenActivated")}  = clamp(sign(${o("CrD_Base_UniformScreenPlane")}), 0.0, 1.0);\n\n\t\t\t\t\t\t// We do the work in the view space\n\t\t\t\t\t\t// We compute the plane's equation: ax + by + cz + d = 0   => Normal(a, b, c), d = -dot(CrD_Base_UniformPlaneNormal, CrD_Base_UniformPlanePosition)\n\t\t\t\t\t\t${l("viewPlaneEq")}  = ${t.vGetWorldViewInvTranspMatrix()} * ${l()}(\n                                                ${o("CrD_Base_UniformPlaneNormal")}, \n                                                -dot(${o("CrD_Base_UniformPlaneNormal")}, ${o("CrD_Base_UniformPlanePosition")})\n                                            );\n\n\t\t\t\t\t\t// eye and Fragment position\n\t\t\t\t\t\t${l("fragPos")}  = ${l()}(${t.vGetViewPosition()}, 1.0);\n\t\t\t\t\t\t${l("eyePos")}  = ${l()}(0.0, 0.0, 0.0, 1.0);\n\n\t\t\t\t\t\t// The sign of the plane's equation applied to the previous position gives the side of each point\n                        // => d\n\t\t\t\t\t\t${a("eyeClip")}  = dot(viewPlaneEq, eyePos); \n\t\t\t\t\t\t${a("fragClip")}  = dot(viewPlaneEq, fragPos) + sign(eyeClip) * 10e-2;\n\n\t\t\t\t\t\t// cutByPlaneActivated == 0 => hide = 0.0\n\t\t\t\t\t\t// If both values have the same sign, they are on the same side => hide = 0.0\n\t\t\t\t\t\t// If there signs are different, they are on opposite side      => hide = 1.0\n\t\t\t\t\t\t${a("hide")}  = mix(0.0, clamp(-1.0 * sign(fragClip * eyeClip), 0.0, 1.0), cutByPlaneActivated);\n\n\t\t\t\t\t\tcommonFinalColor = ${l()}(${o("CrD_Base_UniformColor")}.xyz, pressure * alpha * mix(1.0, 0.25, hide));\n\n\t\t\t\t\t\t//-----------------------------------------------------------------------------------------------\n\t\t\t\t\t\t// handle circle selection\n\t\t\t\t\t\t//-----------------------------------------------------------------------------------------------\n                        // if CircleSelection > 0 => circleSelectActivated = 1 else circleSelectActivated = 0\n\t\t\t\t\t\t${a("circleSelectActivated")}  = clamp(sign(${o("CrD_BallPoint_UniformCircleSelection")}), 0.0, 1.0);\n\n\t\t\t\t\t\t// screen coordinates of current fragment - circle center coordinates\n\t\t\t\t\t\t${i("vect")}  = ${t.vGetFragCoord()}.xy - ${o("CrD_BallPoint_UniformCenter")}.xy;\n\n\t\t\t\t\t\t${a("circleValue")}  = pow(vect.x, 2.0) / pow(${o("CrD_BallPoint_UniformRadius")}.x, 2.0) + pow(vect.y, 2.0) / pow(${o("CrD_BallPoint_UniformRadius")}.y, 2.0);\n\n\t\t\t\t\t\t// at the end, coeff is 0 if circleSelectActivated is 0 or if we are outside the selection circle\n\t\t\t\t\t\t//             coeff is 1 at the middle of the circle, slowly decreases afterward and reaches 0 on the circle border\n\t\t\t\t\t\t${a("coeff")}  = circleSelectActivated * (1.0 - clamp(circleValue, 0.0, 1.0));\n\t\t\t\t\t\t${a("selectionAlpha")}  = 0.3 * coeff + 0.7;\n\n\t\t\t\t\t\t${l("blendResult")} ;\n\n\t\t\t\t\t\tblendResult = ${l()}((selectorColor * selectionAlpha + commonFinalColor.xyz * commonFinalColor.a * (1.0 - selectionAlpha)) / selectionAlpha, \n                                                    selectionAlpha + commonFinalColor.a * (1.0 - selectionAlpha));\n\n\t\t\t\t\t\tcommonFinalColor = mix(commonFinalColor, blendResult, sign(coeff));\n                        `;var s},ComputeAlbedo:function(t,e){return"\n                            return commonFinalColor.xyz;\n                        "},ComputeOpacity:function(t,e){return"\n                            return commonFinalColor.a;\n                        "}}),e.needsUpdate=!0,e}}));