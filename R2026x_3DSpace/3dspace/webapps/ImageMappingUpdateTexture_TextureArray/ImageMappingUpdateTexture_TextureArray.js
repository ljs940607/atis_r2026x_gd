define("DS/UpdateTexture_TextureArray/UpdateTexture_TextureArray",["DS/Visualization/ThreeJS_DS"],(function(n){return function(e,o){e.force=!0,e.activatePDSFX("UpdateTexture_TextureArray_"+o.NbTerrains);e.setPDSFXVaryings({vPosition:{type:"v3"},vCol:{type:"v4"}});var r={ColoredMode:{type:"f",value:o.ColorMode},ObjectColor:{type:"v4",value:new n.Vector4(o.ObjectColor[0],o.ObjectColor[1],o.ObjectColor[2],o.ObjectColor[3])},BlendVal:{type:"f",value:o.BlendVal},TransfoTolinkedMapping:{type:"v4",value:new n.Vector4(o.TransfoTolinkedMapping[0],o.TransfoTolinkedMapping[1],o.TransfoTolinkedMapping[2],o.TransfoTolinkedMapping[3])},NbTerrains:{type:"i",value:o.NbTerrains},ColorMapTexture1:{type:"t2v",value:o.ColorMapTexture1.map,length:o.NbTerrains}};for(let e=1;e<=o.NbTerrains;e++){let t="TerrainMinMax_"+e;r[t]={type:"v4",value:new n.Vector4(o[t][0],o[t][1],o[t][2],o[t][3])}}e.setPDSFXUniforms(r);e.setPDSFXGlobalShaderCode(null,(function(n){const e=n.variableHandler;return`\n                ${o="the_color",e.vec4G(o)};\n            `;var o}));var t={ComputeCommonValues:function(n,e){const o=e=>n.getUniform(e),r=n.variableHandler;return`\n                ${t="colored_mode",r.bool(t)}  = ${o("ColoredMode")} > 0.5 ;\n                if (colored_mode)\n                {\n                \tthe_color = ${(e=>n.getVarying(e))("vCol")} ;\n                }\n                else\n                {\n                    the_color = ${o("ObjectColor")} ;\n                }\n                ${(n=>r.int(n))("NumTerrain")}  = 0;\n                ${function(n){const e=e=>n.getUniform(e),o=e=>n.getTextureUniform(e),r=n.variableHandler,t=n.bridgeFunctions,a=n=>r.vec2(n),i=n=>r.vec4(n),l=n=>r.float(n),s=n.pdsfxDefines;let p="";const u=`\n                ${a("min")}  ; \n                min.x = minmax[0] ; \n                min.y = minmax[1] ;\n                ${a("max")}  ; \n                max.x = minmax[2] ; \n                max.y = minmax[3] ;\n                ${i("the_pos")} ;\n                ${c="vPos",r.vec3(c)} = ${(e=>n.getVarying(e))("vPosition")};\n                ${i("transfoTolinkedMapping")} = ${e("TransfoTolinkedMapping")};\n                if (transfoTolinkedMapping.x != 0. && transfoTolinkedMapping.y != 0.)\n                { \n                    the_pos.x = transfoTolinkedMapping.x * vPos.x - \n                                transfoTolinkedMapping.y * vPos.y + \n                                transfoTolinkedMapping.z;\n                    the_pos.y = transfoTolinkedMapping.y * vPos.x + \n                                transfoTolinkedMapping.x * vPos.y + \n                                transfoTolinkedMapping.w;\n                }\n                else {\n                    the_pos.x = vPos.x;\n                    the_pos.y = vPos.y;\n                }\n                ${l("u")}= (the_pos.x - min.x) / (max.x - min.x) ;\n                ${l("v")} = (the_pos.y - min.y) / (max.y - min.y) ;\n                ${a("texCoord")} = ${a()}(u,v);\n            `;var c;for(let n=1;n<=1;n++){const r=`${i("color")} = ${t.sample2DTexture(o("ColorMapTexture1"),"texCoord")};`;p=`\n                    ${p}\n                    { \n                        ${i("minmax")}  = ${e("TerrainMinMax_"+n)} ;\n                        ${u}\n                        ${s.WebGPU?r:""}\n                        if (0. < u && u < 1. && 0. < v && v < 1.) { \n                            ${s.WebGPU?"":r}\n                            ${l("alpha")}  = color.a ;\n                            ${l("beta")}   = (1. - color.a) * the_color.a ;\n                            the_color = ${i()}(alpha * color.rgb + beta * the_color.rgb, alpha + beta) ;\n                        }\n                    }\n                `}return p}(n)}\n                the_color.a = the_color.a * ${o("ObjectColor.a")};\n                `;var t},ComputeAlbedo:function(n,e){return"\n                    return the_color.rgb;\n                "},ComputeRoughness:function(n,e){return"\n                    // terrain is not shiny but easily visible\n                    return 0.6;\n                "},ComputeOpacity:function(n,e){return"\n                    return the_color.a;\n                "}};return e.setPDSFXOverridableFunctions({ComputeVaryingValues:function(n,e){const o=e=>n.getVarying(e),r=n.variableHandler;return`\n                    ${o("vPosition")} = ${n.vGetAttribPosition()}.xyz;\n                    ${o("vCol")} = ${r.vec4(t)}(${n.vGetAttribColor()}, 1.);\n                `;var t}},t),e}}));