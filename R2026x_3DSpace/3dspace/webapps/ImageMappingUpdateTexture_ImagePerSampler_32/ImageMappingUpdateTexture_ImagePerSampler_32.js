define("DS/ImageMappingUpdateTexture_ImagePerSampler_32/ImageMappingUpdateTexture_ImagePerSampler_32",["DS/Visualization/ThreeJS_DS"],(function(n){return function(e,o){e.force=!0,o.NbTerrains>13&&(o.NbTerrains=13);const r=o.NbTerrains;e.activatePDSFX("ImageMappingUpdateTexture_ImagePerSampler_32_"+r);e.setPDSFXVaryings({vPosition:{type:"v3"},vCol:{type:"v4"}});var t={ColoredMode:{type:"f",value:o.ColorMode},ObjectColor:{type:"v4",value:new n.Vector4(o.ObjectColor[0],o.ObjectColor[1],o.ObjectColor[2],o.ObjectColor[3])},BlendVal:{type:"f",value:o.BlendVal},TransfoTolinkedMapping:{type:"v4",value:new n.Vector4(o.TransfoTolinkedMapping[0],o.TransfoTolinkedMapping[1],o.TransfoTolinkedMapping[2],o.TransfoTolinkedMapping[3])},NbTerrains:{type:"i",value:r}};for(let e=1;e<=r;e++){let r="TerrainMinMax_"+e,a="ColorMapTexture"+e;t[r]={type:"v4",value:new n.Vector4(o[r][0],o[r][1],o[r][2],o[r][3])},t[a]={type:"t2",value:o[a].map},t[a].value.minFilter=n.NearestFilter,t[a].value.magFilter=n.NearestFilter,t[a].value.generateMipmaps=!1}e.setPDSFXUniforms(t);e.setPDSFXGlobalShaderCode(null,(function(n){const e=n.variableHandler;return`\n                ${o="the_color",e.vec4G(o)};\n            `;var o}));var a={ComputeCommonValues:function(n,e){const o=e=>n.getUniform(e),t=n.variableHandler;return`\n                ${a="colored_mode",t.bool(a)}  = ${o("ColoredMode")} > 0.5 ;\n                if (colored_mode)\n                {\n                \tthe_color = ${(e=>n.getVarying(e))("vCol")} ;\n                }\n                else\n                {\n                    the_color = ${o("ObjectColor")} ;\n                }\n                ${(n=>t.int(n))("NumTerrain")}  = 0;\n                ${function(n){const e=e=>n.getUniform(e),o=e=>n.getTextureUniform(e),t=n.variableHandler,a=n.bridgeFunctions,i=n=>t.vec2(n),l=n=>t.vec4(n),p=n=>t.float(n),s=n.pdsfxDefines;let c="";const u=`\n                ${i("min")}  ; \n                min.x = minmax[0] ; \n                min.y = minmax[1] ;\n                ${i("max")}  ; \n                max.x = minmax[2] ; \n                max.y = minmax[3] ;\n                ${l("the_pos")} ;\n                ${v="vPos",t.vec3(v)} = ${(e=>n.getVarying(e))("vPosition")};\n                ${l("transfoTolinkedMapping")} = ${e("TransfoTolinkedMapping")};\n                if (transfoTolinkedMapping.x != 0. && transfoTolinkedMapping.y != 0.)\n                { \n                    the_pos.x = transfoTolinkedMapping.x * vPos.x - \n                                transfoTolinkedMapping.y * vPos.y + \n                                transfoTolinkedMapping.z;\n                    the_pos.y = transfoTolinkedMapping.y * vPos.x + \n                                transfoTolinkedMapping.x * vPos.y + \n                                transfoTolinkedMapping.w;\n                }\n                else {\n                    the_pos.x = vPos.x;\n                    the_pos.y = vPos.y;\n                }\n                ${p("u")}= (the_pos.x - min.x) / (max.x - min.x) ;\n                ${p("v")} = (the_pos.y - min.y) / (max.y - min.y) ;\n                ${i("texCoord")} = ${i()}(u,v);\n            `;var v;for(let n=1;n<=r;n++){const r=`${l("color")} = ${a.sample2DTexture(o(`ColorMapTexture${n}`),"texCoord")};`;c=`\n                    ${c}\n                    { \n                        ${l("minmax")}  = ${e("TerrainMinMax_"+n)} ;\n                        ${u}\n                        ${s.WebGPU?r:""}\n                        if (0. < u && u < 1. && 0. < v && v < 1.) { \n                            ${s.WebGPU?"":r}\n                            ${p("alpha")}  = color.a ;\n                            ${p("beta")}   = (1. - color.a) * the_color.a ;\n                            the_color = ${l()}(alpha * color.rgb + beta * the_color.rgb, alpha + beta) ;\n                        }\n                    }\n                `}return c}(n)}\n                the_color.r = 1. - (1. - the_color.r) * (1. - ${o("BlendVal")});\n                the_color.g = 1. - (1. - the_color.g) * (1. - ${o("BlendVal")});\n                the_color.b = 1. - (1. - the_color.b) * (1. - ${o("BlendVal")});\n                the_color.a = the_color.a * ${o("ObjectColor.a")};\n                `;var a},ComputeAlbedo:function(n,e){return"\n                    return the_color.rgb;\n                "},ComputeRoughness:function(n,e){return"\n                    // terrain is not shiny but easily visible\n                    return 0.6;\n                "},ComputeOpacity:function(n,e){return"\n                    return the_color.a;\n                "}};return e.setPDSFXOverridableFunctions({ComputeVaryingValues:function(n,e){const o=e=>n.getVarying(e),r=n.variableHandler;return`\n                    ${o("vPosition")} = ${n.vGetAttribPosition()}.xyz;\n                    ${o("vCol")} = ${r.vec4(t)}(${n.vGetAttribColor()}, 1.);\n                `;var t}},a),e}}));