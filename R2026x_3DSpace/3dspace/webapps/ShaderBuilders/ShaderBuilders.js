define("DS/ShaderBuilders/ShaderBuilder",["DS/Mesh/ThreeJS_Base"],(function(n){"use strict";var e=new Set;return class{constructor(n,t=null){this.builder=n,this.uniqueID=t,t&&e.has(t)?console.warn("Invalid Operation: "+t+" has already been declared"):t&&e.add(t)}getUniqueID(){if(!this.uniqueID)throw"Not implemented exception";return this.uniqueID}buildLib(n,e,t,r){return this.builder(n,e,t,r)}}})),define("DS/ShaderBuilders/ShaderUtils/UniformUtils",["DS/Mesh/ThreeJS_Base"],(function(n){"use strict";const e="",t={GLOBAL:"global",LIGHT:"light",MATERIAL:"material",OBJECT:"object",MATERIALHIGH:"materialhigh"},r=new Set,a={material:t.MATERIAL,pdsfx:t.MATERIAL,materialhigh:t.MATERIALHIGH,global:t.GLOBAL,postPro:t.GLOBAL,clipping:t.MATERIALHIGH,light:t.LIGHT,shadow:t.LIGHT,object:t.OBJECT};return{UBOs:t,_context:null,_addUniform:function({uniformName:t,uniformType:o,size:i=0,checkName:s=!1,uniformCategory:l=null,locationName:u=null,precision:m=null,customSetter:c=null}){const $=(this._context.isWebGPU?n.ToWGSLTypes:n.ToGLSLTypes)[o];if(!$)return console.error(`Invalid Operation: ${o} for ${t} is not a proper type`),e;if(!$.canBeUniform)return console.error(`Invalid Operation: ${o} for ${t} can not be a uniform`),e;if($.isTexture&&r.has(p))return void console.error(`Invalid Operation: ${p} does not accept uniforms of type ${o}`);if(n.ToWGSLTypes[o]&&n.ToWGSLTypes[o].canBeUniform,s&&t.startsWith("_u"))throw'Reserved naming scheme: do not start the name of your uniforms with "_u"';if(0===i&&$.isArray)return console.error(`Invalid Operation: ${o} for ${t} is not a proper array`),e;i>0&&!$.isArray&&(i=0,console.warn(`Invalid Operation: ${o} for ${t} can not be an array, overriding to single`));var p=l||"material",d=a[p];if(void 0===d)throw"Missing ubo for category "+p;let f={name:t,type:o,value:null,size:i,locationName:u||null,dynamic:!0,ubo:d,customSetter:c};return f[p+"Uniform"]=!0,this._context.__uniforms__[t]=f,this._context.isWebGPU?e:i>0?`\n                        uniform ${m||e} ${$.t} ${t}[${i}];\n                    `:`\n                    uniform ${m||e} ${$.t} ${t};\n                `},addUniform:function({uniformName:n,uniformType:e,size:t=0,locationName:r=null,precision:a=null}){return this._addUniform({uniformName:n,uniformType:e,locationName:r,precision:a,size:t,uniformCategory:"material"})},addHighFrequencyUniform:function({uniformName:n,uniformType:e,size:t=0,locationName:r=null,precision:a=null}){return this._addUniform({uniformName:n,uniformType:e,locationName:r,precision:a,size:t,uniformCategory:this._context.isWebGPU?"materialhigh":"material"})},addGlobalUniform:function({uniformName:n,uniformType:e,size:t=0,locationName:r=null,precision:a=null}){return this._addUniform({uniformName:n,uniformType:e,locationName:r,precision:a,size:t,uniformCategory:"global"})},addLightUniform:function({uniformName:n,uniformType:e,size:t=0,locationName:r=null,precision:a=null}){return this._addUniform({uniformName:n,uniformType:e,locationName:r,precision:a,size:t,uniformCategory:"light"})},addShadowUniform:function({uniformName:n,uniformType:e,size:t=0,locationName:r=null,precision:a=null}){return this._addUniform({uniformName:n,uniformType:e,locationName:r,precision:a,size:t,uniformCategory:"shadow"})},addObjectUniform:function({uniformName:n,uniformType:e,size:t=0,locationName:r=null,precision:a=null,customSetter:o=null}){return this._addUniform({uniformName:n,uniformType:e,locationName:r,precision:a,size:t,uniformCategory:"object",customSetter:o})},addPostProUniform:function({uniformName:n,uniformType:e,size:t=0,locationName:r=null,precision:a=null}){return this._addUniform({uniformName:n,uniformType:e,locationName:r,precision:a,size:t,uniformCategory:"postPro"})},addClippingUniform:function({uniformName:n,uniformType:e,size:t=0,locationName:r=null,precision:a=null}){return this._addUniform({uniformName:n,uniformType:e,locationName:r,precision:a,size:t,uniformCategory:"clipping"})},addPDSFXUniform:function({uniformName:n,uniformType:e,size:t=0,precision:r=null}){return this._addUniform({uniformName:n,uniformType:e,precision:r,checkName:!1,size:t,uniformCategory:"pdsfx"})},_getUniform({uniformName:n,uniformCategory:e,uniformIndex:t}){return this._context||(this._context={}),this._context.__fetchedUniforms__||(this._context.__fetchedUniforms__={}),this._context.__fetchedUniforms__[e]||(this._context.__fetchedUniforms__[e]={}),this._context.__fetchedUniforms__[e][n]=!0,this._context.isWebGPU?t||0===t?`${a[e]}_uniforms.${n}[${t}]`:`${a[e]}_uniforms.${n}`:t||0===t?`${n}[${t}]`:n},getUniform({uniformName:n,uniformIndex:e}){return this._getUniform({uniformName:n,uniformCategory:"material",uniformIndex:e})},getHighFrequencyUniform({uniformName:n,uniformIndex:e}){return this._getUniform({uniformName:n,uniformCategory:this._context.isWebGPU?"materialhigh":"material",uniformIndex:e})},getGlobalUniform({uniformName:n,uniformIndex:e}){return this._getUniform({uniformName:n,uniformCategory:"global",uniformIndex:e})},getLightUniform({uniformName:n,uniformIndex:e}){return this._getUniform({uniformName:n,uniformCategory:"light",uniformIndex:e})},getShadowUniform({uniformName:n,uniformIndex:e}){return this._getUniform({uniformName:n,uniformCategory:"shadow",uniformIndex:e})},getObjectUniform({uniformName:n,uniformIndex:e}){return this._getUniform({uniformName:n,uniformCategory:"object",uniformIndex:e})},getPostProUniform({uniformName:n,uniformIndex:e}){return this._getUniform({uniformName:n,uniformCategory:"postPro",uniformIndex:e})},getClippingUniform({uniformName:n,uniformIndex:e}){return this._getUniform({uniformName:n,uniformCategory:"clipping",uniformIndex:e})},getPDSFXUniform({uniformName:n,uniformIndex:e}){return this._getUniform({uniformName:n,uniformCategory:"pdsfx",uniformIndex:e})},_getTextureUniform({uniformName:n,uniformCategory:e,uniformIndex:t}){return this._context||(this._context={}),this._context.__fetchedUniforms__||(this._context.__fetchedUniforms__={}),this._context.__fetchedUniforms__[e]||(this._context.__fetchedUniforms__[e]={}),this._context.__fetchedUniforms__[e][n]=!0,t||0===t?this._context.isWebGPU?(isNaN(parseInt(t))&&console.warn(`Invalid Operation: Texture uniform ${n} must be accessed with actual integers, not ${t}`),`${n}_${t}`):n+"["+t+"]":n},getTextureUniform({uniformName:n,uniformIndex:e}){return this._getTextureUniform({uniformName:n,uniformCategory:"material",uniformIndex:e})},getGlobalTextureUniform({uniformName:n,uniformIndex:e}){return this._getTextureUniform({uniformName:n,uniformCategory:"global",uniformIndex:e})},getLightTextureUniform({uniformName:n,uniformIndex:e}){return this._getTextureUniform({uniformName:n,uniformCategory:"light",uniformIndex:e})},getShadowTextureUniform({uniformName:n,uniformIndex:e}){return this._getTextureUniform({uniformName:n,uniformCategory:"shadow",uniformIndex:e})},getObjectTextureUniform({uniformName:n,uniformIndex:e}){return this._getTextureUniform({uniformName:n,uniformCategory:"object",uniformIndex:e})},getPostProTextureUniform({uniformName:n,uniformIndex:e}){return this._getTextureUniform({uniformName:n,uniformCategory:"postPro",uniformIndex:e})},getClippingTextureUniform({uniformName:n,uniformIndex:e}){return this._getTextureUniform({uniformName:n,uniformCategory:"clipping",uniformIndex:e})},getPDSFXTextureUniform({uniformName:n,uniformIndex:e}){return this._getTextureUniform({uniformName:n,uniformCategory:"pdsfx",uniformIndex:e})},_addStorageBuffer:function({bufferName:n,bufferType:t,readOnly:r,uniformCategory:o,customSetter:i=null}){if(!this._context.isWebGPU)return console.error(`Invalid storage resource ${n} : storage resources are only supported by WebGPU.`),e;var s=o||"material";let l={type:"ssbo",name:n,bufferType:t,readOnly:r,ubo:a[s],customSetter:i};return l[s+"Uniform"]=!0,this._context.__uniforms__[n]=l,e},addStorageBuffer:function({bufferName:n,bufferType:e,readOnly:t=!1}){return this._addStorageBuffer({bufferName:n,bufferType:e,readOnly:t,uniformCategory:"material"})},addGlobalStorageBuffer:function({bufferName:n,bufferType:e,readOnly:t=!1}){return this._addStorageBuffer({bufferName:n,bufferType:e,readOnly:t,uniformCategory:"global"})},addObjectStorageBuffer:function({bufferName:n,bufferType:e,readOnly:t=!1,customSetter:r=null}){return this._addStorageBuffer({bufferName:n,bufferType:e,readOnly:t,uniformCategory:"object",customSetter:r})},_getStorageBuffer({bufferName:n,uniformCategory:t}){return this._context.isWebGPU?(this._context||(this._context={}),this._context.__fetchedUniforms__||(this._context.__fetchedUniforms__={}),this._context.__fetchedUniforms__[t]||(this._context.__fetchedUniforms__[t]={}),this._context.__fetchedUniforms__[t][n]=!0,n):(console.error(`Invalid storage resource ${n} : storage buffers are only supported by WebGPU.`),e)},getStorageBuffer(n){return this._getStorageBuffer({bufferName:n,uniformCategory:"material"})},getGlobalStorageBuffer(n){return this._getStorageBuffer({bufferName:n,uniformCategory:"global"})},getObjectStorageBuffer(n){return this._getStorageBuffer({bufferName:n,uniformCategory:"object"})}}})),define("DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils",["DS/Mesh/ThreeJS_Base"],(function(n){"use strict";const e={fragCoord:"gl_FragCoord",frontFacing:"gl_FrontFacing",sampleIndex:"gl_SampleID",sampleMaskIn:"gl_SampleMaskIn",vertexIndex:"gl_VertexID",instanceIndex:"gl_InstanceID"},t={out0:"gl_FragData[0]",out1:"gl_FragData[1]",out2:"gl_FragData[2]",out3:"gl_FragData[3]",fragDepth:"gl_FragDepth",sampleMaskOut:"gl_SampleMask",position:"gl_Position"},r={};Object.assign(r,t),Object.assign(r,{out0:"gl_FragColor",out1:"dummyFragColor",out2:"dummyFragColor",out3:"dummyFragColor"});const a={};Object.assign(a,t),Object.assign(a,{out0:"outFragColor",out1:"dummyFragColor",out2:"dummyFragColor",out3:"dummyFragColor"});const o=new Set(["vertex_index","instance_index","clip_distances","position","front_facing","frag_depth","sample_index","sample_mask","local_invocation_id","local_invocation_index","global_invocation_id","workgroup_id","num_workgroups","subgroup_invocation_id","subgroup_size"]);return{_context:null,ShaderStages:{in:"input",out:"out"},addVarying:function({varyingName:e,varyingType:t,varyingInterpolationType:r,size:a=0,checkName:i=!1,pdsfx:s=!1}){if(this._context.isWebGPU&&o.has(e))throw`Trying to add ${e} as a varying but is a webgpu builtin`;const l=(this._context.isWebGPU?n.ToWGSLTypes:n.ToGLSLTypes)[t];return l?l.canBeVarying?(n.ToWGSLTypes[t]&&n.ToWGSLTypes[t].canBeVarying,i&&"v"!==e[0]&&console.warn('Bad Practice: start the name of your varyings with "v"'),0===a&&l.isArray?(console.error(`Invalid Operation: ${t} for ${e} is not a proper array`),""):(a>0&&!l.isArray&&(a=0,console.warn(`Invalid Operation: ${t} for ${e} can not be an array, overriding to single`)),this._context.__varyings__[e]={type:t,interpolationType:void 0!==r?r:n.VaryingInterpolationTypes.PERSPECTIVE,size:a,dynamic:!0,pdsfx:s},this._context.isWebGPU?"":a>0?`\n                        varying ${l.t} ${e}[${a}];\n                    `:`\n                    varying ${l.t} ${e};\n                `)):(console.error(`Invalid Operation: ${t} for ${e} can not be a varying`),""):(console.error(`Invalid Operation: ${t} for ${e} is not a proper type`),"")},getVarying(n,e,t=null){if(this._context.isWebGPU){if(o.has(n))throw`Trying to get ${n} as a varying but is a webgpu builtin`;return null!==t?(isNaN(parseInt(t))&&console.warn(`Invalid Operation: varying ${n} must be accessed with actual integers, not ${t}`),`${e}.${n}_${t}`):`${e}.${n}`}return null!==t?`${n}[${t}]`:n},getPDSFXVarying:(n,e)=>n,getBuiltin:function(n,o){let i=o===this.ShaderStages.in?e:t;if(!i[n])throw"Unsupported builtin "+n+" for stage "+o+", given builtin may not exist in WebGPU or WebGL";return this._context.__builtins__[o]=this._context.__builtins__[o]||{},this._context.__builtins__[o][n]=!0,this._context.isWebGPU?`${o}.${n}`:(o===this.ShaderStages.out&&(1!==this._context.__features__.WebGLVersion||this._context.__features__.drawBuffers?2===this._context.__features__.WebGLVersion&&(i=a):i=r),i[n])},getShaderOutput(n){return this.getBuiltin(n,this.ShaderStages.out)},getShaderInput(n){return this.getBuiltin(n,this.ShaderStages.in)}}})),define("DS/ShaderBuilders/ShaderUtils/TypeUtils",["DS/Mesh/ThreeJS_Base"],(function(n){"use strict";const e={_context:null,_isValid:function({type:e,size:t=0,throwIfNotFound:r=!1}){const a=(this._context.isWebGPU?n.ToWGSLTypes:n.ToGLSLTypes)[e];if(!a){if(r)throw`Invalid standard type ${e}`;return!0}return 0===t&&a.isArray?(console.warn(`Invalid Operation: ${e} is not a proper array`),!1):!(t>0&&!a.isArray)||(console.warn(`Invalid Operation: ${e} is can not be an array`),!1)},struct:function({name:n,size:e=0,constant:t=!1,addressSpace:r="",structName:a}){return this._declareVariable({name:n,constant:t,type:a,size:e,addressSpace:r,throwIfNotFound:!1})},createStruct:function({structName:e,attributes:t=[]}){if(!t||0===t.length)throw"Invalid create structure usage, expected attributes";let r="";for(let e=0;e<t.length;e++){const a=t[e],o=a.name;if(!o||!this._isValid(a))return"";const i=a.type,s=this._context.isWebGPU?n.ToWGSLTypes:n.ToGLSLTypes,l=s[i]?s[i]:{t:i};if(this._context.isWebGPU){const n=a.size;r=n>0?`\n                            ${r}\n                            ${o} : array<${l.t}, ${n}>,\n                        `:`\n                            ${r}\n                            ${o} : ${l.t},\n                        `}else{const n=a.size;r=n>0?`\n                            ${r}\n                            ${l.t} ${o}[${n}];\n                        `:`\n                            ${r}\n                            ${l.t} ${o};\n                        `}}return`\n                struct ${e} {\n                    ${r}\n                };\n            `},_declareVariable:function({name:e,type:t,size:r=0,addressSpace:a="",constant:o=!1,throwIfNotFound:i=!0}){const s=e;let l=this._context&&this._context.isWebGPU;if(!s||!this._isValid({type:t,size:r,throwIfNotFound:i}))return"";let u,m=(l?n.ToWGSLTypes:n.ToGLSLTypes)[t];return m||(m={t:t}),l?o?`const ${s}`:r>0?`var${""!==a?"<"+a+">":""} ${s} : array<${m.t}, ${r}> `:`var${""!==a?"<"+a+">":""} ${s} : ${m.t} `:(u=r>0?`${m.t} ${s}[${r}]`:`${m.t} ${s}`,o&&(u=`const ${u}`),u)},declareVariable:function({name:n,type:e,size:t=0,addressSpace:r="",constant:a=!1}){return this._declareVariable({name:n,type:e,size:t,addressSpace:r,constant:a,throwIfNotFound:!0})},getType:function({type:e}){if(!this._isValid({type:e,throwIfNotFound:!0}))return"";return`${(this._context&&this._context.isWebGPU?n.ToWGSLTypes:n.ToGLSLTypes)[e].t}`},reference(n){return n?this._context.isWebGPU?`(&${n})`:n:this._context.isWebGPU?"&":""},dereference(n){return n?this._context.isWebGPU?`(*${n})`:n:this._context.isWebGPU?"*":""}};{const t=[{name:"float",type:"f",typeV:"fv1"},{name:"vec2",type:"v2",typeV:"fv2"},{name:"vec3",type:"v3",typeV:"fv3"},{name:"vec4",type:"v4",typeV:"fv4"},{name:"int",type:"i",typeV:"iv1"},{name:"ivec2",type:"i2",typeV:"iv2"},{name:"ivec3",type:"i3",typeV:"iv3"},{name:"ivec4",type:"i4",typeV:"iv4"},{name:"bool",type:"b",typeV:"bv1"},{name:"bvec2",type:"b2",typeV:"bv2"},{name:"bvec3",type:"b3",typeV:"bv3"},{name:"bvec4",type:"b4",typeV:"bv4"},{name:"mat2",type:"m2",typeV:"m2v"},{name:"mat3",type:"m3",typeV:"m3v"},{name:"mat4",type:"m4",typeV:"m4v"}];function r(n){e[n.name]=function({name:e=null,size:t=0,addressSpace:r="",constant:a=!1}){const o=t?n.typeV:n.type;return e?this.declareVariable({name:e,type:o,size:t,addressSpace:r,constant:a}):this.getType({type:o})}}for(let a=0;a<t.length;a++){r(t[a])}}return e})),define("DS/ShaderBuilders/WebGPUShaderBuilder",["DS/Mesh/ThreeJS_Base","DS/GPUFormats/WebGPUUBOUtils","DS/Materials/PostProMaterial"],(function(n,e,t){"use strict";let r,a;var o=n._toFastProperties;const i=e.__computeGlobalKeyAndFunc,s=e.__computeObjectKeyAndFunc,l={vertexIndex:{name:"vertex_index",type:"u32"},instanceIndex:{name:"instance_index",type:"u32"}},u={position:{name:"position",type:"vec4<f32>"}},m={fragCoord:{name:"position",type:"vec4<f32>"},frontFacing:{name:"front_facing",type:"bool"},sampleIndex:{name:"sample_index",type:"u32"},sampleMaskIn:{name:"sample_mask",type:"u32"}},c={sampleMaskOut:{name:"sample_mask",type:"u32"},fragDepth:{name:"frag_depth",type:"f32"}},$=function(n){return n.startsWith("out")?{index:parseInt(n.replace("out","")),type:"vec4<f32>"}:null};return class{constructor(){r=n.ObjectUniformEnum,a=n.GlobalUniformEnum,this.attributeOrder=["aPosition","aNormal","aUv","aUv2","aColor","aTangent","aBinormal","aLinePixelDistance","aPatternStartEnd","aPreviousPos","aFollowingPos","aSideExtrusion","aInstanceId","aDefaultInstancingMatrix","aSkinIndex","aSkinWeight","aMorphTarget0","aMorphTarget1","aMorphTarget2","aMorphTarget3","aMorphNormals0","aMorphNormals1","aMorphNormals2","aMorphNormals3","aMorphTarget4","aMorphTarget5","aMorphTarget6","aMorphTarget7"]}getAlignOf(n){switch(n){case"f":case"fv1":case"i":case"iv1":case"u":case"uv1":return 4;case"v2":case"v2v":case"fv2":case"m2":case"m2v":case"i2":case"iv2":case"u2":case"uv2":return 8;case"v3":case"v3v":case"fv3":case"v4":case"v4v":case"fv4":case"c":case"m3":case"m3v":case"m4":case"m4v":case"i3":case"iv3":case"i4":case"iv4":case"u3":case"uv3":case"u4":case"uv4":return 16;case"b":case"bv1":case"b2":case"bv2":case"b3":case"bv3":case"b4":case"bv4":return console.warn("AlignOf bool is not defined in webgpu since it cannot be used as uniform: https://stackoverflow.com/questions/77709970/in-webgpu-what-is-the-stride-and-size-of-a-boolean"),0;case"t2":case"t2ms":case"tu2":case"td2":case"td2ms":case"t2v":case"tc":case"tcv":return console.warn("Textures don\t have an align size !"),0}return 16}getSizeOf(n){switch(n){case"f":case"fv1":case"i":case"iv1":case"u":case"uv1":return 4;case"v2":case"v2v":case"fv2":case"i2":case"iv2":case"u2":case"uv2":return 8;case"v3":case"v3v":case"c":case"i3":case"iv3":case"u3":case"uv3":return 12;case"fv3":case"v4":case"v4v":case"fv4":case"m2":case"m2v":case"i4":case"iv4":case"u4":case"uv4":return 16;case"m3":case"m3v":return 48;case"m4":case"m4v":return 64;case"b":case"bv1":case"b2":case"bv2":case"b3":case"bv3":case"b4":case"bv4":return console.warn("SizeOf bool is not defined in webgpu since it cannot be used as uniform: https://stackoverflow.com/questions/77709970/in-webgpu-what-is-the-stride-and-size-of-a-boolean"),0;case"t2":case"t2ms":case"tu2":case"td2":case"td2ms":case"t2v":case"tc":case"tcv":return console.warn("Textures don\t have a uniform byte size !"),0}return 4}_computeOffsetsAndSize(n,e){var t=this,l=n.shaderContext.__uniforms__,u=0,m=1,c=0,$=[];let p={},d=0;for(var f in l){if((x=l[f]).ubo===e){var h=x.type;if(p[x.locationName||f]=x,"t2"!==h&&"tu2"!==h&&"t2ms"!==h)if("t2v"!==h)if("tc"!==h)if("tcv"!==h)"td2"!==h&&"td2ms"!==h?"ssbo"!==h?$.push(x):(x.offset=d,d++):(x.offset=d,d+=2);else{x.offsets=new Array(x.size);for(let n=0;n<x.size;n++)x.offsets[n]=d,d+=2}else x.offset=d,d+=2;else{x.offsets=new Array(x.size);for(let n=0;n<x.size;n++)x.offsets[n]=d,d+=2}else x.offset=d,d+=2}}$.sort((function(n,e){return t.getAlignOf(e.type)-t.getAlignOf(n.type)}));for(var v=$.length-1,g=0;g<$.length;g++){var x;if((x=$[g]).offset>=0)break;var S=x.size?x.size:1,y=(u=this.getSizeOf(x.type),this.getAlignOf(x.type)),_=(y-c%y)%y;if(y>m&&(m=y),S>1&&(u+=(y-u%y)%y),_>0&&g<v){var T=$[v],D=this.getSizeOf(T.type);4===_?4!==D||T.size?2!==D||T.size||(T.offset=c,g<--v&&(T=$[v],2!==(D=this.getSizeOf(T.type))||T.size||(T.offset=c+2,v--))):(T.offset=c,v--):2===_&&(2!==D||T.size||(T.offset=c,v--))}c+=_,x.offset=c,c+=S*u}if($.sort((function(n,e){return n.offset-e.offset})),o(p),n.shaderIO.orderedUniforms[e]=$,n.shaderIO.uniformLayouts[e]=p,o(n.shaderIO.orderedUniforms),o(n.shaderIO.uniformLayouts),o(n.shaderIO),"object"===e){let[e,t,a]=s(r,p);n.shaderIO.objectUBOFillFunc=t,n.shaderIO.objectUBOUpdateFunc=a,n.shaderIO.objectUBOKey=e}else if("global"===e){let[e,t]=i(a,p);n.shaderIO.globalUBOFillFunc=t,n.shaderIO.globalUBOKey=e}return c+(m-c%m)%m}computeLayoutInfos(n){n.shaderIO.structSize.global=this._computeOffsetsAndSize(n,"global"),n.shaderIO.structSize.object=this._computeOffsetsAndSize(n,"object"),n.shaderIO.structSize.light=this._computeOffsetsAndSize(n,"light"),n.shaderIO.structSize.material=this._computeOffsetsAndSize(n,"material"),n.shaderIO.structSize.materialhigh=this._computeOffsetsAndSize(n,"materialhigh")}getVertexInCode(e){let t=e.shaderIO.attribute,r=e.shaderContext.__attributes__;for(const n in r){const e=r[n];t[e.locationName?e.locationName:n]={name:n,type:e.type,instancingAttribute:e.instancingAttribute}}let a=0;const o=e.shaderContext.__builtins__.input;let i="struct VertexInput {\n";for(let n in o){const e=l[n];e&&(i+=`@builtin(${e.name}) ${n} : ${e.type},\n`)}const s=[];for(let[n,e]of Object.entries(t))s.push(n);for(var u=0;u<this.attributeOrder.length;u++){const r=this.attributeOrder[u];if((!t[r]||!e.shaderContext.__customAttributes__[r])&&t[r]){"m4"===t[r].type?(i+="@location("+a+") "+r+"_c0 : "+n.ToWGSLTypes.fv4.t+",\n",i+="@location("+(a+1)+") "+r+"_c1 : "+n.ToWGSLTypes.fv4.t+",\n",i+="@location("+(a+2)+") "+r+"_c2 : "+n.ToWGSLTypes.fv4.t+",\n",i+="@location("+(a+3)+") "+r+"_c3 : "+n.ToWGSLTypes.fv4.t+",\n",t[r].location=a,a+=4):(i+="@location("+a+") "+r+" : "+n.ToWGSLTypes[t[r].type].t+",\n",t[r].location=a,a++);let e=s.indexOf(r);s.splice(e,1)}}for(let r=0;r<s.length;r++){let o=s[r];t[o]&&e.shaderContext.__customAttributes__[t[o].name]||("m4"===t[o].type?(i+="@location("+a+") "+o+"_c0 : "+n.ToWGSLTypes.fv4.t+",\n",i+="@location("+(a+1)+") "+o+"_c1 : "+n.ToWGSLTypes.fv4.t+",\n",i+="@location("+(a+2)+") "+o+"_c2 : "+n.ToWGSLTypes.fv4.t+",\n",i+="@location("+(a+3)+") "+o+"_c3 : "+n.ToWGSLTypes.fv4.t+",\n",t[o].location=a,a+=4):void 0!==t[o].type&&(i+="@location("+a+") "+o+" : "+n.ToWGSLTypes[t[o].type].t+",\n",t[o].location=a,a++))}return i+"};\n"}getVaryingCode(e){const t=e.shaderContext.__varyings__;let r=0,a="";for(let e in t){const o=t[e],i=o.type;let s="";switch(o.interpolationType){case n.VaryingInterpolationTypes.NO_PERSPECTIVE:s="@interpolate(linear)";break;case n.VaryingInterpolationTypes.FLAT:s="@interpolate(flat)"}if(o.size)for(let t=0;t<o.size;t++)a=`\n                            ${a}\n                            @location(${r++}) ${s} ${e}_${t} : ${n.ToWGSLTypes[i].t},\n                        `;else a=`\n                        ${a}\n                        @location(${r++}) ${s}\n                    `,a=o.size?`\n                            ${a} ${e} : array<${n.ToWGSLTypes[i].t}, ${o.size}>,\n                        `:`\n                            ${a} ${e} : ${n.ToWGSLTypes[i].t},\n                        `}return a}getVertexOutCode(n){const e=n.shaderContext.__builtins__.out;let t="struct VertexOutput {\n";for(let n in e){const e=u[n];e&&(t+=`@builtin(${e.name}) ${n} : ${e.type},\n`)}return t+=this.getVaryingCode(n),t+"};\n"}getFragmentInCode(n){const e=n.shaderContext.__builtins__.input;let t="struct FragmentInput {\n",r="";for(let n in e){let e=m[n];e&&(r+=`@builtin(${e.name}) ${n} : ${e.type},\n`)}return""===r&&0===Object.keys(n.shaderContext.__varyings__).length&&"position"in n.shaderContext.__builtins__.out&&(t+="@builtin(position) fragCoord : vec4<f32>,\n"),t+=r,t+=this.getVaryingCode(n),t+"};\n"}getFragmentOutCode(n){const e=n.shaderContext.__builtins__.out;let t="struct FragmentOutput {\n";for(let n in e){let e=c[n];e?t+=`@builtin(${e.name}) ${n} : ${e.type},\n`:(e=$(n),e&&(t+=`@location(${e.index}) ${n} : ${e.type},\n`))}return t+"};\n"}__getGenericUBOCode(e,t,r,a){if(!t)return["",a];const o=t.toLowerCase(),i=e.orderedUniforms[o];let s="";if(i.length){s="struct "+t+"Uniforms {\n";for(var l=0;l<i.length;l++){const e=i[l],t=n.ToWGSLTypes[e.type].t;e.size?s+=e.name+" : array<"+t+", "+e.size+">,\n":s+=e.name+" : "+t+",\n"}s+="};\n",s+="@group("+r+") @binding("+a+++" ) var<uniform> "+o+"_uniforms : "+t+"Uniforms;\n"}else a++;const u=e.uniformLayouts[o];for(var m in u){let n=u[m],e=n.name;if("t2"==n.type||"tu2"==n.type||"tc"==n.type){s+=`@group(${r}) @binding(${a++}) var ${e}Sampler: sampler;\n`,s+=`@group(${r}) @binding(${a++}) var ${e}: texture_${"t2"===n.type?"2d<f32>":"tc"===n.type?"cube<f32>":"2d<u32>"};\n`}else if("t2ms"==n.type){s+=`@group(${r}) @binding(${a++}) var ${e}multisampledSampler: sampler;\n`,s+=`@group(${r}) @binding(${a++}) var ${e}: texture_multisampled_2d<${"f32"}>;\n`}else if("t2v"==n.type||"tcv"==n.type){let t=n.size,o="t2v"===u[m].type?"2d<f32>":"cube<f32>";for(let n=0;n<t;n++)s+=`@group(${r}) @binding(${a++}) var ${e}_${n}Sampler: sampler;\n`,s+=`@group(${r}) @binding(${a++}) var ${e}_${n}: texture_${o};\n`}else if("td2"==n.type)s+=`@group(${r}) @binding(${a++}) var ${e}Sampler: sampler;\n`,s+=`@group(${r}) @binding(${a++}) var ${e}: texture_depth_2d;\n`;else if("td2ms"==n.type)s+=`@group(${r}) @binding(${a++}) var ${e}multisampledSampler: sampler;\n`,s+=`@group(${r}) @binding(${a++}) var ${e}: texture_depth_multisampled_2d;\n`;else if("ssbo"==n.type){s+=`@group(${r}) @binding(${a++}) var<storage, ${n.readOnly?"read":"read_write"}> ${n.name}: ${n.bufferType};\n`}}return[s,a]}_getGenericUniformsCode(n,e,t,r){let a,o=0;return[a,o]=this.__getGenericUBOCode(n,e,r,0),a=`\n                ${a}\n                ${this.__getGenericUBOCode(n,t,r,o)[0]}\n            `,a}getUniformsCode(n,e){let t=0,r="";for(let a=0;a<e.length;a++)switch(e[a]){case"Global":r+=this._getGenericUniformsCode(n.shaderIO,"Global",null,t++)+"\n";break;case"Object":r+=this._getGenericUniformsCode(n.shaderIO,"Object",null,t++)+"\n";break;case"Material":r+=this._getGenericUniformsCode(n.shaderIO,"Material","MaterialHigh",t++)+"\n";break;case"Light":n.useLighting&&(r+=this._getGenericUniformsCode(n.shaderIO,"Light",null,t++)+"\n")}return r}}})),define("DS/ShaderBuilders/ShaderUtils/FunctionUtils",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e){"use strict";function t(n,e){let t;t=n||"void";let r="";for(let n=0;n<e.length;n++){let t=e[n];r+=t.type,t.inOut&&(r+="!io"),t.private&&(r+="!prvt"),n!==e.length-1&&(r+=";")}return t+";"+r}class r{constructor(n){this.name=n,this.count=0,this.sigToName=new Map}addFunction(n,e){const r=t(n,e);this.sigToName.has(r)||(0===this.count?this.sigToName.set(r,this.name):this.sigToName.set(r,this.name+"_"+this.count),this.count++)}getFunction(n,e){const r=t(n,e);if(!this.sigToName.has(r))throw`Invalid Operation: ${r} for ${this.name} not declared`;return this.sigToName.get(r)}toWebGLDeclare(e,t){let r;if(e){const t=n.ToGLSLTypes[e];r=t?t.t:e}else r="void";let a=this.getFunction(e,t),o="";for(let e=0;e<t.length;e++){const r=t[e],a=r.struct?r.type:n.ToGLSLTypes[r.type].t;o+=`${r.inOut?"inout":"const in"} ${a} ${r.name}`,e!==t.length-1&&(o+=",")}return`${r} ${a}(${o})`}toWebGLCall(n,t){let r=this.getFunction(n,t),a="";for(let n=0;n<t.length;n++){const r=t[n];a+=`${r.toRef?e.reference(r.name):r.name}`,n!==t.length-1&&(a+=",")}return`${r}(${a})`}toWebGPUDeclare(e,t){let r="";if(e){const t=n.ToWGSLTypes[e];r=t?" -> "+t.t:" -> "+e}const a=this.getFunction(e,t);let o="";for(let e=0;e<t.length;e++){const r=t[e],a=r.struct?r.type:n.ToWGSLTypes[r.type].t;var i=r.inOut?r.private?`ptr<private, ${a}>`:`ptr<function, ${a}>`:a;o+=`${r.name} : ${i}`,"t2"!==r.type&&"tc"!==r.type||(o+=`, ${r.name}Sampler : sampler`),e!==t.length-1&&(o+=",")}return`fn ${a}(${o})${r}`}toWebGPUCall(n,t){const r=this.getFunction(n,t);let a="";for(let n=0;n<t.length;n++){const r=t[n];if(a+=`${r.toRef?e.reference(r.name):r.name}`,"t2"===r.type||"tc"===r.type){let n=r.name;if(n.includes("[")){let e=n.split("[");n=e[0]+"Sampler["+e[1]}else n+="Sampler";a+=`, ${n}`}n!==t.length-1&&(a+=",")}return`${r}(${a})`}}const a=[{name:"F",type:"f"},{name:"V2",type:"v2"},{name:"V3",type:"v3"},{name:"V4",type:"v4"},{name:"I",type:"i"},{name:"I2",type:"i2"},{name:"I3",type:"i3"},{name:"I4",type:"i4"},{name:"B",type:"b"},{name:"B2",type:"b2"},{name:"B3",type:"b3"},{name:"B4",type:"b4"},{name:"M2",type:"m2"},{name:"M3",type:"m3"},{name:"M4",type:"m4"},{name:"T2",type:"t2",noRef:!0},{name:"TC",type:"tc",noRef:!0}],o={parameter:function(n,e){return{inOut:!1,name:e,type:n,toRef:!1,struct:!1}},parameterInOut:function(n,e){return{inOut:!0,name:e,type:n,toRef:!1,struct:!1}},parameterInOutPrivate:function(n,e){return{inOut:!0,name:e,type:n,toRef:!1,struct:!1,private:!0}},parameterRef:function(n,e){return{inOut:!0,name:e,type:n,toRef:!0,struct:!1}},parameterRefPrivate:function(n,e){return{inOut:!0,name:e,type:n,toRef:!0,struct:!1,private:!0}},parameterStruct:function(n,e){return{inOut:!1,name:e,type:n,toRef:!1,struct:!0}},parameterInOutStruct:function(n,e){return{inOut:!0,name:e,type:n,toRef:!1,struct:!0}},parameterInOutPrivateStruct:function(n,e){return{inOut:!0,name:e,type:n,toRef:!1,private:!0,struct:!0}},parameterRefStruct:function(n,e){return{inOut:!0,name:e,type:n,toRef:!0,struct:!0}},parameterRefPrivateStruct:function(n,e){return{inOut:!0,name:e,type:n,toRef:!0,private:!0,struct:!0}}};function i(n,e,t){o["parameter"+n]=function(n){return this.parameter(e,n)},t||(o["parameterInOut"+n]=function(n){return this.parameterInOut(e,n)},o["parameterRef"+n]=function(n){return this.parameterRef(e,n)},o["parameterInOutPrivate"+n]=function(n){return this.parameterInOutPrivate(e,n)},o["parameterRefPrivate"+n]=function(n){return this.parameterRefPrivate(e,n)})}for(let n=0;n<a.length;n++){i(a[n].name,a[n].type,!!a[n].noRef)}return{FunctionHandler:new class{constructor(){this._context=null}declareFunction(n,e,t){this._context||(this._context={}),this._context.__functions__||(this._context.__functions__=new Map);let a=this._context.__functions__,o=a.get(n);return o||(o=new r(n),a.set(n,o)),o.addFunction(e,t),this._context.isWebGPU?o.toWebGPUDeclare(e,t):o.toWebGLDeclare(e,t)}callFunction(n,e,t){this.declareFunction(n,e,t);let r=this._context.__functions__.get(n);return this._context.isWebGPU?r.toWebGPUCall(e,t):r.toWebGLCall(e,t)}getMainVertexStart(e,t=""){return this._context.isWebGPU?`@vertex\n                fn vertex_main(input: VertexInput) -> VertexOutput {\n                    ${t}\n                    var out: VertexOutput;\n                    ${n._ShaderChunk.attribute_vertex(e)} \n                    ${n._ShaderChunk.large_scale_VS(e)}\n                `:`\n                void main() {            \n                    ${n._MultiDrawShaderBuilder.multidraw_vertex(e)}\n                    ${n._ShaderChunk.attribute_vertex(e)} \n                    ${n._ShaderChunk.large_scale_VS(e)}\n                `}getMainVertexEnd(n){return this._context.isWebGPU?"\n                    return out;\n                }\n                ":"}"}getMainFragmentStart(e){return this._context.isWebGPU?`\n                @fragment\n                fn fragment_main(input : FragmentInput) -> FragmentOutput {\n                    var out: FragmentOutput;\n                    ${n._ShaderChunk.large_scale_FS(e)}\n                `:`\n                void main() {\n                    ${n._MultiDrawShaderBuilder.multidraw_fragment(e)}\n                    ${n._ShaderChunk.large_scale_FS(e)}\n                `}getMainFragmentEnd(n){return this._context.isWebGPU?"\n                return out;\n            }\n            ":"}"}getEarlyFragmentEnd(){return this._context.isWebGPU?"\n                return out;\n            ":"return;"}},BridgeFunctions:new class{constructor(){this._context=null}__mod(n,e){return this._context.isWebGPU?`((${n}) % (${e}))`:`mod(${n},${e})`}mod(n,e){return this.__mod(`${this.__mod(n,e)} + ${e}`,e)}modf(n,e,t){return this._context.isWebGPU?`\n                    {\n                        let fractAndWhole_ = modf(${n});\n                        ${e} = fractAndWhole_.fract;\n                        ${t} = fractAndWhole_.whole;\n                    }\n                `:`\n                ${e} = modf(${n}, ${t});\n            `}modulo(n,e){return this.mod(n,e)}lessThan(n,e){return this._context.isWebGPU?`${n} < ${e} `:`lessThan(${n},${e})`}lessThanEqual(n,e){return this._context.isWebGPU?`${n} <= ${e} `:`lessThanEqual(${n},${e})`}greaterThan(n,e){return this._context.isWebGPU?`${n} > ${e} `:`greaterThan(${n},${e})`}greaterThanEqual(n,e){return this._context.isWebGPU?`${n} >= ${e} `:`greaterThanEqual(${n},${e})`}dpdx(n){return this._context.isWebGPU?`dpdx(${n})`:`dFdx(${n})`}dpdy(n){return this._context.isWebGPU?`(-dpdy(${n}))`:`dFdy(${n})`}atan2(n,e){return this._context.isWebGPU?`atan2(${n},${e})`:`atan(${n},${e})`}equal(n,e){return this._context.isWebGPU?`${n} == ${e}`:`equal(${n},${e})`}notEqual(n,e){return this._context.isWebGPU?`${n} != ${e}`:`notEqual(${n},${e})`}inverseSqrt(n){return this._context.isWebGPU?`inverseSqrt(${n})`:`inversesqrt(${n})`}uvConvention(n){return this._context.isWebGPU?`${n}.y = 1.0 - ${n}.y;`:""}setDepthWithConvention(n){return this._context.isWebGPU?n:`0.5 + 0.5 * ${n}`}getDepthWithConvention(n){return this._context.isWebGPU?n:`2.0 * ${n} - 1.0`}__getSamplerName(n){let e=n;if(e.includes("[")){let n=e.split("[");e=n[0]+"Sampler["+n[1]}else e+="Sampler";return e}sample2DTextureGrad(n,e,t,r){if(!e)throw"Missing uv in sample2DTextureGrad";if(this._context.isWebGPU){return`textureSampleGrad(${n}, ${this.__getSamplerName(n)}, ${e}, ${t=t||"vec2<f32>(0.0, 0.0)"}, ${r=r||"vec2<f32>(0.0, 0.0)"})`}return this._context.__features__.extTextureLODs?(t=t||"vec2(0.0, 0.0)",r=r||"vec2(0.0, 0.0)",1===this._context.__features__.WebGLVersion?`texture2DGradEXT(${n}, ${e}, ${t}, ${r})`:`textureGrad(${n}, ${e}, ${t}, ${r})`):`texture2D(${n}, ${e})`}sample2DTexture(n,e){if(!e)throw"Missing uv in sample2DTexture";if(this._context.isWebGPU){return`textureSample(${n}, ${this.__getSamplerName(n)}, ${e})`}return 1!==this._context.__features__.WebGLVersion?`texture(${n}, ${e})`:`texture2D(${n}, ${e})`}sample2DTextureBias(n,e,t){if(!e)throw"Missing uv in sample2DTextureBias";if(!t)throw"Missing bias in sample2DTextureBias";if(this._context.isWebGPU){return`textureSampleBias(${n}, ${this.__getSamplerName(n)}, ${e}, ${t})`}return 1!==this._context.__features__.WebGLVersion?`texture(${n}, ${e}, ${t})`:`texture2D(${n}, ${e}, ${t})`}sample2DTextureMultisampled(n,e,t){if(!e)throw"Missing uv in sample2DTextureMultisampled";return this._context.isWebGPU?`textureLoad(${n}, vec2<i32>(${e} * vec2f(textureDimensions(${n}))), ${t})`:1!==this._context.__features__.WebGLVersion?`texture(${n}, ${e})`:`texture2D(${n}, ${e})`}sample2DTextureLevel(n,e,t){if(!e)throw"Missing uv in sample2DTextureLevel";if(!t)throw"Missing level in sample2DTextureLevel";if(this._context.isWebGPU){return`textureSampleLevel(${n}, ${this.__getSamplerName(n)}, ${e}, ${t})`}return this._context.__features__.extTextureLODs?1===this._context.__features__.WebGLVersion?`texture2DLodEXT(${n}, ${e}, ${t})`:`textureLod(${n}, ${e}, ${t})`:`texture2D(${n}, ${e})`}sampleCubeTexture(n,e){if(!e)throw"Missing uv in sampleCubeTexture";if(this._context.isWebGPU){return`textureSample(${n}, ${this.__getSamplerName(n)}, ${e})`}return 1!==this._context.__features__.WebGLVersion?`texture(${n}, ${e})`:`textureCube(${n}, ${e})`}sampleCubeTextureGrad(n,e,t,r){if(!e)throw"Missing uv in sampleCubeTextureGrad";if(this._context.isWebGPU){return`textureSampleGrad(${n}, ${this.__getSamplerName(n)}, ${e}, ${t=t||"vec3<f32>(0.0, 0.0, 0.0)"}, ${r=r||"vec3<f32>(0.0, 0.0, 0.0)"})`}return this._context.__features__.extTextureLODs?(t=t||"vec2(0.0, 0.0)",r=r||"vec2(0.0, 0.0)",1===this._context.__features__.WebGLVersion?`textureCubeGradEXT(${n}, ${e}, ${t}, ${r})`:`textureGrad(${n}, ${e}, ${t}, ${r})`):`textureCube(${n}, ${e})`}sampleCubeTextureLevel(n,e,t){if(!e)throw"Missing uv in sampleCubeTextureLevel";if(!t)throw"Missing level in sampleCubeTextureLevel";if(this._context.isWebGPU){return`textureSampleLevel(${n}, ${this.__getSamplerName(n)}, ${e}, ${t})`}return this._context.__features__.extTextureLODs?1===this._context.__features__.WebGLVersion?`textureCubeLodEXT(${n}, ${e}, ${t})`:`textureLod(${n}, ${e}, ${t})`:`textureCube(${n}, ${e})`}sampleCubeTextureBias(n,e,t){if(!e)throw"Missing uv in sampleCubeTextureBias";if(!t)throw"Missing bias in sampleCubeTextureBias";if(this._context.isWebGPU){return`textureSampleBias(${n}, ${this.__getSamplerName(n)}, ${e}, ${t})`}return 1!==this._context.__features__.WebGLVersion?`texture(${n}, ${e}, ${t})`:`textureCube(${n}, ${e}, ${t})`}},ParameterUtils:o}})),define("DS/ShaderBuilders/FiniteEnvMapShaderBuilder",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a,o){"use strict";const i=a.ParameterUtils,s=a.FunctionHandler,l=a.BridgeFunctions,u=n=>i.parameterF(n),m=n=>i.parameterV2(n),c=n=>i.parameterV3(n),$=n=>i.parameterT2(n),p=(n,e,t)=>s.declareFunction(n,e,t),d=(n,e,t)=>s.callFunction(n,e,t),f=n=>t.addUniform(n),h=n=>{var e={uniformName:n};return t.getUniform(e)},v=n=>{var e={uniformName:n};return t.getGlobalUniform(e)},g=(n=null)=>{var e={name:n};return o.float(e)},x=(n=null)=>{var e={name:n};return o.vec2(e)},S=(n=null,e=0)=>{var t={name:n,size:e};return o.vec3(t)},y=(n=null,e=0)=>{var t={name:n,size:e};return o.vec4(t)},_=n=>{var e={name:n,constant:!0};return o.float(e)},T=n=>r.addVarying(n),D=n=>r.getShaderOutput(n);return new e((function(e,a){let o=n._ShaderChunk,i=n._DefaultShaderChunk;const C=(P={uniformName:"tEnvMap"},t.getTextureUniform(P));var P;let N=`\n            ${a.useLatLongMap?`\n                ${f({uniformName:C,uniformType:"t2"})}\n                `:`\n                ${f({uniformName:C,uniformType:"tc"})}\n                `}\n\n            ${f({uniformName:"blurCoef",uniformType:"f"})}\n            ${f({uniformName:"withGround",uniformType:"f"})}\n            ${f({uniformName:"envMapExposure",uniformType:"f"})}\n            ${f({uniformName:"ambient",uniformType:"v3"})}\n            ${f({uniformName:"groundPosition",uniformType:"v3"})}\n            ${f({uniformName:"groundNormal",uniformType:"v3"})}\n            ${f({uniformName:"sceneHeight",uniformType:"v3"})}\n            ${f({uniformName:"groundHeight",uniformType:"v3"})}\n            ${f({uniformName:"groundOffset",uniformType:"f"})}\n            ${f({uniformName:"groundRadius",uniformType:"f"})}\n            ${f({uniformName:"groundScale",uniformType:"f"})}\n            ${f({uniformName:"invScreenSize",uniformType:"v2"})}\n            ${f({uniformName:"cameraSight",uniformType:"v3"})}\n            ${f({uniformName:"cameraUp",uniformType:"v3"})}\n            ${f({uniformName:"cameraRight",uniformType:"v3"})}\n            ${f({uniformName:"near",uniformType:"f"})}\n            ${f({uniformName:"right",uniformType:"f"})}\n            ${f({uniformName:"up",uniformType:"f"})}\n            ${f({uniformName:"startOffset",uniformType:"v2"})}\n            ${f({uniformName:"endOffset",uniformType:"v2"})}\n            ${f({uniformName:"ambienceMatrix",uniformType:"m4"})}\n            ${f({uniformName:"projectionConic",uniformType:"f"})}\n\n            ${T({varyingName:"vWorldPosition",varyingType:"v3"})}\n\n            ${_("PI")} = 3.14159;\n            ${_("INV_PI")} = 0.31830988618;\n\n            ${a.useHDR&&!a.useHDRFloat?`\n                ${f({uniformName:"envMapHDRSize",uniformType:"v2"})}\n                ${f({uniformName:"envMapHDRToMipsRatio",uniformType:"f"})}\n    \n                ${i.ibl_sample_methods(a)}\n\n                ${p("sampleMipMapRoughness","v4",[m("uv"),u("mip"),u("coef"),$("map0"),$("map1"),m("textureSize"),m("texelSize")])}{\n                    ${y("color1")} ;\n                    ${y("color2")} ;\n                    ${x("uv1")} ;\n                    ${x("uv2")} ;\n                    ${x("textureSize2")} = textureSize * ${h("envMapHDRToMipsRatio")} * ${x()}(1.0,2.0);\n                    ${x("texelSize2")}  = texelSize / ${h("envMapHDRToMipsRatio")} * ${x()}(1.0,2.0);\n                    if (mip < 1.0) {\n                        color1 = ${d("texture2DBilinearRGBE","v4",[$("map0"),m("uv"),m("textureSize"),m("texelSize")])};\n                    } else {\n                        ${g("level1")}  = clamp(floor(mip) - 1.0, 0.0, 4.0);\n                        ${g("t10")}  = pow(2.0, -floor(log2(level1 + 1.0)));\n                        ${g("t11")}  = 2.0 - (level1 + 2.0) * t10;\n                        ${g("t12")}  = 0.5 * t10;\n\n                        uv1 = ${x()}(t11 + 1.5 * texelSize2.x + (2.0 * t12 - 3.0 * texelSize2.x) * uv.x, t12 + 1.5 * texelSize2.x + (t12 - 3.0 * texelSize2.x) * uv.y);\n                        color1 = ${d("texture2DBilinearRGBE","v4",[$("map1"),m("uv1"),m("textureSize2"),m("texelSize2")])};\n                    }\n\n                    ${g("level2")}  = clamp(floor(mip), 0.0, 5.0);\n                    ${g("t20")}  = pow(2.0, -floor(log2(level2 + 1.0)));\n                    ${g("t21")}  = 2.0 - (level2 + 2.0) * t20;\n                    ${g("t22")}  = 0.5 * t20;\n\n                    uv2 = ${x()}(t21 + 1.5 * texelSize2.x + (2.0 * t22 - 3.0 * texelSize2.x) * uv.x, t22 + 1.5 * texelSize2.x + (t22 - 3.0 * texelSize2.x) * uv.y);\n                    color2 = ${d("texture2DBilinearRGBE","v4",[$("map1"),m("uv2"),m("textureSize2"),m("texelSize2")])};\n\n                    return mix(color1, color2, coef);\n                }\n                `:""}\n\n            ${p("MapNormalToTextureCoordinate","v2",[c("iNormal")])}{\n                ${g("phi")}  = ${b="iNormal.y",M="iNormal.x",l.atan2(b,M)};\n                ${g("theta")}  = acos(iNormal.z);\n                return ${x()}(fract(0.5 + 0.5 * INV_PI * phi), 1.0 - INV_PI * theta);\n            }\n\n            ${p("IntersectPlane","f",[c("iPos"),c("iRay"),c("iPlaneOrig"),c("iPlaneNormal")])} {\n                ${g("t")}  = dot(iPlaneNormal, iPlaneOrig-iPos);\n                ${g("cosNormalDir")}  = dot(iPlaneNormal, iRay);\n                if (cosNormalDir==0.0) {\n                    return 0.0;\n                }    \n                return t/cosNormalDir;\n            }\n\n            ${p("IntersectSphereFar","f",[c("iSphereCenter"),u("iSphereRadius"),c("iRayDir"),c("iRayOrig")])} {\n               ${S("dist")}  = iRayOrig - iSphereCenter;\n               ${g("B")}  = 2.0*dot(iRayDir, dist);\n               ${g("C")}  = dot(dist, dist) - iSphereRadius*iSphereRadius;\n               ${g("disc")}  = B*B - 4.0*C;\n               if (disc < 0.0) {\n                    return -1.0;\n               }\n               return (-B + sqrt(disc)) / 2.0;\n            }\n\n            ${o.postprocess_pars_fragment(a)}\n            \n            ${s.getMainFragmentStart(a)}\n                ${S("n")}  = normalize(${(n=>r.getVarying(n,r.ShaderStages.in))("vWorldPosition")} - ${v("cameraPosition")});\n                ${S("groundPos")}  = (${h("ambienceMatrix")} * ${y()}(${h("groundPosition")}, 1.0)).xyz;\n                ${S("groundNor")}  = (${h("ambienceMatrix")} * ${y()}(${h("groundNormal")}, 0.0)).xyz;\n                ${S("sphereCenter")}    = groundPos + groundNor * ${h("sceneHeight")} * ${h("groundRadius")};\n                ${S("offset")}    = ${S()}(0.0,0.0,${h("groundOffset")});\n                offset = (${h("ambienceMatrix")} * ${y()}(offset, 0.0)).xyz;\n\n                ${a.useAmbianceV2?`\n                    groundNor = ${h("groundNormal")};\n                    sphereCenter  = ${h("groundPosition")} +  ${h("sceneHeight")} * ${h("groundRadius")};\n                    offset = ${h("groundOffset")} * groundNor;\n                    groundPos = ${h("groundPosition")} + offset;\n                    `:""}\n\n                ${g("sphereRadius")}   = ${h("groundRadius")} * ${h("groundScale")};\n                ${S("rayDir")}        = ${S()}(0.0);\n                ${S("rayOrig")}       = ${S()}(0.0);\n                if (sphereRadius > 0.0) {\n                    if (${h("projectionConic")} > 0.0 ) {\n                        rayDir      = n;\n                        rayOrig     = ${v("cameraPosition")};\n                    } else {\n                        ${x("screenUV")} = ${(n=>r.getShaderInput(n))("fragCoord")}.xy * ${h("invScreenSize")};\n                        ${l.uvConvention("screenUV")};\n                        ${x("screenOffset")}  = 2.0 * mix(${h("startOffset")}, ${h("endOffset")}, screenUV) - 1.0;\n                        ${S("centerPosition")}  = ${v("cameraPosition")} - (${h("cameraSight")} * ${h("near")});\n                        n = normalize(${h("cameraSight")} + screenOffset.x * ${h("cameraRight")} + screenOffset.y * ${h("cameraUp")});\n                        rayOrig = centerPosition + screenOffset.x * (${h("cameraRight")}*${h("right")}) + screenOffset.y * (${h("cameraUp")} * ${h("up")});\n                        rayDir = ${h("cameraSight")};\n                    }\n                    ${g("t")} =  ${d("IntersectSphereFar","f",[c("sphereCenter"),u("sphereRadius"),c("rayDir"),c("rayOrig")])};\n                    ${S("planeNormal")} = groundNor;\n                    if (t>0.0) {\n                        if (dot(planeNormal, rayDir)<0.0){\n                            ${a.useAmbianceV2?`${g("planeT")} = ${d("IntersectPlane","f",[c("rayOrig"),c("rayDir"),c("groundPos"),c("planeNormal")])};`:`${g("planeT")} = ${d("IntersectPlane","f",[c("rayOrig"),c("rayDir"),c("groundPos + offset"),c("planeNormal")])};`}\n                            planeT = planeT * ${h("withGround")};\n                            if (${h("projectionConic")} > 0.0 ) {\n                                if  (planeT > 0.0) {\n                                    t = min(planeT,t);\n                                }\n                            } else {\n                                t =  min(planeT,t);\n                            }\n                        }\n                        ${S("hitPos")}  = rayOrig + t*rayDir;\n                        ${a.useAmbianceV2?`${S("projectionCenter")}  = ${h("groundPosition")} + ${h("groundHeight")} * sphereRadius;`:`${S("projectionCenter")}  = groundPos + offset + groundNor * ${h("groundHeight")}*${h("groundRadius")};`}\n                        ${S("sn")}  = (hitPos - projectionCenter);\n                        n = normalize(sn);\n                    }\n                }\n                ${S("mapColor")};\n                ${a.useLatLongMap?`\n                    n = (${h("ambienceMatrix")} * ${y()}(n, 0.0)).xyz;\n                    ${a.useHDR?"":"n.y *= -1.0;"}\n                    ${x("coords")}  = ${d("MapNormalToTextureCoordinate","v2",[c("n")])};\n                    ${a.useHDR&&!a.useHDRFloat?`\n                        ${x("texelSize")} = ${x()}(1.0 / ${h("envMapHDRSize")});\n                        mapColor = ${d("texture2DBilinearRGBE","v4",[$(C),m("coords"),m(`${h("envMapHDRSize")}`),m("texelSize")])}.xyz;\n                        `:`mapColor = ${l.sample2DTexture(C,"coords")}.xyz;`}\n                    `:`\n                    n = (${h("ambienceMatrix")} * ${y()}(n, 0.0)).xyz;\n                    mapColor= ${l.sampleCubeTexture(C,`${S()}(n.x, -n.z,n.y)`)}.xyz;\n                    `}\n                ${D("out0")}.x = mapColor.x;\n                ${D("out0")}.y = mapColor.y;\n                ${D("out0")}.z = mapColor.z;\n                ${D("out0")}.w = 1.0;\n                ${!a.gammaOutput&&a.useSRGB?`\n                    ${S("convertedColor")} = ${d("convertToLinear","v3",[c("mapColor.xyz")])};\n                    ${D("out0")}.x = convertedColor.x;\n                    ${D("out0")}.y = convertedColor.y;\n                    ${D("out0")}.z = convertedColor.z;\n                    `:""}\n\n                ${D("out0")} *= ${y()}(${h("ambient")} * ${h("envMapExposure")}, 1.0);\n                ${o.postprocess_fragment(a)}\n                ${a.gammaOutput&&a.useHDR?o.linear_to_gamma_fragment(a):""}\n            ${s.getMainFragmentEnd(a)}\n        `;var b,M;let U=`\n            ${T({varyingName:"vWorldPosition",varyingType:"v3"})}\n            ${s.getMainVertexStart(a)}\n                ${y("worldPosition")} = modelMatrix * ${y()}( position_, 1.0 );\n                ${(n=>r.getVarying(n,r.ShaderStages.out))("vWorldPosition")} = worldPosition.xyz;\n                ${i.model_view_projection_transformation_vertex(a)}\n            ${s.getMainVertexEnd(a)}\n        `;return{vertexShader:U,fragmentShader:N}}))})),define("DS/ShaderBuilders/Commons/ClipShaders",["DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r){"use strict";const a="",o=t.ParameterUtils,i=t.FunctionHandler,s=t.BridgeFunctions,l=n=>o.parameterI(n),u=n=>o.parameterV2(n),m=n=>o.parameterV3(n),c=n=>o.parameterT2(n),$=(n,e,t)=>i.declareFunction(n,e,t),p=(n,e,t)=>i.callFunction(n,e,t),d=e=>n.addClippingUniform(e),f=e=>{var t={uniformName:e};return n.getClippingUniform(t)},h=e=>{var t={uniformName:e};return n.getClippingTextureUniform(t)},v=n=>e.addVarying(n),g=n=>e.getVarying(n,e.ShaderStages.in),x=(n,t)=>e.getVarying(n,e.ShaderStages.in,t),S=n=>e.getVarying(n,e.ShaderStages.out),y=(n,t)=>e.getVarying(n,e.ShaderStages.out,t),_=(n=null)=>{var e={name:n};return r.bool(e)},T=(n=null)=>{var e={name:n};return r.int(e)},D=(n=null)=>{var e={name:n};return r.float(e)},C=(n=null)=>{var e={name:n};return r.vec2(e)},P=(n=null)=>{var e={name:n};return r.vec3(e)},N=(n=null)=>{var e={name:n};return r.vec4(e)};return{clip_pars_vertex:function(n){let e=a;return n.clipPlanesEnabled&&(e=`\n                    ${e}\n                    ${d({uniformName:"nbClipPlanes",uniformType:"i",precision:"lowp"})}\n                    ${d({uniformName:"clipPlaneEquations",uniformType:"fv4",size:6})}\n                    ${v({varyingName:"clipDist",varyingType:"fv1",size:6})}\n\n                    ${$("getClipPlaneEquation","v4",[l("index")])}{\n                        if (index == 0) { return ${f("clipPlaneEquations")}[0]; }\n                        if (index == 1) { return ${f("clipPlaneEquations")}[1]; }\n                        if (index == 2) { return ${f("clipPlaneEquations")}[2]; }\n                        if (index == 3) { return ${f("clipPlaneEquations")}[3]; }\n                        if (index == 4) { return ${f("clipPlaneEquations")}[4]; }\n                        if (index == 5) { return ${f("clipPlaneEquations")}[5]; }\n                        return ${f("clipPlaneEquations")}[0];\n                    }\n                `),n.maxPolyLineSize>0&&(e=`\n                        ${e}\n                        ${v({varyingName:"extrusionPlaneUV",varyingType:"fv2",size:n.maxNbPolyLine})}\n                        ${d({uniformName:"extrusionPlaneU",uniformType:"fv3",size:n.maxNbPolyLine})}\n                        ${d({uniformName:"extrusionPlaneV",uniformType:"fv3",size:n.maxNbPolyLine})}\n                    `),n.useClippingCylinder&&(e=`\n                        ${e}\n                        ${v({varyingName:"cylinderAxisUV",varyingType:"v2"})}\n                        ${d({uniformName:"cylinderCenter",uniformType:"v3"})}\n                        ${d({uniformName:"cylinderAxisU",uniformType:"v3"})}\n                        ${d({uniformName:"cylinderAxisV",uniformType:"v3"})}\n                    `),n.maxScissorSize>0&&(e=`\n                    ${e}\n                    ${v({varyingName:"scissorClipPos",varyingType:"v4"})}\n                `),e},clip_vertex:function(n){let t=a;if(n.clipPlanesEnabled){let n=function(n){return y("clipDist",n)};t=`\n                    ${t}\n                    if(${f("nbClipPlanes")} > 0) {\n                        ${n(0)} = dot( mvPosition.xyz, ${f("clipPlaneEquations")}[ 0 ].xyz ) + ${f("clipPlaneEquations")}[ 0 ].w;\n                        ${n(1)} = dot( mvPosition.xyz, ${f("clipPlaneEquations")}[ 1 ].xyz ) + ${f("clipPlaneEquations")}[ 1 ].w;\n                        ${n(2)} = dot( mvPosition.xyz, ${f("clipPlaneEquations")}[ 2 ].xyz ) + ${f("clipPlaneEquations")}[ 2 ].w;\n                        ${n(3)} = dot( mvPosition.xyz, ${f("clipPlaneEquations")}[ 3 ].xyz ) + ${f("clipPlaneEquations")}[ 3 ].w;\n                        ${n(4)} = dot( mvPosition.xyz, ${f("clipPlaneEquations")}[ 4 ].xyz ) + ${f("clipPlaneEquations")}[ 4 ].w;\n                        ${n(5)} = dot( mvPosition.xyz, ${f("clipPlaneEquations")}[ 5 ].xyz ) + ${f("clipPlaneEquations")}[ 5 ].w;\n                    }\n                `}if(n.maxPolyLineSize>0||n.maxScissorSize>0){if(t=`\n                    ${t}\n                    ${P("positionWorld")} = ${p("getModelTransformation","v4",[m("vertexLocalPosition.xyz")])}.xyz;\n                `,n.maxPolyLineSize>0){let e,r=function(n){return y("extrusionPlaneUV",n)};for(e=0;e<n.maxNbPolyLine;e++)t=`\n                            ${t}\n                            ${r(e)} = ${C()}(dot(mvPosition.xyz, ${f("extrusionPlaneU")}[${e}]), dot(mvPosition.xyz, ${f("extrusionPlaneV")}[${e}]));\n                        `}n.maxScissorSize>0&&(t=`\n                        ${t}\n                        ${S("scissorClipPos")} = ${r="position",e.getBuiltin(r,e.ShaderStages.out)};\n                    `)}var r;return n.useClippingCylinder&&(t=`\n                    ${t}\n                    ${P("posWorldCylinder")} = ${p("getModelTransformation","v4",[m("vertexLocalPosition.xyz")])}.xyz - ${f("cylinderCenter")};\n                    ${S("cylinderAxisUV")} = ${C()}(dot(posWorldCylinder, ${f("cylinderAxisU")}), dot(posWorldCylinder, ${f("cylinderAxisV")}));\n                `),t},clip_pars_fragment:function(n){let e=a;return n.clipPlanesEnabled&&(e=`\n                    ${e}\n                    ${d({uniformName:"nbClipPlanes",uniformType:"i",precision:"lowp"})}\n                    ${v({varyingName:"clipDist",varyingType:"fv1",size:6})}\n                    ${d({uniformName:"clipPlaneActive",uniformType:"iv4",size:2})}\n                    ${d({uniformName:"clipFrontOpacity",uniformType:"f",precision:"lowp"})}\n                    ${d({uniformName:"clipBackOpacity",uniformType:"f",precision:"lowp"})}\n                `),(n.maxPolyLineSize>0||n.maxScissorSize>0)&&(e=`\n                    ${e}\n                    ${$("getPolygonPoint","v2",[c("sampler"),l("size"),l("index")])}{\n                        ${D("fI")} = ${D()}(index);\n                        ${D("fS")} = ${D()}(size);\n                        ${C("coord")} = ${C()}((fI + 0.5) / fS, 0.5);\n                        return ${s.sample2DTexture("sampler","coord")}.rg;\n                    }\n\n                    ${$("isPointInsidePolygon","b",[c("sampler"),l("size"),u("point"),l("offset"),l("totalSize")])}{\n                        ${C("previousPoint")} = ${p("getPolygonPoint","v2",[c("sampler"),l("totalSize"),l("size-1+offset")])};;\n                        ${C("currentPoint")};\n                        ${_("result")} = false;\n                        for(${T("i")} =0; i < ${n.maxPolygonSize};i++) {\n                            if(i < size) {\n                                currentPoint = ${p("getPolygonPoint","v2",[c("sampler"),l("totalSize"),l("i+offset")])};\n                                if ( ((currentPoint.y>point.y) != (previousPoint.y>point.y)) &&\n                                   (point.x < (previousPoint.x-currentPoint.x) * (point.y-currentPoint.y) / (previousPoint.y-currentPoint.y) + currentPoint.x) ) {\n                                    result = !result;\n                                }\n                                previousPoint = currentPoint;\n                            }\n                        }\n                        return result;\n                    }\n                `,n.maxPolyLineSize>0&&(e=`\n                    ${e}\n                    ${d({uniformName:"polygonPoints",uniformType:"t2"})}\n                    ${d({uniformName:"polygonSize",uniformType:"iv4",size:Math.ceil(n.maxNbPolyLine/4)})}\n                    ${v({varyingName:"extrusionPlaneUV",varyingType:"fv2",size:n.maxNbPolyLine})}\n                    ${n.clipPlanesEnabled?"":d({uniformName:"clipBackOpacity",uniformType:"f",precision:"lowp"})}\n                `),n.maxScissorSize>0&&(e=`\n                    ${e}\n                    ${v({varyingName:"scissorClipPos",varyingType:"v4"})}\n                    ${d({uniformName:"scissorPoints",uniformType:"t2"})}\n                    ${d({uniformName:"scissorSize",uniformType:"iv4",size:Math.ceil(n.maxNbScissor/4)})}\n                `)),n.useClippingCylinder&&(e=`\n                    ${e}\n                    ${v({varyingName:"cylinderAxisUV",varyingType:"v2"})}\n                    ${d({uniformName:"cylinderClipZone",uniformType:"i"})}\n                `),e},clip_fragment:function(n){let e=a;if(n.clipPlanesEnabled){let n=function(n){return x("clipDist",n)},t=function(n){let e=n%4,t=Math.floor(n/4);switch(e){case 0:return`${f("clipPlaneActive")}[${t}].x`;case 1:return`${f("clipPlaneActive")}[${t}].y`;case 2:return`${f("clipPlaneActive")}[${t}].z`;default:return`${f("clipPlaneActive")}[${t}].w`}};e=`\n                    ${e}\n                    ${D("clipOpacity")} = -1.0;\n                    if(${f("nbClipPlanes")} > 0) {\n\n                        if (0 < ${f("nbClipPlanes")} && ${n(0)} < 0.0 && ${t(0)} > 0) { clipOpacity = ${f("clipBackOpacity")}; }\n                        else if (clipOpacity == -1.0 && 0 < ${f("nbClipPlanes")} && ${t(0)} > 0) { clipOpacity = ${f("clipFrontOpacity")}; }\n\n                        if (1 < ${f("nbClipPlanes")} && ${n(1)} < 0.0 && ${t(1)} > 0) { clipOpacity = ${f("clipBackOpacity")}; }\n                        else if (clipOpacity == -1.0 && 1 < ${f("nbClipPlanes")} && ${t(1)} > 0) { clipOpacity = ${f("clipFrontOpacity")}; }\n                        \n                        if (2 < ${f("nbClipPlanes")} && ${n(2)} < 0.0 && ${t(2)} > 0) { clipOpacity = ${f("clipBackOpacity")}; }\n                        else if (clipOpacity == -1.0 && 2 < ${f("nbClipPlanes")} && ${t(2)} > 0) { clipOpacity = ${f("clipFrontOpacity")}; }\n\n                        if (3 < ${f("nbClipPlanes")} && ${n(3)} < 0.0 && ${t(3)} > 0) { clipOpacity = ${f("clipBackOpacity")}; }\n                        else if (clipOpacity == -1.0 && 3 < ${f("nbClipPlanes")} && ${t(3)} > 0) { clipOpacity = ${f("clipFrontOpacity")}; }\n\n                        if (4 < ${f("nbClipPlanes")} && ${n(4)} < 0.0 && ${t(4)} > 0) { clipOpacity = ${f("clipBackOpacity")}; }\n                        else if (clipOpacity == -1.0 && 4 < ${f("nbClipPlanes")} && ${t(4)} > 0) { clipOpacity = ${f("clipFrontOpacity")}; }\n\n                        if (5 < ${f("nbClipPlanes")} && ${n(5)} < 0.0 && ${t(5)} > 0) { clipOpacity = ${f("clipBackOpacity")}; }\n                        else if (clipOpacity == -1.0 && 5 < ${f("nbClipPlanes")} && ${t(5)} > 0) { clipOpacity = ${f("clipFrontOpacity")}; }\n\n                        if(clipOpacity == 0.0) { discard; }\n                    }\n                `}if(n.maxPolyLineSize>0){let t=function(n){return x("extrusionPlaneUV",n)},r=function(n){let e=n%4,t=Math.floor(n/4);switch(e){case 0:return`${f("polygonSize")}[${t}].x`;case 1:return`${f("polygonSize")}[${t}].y`;case 2:return`${f("polygonSize")}[${t}].z`;default:return`${f("polygonSize")}[${t}].w`}},o=a,i=a;for(let e=0;e<n.maxNbPolyLine;e++)o=`\n                        ${o}\n                        totalSize_polygon += ${r(e)};\n                    `,i=`\n                        ${i}\n                        if (isInside) {\n                            ${T("size")} = ${r(e)};\n                            if(size > 0) {\n                                if(!${p("isPointInsidePolygon","b",[c(h("polygonPoints")),l("size"),u(`${t(e)}`),l("offset_polygon"),l("totalSize_polygon")])}) {\n                                    isInside = false;\n                                } else {\n                                    offset_polygon+=size;\n                                }\n                            }\n                        }\n                    `;e=`\n                    ${e}\n                    ${T("offset_polygon")} = 0;\n                    ${T("totalSize_polygon")} = 0;\n                    ${o}\n                    ${_("isInside")} = true;\n                    ${i}\n                    // jhg: refactor due to Samsung Galaxy S7 compilation error\n                    ${_("discardOutside")} = (${f("clipBackOpacity")} < 0.5);\n                    if(isInside) {\n                        if(!discardOutside) {\n                            discard;\n                        }\n                    } else {\n                        if(discardOutside) {\n                            discard;\n                        }\n                    }\n                `}if(n.maxScissorSize>0){let t=function(n){let e=n%4,t=Math.floor(n/4);switch(e){case 0:return`${f("scissorSize")}[${t}].x`;case 1:return`${f("scissorSize")}[${t}].y`;case 2:return`${f("scissorSize")}[${t}].z`;default:return`${f("scissorSize")}[${t}].w`}},r=a,o=a;for(let e=0;e<n.maxNbScissor;e++)r=`\n                        ${r}\n                        totalSize_scissor += ${t(e)};\n                    `,o=`\n                        ${o}\n                        {\n                                \n                            ${T("size")} = ${t(e)};\n                            ${N("clipSpacePosition")} = ${g("scissorClipPos")};\n                            ${C("position2d")} = clipSpacePosition.xy / clipSpacePosition.w;\n                            if(size > 0) {\n                                if(!${p("isPointInsidePolygon","b",[c(h("scissorPoints")),l("size"),u("position2d"),l("offset_scissor"),l("totalSize_scissor")])}) {\n                                    discard;\n                                }\n                                offset_scissor+=size;\n                            }\n                        }\n                    `;e=`\n                    ${e}\n                    ${T("offset_scissor")} = 0;\n                    ${T("totalSize_scissor")} = 0;\n                    ${r}\n                    ${o}\n                `}return n.useClippingCylinder&&(e=`\n                    ${e}\n                    if(${f("cylinderClipZone")} != 0) {\n                        ${_("isInside")} = dot(${g("cylinderAxisUV")}, ${g("cylinderAxisUV")}) <= 1.0;\n                        ${_("removeInside")} = ${f("cylinderClipZone")} < 0;\n                        if(isInside == removeInside) {\n                            discard;\n                        }\n                    }\n                `),e}}})),define("DS/ShaderBuilders/PDSFXShaderBuilder",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a){"use strict";const o=r.ParameterUtils,i=n=>o.parameterM3(n),s=(n,e,t)=>r.FunctionHandler.callFunction(n,e,t),l=(n,e,t)=>r.FunctionHandler.declareFunction(n,e,t);class u{constructor(){}reference(n){return a.reference(n)}dereference(n){return a.dereference(n)}createStruct({structName:n,attributes:e=[]}){return a.createStruct({structName:n,attributes:e})}struct({name:n,size:e=0,structName:t}){return a.struct({name:n,size:e,constant:!1,structName:t})}structC({name:n,size:e=0,structName:t}){return a.struct({name:n,size:e,constant:!0,structName:t})}structG({name:n,size:e=0,structName:t}){return a.struct({name:n,size:e,constant:!1,structName:t,addressSpace:"private"})}}{const h=["bool","bvec2","bvec3","bvec4","int","ivec2","ivec3","ivec4","float","vec2","vec3","vec4","mat2","mat3","mat4"];function v(n){u.prototype[n]=function(e=null,t=0,r=""){let o={name:e,size:t,constant:!1,addressSpace:r};return a[n](o)},u.prototype[n+"C"]=function(e=null,t=0){let r={name:e,size:t,constant:!0};return a[n](r)},u.prototype[n+"G"]=function(e=null,t=0){let r={name:e,size:t,constant:!1,addressSpace:"private"};return a[n](r)}}for(let g=0;g<h.length;g++){v(h[g])}}class m{constructor(){}declareFunction(n,e,t){return l(n="CustomPDSFX"+n,e,t)}callFunction(n,e,t){return s(n="CustomPDSFX"+n,e,t)}dF(n,e,t){return l(n="CustomPDSFX"+n,e,t)}cF(n,e,t){return s(n="CustomPDSFX"+n,e,t)}}{const x=["B","B2","B3","B4","F","V2","V3","V4","I","I2","I3","I4","M2","M3","M4","TC","T2"];function S(n){r.ParameterUtils["parameter"+n]&&(m.prototype["parameter"+n]=function(e){return r.ParameterUtils["parameter"+n](e)},m.prototype["prm"+n]=function(e){return r.ParameterUtils["parameter"+n](e)}),r.ParameterUtils["parameterInOut"+n]&&(m.prototype["parameterInOut"+n]=function(e){return r.ParameterUtils["parameterInOut"+n](e)},m.prototype["prmIO"+n]=function(e){return r.ParameterUtils["parameterInOut"+n](e)}),r.ParameterUtils["parameterInOutPrivate"+n]&&(m.prototype["parameterInOutG"+n]=function(e){return r.ParameterUtils["parameterInOutPrivate"+n](e)},m.prototype["prmIOG"+n]=function(e){return r.ParameterUtils["parameterInOutPrivate"+n](e)}),r.ParameterUtils["parameterRef"+n]&&(m.prototype["parameterRef"+n]=function(e){return r.ParameterUtils["parameterRef"+n](e)},m.prototype["prmRef"+n]=function(e){return r.ParameterUtils["parameterRef"+n](e)}),r.ParameterUtils["parameterRefPrivate"+n]&&(m.prototype["parameterRefG"+n]=function(e){return r.ParameterUtils["parameterRefPrivate"+n](e)},m.prototype["prmRefG"+n]=function(e){return r.ParameterUtils["parameterRefPrivate"+n](e)})}for(let _=0;_<x.length;_++){S(x[_])}const y="Struct";r.ParameterUtils["parameter"+y]&&(m.prototype["parameter"+y]=function(n,e){return r.ParameterUtils["parameter"+y](n,e)},m.prototype["prm"+y]=function(n,e){return r.ParameterUtils["parameter"+y](n,e)}),r.ParameterUtils["parameterInOut"+y]&&(m.prototype["parameterInOut"+y]=function(n,e){return r.ParameterUtils["parameterInOut"+y](n,e)},m.prototype["prmIO"+y]=function(n,e){return r.ParameterUtils["parameterInOut"+y](n,e)}),r.ParameterUtils["parameterInOutPrivate"+y]&&(m.prototype["parameterInOutG"+y]=function(n,e){return r.ParameterUtils["parameterInOutPrivate"+y](n,e)},m.prototype["prmIOG"+y]=function(n,e){return r.ParameterUtils["parameterInOutPrivate"+y](n,e)}),r.ParameterUtils["parameterRef"+y]&&(m.prototype["parameterRef"+y]=function(n,e){return r.ParameterUtils["parameterRef"+y](n,e)},m.prototype["prmRef"+y]=function(n,e){return r.ParameterUtils["parameterRef"+y](n,e)}),r.ParameterUtils["parameterRefPrivate"+y]&&(m.prototype["parameterRefG"+y]=function(n,e){return r.ParameterUtils["parameterRefPrivate"+y](n,e)},m.prototype["prmRefG"+y]=function(n,e){return r.ParameterUtils["parameterRefPrivate"+y](n,e)})}const c=new m,$=new u,p=r.BridgeFunctions,d=new Proxy(p,{set(n,e,t){},get(n,e,t){if("sample2DTextureBias"===e||"sampleCubeTextureBias"===e)throw e+" is not available in the vertex shader";"sampleCubeTexture"!==e&&"sample2DTexture"!==e||(e+="Grad");const r=n[e];return r instanceof Function?function(...e){return r.apply(n,e)}:r}});class f{constructor(){this.userDefines=null,this.pdsfxDefines=null,this.__internalOptions__=null}_initContext(n,e,t){this.userDefines={},Object.assign(this.userDefines,n),this.pdsfxDefines={},Object.assign(this.pdsfxDefines,e),this.__internalOptions__=t}_throw(){if(!this.__internalOptions__)throw"Invalid Operation";this.__internalOptions__.pdsfxShaderBuilderUsed=!0}getTextureUniform(n,t=null){return this._throw(),e.getPDSFXTextureUniform({uniformName:n,uniformIndex:t})}getUniform(n,t=null){return this._throw(),e.getPDSFXUniform({uniformName:n,uniformIndex:t})}vGetWorldViewMatrix(){return this._throw(),this.__internalOptions__.largeScale=!1,s("vGetWorldViewMatrix","m4",[])}vGetWorldViewInvTranspMatrix(){return this._throw(),s("vGetWorldViewInvTranspMatrix","m4",[])}vGetViewMatrix(){return this._throw(),s("vGetViewMatrix","m4",[])}vGetProjectionMatrix(){return this._throw(),s("vGetProjectionMatrix","m4",[])}vGetViewProjectionMatrix(){return this._throw(),s("vGetViewProjectionMatrix","m4",[])}vGetViewInvMatrix(){return this._throw(),s("vGetViewInvMatrix","m4",[])}vGetProjectionInvMatrix(){return this._throw(),s("vGetProjectionInvMatrix","m4",[])}vGetViewProjectionInvMatrix(){return this._throw(),s("vGetViewProjectionInvMatrix","m4",[])}vGetViewInvTranspMatrix(){return this._throw(),s("vGetViewInvTranspMatrix","m4",[])}vGetTextureMatrix(){return this._throw(),s("vGetTextureMatrix","m4",[])}vGetWorldEyePos(){return this._throw(),s("vGetWorldEyePos","v3",[])}vGetLowlightColor(){return this._throw(),s("vGetLowlightColor","v3",[])}vGetDefaultPointSize(){return this._throw(),s("vGetDefaultPointSize","f",[])}vGetNearFarLogFactor(){return this._throw(),s("vGetNearFarLogFactor","v3",[])}vGetViewportSize(){return this._throw(),s("vGetViewportSize","i2",[])}vGet3x3WorldMatrix(){return this._throw(),s("vGet3x3WorldMatrix","m3",[])}vGet3x3WorldInvTranspMatrix(){return this._throw(),s("vGet3x3WorldInvTranspMatrix","m3",[])}vComputeWorldScaling(){return this._throw(),s("vComputeWorldScaling","v3",[])}vGetInstanceData(n){return this._throw(),s("vGetInstanceData","v4",[(e=n,o.parameterI(e))]);var e}get variableHandler(){return this._throw(),$}get functionHandler(){return this._throw(),c}get bridgeFunctions(){return this._throw(),p}dispose(){this.userDefines=null,this.pdsfxDefines=null,this.__internalOptions__=null}}return{Vertex:class extends f{constructor(){super()}getVarying(n){return this._throw(),t.getPDSFXVarying(n,t.ShaderStages.out)}vGetInstanceID(){return this._throw(),s("vGetInstanceID","i",[])}vGetVertexID(){return this._throw(),s("vGetVertexID","i",[])}vGetAttribPosition(){return this._throw(),s("vGetAttribPosition","v3",[])}vGetAttribPreviousPosition(){return this._throw(),s("vGetAttribPreviousPosition","v3",[])}vGetAttribFollowingPosition(){return this._throw(),s("vGetAttribFollowingPosition","v3",[])}vGetAttribNormal(){return this._throw(),s("vGetAttribNormal","v3",[])}vGetAttribColor(){return this._throw(),this.__internalOptions__.pdsfxUseVertexColors=!0,s("vGetAttribColor","v3",[])}vGetAttribColorAlpha(){return this._throw(),this.__internalOptions__.pdsfxUseVertexColors=!0,s("vGetAttribColorAlpha","f",[])}vGetAttribTexCoord0(){return this._throw(),this.__internalOptions__.useUV=!0,s("vGetAttribTexCoord0","v4",[])}vGetAttribTexCoord1(){return this._throw(),this.__internalOptions__.useUV=!0,this.__internalOptions__.pdsfxUseUv2=!0,s("vGetAttribTexCoord1","v4",[])}vGetAttribTexCoord2(){return this._throw(),this.__internalOptions__.useUV=!0,this.__internalOptions__.pdsfxUseUv3=!0,s("vGetAttribTexCoord2","v4",[])}vGetAttribTangent(){return this._throw(),this.__internalOptions__.pdsfxUseTangentBinormal=!0,s("vGetAttribTangent","v3",[])}vGetAttribBinormal(){return this._throw(),this.__internalOptions__.pdsfxUseTangentBinormal=!0,s("vGetAttribBinormal","v3",[])}vGetHalfWidth(){return this._throw(),s("vGetHalfWidth","f",[])}get bridgeFunctions(){return this._throw(),d}},Fragment:class extends f{constructor(){super()}getVarying(n){return this._throw(),t.getPDSFXVarying(n,t.ShaderStages.in)}vGetFragCoord(){return this._throw(),s("vGetFragCoord","v4",[])}vGetSampleID(){return this._throw(),s("vGetSampleID","i",[])}vSetFragDepth(n){return this._throw(),this.__internalOptions__.pdsfxUseFragDepth=!0,s("vSetFragDepth",null,[r.ParameterUtils.parameterF(n)])}vIsFrontFacing(){return this._throw(),s("vIsFrontFacing","b",[])}vGetPointCoord(){return this._throw(),s("vGetPointCoord","v2",[])}vGetViewPosition(){return this._throw(),s("vGetViewPosition","v3",[])}vGetViewNormal(){return this._throw(),s("vGetViewNormal","v3",[])}vGetViewTangent(){return this._throw(),s("vGetViewTangent","v3",[])}vGetViewBinormal(){return this._throw(),s("vGetViewBinormal","v3",[])}vGetTexCoord0(){return this._throw(),this.__internalOptions__.useUV=!0,s("vGetTexCoord0","v4",[])}vGetTexCoord1(){return this._throw(),this.__internalOptions__.useUV=!0,this.__internalOptions__.pdsfxUseUv2=!0,s("vGetTexCoord1","v4",[])}vGetTexCoord2(){return this._throw(),this.__internalOptions__.useUV=!0,this.__internalOptions__.pdsfxUseUv3=!0,s("vGetTexCoord2","v4",[])}vGetMappingOperatorTexCoord0(n){return this._throw(),this.__internalOptions__.useUV=!0,this.__internalOptions__.pdsfxUseMappedUv=!0,s("vGetMappingOperatorTexCoord0","v4",[i(n)])}vGetMappingOperatorTexCoord1(n){return this._throw(),this.__internalOptions__.useUV=!0,this.__internalOptions__.pdsfxUseUv2=!0,this.__internalOptions__.pdsfxUseMappedUv2=!0,s("vGetMappingOperatorTexCoord1","v4",[i(n)])}vGetMappingOperatorTexCoord2(n){return this._throw(),this.__internalOptions__.useUV=!0,this.__internalOptions__.pdsfxUseUv3=!0,this.__internalOptions__.pdsfxUseMappedUv3=!0,s("vGetMappingOperatorTexCoord2","v4",[i(n)])}vGetClipSpacePosition(){return this._throw(),s("vGetClipSpacePosition","v4",[])}vGetHalfWidth(){return this._throw(),s("vGetHalfWidth","f",[])}vGetOpacity(){return this._throw(),s("vGetOpacity","f",[])}vGetTranslucency(){return this._throw(),s("vGetTranslucency","f",[])}vGetThickness(){return this._throw(),s("vGetThickness","f",[])}vGetTransparency(){return this._throw(),s("vGetTransparency","f",[])}vGetRoughness(){return this._throw(),s("vGetRoughness","f",[])}vGetClearcoat(){return this._throw(),s("vGetClearcoat","f",[])}vGetClearcoatRoughness(){return this._throw(),s("vGetClearcoatRoughness","f",[])}vGetFlakeCoverage(){return this._throw(),s("vGetFlakeCoverage","f",[])}vGetFlakeRoughness(){return this._throw(),s("vGetFlakeRoughness","f",[])}vGetFlakeSize(){return this._throw(),s("vGetFlakeSize","f",[])}vGetFlipFlop(){return this._throw(),s("vGetFlipFlop","f",[])}vGetSheen(){return this._throw(),s("vGetSheen","f",[])}vGetSheenRoughness(){return this._throw(),s("vGetSheenRoughness","f",[])}vGetMetallic(){return this._throw(),s("vGetMetallic","f",[])}vGetSpecular(){return this._throw(),s("vGetSpecular","f",[])}vGetAnisotropy(){return this._throw(),s("vGetAnisotropy","f",[])}vGetAnisotropyRotation(){return this._throw(),s("vGetAnisotropyRotation","f",[])}vGetIridescence(){return this._throw(),s("vGetIridescence","f",[])}vGetIridescenceThickness(){return this._throw(),s("vGetIridescenceThickness","f",[])}vGetEmissive(){return this._throw(),s("vGetEmissive","v3",[])}vGetSpecularReflectance(){return this._throw(),s("vGetSpecularReflectance","v3",[])}vGetSpecularTint(){return this._throw(),s("vGetSpecularReflectance","v3",[])}vGetAlbedo(){return this._throw(),s("vGetAlbedo","v3",[])}vGetClearcoatColor(){return this._throw(),s("vGetClearcoatColor","v3",[])}vGetTranslucencyColor(){return this._throw(),s("vGetTranslucencyColor","v3",[])}vGetFlakeColor(){return this._throw(),s("vGetFlakeColor","v3",[])}vGetFlipFlopColor(){return this._throw(),s("vGetFlipFlopColor","v3",[])}vGetSheenColor(){return this._throw(),s("vGetSheenColor","v3",[])}}}})),define("DS/ShaderBuilders/Commons/FogShaders",["DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r){"use strict";const a=e=>n.addObjectUniform(e),o=e=>{var t={uniformName:e};return n.getObjectUniform(t)},i=n=>e.addVarying(n),s=n=>e.getShaderInput(n),l=n=>e.getShaderOutput(n),u=(n=null)=>{var e={name:n};return r.float(e)};return{fog_pars_vertex:function(n){return n.fogViewMode?i({varyingName:"bvmDepth",varyingType:"f"}):""},fog_vertex:function(n){return n.fogViewMode?`${t="bvmDepth",e.getVarying(t,e.ShaderStages.out)} = ${l("position")}.w;`:"";var t},fog_pars_fragment:function(n){return n.fogViewMode?`\n                ${a({uniformName:"backgroundViewModeControl",uniformType:"v4"})} \n                ${a({uniformName:"backgroundViewModeNearFar",uniformType:"v2"})} \n                ${i({varyingName:"bvmDepth",varyingType:"f"})}\n            `:""},fog_fragment:function(t){return t.fogViewMode?`                \n\t\t\t\tif(${o("backgroundViewModeControl")}.w > 0.5)\n\t\t\t\t{\n\t\t\t\t\t${u("isOrtho")};\n                    if (${a="projectionMatrix",i={uniformName:a},n.getGlobalUniform(i)}[2].w < 0.0 ) {\n                        isOrtho = 0.0;\n                    } else {\n                        isOrtho = 1.0;\n                    } \n\t\t\t\t\t${u("bvm_fog_depth")} = (${(n=>e.getVarying(n,e.ShaderStages.in))("bvmDepth")} - ${o("backgroundViewModeNearFar")}.x) / (${o("backgroundViewModeNearFar")}.y - ${o("backgroundViewModeNearFar")}.x);\n\t\t\t\t\t${u("fog_mix")} = ${s("fragCoord")}.z * ${s("fragCoord")}.w * isOrtho + (1.0 - isOrtho) * bvm_fog_depth;\n\t\t\t\t\tfog_mix = min(max(fog_mix, 0.0), 1.0);\n\t\t\t\t\t${((n=null)=>{var e={name:n};return r.vec3(e)})("finalFogColor")}  = ${l("out0")}.xyz * (1.0 - fog_mix) + ${o("backgroundViewModeControl")}.xyz * fog_mix;\n                    ${l("out0")}.x = finalFogColor.x;\n                    ${l("out0")}.y = finalFogColor.y;\n                    ${l("out0")}.z = finalFogColor.z;\n\t\t\t\t}\n            `:"";var a,i},backgroundviewmode_lowlight_fragment:function(n){return n.lowlightViewMode?`              \n\t\t\t\tif(${o("backgroundViewModeControl")}.w > 0.0)\n\t\t\t\t{\n\t\t\t\t\t${l("out0")}.x *= 0.55;\n\t\t\t\t\t${l("out0")}.y *= 0.55;\n\t\t\t\t\t${l("out0")}.z *= 0.55;\n\t\t\t\t}\n            `:""}}})),define("DS/ShaderBuilders/SimpleMapShaderBuilder",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a,o){"use strict";const i=a.ParameterUtils,s=a.FunctionHandler,l=a.BridgeFunctions,u=n=>i.parameterV2(n),m=n=>i.parameterV3(n),c=n=>i.parameterT2(n),$=(n,e,t)=>s.callFunction(n,e,t),p=n=>t.addUniform(n),d=n=>{var e={uniformName:n};return t.getUniform(e)},f=(n=null)=>{var e={name:n};return o.vec2(e)},h=(n=null,e=0)=>{var t={name:n,size:e};return o.vec4(t)};return new e((function(e,a){let i=n._ShaderChunk,v=n._DefaultShaderChunk,g=a.shaderContext&&a.shaderContext.isWebGPU;const x=(S={uniformName:"tEnvMap"},t.getTextureUniform(S));var S;let y=`\n            ${p({uniformName:"tEnvMap",uniformType:"t2"})}\n            ${p({uniformName:"ambient",uniformType:"v3"})}\n            ${p({uniformName:"backgroundColor",uniformType:"v3"})}\n            ${p({uniformName:"backgroundAlpha",uniformType:"f"})}\n            ${p({uniformName:"invSize",uniformType:"v2"})}\n            ${p({uniformName:"offset",uniformType:"v2"})}\n            ${p({uniformName:"envMapExposure",uniformType:"f"})}\n\n            ${a.useHDR&&!a.useHDRFloat?`\n                ${p({uniformName:"envMapHDRSize",uniformType:"v2"})}\n                ${v.ibl_sample_methods(a)}\n                `:""}\n\n            ${i.postprocess_pars_fragment(a)}\n\n            ${s.getMainFragmentStart(a)}\n                ${f("localOffset")} = ${d("offset")};\n                ${g?"localOffset.y = - localOffset.y;":""}\n                ${f("coord")}  = (${(n=>r.getShaderInput(n))("fragCoord")}.xy - localOffset) * ${d("invSize")};\n                ${l.uvConvention("coord")}\n                ${h("color")} = ${h()}(0.0);\n\n                ${a.useHDR&&!a.useHDRFloat?`\n                    coord.x = 1.0 - coord.x;\n                    ${f("texelSize")}  = 1.0 / envMapHDRSize;\n                    color = ${$("texture2DRGBE","v4",[c(x),u("coord")])};\n                    `:`color = ${l.sample2DTexture(x,"coord")};`}\n\n                ${a.gammaInput&&a.useSRGB?`\n                    color = ${h()}(${$("convertToLinear","v3",[m("color.rgb")])}, color.a);\n                    `:""}\n\n                ${f("edge")}  = step(${f()}(0.0), coord) - step(${f()}(1.0), coord);\n                ${((n=null)=>{var e={name:n};return o.float(e)})("mixCoeff")} = edge.x * edge.y;\n                ${h("backgroundValue")} = vec4(${d("backgroundColor")},${d("backgroundAlpha")});\n                ${h("foregroundValue")} = color * vec4(${d("ambient")} * ${d("envMapExposure")}, 1.0);\n                ${(n=>r.getShaderOutput(n))("out0")} = foregroundValue * mixCoeff +  backgroundValue * (1.0 - mixCoeff) ;\n                ${i.postprocess_fragment(a)}\n                ${i.linear_to_gamma_fragment(a)}\n            ${s.getMainFragmentEnd(a)}\n        `;return{vertexShader:`\n\n            ${s.getMainVertexStart(a)}\n                ${v.model_view_projection_transformation_vertex(a)}\n            ${s.getMainVertexEnd(a)}\n        `,fragmentShader:y}}))})),define("DS/ShaderBuilders/GradientBackgroundShaderBuilder",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a,o){"use strict";const i=a.ParameterUtils,s=a.FunctionHandler,l=n=>i.parameterV3(n),u=(n,e,t)=>a.FunctionHandler.callFunction(n,e,t),m=n=>t.addUniform(n),c=n=>{var e={uniformName:n};return t.getUniform(e)},$=(n=null)=>{var e={name:n};return o.float(e)},p=(n=null,e=0)=>{var t={name:n,size:e};return o.vec3(t)},d=(n=null,e=0)=>{var t={name:n,size:e};return o.vec4(t)},f=n=>r.addVarying(n),h=n=>r.getVarying(n,r.ShaderStages.in),v=n=>r.getVarying(n,r.ShaderStages.out),g=n=>r.getShaderOutput(n);return{Gradient2Builder:new e((function(e,t){let r=n._ShaderChunk,a=n._DefaultShaderChunk,o=`\n            \n            ${f({varyingName:"vColor",varyingType:"v3"})}\n\n            ${r.postprocess_pars_fragment(t)}\n\n            ${s.getMainFragmentStart(t)}\n                ${d("finalColor")} = ${d()}(${h("vColor")}, 1.0);\n                ${p("convertedColor")} = ${u("convertToLinear","v3",[l("finalColor.xyz")])};\n                ${g("out0")}.x = convertedColor.x;\n                ${g("out0")}.y = convertedColor.y;\n                ${g("out0")}.z = convertedColor.z;\n\t\t\t\t${g("out0")}.a = 1.0;\n\n                ${r.postprocess_fragment(t)}\n                ${r.linear_to_gamma_fragment(t)}\n            ${s.getMainFragmentEnd(t)}\n        `;return{vertexShader:`\n            ${m({uniformName:"colors",uniformType:"fv3",size:2})}\n            ${m({uniformName:"YUp",uniformType:"i"})}\n            ${f({varyingName:"vColor",varyingType:"v3"})}\n\n            ${s.getMainVertexStart(t)}\n                if (${c("YUp")} == 0){\n                    ${v("vColor")} = mix(${c("colors")}[0], ${c("colors")}[1], smoothstep(-1.0, 1.0, position_.z));\n                } else {\n                    ${v("vColor")} = mix(${c("colors")}[0], ${c("colors")}[1], smoothstep(-1.0, 1.0, position_.y));\n                }\n                ${a.model_view_projection_transformation_vertex(t)}\n            ${s.getMainVertexEnd(t)}\n        `,fragmentShader:o}})),Gradient3Builder:new e((function(e,t){let r=n._ShaderChunk,a=n._DefaultShaderChunk,o=`\n            \n            ${f({varyingName:"vColor",varyingType:"v3"})}\n\n            ${r.postprocess_pars_fragment(t)}\n\n            ${s.getMainFragmentStart(t)}\n                ${d("finalColor")} = ${d()}(${h("vColor")}, 1.0);\n                \n                ${p("convertedColor")} = ${u("convertToLinear","v3",[l("finalColor.xyz")])};\n                ${g("out0")}.x = convertedColor.x;\n                ${g("out0")}.y = convertedColor.y;\n                ${g("out0")}.z = convertedColor.z;\n\t\t\t\t${g("out0")}.a = 1.0;\n\n                ${r.postprocess_fragment(t)}\n                ${r.linear_to_gamma_fragment(t)}\n            ${s.getMainFragmentEnd(t)}\n        `;return{vertexShader:`\n            ${m({uniformName:"colors",uniformType:"fv3",size:3})}\n            ${m({uniformName:"YUp",uniformType:"i"})}\n       \n            ${f({varyingName:"vColor",varyingType:"v3"})}\n\n            ${s.getMainVertexStart(t)}\n                ${p("borderColor")};\n                ${$("a")};\n                if (${c("YUp")} == 0){\n                    borderColor = mix(${c("colors")}[2], ${c("colors")}[0], step(0.0, position_.z));\n                    a = sign(position_.z) * position_.z;\n                } else {\n                    borderColor = mix(${c("colors")}[2], ${c("colors")}[0], step(0.0, position_.y));\n                    a = sign(position_.y) * position_.y;\n                }\n                ${v("vColor")} = mix(${c("colors")}[1], borderColor, a);\n                ${a.model_view_projection_transformation_vertex(t)}\n            ${s.getMainVertexEnd(t)}\n        `,fragmentShader:o}})),Gradient4Builder:new e((function(e,t){let r=n._ShaderChunk,a=n._DefaultShaderChunk,o=`\n            ${m({uniformName:"colors",uniformType:"fv3",size:4})}\n            ${m({uniformName:"horizonHeight",uniformType:"f"})}\n            ${m({uniformName:"skylineFading",uniformType:"f"})}\n\n            ${f({varyingName:"vPositionZ",varyingType:"f"})}\n\n            ${r.postprocess_pars_fragment(t)}\n\n            ${s.getMainFragmentStart(t)}\n                ${$("positionSign")}  = step(${c("horizonHeight")}, ${h("vPositionZ")});\n                ${p("centerColor")}  = positionSign * ${c("colors")}[1] + ((1.0 - positionSign) * ${c("colors")}[3]);\n                ${p("borderColor")}  = positionSign * ${c("colors")}[0] + ((1.0 - positionSign) * ${c("colors")}[2]);\n\n                ${$("minHeight")}  = positionSign * ${c("horizonHeight")} + ((1.0 - positionSign) * -1.0);\n                ${$("maxHeight")}  = positionSign + ((1.0 - positionSign) * ${c("horizonHeight")});\n                ${p("color")}  = mix(centerColor, borderColor, smoothstep(minHeight, maxHeight, ${h("vPositionZ")}));\n                if ((${c("skylineFading")} > 0.0) && (positionSign == 1.0)) {\n                    color = ${p()}(smoothstep(${c("horizonHeight")}, ${c("horizonHeight")} + ${c("skylineFading")}, ${h("vPositionZ")}));\n                }\n\n                ${d("finalColor")} = ${d()}(color, 1.0);\n                \n                ${p("convertedColor")} = ${u("convertToLinear","v3",[l("finalColor.xyz")])};\n                ${g("out0")}.x = convertedColor.x;\n                ${g("out0")}.y = convertedColor.y;\n                ${g("out0")}.z = convertedColor.z;\n\t\t\t\t${g("out0")}.a = 1.0;\n                ${r.postprocess_fragment(t)}\n                ${r.linear_to_gamma_fragment(t)}\n            ${s.getMainFragmentEnd(t)}\n        `;return{vertexShader:`\n            ${m({uniformName:"YUp",uniformType:"i"})}\n\n            ${f({varyingName:"vPositionZ",varyingType:"f"})}\n\n            ${s.getMainVertexStart(t)}\n                if (${c("YUp")} == 0){\n                    ${v("vPositionZ")} = position_.z;\n                } else {\n                    ${v("vPositionZ")} = position_.y;\n                }\n                ${a.model_view_projection_transformation_vertex(t)}\n                ${s.getMainVertexEnd(t)}\n        `,fragmentShader:o}}))}})),define("DS/ShaderBuilders/Commons/ShadowingShaders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a){"use strict";const o="",i=r.ParameterUtils,s=r.FunctionHandler,l=r.BridgeFunctions,u=(n,e)=>i.parameter(n,e),m=n=>i.parameterF(n),c=n=>i.parameterI(n),$=n=>i.parameterV2(n),p=n=>i.parameterV3(n),d=n=>i.parameterV4(n),f=n=>i.parameterRefV4(n),h=n=>i.parameterT2(n),v=n=>i.parameterTC(n),g=(n,e,t)=>s.declareFunction(n,e,t),x=(n,e,t)=>s.callFunction(n,e,t),S=n=>e.addShadowUniform(n),y=n=>{var t={uniformName:n};return e.getShadowUniform(t)},_=(n,t)=>{var r={uniformName:n,uniformIndex:t};return e.getShadowTextureUniform(r)},T=n=>t.addVarying(n),D=n=>t.getVarying(n,t.ShaderStages.in),C=(n,e)=>t.getVarying(n,t.ShaderStages.in,e),P=n=>t.getShaderOutput(n),N=(n=null)=>{var e={name:n};return a.bool(e)},b=(n=null)=>{var e={name:n};return a.int(e)},M=(n=null,e=0)=>{var t={name:n,size:e};return a.float(t)},U=(n=null,e=0,t="")=>{var r={name:n,size:e,addressSpace:t};return a.vec2(r)},w=(n=null)=>{var e={name:n};return a.bvec2(e)},V=(n=null,e=0)=>{var t={name:n,size:e};return a.vec3(t)},z=(n=null,e=0,t="")=>{var r={name:n,size:e,addressSpace:t};return a.vec4(r)},F=(n=null)=>{var e={name:n};return a.bvec4(e)},I=n=>{var e={name:n,constant:!0};return a.int(e)},R=n=>{var e={name:n,constant:!0};return a.float(e)},A=(n,e)=>l.sample2DTexture(n,e),L=(n,e)=>l.sampleCubeTexture(n,e),B=(n,e,t)=>x("texture2DCompare","f",[h(n),$(e),m(t)]),E=n=>x("unpackDepthESM","f",[d(n)]),k=(n,e,t,r,a)=>x("texture2DShadowLerp","f",[h(n),$(e),$(t),$(r),m(a)]),O=(n,e,t,r,a)=>x("compESM","f",[h(n),$(e),m(t),$(r),$(a)]),G=(n,e,t,r)=>x("esmLinearSampling","f",[h(n),$(e),$(t),$(r)]),H=(n,e,t)=>x("textureCubeCompare","f",[v(n),p(e),m(t)]);function X(e){function t(n,e){return`\n            for  (${b("i")} = 0; i < ${n}; i ++) {\n                for  (${b("j")} = 0; j < ${e}; j ++) {\n                    shadow += uw[i] * vw[j] *  ${k("iShadowMap","iShadowMapSize","pixelOffset",`base_uv + ${U()}(u[i],v[j])`,"shadowCoord.z")};\n                }\n            }\n            `}function r(n,e){for(var t,r,a,i,s,l=o,u=0;u<n;u++)for(var c=0;c<e;c++)l=`\n                        ${l}\n                        shadow += uw${u} * vw${c} *  ${t="iShadowMap",r="iShadowMapSize",a="pixelOffset",i=`base_uv + ${U()}(u${u},v${c})`,s="depthFragOffset",x("texture2DShadowESMLerp","f",[h(t),$(r),$(a),$(i),m(s)])};\n                    `;return l}switch(e.shadowMapType){case n.PCFShadowMap:return`\n                ${M("shadow")}  = 0.0;\n                ${e.shadowMapQuality===n.MediumQuality?`\n                    ${R("shadowDelta")}  = 1.0 / 25.0;\n                    ${I("fetchCount")}  = 5;\n                    `:o}\n                ${e.shadowMapQuality===n.HighQuality?`\n                    ${R("shadowDelta")}  = 1.0 / 49.0;\n                    ${I("fetchCount")}  = 7;\n                    `:o}\n                ${e.shadowMapQuality!==n.HighQuality&&e.shadowMapQuality!==n.MediumQuality?`\n                    ${R("shadowDelta")}  = 1.0 / 9.0;\n                    ${I("fetchCount")}  = 3;\n                    `:o}\n                ${M("xPixelOffset")}  = 1.0 / iShadowMapSize.x;\n                ${M("yPixelOffset")}  = 1.0 / iShadowMapSize.y;\n                ${M("dx0")}  = -1.25 * ${M()}((fetchCount-1)/2) *xPixelOffset;\n                ${M("dy0")}  = -1.25 * ${M()}((fetchCount-1)/2) *yPixelOffset;\n                ${M("dx1")}  = 1.25 * xPixelOffset;\n                ${M("dy1")}  = 1.25 * yPixelOffset;\n\n                ${M("fDepth")} ;\n                ${U("delta")}  = ${U()}(dx0,dy0);\n                for  (${b("i")} = 0; i < fetchCount; i ++) {\n                    for  (${b("j")} = 0; j < fetchCount; j ++) {\n                        shadow += shadowDelta * ${B("iShadowMap","shadowCoord.xy + delta","shadowCoord.z")};\n                        delta.y +=dy1;\n                    }\n                    delta.y =dy0;\n                    delta.x +=dx1;\n                }\n                return shadow;\n                `;case n.PCFSoftShadowMap:return`\n                ${M("shadow")} = 0.0;\n                ${M("xPixelOffset")}  = 1.0 / iShadowMapSize.x;\n                ${M("yPixelOffset")}  = 1.0 / iShadowMapSize.y;\n                ${M("dx0")}  = -1.0 * xPixelOffset;\n                ${M("dy0")}  = -1.0 * yPixelOffset;\n                ${M("dx1")}  = 1.0 * xPixelOffset;\n                ${M("dy1")}  = 1.0 * yPixelOffset;\n\n                ${((n=null)=>{var e={name:n};return a.mat3(e)})("shadowKernel")} ;\n                ${U("delta")}  = ${U()}(dx0,dy0);\n                for  (${b("i")} = 0; i < 3; i ++) {\n                    for  (${b("j")} = 0; j < 3; j ++) {\n                        shadowKernel[i][j]= 0.25 * ${B("iShadowMap","shadowCoord.xy + delta","shadowCoord.z")};\n                        delta.y +=dy1;\n                    }\n                    delta.y =dy0;\n                    delta.x +=dx1;\n                }\n                ${U("fractionalCoord")} = 1.0 - fract( shadowCoord.xy * iShadowMapSize.xy );\n\n                shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\n                shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\n\n                ${z("shadowValues")} ;\n                shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\n                shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\n                shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\n                shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\n                shadow = dot( shadowValues, vec4( 1.0 ) );\n                return shadow;\n                `;case n.PCFInterpolShadowMap:return`\n                ${M("shadow")}  = 0.0;\n                ${R("dimFilter")}  = 4.0;\n                ${R("sizeFilter")}  = dimFilter * dimFilter;\n                ${R("shadowDelta")}  = 1.0 / sizeFilter;\n                ${U("shadowPixelSize")}  = 1.0 / iShadowMapSize;\n                for (${M("xFilter")}  = -0.5 * dimFilter + 0.5; xFilter <= 0.5 * dimFilter; xFilter += 1.0) {\n                    for (${M("yFilter")}  = -0.5 * dimFilter + 0.5; yFilter <= 0.5 * dimFilter; yFilter += 1.0) {\n                        shadow += ${k("iShadowMap","iShadowMapSize","shadowPixelSize",`shadowCoord.xy + shadowPixelSize * ${U()}(xFilter, yFilter)`,"shadowCoord.z")};\n                    }\n                }\n                shadow *= shadowDelta;\n                return shadow;\n                `;case n.PCFPoissonShadowMap:return`\n                ${M("shadow")}  = 0.0;\n                ${M("xPixelOffset")}  = 1.0/ iShadowMapSize.x;\n                ${M("yPixelOffset")}  = 1.0 / iShadowMapSize.y;\n                ${M("randAngle")}  = ${x("randomValue","f",[p("shadowCoord.xyz"),m("fract(shadowCoord.x*shadowCoord.y)"),d("globalPCFPoissonFragCoord")])}* 2.0 * 3.14159265359;\n                \n                for  (${b("i")} = 0; i < poissonCount; i ++) {\n                    ${U("p")}  = poisson49[i];\n                    ${M("posX")}  = (cos(randAngle)*p.x-sin(randAngle)*p.y)*xPixelOffset;\n                    ${M("posY")}  = (sin(randAngle)*p.x+cos(randAngle)*p.y)*yPixelOffset;\n                    shadow += ${B("iShadowMap",`shadowCoord.xy + ${U()}(posX,posY)`,"shadowCoord.z")};\n                }\n                shadow *= poissonInvSamples;\n                return shadow;\n                `;case n.PCFOptimizedShadowMap:return`\n                ${M("shadow")}  = 0.0;\n                ${U("fractCoord")}  = fract(shadowCoord.xy * iShadowMapSize + 0.5);\n                ${U("pixelOffset")}  = 1.0 / iShadowMapSize;\n                ${U("base_uv")}  = (shadowCoord.xy * iShadowMapSize - fractCoord) * pixelOffset;\n                ${e.shadowMapQuality===n.MediumQuality?`\n                    ${M("uw",3)};\n                    uw[0]  = (4.0 - 3.0 * fractCoord.x);\n                    uw[1]  = 7.0;\n                    uw[2]  = (1.0 + 3.0 * fractCoord.x);\n\n                    ${M("u",3)};\n                    u[0] = ((3.0 - 2.0 * fractCoord.x) / uw[0] - 2.0) * pixelOffset.x;\n                    u[1] = ((3.0 + fractCoord.x) / uw[1]) * pixelOffset.x;\n                    u[2] = (fractCoord.x / uw[2] + 2.0) * pixelOffset.x;\n\n                    ${M("vw",3)};\n                    vw[0] = (4.0 - 3.0 * fractCoord.y);\n                    vw[1] = 7.0;\n                    vw[2] = (1.0 + 3.0 * fractCoord.y);\n\n                    ${M("v",3)};\n                    v[0] = ((3.0 - 2.0 * fractCoord.y) / vw[0] - 2.0) * pixelOffset.y;\n                    v[1] = ((3.0 + fractCoord.y) / vw[1]) * pixelOffset.y;\n                    v[2] = (fractCoord.y / vw[2] + 2.0) * pixelOffset.y;\n\n                    ${t(3,3)}\n\n                    shadow *= 0.0069444;\n                    `:o}\n                ${e.shadowMapQuality===n.HighQuality?`\n                    ${M("uw",4)};\n                    uw[0]  = (5.0 * fractCoord.x - 6.0);\n                    uw[1]  = (11.0 * fractCoord.x - 28.0);\n                    uw[2]  = -(11.0 * fractCoord.x + 17.0);\n                    uw[3]  = -(5.0 * fractCoord.x + 1.0);\n\n                    ${M("u",4)};\n                    u[0] = ((4.0 * fractCoord.x - 5.0) / uw[0] - 3.0) * pixelOffset.x;\n                    u[1] = ((4.0 * fractCoord.x - 16.0) / uw[1] - 1.0) * pixelOffset.x;\n                    u[2] = (-(7.0 * fractCoord.x + 5.0) / uw[2] + 1.0) * pixelOffset.x;\n                    u[3] = (-fractCoord.x / uw[3] + 3.0) * pixelOffset.x;\n\n                    ${M("vw",4)};\n                    vw[0] = (5.0 *fractCoord.y - 6.0);\n                    vw[1] = (11.0 *fractCoord.y - 28.0);\n                    vw[2] = -(11.0 *fractCoord.y + 17.0);\n                    vw[3] = -(5.0 *fractCoord.y + 1.0);\n\n                    ${M("v",4)};\n                    v[0] = ((4.0 *fractCoord.y - 5.0) / vw[0] - 3.0) * pixelOffset.y;\n                    v[1] = ((4.0 *fractCoord.y - 16.0) / vw[1] - 1.0) * pixelOffset.y;\n                    v[2] = (-(7.0 *fractCoord.y + 5.0) / vw[2] + 1.0) * pixelOffset.y;\n                    v[3] = (-fractCoord.y / vw[3] + 3.0) * pixelOffset.y;\n\n                    ${t(4,4)}\n\n                    shadow *= 0.0003698225;\n                    `:o}\n                ${e.shadowMapQuality!==n.HighQuality&&e.shadowMapQuality!==n.MediumQuality?`\n                    ${M("uw",2)};\n                    uw[0]  = (3.0 - 2.0 * fractCoord.x);\n                    uw[1]  = (1.0 + 2.0 * fractCoord.x);\n\n                    ${M("u",2)};\n                    u[0] = ((2.0 - fractCoord.x) / uw[0] - 1.0) * pixelOffset.x;\n                    u[1] = (fractCoord.x / uw[1] + 1.0) * pixelOffset.x;\n\n                    ${M("vw",2)};\n                    vw[0] = (3.0 - 2.0 * fractCoord.y);\n                    vw[1] = (1.0 + 2.0 * fractCoord.y);\n\n                    ${M("v",2)};\n                    v[0] = ((2.0 - fractCoord.y) / vw[0] - 1.0) * pixelOffset.y;\n                    v[1] = (fractCoord.y / vw[1] + 1.0) * pixelOffset.y;\n\n                    ${t(2,2)}\n\n                    shadow *= 0.0625;\n                    `:o}\n                return shadow;\n                `;case n.ESMShadowMap:function i(){for(var n=`\n                        ${M("zMaxNeighbor")} = 0.0;\n                        ${U("coordDetect")};\n                    `,e=-1;e<=1;e++)for(var t=-1;t<=1;t++)if(0!==e||e!==t){var r=-1===e?"-pixelOffset.x":0===e?"0.0":"pixelOffset.x",a=-1===t?"-pixelOffset.y":0===t?"0.0":"pixelOffset.y";n=`\n                                ${n}\n                                coordDetect = shadowCoord.xy + ${U()}(${r}, ${a});\n                                zMaxNeighbor = max(zMaxNeighbor, ${G("iShadowMap","coordDetect","iShadowMapSize","pixelOffset")});\n                            `}return`\n                        ${n}\n                        zMaxNeighbor = log(zMaxNeighbor) * 0.0125;\n                    `}return`\n                ${M("shadow")}  = 0.0;\n                ${M("depthFragOffset")}  = shadowCoord.z;\n                ${U("pixelOffset")}  = 1.0 / iShadowMapSize.xy;\n\n                shadow = ${O("iShadowMap","shadowCoord.xy","depthFragOffset","iShadowMapSize","pixelOffset")};\n\n                ${i()}\n\n                if(zMaxNeighbor < 0.9999999 && (shadowCoord.z + 0.015) < zMaxNeighbor) {\n                    shadow = 0.0;\n\n                    ${U("fractCoord")}  = fract(shadowCoord.xy * iShadowMapSize + 0.5);\n                    ${U("base_uv")}  = (shadowCoord.xy * iShadowMapSize - fractCoord) * pixelOffset;\n\n                    ${M("uw0")}  = (4.0 - 3.0 * fractCoord.x);\n                    ${M("uw1")}  = 7.0;\n                    ${M("uw2")}  = (1.0 + 3.0 * fractCoord.x);\n\n                    ${M("u0")}  = ((3.0 - 2.0 * fractCoord.x) / uw0 - 2.0) * pixelOffset.x;\n                    ${M("u1")}  = ((3.0 + fractCoord.x) / uw1) * pixelOffset.x;\n                    ${M("u2")}  = (fractCoord.x / uw2 + 2.0) * pixelOffset.x;\n\n                    ${M("vw0")}  = (4.0 - 3.0 * fractCoord.y);\n                    ${M("vw1")}  = 7.0;\n                    ${M("vw2")}  = (1.0 + 3.0 * fractCoord.y);\n\n                    ${M("v0")}  = ((3.0 - 2.0 * fractCoord.y) / vw0 - 2.0) * pixelOffset.y;\n                    ${M("v1")}  = ((3.0 + fractCoord.y) / vw1) * pixelOffset.y;\n                    ${M("v2")}  = (fractCoord.y / vw2 + 2.0) * pixelOffset.y;\n\n                    ${r(3,3)}\n\n                    shadow *= 0.0069444;\n\n\n                    shadow = clamp(shadow * 2.0, 0.0, 1.0);\n\n                } else {\n\n                    shadow *= shadow * shadow;\n                    shadow = 1.0 - clamp(shadow, 0.0, 1.0);\n                }\n                return shadow;\n                `;case n.ESMImprovedShadowMap:return`\n                        ${M("shadow")}  = 0.0;\n                        ${M("depthFragOffset")}  = shadowCoord.z;\n\n                        ${U("uv")}  = shadowCoord.xy * iShadowMapSize;\n                        ${U("pixelOffset")}  = 1.0 / iShadowMapSize.xy;\n                        ${U("base_uv")}  = floor(uv + 0.5);\n                        ${U("fractCoord")}  = uv + 0.5 - base_uv;\n\n                        base_uv = (base_uv - 0.5) * pixelOffset;\n\n                        ${M("uw0")}  = (3.0 - 2.0 * fractCoord.x);\n                        ${M("uw1")}  = (1.0 + 2.0 * fractCoord.x);\n\n                        ${M("u0")}  = ((2.0 - fractCoord.x) / uw0 - 1.0) * pixelOffset.x;\n                        ${M("u1")}  = (fractCoord.x / uw1 + 1.0 ) * pixelOffset.x;\n\n                        ${M("vw0")}  = (3.0 - 2.0 * fractCoord.y);\n                        ${M("vw1")}  = (1.0 + 2.0 * fractCoord.y);\n\n                        ${M("v0")}  = ((2.0 - fractCoord.y) / vw0 - 1.0) * pixelOffset.y;\n                        ${M("v1")}  = (fractCoord.y / vw1 + 1.0) * pixelOffset.y;\n                 \n                        ${r(2,2)}\n\n                        shadow *= 0.0625;\n\n                        shadow = clamp(shadow * 1.5, 0.0, 1.0);\n                        \n                        return shadow;\n                \n                `;default:return`return ${B("iShadowMap","shadowCoord.xy","shadowCoord.z")};`}}function W(n,e){var t=o;if(e){t=`\n                ${t}\n                ${g("getExposureFromIndexCube","f",[c("index"),p("worldPosition")])}{\n                    ${M("result")} ;\n            `;for(r=0;r<n.maxShadowsCube;r++)t=`\n                    ${t}\n                    if (index == ${r}) {\n                        result = ${x("getExposure","f",[p(`${y("shadowPointPosition")}[${r}].xyz`),p("worldPosition"),v(_("shadowMapCube",r)),m(`${y("shadowCubeInfos")}[${r}].y`),m(`${y("shadowPointPosition")}[${r}].w`),m(`${y("shadowCubeInfos")}[${r}].z`),m(`${y("shadowCubeInfos")}[${r}].w`)])};\n                    }\n                `;t=`\n                ${t}\n                    return result;\n                }\n            `}else{t=`\n                ${t}\n                ${g("getExposureFromIndex","f",[c("index")])}{\n                    ${M("result")} ;\n            `;for(var r=0;r<n.maxShadows;r++)t=`\n                    ${t}\n                    if (index == ${r}) {\n                        result = ${x("getExposure","f",[d(`gShadowCoord[${r}]`),h(_("shadowMap",r)),m(`${y("shadowMapSizeDarknessBias")}[${r}].w`),$(`${y("shadowMapSizeDarknessBias")}[${r}].xy`)])};\n                    }\n                `;t=`\n                ${t}\n                    return result;\n                }\n            `}if(n.transparentShadowEnabled)if(e){t=`\n                    ${t}\n                    ${g("getTransparentExposureFromIndexCube","v4",[c("index"),p("worldPosition")])}{\n                        ${z("result")} ;\n                `;for(r=0;r<n.maxShadowsCube;r++)t=`\n                        ${t}\n                        if (index == ${r}) {\n                            ${z("lPosition")}  =  ${z()}( ${y("shadowPointPosition")}[${r}].xyz, 1.0 );\n                            ${V("pointVector")}  = normalize(worldPosition.xyz-lPosition.xyz);\n                            result = ${L(_("transparentShadowMapCube",r),"pointVector")};\n                        }\n                    `;t=`\n                    ${t}\n                        return result;\n                    }\n                `}else{t=`\n                    ${t}\n                    ${g("getTransparentExposureFromIndex","v4",[c("index")])}{\n                        ${z("result")} ;\n                `;for(var r=0;r<n.maxShadows;r++)t=`\n                        ${t}\n                        if (index == ${r}) {\n                            ${V("shadowCoord")}  = gShadowCoord[${r}].xyz / gShadowCoord[${r}].w;\n                            ${M("isNotbehindFrustum")}  = step(0.0,gShadowCoord[${r}].w);\n                            result = isNotbehindFrustum * ${A(_("transparentShadowMap",r),"shadowCoord.xy")} + (1.0-isNotbehindFrustum) * ${z()}(1.0);\n                        }\n                    `;t=`\n                    ${t}\n                        return result;\n                    }\n                `}return t}return{shadowmap_pars_fragment:function(e){var t,r="";if(e.shadowMapEnabled||e.shadowMapCubeEnabled){if(r=`\n                    ${r}\n                    ${g("unpackDepthESM","f",[d("rgba_depth")])}{\n                        ${M("depth")}  = ${x("unpackRGB","f",[p("rgba_depth.xyz")])} * pow(10.0,rgba_depth.w*255.0);\n                        return depth;\n                    }\n\n                    ${g("randomValue","f",[p("scale"),m("seed"),d("fragCoord")])}{\n                        return fract(sin(dot(fragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n                    }\n                `,e.shadowMapEnabled){var s=e.maxShadows;r=`\n                        ${r}\n                        ${S({uniformName:"shadowMap",uniformType:"t2v",size:s})} \n                        ${S({uniformName:"shadowMapSizeDarknessBias",uniformType:"fv4",size:s})} \n                        ${S({uniformName:"shadowMapNearFar",uniformType:"fv4",size:s})} \n                        ${e.transparentShadowDeclarationEnabled?`\n                            ${S({uniformName:"transparentShadowMap",uniformType:"t2v",size:s})} \n                            ${e.maxDirLights>0?S({uniformName:"directionalLightColorNoIntensity",uniformType:"fv4",size:e.maxDirLights}):o}\n                            ${e.maxSpotLights>0?S({uniformName:"spotLightColorNoIntensity",uniformType:"fv4",size:e.maxSpotLights}):o}\n                            `:o}\n                        ${I("SHADOWS_DIR_END")}  = ${e.maxDirShadows};\n                        ${I("SHADOWS_SPOT_START")}  = SHADOWS_DIR_END;\n                        ${I("SHADOWS_SPOT_END")}  = SHADOWS_SPOT_START + ${e.maxSpotShadows};\n                        ${I("SHADOWS_DIR_IBL_START")}  = SHADOWS_SPOT_END;\n                        ${I("SHADOWS_DIR_IBL_END")}  = SHADOWS_DIR_IBL_START + ${e.maxDirIBLShadows};\n                        ${I("SHADOWS_CASTABLE_END")}  = SHADOWS_DIR_IBL_START;\n                    `,e.shadowMapType!==n.PCFPoissonShadowMap&&e.shadowMapType!==n.PCFInterpolShadowMap||(r=`\n                            ${r}\n                            ${z("globalPCFPoissonFragCoord",0,"private")};\n                            ${U("poisson49",49,"private")};\n\n                            ${g("initDiskPCF",null,[])} {\n                                poisson49[0] = ${U()}( -0.770613,-0.239161);\n                                poisson49[1] = ${U()}( 0.654029,-0.712337);\n                                poisson49[2] = ${U()}( -0.307109,0.184156);\n                                poisson49[3] = ${U()}( 0.511665,0.311578);\n                                poisson49[4] = ${U()}( 0.950228,-0.256954);\n                                poisson49[5] = ${U()}( -0.00583136,-0.537149);\n                                poisson49[6] = ${U()}( -0.692077,0.433278);\n                                poisson49[7] = ${U()}( -0.357517,0.88078);\n                                poisson49[8] = ${U()}( 0.278742,0.859941);\n                                poisson49[9] = ${U()}( -0.631555,-0.471973);\n                                poisson49[10] = ${U()}( -0.480475,-0.732053);\n                                poisson49[11] = ${U()}( -0.486058,0.576291);\n                                poisson49[12] = ${U()}( 0.190138,-0.625394);\n                                poisson49[13] = ${U()}( -0.176393,-0.166675);\n                                poisson49[14] = ${U()}( 0.0663065,-0.333703);\n                                poisson49[15] = ${U()}( 0.348117,-0.812683);\n                                poisson49[16] = ${U()}( 0.0817859,0.0594559);\n                                poisson49[17] = ${U()}( 0.375191,-0.0632498);\n                                poisson49[18] = ${U()}( 0.770788,-0.0723965);\n                                poisson49[19] = ${U()}( 0.800971,0.431381);\n                                poisson49[20] = ${U()}( -0.100114,0.320657);\n                                poisson49[21] = ${U()}( 0.285262,0.61499);\n                                poisson49[22] = ${U()}( -0.579148,0.219349);\n                                poisson49[23] = ${U()}( -0.684372,-0.0462647);\n                                poisson49[24] = ${U()}( -0.313914,-0.939188);\n                                poisson49[25] = ${U()}( -0.414696,0.367707);\n                                poisson49[26] = ${U()}( 0.698927,0.219188);\n                                poisson49[27] = ${U()}( 0.971183,0.130313);\n                                poisson49[28] = ${U()}( 0.0822042,0.526062);\n                                poisson49[29] = ${U()}( -0.214193,0.522263);\n                                poisson49[30] = ${U()}( -0.0751906,0.901432);\n                                poisson49[31] = ${U()}( 0.488676,-0.253098);\n                                poisson49[32] = ${U()}( -0.580828,0.778049);\n                                poisson49[33] = ${U()}( 0.816108,-0.536974);\n                                poisson49[34] = ${U()}( 0.51456,0.543311);\n                                poisson49[35] = ${U()}( -0.213744,-0.428735);\n                                poisson49[36] = ${U()}( 0.293803,-0.405018);\n                                poisson49[37] = ${U()}( 0.169169,0.259656);\n                                poisson49[38] = ${U()}( 0.445091,-0.594255);\n                                poisson49[39] = ${U()}( -0.453123,-0.1009);\n                                poisson49[40] = ${U()}( -0.420509,-0.388243);\n                                poisson49[41] = ${U()}( 0.576791,0.0184982);\n                                poisson49[42] = ${U()}( 0.610535,0.759891);\n                                poisson49[43] = ${U()}( 0.692311,-0.348235);\n                                poisson49[44] = ${U()}( 0.0912182,0.752741);\n                                poisson49[45] = ${U()}( -0.840539,0.203544);\n                                poisson49[46] = ${U()}( 0.0673295,-0.961926);\n                                poisson49[47] = ${U()}( -0.951943,0.0129663);\n                                poisson49[48] = ${U()}( -0.14793,-0.811125);\n                            }\n                            ${e.shadowMapQuality===n.MediumQuality?`\n                                ${I("poissonCount")}  = 25;\n                                ${R("poissonInvSamples")}  = 0.04;\n                                `:o}\n                            ${e.shadowMapQuality===n.HighQuality?`\n                                ${I("poissonCount")}  = 49;\n                                ${R("poissonInvSamples")}  = 0.02040816326;\n                                `:o}\n                            ${e.shadowMapQuality!==n.HighQuality&&e.shadowMapQuality!==n.MediumQuality?`\n                                ${I("poissonCount")}  = 9;\n                                ${R("poissonInvSamples")}  = 0.111111;\n                                `:o}\n                        \n                        `),r=`\n                        ${r}\n                        ${z("gShadowCoord",s,"private")};\n                        ${e.isDecal?`\n                            ${S({uniformName:"shadowMatrix",uniformType:"m4v",size:s})} \n                            ${S({uniformName:"shadowCameraPosition",uniformType:"fv4",size:s})} \n                            ${S({uniformName:"lowPartShadowCameraPosition",uniformType:"fv4",size:s})} \n                            `:T({varyingName:"vShadowCoord",varyingType:"fv4",size:s})}\n                    `,e.shadowMapType!==n.ESMShadowMap&&e.shadowMapType!==n.ESMImprovedShadowMap||(r=`\n                            ${r}\n                            ${g("esmLinearSampling","f",[h("iShadowMap"),$("coord"),$("iShadowMapSize"),$("invSize")])}{\n                                ${e.uintESM?`\n                                    ${U("fractCoord")}  = fract(coord*iShadowMapSize + 0.5);\n                                    ${U("centroidUV")}  = (coord*iShadowMapSize - fractCoord) * invSize;\n                                    ${M("lb")}  = ${E(`${A("iShadowMap","centroidUV")}`)};\n                                    ${M("lt")}  = ${E(`${A("iShadowMap",`centroidUV + ${U()}(0.0, invSize.y)`)}`)};\n                                    ${M("rb")}  = ${E(`${A("iShadowMap",`centroidUV + ${U()}(invSize.x, 0.0)`)}`)};\n                                    ${M("rt")}  = ${E(`${A("iShadowMap","centroidUV + invSize")}`)};\n                                    ${M("a")}  = mix(lb, lt, fractCoord.y);\n                                    ${M("b")}  = mix(rb, rt, fractCoord.y);\n                                    return mix(a, b, fractCoord.x);\n                                    `:`\n                                    return ${A("iShadowMap","coord")}.x;\n                                    `}\n                            }\n\n                            ${g("compESM","f",[h("iShadowMap"),$("coord"),m("depthFrag"),$("iShadowMapSize"),$("shadowPixelSize")])}{\n                                ${M("result")}  = ${G("iShadowMap","coord","iShadowMapSize","shadowPixelSize")} * exp(-80.0 * depthFrag);\n                                return result * result;\n                            }\n\n                            ${g("texture2DESMToPCFCompare","f",[h("iShadowMap"),$("coord"),m("depthFrag"),$("iShadowMapSize"),$("shadowPixelSize")])}{\n                                ${M("depthShadowMap")}  = log(${G("iShadowMap","coord","iShadowMapSize","shadowPixelSize")}) / 80.0;\n                                return step(depthShadowMap, depthFrag);\n                            }\n\n                            ${g("texture2DShadowESMLerp","f",[h("iShadowMap"),$("iShadowMapSize"),$("shadowPixelSize"),$("coord"),m("depthFrag")])}{ \n                                ${U("fractCoord")}  = fract(coord * iShadowMapSize + 0.5);\n                                ${U("centroidUV")}  = (coord * iShadowMapSize - fractCoord) * shadowPixelSize;\n                                ${M("lb")}  = clamp(${O("iShadowMap","centroidUV","depthFrag","iShadowMapSize","shadowPixelSize")}, 0.0, 1.0);\n                                ${M("lt")}  = clamp(${O("iShadowMap",`centroidUV + ${U()}(0.0, shadowPixelSize.y)`,"depthFrag","iShadowMapSize","shadowPixelSize")}, 0.0, 1.0);\n                                ${M("rb")}  = clamp(${O("iShadowMap",`centroidUV + ${U()}(shadowPixelSize.x, 0.0)`,"depthFrag","iShadowMapSize","shadowPixelSize")}, 0.0, 1.0);\n                                ${M("rt")}  = clamp(${O("iShadowMap","centroidUV + shadowPixelSize","depthFrag","iShadowMapSize","shadowPixelSize")}, 0.0, 1.0);\n                                ${M("a")}  = mix(lb, lt, fractCoord.y);\n                                ${M("b")}  = mix(rb, rt, fractCoord.y);\n                                return 1.0 - mix(a, b, fractCoord.x);\n                            }\n                        `),r=`\n                        ${r}\n                        ${g("texture2DCompare","f",[h("iShadowMap"),$("coord"),m("depthFrag")])}{\n                            ${M("depthShadowMap")}  = ${x("unpackRGBA","f",[d(`${A("iShadowMap","coord")}`)])};\n                            return step(depthShadowMap, depthFrag);\n                        }\n                        ${g("texture2DShadowLerp","f",[h("iShadowMap"),$("iShadowMapSize"),$("shadowPixelSize"),$("coord"),m("depthFrag")])}{\n                            ${U("fractCoord")} = fract(coord * iShadowMapSize + 0.5);\n                            ${U("centroidUV")} = (coord * iShadowMapSize - fractCoord) * shadowPixelSize;\n                            ${M("lb")} = ${B("iShadowMap","centroidUV","depthFrag")};\n                            ${M("lt")} = ${B("iShadowMap",`centroidUV + ${U()}(0.0, shadowPixelSize.y)`,"depthFrag")};\n                            ${M("rb")} = ${B("iShadowMap",`centroidUV + ${U()}(shadowPixelSize.x, 0.0)`,"depthFrag")};\n                            ${M("rt")} = ${B("iShadowMap","centroidUV + shadowPixelSize","depthFrag")};\n                            ${M("a")} = mix(lb, lt, fractCoord.y);\n                            ${M("b")} = mix(rb, rt, fractCoord.y);\n                            return mix(a, b, fractCoord.x);\n                        }\n                        ${g("getExposureForShadowType","f",[h("iShadowMap"),p("shadowCoord"),$("iShadowMapSize")])}{\n                            ${X(e)}\n                        }\n\n                        ${g("getExposure","f",[d("iShadowCoord"),h("iShadowMap"),m("iShadowBias"),$("iShadowMapSize")])}{\n                            ${V("shadowCoord")}  = iShadowCoord.xyz / iShadowCoord.w;\n                            ${F("inFrustumVec")}  = ${F()} ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n                            ${N("inFrustum")}  = all( inFrustumVec );\n                            \n                            ${M("exposureResult")}  = 0.0;\n                            ${w("frustumTestVec")}  = ${w()}( inFrustum, shadowCoord.z <= 1.0 );\n                            ${N("frustumTest")}  = all( frustumTestVec );\n\n                            if ( frustumTest ) {\n                                shadowCoord.z += iShadowBias;              \n                                exposureResult = ${x("getExposureForShadowType","f",[h("iShadowMap"),p("shadowCoord"),$("iShadowMapSize")])};\n                            }                \n                            return max(1.0-exposureResult,0.0);\n                        }\n                \n                        ${W(e,!1)}\n\n                        ${e.shadowMapCascade?`\n                            ${g("getExposureCascaded","f",[(t="transparentExposure",i.parameterInOutV4(t))])}{\n                                ${M("exposure")}  = 1.0;\n                                ${b("inFrustumCount")}  = 0;   \n                                ${function(n){for(var e,t=`\n            ${V("shadowCoord")} ;\n            ${F("inFrustumVec")} ;\n            ${N("inFrustum")} ;\n            ${w("inFrustumAndZVec")} ;\n            ${N("inFrustumAndZ")} ;\n            ${w("frustumTestVec")} ;\n            ${N("frustumTest")} ;\n        `,r=0;r<n.maxDirShadows;r++)t=`\n                ${t}\n                shadowCoord = gShadowCoord[${r}].xyz / gShadowCoord[${r}].w;\n                inFrustumVec = ${F()} ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n                inFrustum = all( inFrustumVec );\n                inFrustumAndZVec = ${w()}(inFrustum, shadowCoord.z <= 1.0);\n                inFrustumAndZ = all(inFrustumAndZVec);\n                inFrustumCount += ${b()}( inFrustumAndZ );\n                frustumTestVec = ${w()}( inFrustumAndZ, inFrustumCount == 1 );\n                frustumTest = all( frustumTestVec );\n                if ( frustumTest ) {\n                    exposure = ${x("getExposure","f",[d(`gShadowCoord[${r}]`),h(_("shadowMap",r)),m(`${y("shadowMapSizeDarknessBias")}[${r}].w`),$(`${y("shadowMapSizeDarknessBias")}[${r}].xy`)])};\n            `,n.transparentShadowEnabled&&(t=`\n                    ${t}\n                    ${V("shadowCoord")}  = gShadowCoord[${r}].xyz / gShadowCoord[${r}].w;\n                    ${M("isNotbehindFrustum")}  = step(0.0,gShadowCoord[${r}].w);\n                    ${e="transparentExposure",a.dereference(e)} = isNotbehindFrustum * ${A(_("transparentShadowMap",r),"shadowCoord.xy")} + (1.0-isNotbehindFrustum) * ${z()}(1.0);\n                `),n.shadowMapDebug&&(t=`\n                    ${t}\n                    if ( frustumTest ) {\n                        exposure *=  ${M()}(${r/n.maxDirShadows});\n                    }\n                `),t=`\n                ${t}\n                }\n            `;return t}(e)}                       \n                                return exposure;                           \n                            }\n                            `:o}\n                    `}if(e.shadowMapCubeEnabled){var l=e.maxShadowsCube;r=`\n                        ${r}\n\n                        ${S({uniformName:"shadowMapCube",uniformType:"tcv",size:l})} \n                        ${e.transparentShadowDeclarationEnabled?`\n                            ${S({uniformName:"transparentShadowMapCube",uniformType:"tcv",size:l})} \n                            ${e.maxPointLights>0?S({uniformName:"pointLightColorNoIntensity",uniformType:"fv4",size:e.maxPointLights}):o}\n                            `:o}\n                        ${S({uniformName:"shadowCubeInfos",uniformType:"fv4",size:l})}\n                        ${S({uniformName:"shadowPointPosition",uniformType:"fv4",size:l})} \n                        \n                        ${g("textureCubeCompare","f",[v("iShadowMap"),p("coord"),m("depthFrag")])}{\n                            ${z("fetchedValue")} = ${L("iShadowMap","coord")};\n                            ${M("depthShadowMap")}  = ${x("unpackRGBA","f",[d("fetchedValue")])};\n                            return step(depthShadowMap, depthFrag);\n                        }\n                        \n                        ${e.shadowMapType===n.ESMShadowMap||e.shadowMapType===n.ESMImprovedShadowMap?`\n                            ${g("esmLinearSamplingCube","f",[v("iShadowMap"),p("coord"),m("iShadowMapSize")])}{\n                                ${e.uintESM?`\n                                    ${V("absCoord")}  = abs(coord);\n                                \t${M("mainComp")}  = max(max(absCoord.x,absCoord.y),absCoord.z);\n                                \t${V("mainDir")}  = step(${V()}(mainComp),absCoord);\n                                \tif(dot(mainDir,${V()}(1.0))>1.0){\n                                        ${z("fetchedValue")} = ${L("iShadowMap","coord")};\n                                \t\treturn ${E("fetchedValue")};\n                                \t}else{                    \n                                \t\t${M("smSize")} =iShadowMapSize; \n                                \t\t${U("uv")} ;\n                                \t\t${V("uv3")} ;\n                                \t\t${M("lengthRatio")} ;\n                                \t\tif(mainDir.x == 1.0){\n                                \t\t\tuv = coord.yz;\n                                \t\t\tlengthRatio = abs(coord.x);\n                                \t\t}else if(mainDir.y == 1.0){\n                                \t\t\tuv = coord.xz;\n                                \t\t\tlengthRatio = abs(coord.y);\n                                \t\t}else{\n                                \t\t\tuv = coord.xy;\n                                \t\t\tlengthRatio = abs(coord.z);\n                                \t\t}\n\n                                \t\tuv/=lengthRatio;\n                                \t\tuv = (uv+${U()}(1.0)) * 0.5;\n\n                                \t\t${U("invSize")}  = ${U()}(1.0/smSize);\n\n                                        ${U("fractCoord")}  = fract(uv*smSize + ${U()}(0.5));\n                                        ${U("centroidUV")} = (uv*smSize - fractCoord) * invSize;\n                                \t\t${U("ltUv")}  =centroidUV + ${U()}(0.0, invSize.y);\n                                \t\t${U("rbUv")}  =centroidUV + ${U()}(invSize.x, 0.0);\n                                \t\t${U("rtUv")}  =centroidUV + invSize;\n\n                                \t\tcentroidUV = (centroidUV*2.0)-1.0;\n                                \t\tltUv = (ltUv*2.0)-1.0;\n                                \t\trbUv = (rbUv*2.0)-1.0;\n                                \t\trtUv = (rtUv*2.0)-1.0;\n\n                                \t\tcentroidUV *= lengthRatio;\n                                \t\tltUv *= lengthRatio;\n                                \t\trbUv *= lengthRatio;\n                                \t\trtUv *= lengthRatio;\n\n                                        ${V("centroidCoord")} ;\n                                \t\t${V("ltCoord")} ;\n                                \t\t${V("rbCoord")} ;\n                                \t\t${V("rtCoord")} ;\n                                \t\tif(mainDir.x == 1.0){\n                                   \t\t    centroidCoord = normalize( ${V()}(coord.x,centroidUV));\n                                \t\t\tltCoord = normalize(${V()}(coord.x,ltUv));\n                                \t\t\trbCoord = normalize(${V()}(coord.x,rbUv));\n                                \t\t\trtCoord = normalize(${V()}(coord.x,rtUv));\n                                \t\t}else if(mainDir.y == 1.0){\n                                   \t\t    centroidCoord = normalize(${V()}(centroidUV.x,coord.y,centroidUV.y));\n                                \t\t\tltCoord = normalize(${V()}(ltUv.x,coord.y,ltUv.y));\n                                \t\t\trbCoord = normalize(${V()}(rbUv.x,coord.y,rbUv.y));\n                                \t\t\trtCoord = normalize(${V()}(rtUv.x,coord.y,rtUv.y));\n                                \t\t}else{\n                                   \t\t    centroidCoord = normalize(${V()}(centroidUV,coord.z));\n                                \t\t\tltCoord = normalize(${V()}(ltUv,coord.z));\n                                \t\t\trbCoord = normalize(${V()}(rbUv,coord.z));\n                                \t\t\trtCoord = normalize(${V()}(rtUv,coord.z));\n                                \t\t}\n                    \n                                   \t${M("lb")} = ${E(`${L("iShadowMap","centroidCoord")}`)};\n                                   \t${M("lt")} = ${E(`${L("iShadowMap","ltCoord")}`)};\n                                   \t${M("rb")} = ${E(`${L("iShadowMap","rbCoord")}`)};\n                                   \t${M("rt")} = ${E(`${L("iShadowMap","rtCoord")}`)};\n                                   \t${M("a")} = mix(lb, rb, fractCoord.x);\n                                   \t${M("b")} = mix(lt, rt, fractCoord.x);\n                                   \treturn mix(a, b, fractCoord.y);\n                                   }\n                                    `:`return ${L("iShadowMap","coord")}.x;`}\n                            }\n                        \n                            ${g("compESMCube","f",[v("iShadowMap"),p("coord"),m("depthFrag"),m("iShadowMapSize")])}{\n                                ${M("result")}  = ${x("esmLinearSamplingCube","f",[v("iShadowMap"),p("coord"),m("iShadowMapSize")])} * exp(-80.0 * depthFrag);\n                                result = 1.0 - clamp(result * result * result * result,0.0,1.0);\n                                return result;\n                            }\n                            `:o}\n\n                        ${e.shadowMapType===n.PCFOptimizedShadowMap||e.shadowMapType===n.PCFPoissonShadowMap||e.shadowMapType===n.PCFShadowMap?`\n                            ${g("getExposureCubePCF","f",[p("normPointVector"),m("iShadowMapSize"),v("iShadowMap"),m("depth")])}{\n                                ${V("rndseed")}  = ${V()}(12.9898,78.233,45.5432);\n                                ${V("randomDir")}  = ${V()}( dot(normPointVector,rndseed) , dot(normPointVector.yzx,rndseed) , dot(normPointVector.zxy,rndseed) );\n                                randomDir = fract(sin(randomDir) * 43758.5453);\n                                \n                                ${M("pixelSize")}  = 2.0 / iShadowMapSize;\n                                \n                                ${V("xvec")}  = normalize(cross(normPointVector,randomDir))* pixelSize *1.1;\n                                ${V("yvec")}  = normalize(cross(normPointVector,xvec))* pixelSize *1.1;\n\n                                ${M("divider")}  = 8.0;\n                                \n                                ${M("inShadow")}  = 0.0;\n                                inShadow += ${H("iShadowMap","normPointVector+xvec+yvec","depth")};\n                                inShadow += ${H("iShadowMap","normPointVector+xvec","depth")};\n                                inShadow += ${H("iShadowMap","normPointVector+xvec-yvec","depth")};\n                                inShadow += ${H("iShadowMap","normPointVector+yvec","depth")};\n                                inShadow += ${H("iShadowMap","normPointVector-yvec","depth")};\n                                inShadow += ${H("iShadowMap","normPointVector-xvec+yvec","depth")};\n                                inShadow += ${H("iShadowMap","normPointVector-xvec","depth")};\n                                inShadow += ${H("iShadowMap","normPointVector-xvec-yvec","depth")};\n                                \n                                ${e.shadowMapQuality===n.HighQuality||e.shadowMapQuality===n.MediumQuality?`\n                                    divider = 20.0;\n                                    inShadow += ${H("iShadowMap","normPointVector+2.0*xvec+yvec","depth")};\n                                    inShadow += ${H("iShadowMap","normPointVector+2.0*xvec","depth")};\n                                    inShadow += ${H("iShadowMap","normPointVector+2.0*xvec-yvec","depth")};\n                                    inShadow += ${H("iShadowMap","normPointVector-2.0*xvec+yvec","depth")};\n                                    inShadow += ${H("iShadowMap","normPointVector-2.0*xvec","depth")};\n                                    inShadow += ${H("iShadowMap","normPointVector-2.0*xvec-yvec","depth")};\n                                    inShadow += ${H("iShadowMap","normPointVector+2.0*yvec+xvec","depth")};\n                                    inShadow += ${H("iShadowMap","normPointVector+2.0*yvec","depth")};\n                                    inShadow += ${H("iShadowMap","normPointVector+2.0*yvec-xvec","depth")};\n                                    inShadow += ${H("iShadowMap","normPointVector-2.0*yvec+xvec","depth")};\n                                    inShadow += ${H("iShadowMap","normPointVector-2.0*yvec","depth")};\n                                    inShadow += ${H("iShadowMap","normPointVector-2.0*yvec-xvec","depth")};\n                                    `:o}\n\n                                ${e.shadowMapQuality===n.HighQuality?`\n                                    divider = 36.0;\n                                    inShadow += ${H("iShadowMap","normPointVector+3.0*xvec+yvec","depth")};\n                                    inShadow += ${H("iShadowMap","normPointVector+3.0*xvec","depth")};\n                                    inShadow += ${H("iShadowMap","normPointVector+3.0*xvec-yvec","depth")};\n                                    inShadow += ${H("iShadowMap","normPointVector-3.0*xvec+yvec","depth")};\n                                    inShadow += ${H("iShadowMap","normPointVector-3.0*xvec","depth")};\n                                    inShadow += ${H("iShadowMap","normPointVector-3.0*xvec-yvec","depth")};\n                                    inShadow += ${H("iShadowMap","normPointVector+3.0*yvec+xvec","depth")};\n                                    inShadow += ${H("iShadowMap","normPointVector+3.0*yvec","depth")};\n                                    inShadow += ${H("iShadowMap","normPointVector+3.0*yvec-xvec","depth")};\n                                    inShadow += ${H("iShadowMap","normPointVector-3.0*yvec+xvec","depth")};\n                                    inShadow += ${H("iShadowMap","normPointVector-3.0*yvec","depth")};\n                                    inShadow += ${H("iShadowMap","normPointVector-3.0*yvec-xvec","depth")};\n                                    inShadow += ${H("iShadowMap","normPointVector+2.0*xvec+2.0*yvec","depth")};\n                                    inShadow += ${H("iShadowMap","normPointVector+2.0*xvec-2.0*yvec","depth")};\n                                    inShadow += ${H("iShadowMap","normPointVector-2.0*xvec-2.0*yvec","depth")};\n                                    inShadow += ${H("iShadowMap","normPointVector-2.0*xvec+2.0*yvec","depth")};\n                                    `:o}\n                                \n                                return inShadow / divider;\n                            }\n                            `:o}\n\n                        ${e.isDecal?`${z("decalShadowCubeWorldPosition")} ;`:o}\n                        \n                        ${g("getExposure","f",[p("pointPosition"),p("worldPosition"),v("iShadowMap"),m("iShadowBias"),m("iShadowMapSize"),m("shadowNear"),m("shadowFar")])}{\n                            ${z("lPosition")}  =  ${z()}( pointPosition, 1.0 );\n                            \n                            ${V("pointVector")};\n                            ${e.isDecal?"pointVector = decalShadowCubeWorldPosition.xyz-lPosition.xyz;":"pointVector = worldPosition.xyz-lPosition.xyz;"}\n                            \n                            ${M("exposureResult")}  = 0.0;\n                            \n                            ${V("absVector")}  = abs(pointVector);\n                            ${M("localZComp")}  = max(absVector.x,max(absVector.y,absVector.z));\n                            ${M("normZComp")}  = (shadowFar+shadowNear)/(shadowFar-shadowNear)-(2.0*shadowFar*shadowNear)/(shadowFar-shadowNear)/localZComp;\n                            normZComp = (normZComp + 1.0) * 0.5;\n                            \n                            ${M("depthCube")}  = normZComp +iShadowBias;\n                            \n                            ${V("normPointVector")}  = normalize( pointVector );\n                            \n                            ${e.shadowMapType===n.PCFOptimizedShadowMap||e.shadowMapType===n.PCFPoissonShadowMap||e.shadowMapType===n.PCFShadowMap?`exposureResult = ${x("getExposureCubePCF","f",[p("normPointVector"),m("iShadowMapSize"),v("iShadowMap"),m("depthCube")])};`:`\n                                ${e.shadowMapType===n.ESMShadowMap?`exposureResult = ${x("compESMCube","f",[v("iShadowMap"),p("normPointVector"),m("depthCube"),m("iShadowMapSize")])};`:`exposureResult = ${H("iShadowMap","normPointVector","depthCube")};`}\n                                `}\n                            \n                            return 1.0-exposureResult;\n                        }\n                        ${W(e,!0)}\t\t\n                    `}}return r},shadowmap_fragment_old:function(e){var r,a=`\n            ${M("shadowExposure")}  = 1.0;\n            ${z("transparentExposure")}  = ${z()}(1.0);\n            `;if(e.shadowMapEnabled||e.shadowMapCubeEnabled){if(e.shadowMapType!==n.PCFPoissonShadowMap&&e.shadowMapType!==n.PCFInterpolShadowMap||(a=`\n                        ${a}\n                        globalPCFPoissonFragCoord =${r="fragCoord",t.getShaderInput(r)};\n                        ${x("initDiskPCF",null,[])};`),e.shadowMapEnabled){var i=function(){return`\n                        currentExposure = ${x("getExposureFromIndex","f",[c("i")])};\n                        ${e.transparentShadowEnabled?`currentTransparentExposure = ${x("getTransparentExposureFromIndex","v4",[c("i")])};`:o}\n                        if (currentExposure < 1.0) {\n                            shadowExposure *=1.0 - (${y("shadowMapSizeDarknessBias")}[ i ].z * (1.0-currentExposure));\n                        }\n                        transparentExposure *= ${z()}(1.0) - (${y("shadowMapSizeDarknessBias")}[ i ].z * (${z()}(1.0)-currentTransparentExposure));\n                        `};for(let n=0;n<e.maxShadows;n++)a+=`gShadowCoord[ ${n} ] = ${C("vShadowCoord",n)};`;a=`\n                        ${a}\n                        ${M("currentExposure")}  = 1.0;\n                        ${z("currentTransparentExposure")}  = ${z()}(1.0);\n                        ${e.shadowMapCascade?`\n                            currentExposure  = ${x("getExposureCascaded","f",[f("currentTransparentExposure")])};\n                            `:`\n                            currentExposure = ${x("getExposure","f",[d("gShadowCoord[0]"),h(_("shadowMap",0)),m(`${y("shadowMapSizeDarknessBias")}[0].w`),$(`${y("shadowMapSizeDarknessBias")}[0].xy`)])};\n                            ${e.transparentShadowEnabled?`currentTransparentExposure = ${x("getTransparentExposureFromIndex","v4",[c("0")])};`:o}\n                            `}\n                        if (currentExposure < 1.0) {\n                            shadowExposure *=1.0 - (${y("shadowMapSizeDarknessBias")}[ 0 ].z * (1.0-currentExposure));\n                        }\n                        transparentExposure *= ${z()}(1.0) - (${y("shadowMapSizeDarknessBias")}[ 0 ].z * (${z()}(1.0)-currentTransparentExposure));\n                        ${e.shadowMapCascade?`\n                            ${e.maxShadows>e.maxDirShadows?`\n                                for( ${b("i")} = ${e.maxDirShadows}; i < ${e.maxShadows}; i ++ ) {\n                                    ${i()}\n                                }\n                                `:o}\n                            `:`\n                            ${e.maxShadows>1?`\n                                for( ${b("i")} = 1; i < ${e.maxShadows}; i ++ ) {\n                                    ${i()}\n                                }\n                                `:o} \n                            `}\n                    `}e.shadowMapCubeEnabled&&(a=`\n                        ${a}\n                        for ( ${b("i")} = 0; i < ${e.maxShadowsCube}; i ++ ) {\n                            ${M("currentExposure")}  = ${x("getExposureFromIndexCube","f",[c("i"),p(D("vWorldPosition"))])};\n                            ${z("currentTransparentExposure")}  = ${z()}(1.0);\n                            ${e.transparentShadowEnabled?`currentTransparentExposure = ${x("getTransparentExposureFromIndexCube","v4",[c("i"),p(D("vWorldPosition"))])};`:o}\n                            if (currentExposure < 1.0) {\n                                shadowExposure *= 1.0 - (${y("shadowCubeInfos")}[ i ].x * (1.0-currentExposure));\n                            }\n                            transparentExposure *=  ${z()}(1.0) - (${y("shadowCubeInfos")}[ i ].x * ( ${z()}(1.0)-currentTransparentExposure));\n                        }\n                    `)}return a=`\n            ${a}\n            shadowExposure = min(shadowExposure,transparentExposure.a);\n            ${P("out0")}.x *= transparentExposure.r * shadowExposure;\n            ${P("out0")}.y *= transparentExposure.g * shadowExposure;\n            ${P("out0")}.z *= transparentExposure.b * shadowExposure;\n            `},shadowmap_pars_vertex:function(n){if(!n.shadowMapEnabled||n.isDecal)return o;var e=n.maxShadows;return`\n            ${T({varyingName:"vShadowCoord",varyingType:"fv4",size:e})}\n            ${S({uniformName:"shadowMatrix",uniformType:"m4v",size:e})} \n            ${S({uniformName:"shadowCameraPosition",uniformType:"fv4",size:e})} \n            ${S({uniformName:"lowPartShadowCameraPosition",uniformType:"fv4",size:e})} \n            `},shadowmap_vertex:function(n){if(!n.shadowMapEnabled||n.isDecal)return o;var e,r,a="";for(let o=0;o<n.maxShadows;o++)a+=`${e="vShadowCoord",r=o,t.getVarying(e,t.ShaderStages.out,r)} = ${x("computeShadowCoord","v4",[p("vertexLocalPosition.xyz"),u("m4",`${y("shadowMatrix")}[${o}]`),p(`${y("shadowCameraPosition")}[${o}].xyz`),p(`${y("lowPartShadowCameraPosition")}[${o}].xyz`)])};`;return a},shadowmap_fragment:function(n){if(!n.shadowMapEnabled||n.isDecal)return o;var e="";for(let t=0;t<n.maxShadows;t++)e+=`gShadowCoord[ ${t} ] = ${C("vShadowCoord",t)};`;return e}}})),define("DS/ShaderBuilders/CubeMapShaderBuilder",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a,o){"use strict";const i=a.FunctionHandler,s=a.BridgeFunctions,l=n=>t.addUniform(n),u=n=>{var e={uniformName:n};return t.getUniform(e)},m=(n=null,e=0)=>{var t={name:n,size:e};return o.vec3(t)},c=(n=null,e=0)=>{var t={name:n,size:e};return o.vec4(t)},$=n=>r.addVarying(n);return new e((function(e,a){let o=`\n            ${l({uniformName:"tEnvMap",uniformType:"tc"})}\n            ${l({uniformName:"ambient",uniformType:"v3"})}\n            ${l({uniformName:"ambienceMatrix",uniformType:"m4"})}\n\n            ${$({varyingName:"vWorldPosition",varyingType:"v3"})}\n\n            ${i.getMainFragmentStart(a)}\n                ${m("relPos")}  = ${p="vWorldPosition",r.getVarying(p,r.ShaderStages.in)} - ${(n=>{var e={uniformName:n};return t.getGlobalUniform(e)})("cameraPosition")};\n                relPos = (${u("ambienceMatrix")} * ${c()}(relPos,0.0)).xyz;\n\t\t\t\t${(n=>r.getShaderOutput(n))("out0")} = ${c()}(${u("ambient")}, 1.0) * ${s.sampleCubeTexture((n=>{var e={uniformName:n};return t.getTextureUniform(e)})("tEnvMap"),`${m()}(relPos.x, -relPos.z, relPos.y)`)};\n            ${i.getMainFragmentEnd(a)}\n        `;var p;let d=`\n            ${$({varyingName:"vWorldPosition",varyingType:"v3"})}\n\n            ${i.getMainVertexStart(a)}\n                ${c("worldPosition")}  = modelMatrix * ${c()}( position_, 1.0 );\n                ${(n=>r.getVarying(n,r.ShaderStages.out))("vWorldPosition")} = worldPosition.xyz;\n\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(a)}\n            ${i.getMainVertexEnd(a)}\n        `;return{vertexShader:d,fragmentShader:o}}))})),define("DS/ShaderBuilders/MeshPhongShaderBuilder",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a,o){"use strict";const i="",s=a.ParameterUtils,l=a.FunctionHandler,u=(n,e,t)=>a.FunctionHandler.callFunction(n,e,t),m=n=>t.addUniform(n),c=n=>{var e={uniformName:n};return t.getUniform(e)},$=n=>t.addLightUniform(n),p=n=>{var e={uniformName:n};return t.getLightUniform(e)},d=n=>{var e={uniformName:n};return t.getGlobalUniform(e)},f=(n,e)=>e.highFrequencyColors?(n=>t.addHighFrequencyUniform(n))(n):m(n),h=(n,e)=>e.highFrequencyColors?(n=>{var e={uniformName:n};return t.getHighFrequencyUniform(e)})(n):c(n),v=(n=null)=>{var e={name:n};return o.int(e)},g=(n=null)=>{var e={name:n};return o.float(e)},x=(n=null,e=0)=>{var t={name:n,size:e};return o.vec3(t)},S=(n=null,e=0)=>{var t={name:n,size:e};return o.vec4(t)},y=n=>r.addVarying(n),_=n=>r.getVarying(n,r.ShaderStages.in),T=n=>r.getShaderOutput(n),D=n.TextureBlendOperations;function C(n){return`\n        ${g("diffuseWeightFull")}  = diffuseWeight.x;\n        ${g("diffuseWeightHalf")}  = max( 0.5 * dotProduct + 0.5, 0.0 );\n        diffuseWeight = mix( ${x()}( diffuseWeightFull ), ${x()}( diffuseWeightHalf ), ${c("wrapRGB")} );\n    `}function P(n,e){return`\n            ${S("lDirection")}  = ${d("viewMatrix")} * ${S()}( ${p("directionalLightDirection")}[ ${n} ].xyz, 0.0 );\n            ${x("dirVector")}  = normalize( lDirection.xyz );\n            ${g("dotProduct")}  = dot( normal, dirVector );\n            ${x("diffuseWeight")}  = ${x()}(max( dotProduct, 0.0 ));\n            ${e.wrapAround?`\n                ${C()}\n                `:i}\n            totalDiffuse  += diffuseToUse * ${e.phongFirstDir?"3.0":"1.0"} *${p("directionalLightColor")}[ ${n} ].xyz * diffuseWeight;\n\n            ${x("dirHalfVector")} = normalize( dirVector + view );\n            ${g("dirDotNormalHalf")}  = max( dot( normal, dirHalfVector ), 0.0 );\n            ${g("specularWeight")}  = specularStrength * max( pow( dirDotNormalHalf, shininessValue ), 0.0 );\n            totalSpecular += specularToUse * ${p("directionalLightColor")}[ ${n} ].xyz * specularWeight * diffuseWeight;\n        `}function N(e){let t=`\n            ${n._DefaultShaderChunk.normal_viewposition_pars_fragment(e)}\n            ${e.useLighting?`\n                ${$({uniformName:"ambientLightColor",uniformType:"v4"})}\n                `:i}   \n\n            ${((n=null)=>{var e={name:n,addressSpace:"private"};return o.vec4(e)})("ambientLightColorToUse")} = ${S()}(1.0, 1.0, 1.0, 1.0);\n        `,r=`      \n            ${e.useLighting?`\n                ambientLightColorToUse = ${p("ambientLightColor")};            \n                `:i}      \n            ${n._DefaultShaderChunk.normal_viewposition_fragment(e)}\n            ${e.normalMap?"normal = perturbNormal2Arb( -vPos, normal );":i}\n            ${e.bumpMap&&!e.normalMap?`normal = perturbNormalArb( -vPos, normal, ${u("dHdxy_fwd","v2",[(a=`${_("vUv")}.xy`,s.parameterV2(a))])} );`:i}\n            ${x("totalDiffuse")}  = ${x()}( 0.0 );\n            ${x("totalSpecular")}  = ${x()}( 0.0 );\n        `;var a;return(e.maxSpotLights>0||e.bumpMap||e.normalMap||e.envMap||e.shadowMapCubeEnabled)&&(t=`\n                ${t}\n                ${y({varyingName:"vWorldPosition",varyingType:"v3"})}\n            `),e.wrapAround&&(t=`\n                ${t}\n                ${m({uniformName:"wrapRGB",uniformType:"v3"})}\n            `),e.maxDirLights>0&&(t=`\n                ${t}\n                ${$({uniformName:"directionalLightColor",uniformType:"fv4",size:e.maxDirLights})}\n                ${$({uniformName:"directionalLightDirection",uniformType:"fv4",size:e.maxDirLights})}\n            `,r=`\n                ${r}\n                {\n                    ${P("0",e)}\n                }\n                ${!e.phongFirstDir&&e.maxDirLights>1?`\n                    for( ${v("i")} = 1; i < ${e.maxDirLights} ; i ++ ) { \n                        ${P("i",e)}\n                    }\n                    `:i}\n            `),e.maxDirPhongLights>0&&(t=`\n                ${t}\n                ${$({uniformName:"directionalPhongLightColor",uniformType:"fv4",size:e.maxDirPhongLights})}\n                ${$({uniformName:"directionalPhongLightDirection",uniformType:"fv4",size:e.maxDirPhongLights})}\n            `,e.phongFirstDir||(r=`\n                ${r}\n                for ( ${v("i")} = 0; i < ${e.maxDirPhongLights}; i ++ ) {\n                    ${S("lDirection")}  = ${d("viewMatrix")} * ${S()}( ${p("directionalPhongLightDirection")}[ i ].xyz, 0.0 );\n                    ${x("dirVector")}  = normalize( lDirection.xyz );\n                    ${g("dotProduct")} = dot( normal, dirVector );                 \n                    ${x("diffuseWeight")}  = ${x()}(max( dotProduct, 0.0 ));\n                    ${e.wrapAround?`\n                        ${C()}\n                        `:i}\n                    totalDiffuse  += diffuseToUse * ${p("directionalPhongLightColor")}[ i ].xyz * diffuseWeight;\n                    ${x("dirHalfVector")}  = normalize( dirVector + view );\n                    ${g("dirDotNormalHalf")}  = max( dot( normal, dirHalfVector ), 0.0 );\n                    ${g("specularWeight")}  = specularStrength * max( pow( dirDotNormalHalf, shininessValue ), 0.0 );\n                    totalSpecular += specularToUse * ${p("directionalPhongLightColor")}[ i ].xyz * specularWeight * diffuseWeight;\n                }\n            `)),e.maxPointLights>0&&(t=`\n                ${t}\n                ${$({uniformName:"pointLightColor",uniformType:"fv4",size:e.maxPointLights})}\n                ${$({uniformName:"pointLightPosition",uniformType:"fv4",size:e.maxPointLights})}\n            `,e.phongFirstDir||(r=`\n                ${r}\n                for ( ${v("i")} = 0; i < ${e.maxPointLights}; i ++ ) {\n                    ${S("lPosition")}  = ${d("viewMatrix")} * ${S()}( ${p("pointLightPosition")}[ i ].xyz, 1.0 );\n                    ${x("lVector")}  = lPosition.xyz + vPos.xyz;\n                    ${g("lDistance")} = 1.0;\n                    if (${p("pointLightColor")}[ i ].w > 0.0){\n                        lDistance = 1.0 / (dot(lVector,lVector) * ${p("pointLightPosition")}[ i ].w);\n                    } else {\n                        if ( ${p("pointLightPosition")}[ i ].w > 0.0 ) {\n                            lDistance = 1.0 - min( ( length( lVector ) / ${p("pointLightPosition")}[ i ].w ), 1.0 );\n                        }\n                    }\n                    lVector = normalize( lVector );\n                    ${g("dotProduct")} = dot( normal, lVector );                  \n                    ${x("diffuseWeight")} = ${x()}(max( dotProduct, 0.0 ));\n                    ${e.wrapAround?`\n                        ${C()}\n                        `:i}\n                    totalDiffuse  += diffuseToUse * ${p("pointLightColor")}[ i ].xyz * diffuseWeight * lDistance;\n\n                    ${x("pointHalfVector")}  = normalize( lVector + view );\n                    ${g("pointDotNormalHalf")}  = max( dot( normal, pointHalfVector ), 0.0 );\n                    ${g("specularWeight")}  = specularStrength * max( pow( pointDotNormalHalf, shininessValue ), 0.0 );\n\n                    totalDiffuse += specularToUse * ${p("pointLightColor")}[ i ].xyz * specularWeight * diffuseWeight * lDistance;\n                }\n            `)),e.maxSpotLights>0&&(t=`\n                ${t}\n                ${$({uniformName:"spotLightColor",uniformType:"fv4",size:e.maxSpotLights})}\n                ${$({uniformName:"spotLightPosition",uniformType:"fv4",size:e.maxSpotLights})}\n                ${$({uniformName:"spotLightDirection",uniformType:"fv4",size:e.maxSpotLights})}\n                ${$({uniformName:"spotLightPhysicalAttenuation",uniformType:"iv4",size:e.maxSpotLights})}\n            `,e.phongFirstDir||(r=`\n                ${r}\n                for ( ${v("i")} = 0; i < ${e.maxSpotLights}; i ++ ) {\n                    ${S("lPosition")}  = ${d("viewMatrix")} * ${S()}( ${p("spotLightPosition")}[ i ].xyz, 1.0 );\n                    ${x("lVector")}  = lPosition.xyz + vPos.xyz;\n                    ${g("lDistance")} = 1.0;\n                    if (${p("spotLightPhysicalAttenuation")}[ i ].x > 0){\n                        lDistance =1.0 / (dot(lVector,lVector) * ${p("spotLightColor")}[ i ].w );\n                    }else {\n                        if ( ${p("spotLightColor")}[ i ].w > 0.0 ) {\n                            lDistance = 1.0 - min( ( length( lVector ) / ${p("spotLightColor")}[ i ].w ), 1.0 );\n                        }\n                    }\n                    lVector = normalize( lVector );\n                    ${g("spotEffect")}  = dot( ${p("spotLightDirection")}[ i ].xyz, normalize( ${p("spotLightPosition")}[ i ].xyz - ${_("vWorldPosition")} ) );\n                    if ( spotEffect > ${p("spotLightPosition")}[ i ].w ) {\n                        spotEffect = 1.0 - smoothstep( ${p("spotLightDirection")}[ i ].w,${p("spotLightPosition")}[ i ].w,spotEffect );\n                        ${g("dotProduct")} = dot( normal, lVector );\n                        ${x("diffuseWeight")} = ${x()}(max( dotProduct, 0.0 ));\n                        ${e.wrapAround?`\n                            ${C()}\n                            `:i}\n                        totalDiffuse += diffuseToUse *  ${p("spotLightColor")}[ i ].xyz * diffuseWeight * lDistance * spotEffect;\n                        ${x("spotHalfVector")}  = normalize( lVector + view );\n                        ${g("spotDotNormalHalf")}  = max( dot( normal, spotHalfVector ), 0.0 );\n                        ${g("specularWeight")}  = specularStrength * max( pow( spotDotNormalHalf, shininessValue ), 0.0 );\n                        totalSpecular += specularToUse *  ${p("spotLightColor")}[ i ].xyz * specularWeight * diffuseWeight * lDistance * spotEffect;\n                    }\n                }\n            `)),r=`\n            ${r}\n            ${x("finalPhongColor")} = ${T("out0")}.xyz;\n            ${e.metal?`\n                finalPhongColor = ${T("out0")}.xyz * ( emissiveToUse + totalDiffuse + ${e.useLighting?"ambientLightColorToUse.xyz *":""} ${h("ambient",e)} + totalSpecular );\n                `:`\n                ${(e.map||e.pdsfxUseMap)&&e.textureBlending!==D.KEEP_DEFAULT?`\n                    ${S("texture")}  = texelColor;\n                    ${x("colorValue")}  = ( totalDiffuse + ${e.useLighting?"ambientLightColorToUse.xyz *":""} ${h("ambient",e)} ) + totalSpecular;\n                    ${e.textureBlending===D.MODULATE?`finalPhongColor = texture.xyz * ( totalDiffuse + ambientLightColorToUse.xyz * ${h("ambient",e)} ) + totalSpecular;`:i}\n                    ${e.textureBlending===D.DECAL?"finalPhongColor = (1.0-texture.xyz) * colorValue + texture.xyz;":i}\n                    ${e.textureBlending===D.BLEND?"finalPhongColor = (1.0-texture.a) * colorValue + texture.a * texture.xyz;":i}\n                    ${e.textureBlending===D.REPLACE&&1021===e.textureFormat?`${T("out0")}.a = texture.a;`:i}\n                    `:`finalPhongColor = ${T("out0")}.xyz * ( totalDiffuse + ${e.useLighting?"ambientLightColorToUse.xyz *":""} ${h("ambient",e)} ) + totalSpecular;`}\n                `}\n            \n            ${T("out0")}.x = finalPhongColor.x;\n            ${T("out0")}.y = finalPhongColor.y;\n            ${T("out0")}.z = finalPhongColor.z;\n        `,[t,r]}function b(n){let e=i,t=i;var a;return(n.maxSpotLights>0||n.bumpMap||n.normalMap||n.envMap||n.shadowMapCubeEnabled)&&(e=y({varyingName:"vWorldPosition",varyingType:"v3"}),t=`${a="vWorldPosition",r.getVarying(a,r.ShaderStages.out)} = worldPosition.xyz;`),[e,t]}return new e((function(e,t){let r=t.isDeferredMaterial,a=function(e,t){let r=n._ShaderChunk,a=n._DeferredShaderChunk,[o,s]=N(e),$=`\n\n            ${a._debug_common_pars_fragment(e)}\n            ${r.PDSFX_Color_pars_fragment(e)}\n            ${f({uniformName:"ambient",uniformType:"v3"},e)}\n            ${r.PDSFX_Phong_pars_fragment(e)}\n            ${m({uniformName:"shininess",uniformType:"f"})}\n            ${m({uniformName:"shininessInSpecMap",uniformType:"i"})}      \n            ${r.clip_pars_fragment(e)}\n\t\t\t${r.color_pars_fragment(e)}\n\t\t\t${r.map_pars_fragment(e)}\n\t\t\t${r.envmap_pars_fragment(e)}\n\t\t\t${o}\n\t\t\t${t?i:r.shadowmap_pars_fragment(e)}\n\t\t\t${r.bumpmap_pars_fragment(e)}\n\t\t\t${r.normalmap_pars_fragment(e)}\n\t\t\t${r.specularmap_pars_fragment(e)}\n\t\t\t${r.fog_pars_fragment(e)}\n\t\t\t${r.ao_pars_fragment(e)}\n\t\t\t${a.oit_pars_fragment(e)}\n\t\t\t${t?`\n                ${a.depth_pars_fragment(e)}\n                ${a.picking_pars_fragment(e)}\n                ${a.picking_instancing_pars_fragment(e)}\n                ${a.decal_normal_depth_pars_fragment(e)}\n                ${a.shadowmap_pars_fragment(e)}\n                ${a.highlight_pars_fragment(e)}\n                ${a.texcoord_pars_fragment(e)}\n                ${a.gpupos_pars_fragment(e)}\n                `:i}\n\t\t\t${r.postprocess_pars_fragment(e)}\n        `,p=`\n                ${x("diffuseToUse")}  = ${h("diffuse",e)}.rgb;\n                ${x("emissiveToUse")}  = ${c("emissive")};\n                ${x("specularToUse")}  = ${c("specular")};     \n                ${g("opacityToUse")}  = ${h("opacity",e)};\n                ${e.selectionMaterial?"opacityToUse = 1.0;":i}\n                ${T("out0")} = ${S()}( 1.0, 1.0, 1.0, opacityToUse );\n                ${r.uvmapping_fragment(e)}\n                ${r.map_fragment(e)}\n\t\t\t\t${r.color_fragment(e)}\n                if(${h("diffuse",e)}.w > 0.5) {\n                    diffuseToUse = ${h("diffuse",e)}.rgb;\n                }\n                ${e.PDSFX?`\n                    ${r.PDSFX_start_fragment(e)}\n                    ${r.PDSFX_uv_fragment(e)}\n                    ${r.PDSFX_mapping_uv_transform_fragment(e)}\n                    ${r.PDSFX_Color_backup_fragment(e)}\n                    ${r.PDSFX_Phong_backup_fragment(e)}\n\t\t\t\t    ${u("ComputeCommonValues",null,[])}; \n                    ${r.PDSFX_discard_fragment(e)}\n                    ${r.PDSFX_Color_fragment(e)}\n                    ${r.PDSFX_Phong_fragment(e)}\n                    ${r.PDSFX_Diffuse_Texel_fragment(e)}\n                    ${r.PDSFX_viewNormal_fragment(e)}\n                    ${r.PDSFX_viewPosition_fragment(e)}\n                    ${T("out0")}.a = opacityToUse;\n                    `:i}\n\t\t\t\t${r.alphatest_fragment(e)}\n                \n                ${g("shininessValue")}  = ${c("shininess")};\n\n\t\t\t\t${r.specularmap_fragment(e)}\n        \n\t\t\t\t${s}\n                ${r.clip_fragment(e)}\n\n\t\t\t\t${r.envmap_fragment(e)}\n\t\t\t\t${t?i:r.shadowmap_fragment_old(e)}\n               \n\t\t\t\t${r.ao_fragment(e)}\n\t\t\t\t${r.postprocess_fragment(e)}\n\t\t\t\t${r.linear_to_gamma_fragment(e)}\n\n\t\t\t\t${r.PDSFX_end_fragment(e)}\n\t\t\t\t${r.fog_fragment(e)}\n\t\t\t\t${r.backgroundviewmode_lowlight_fragment(e)}\n                ${a._debug_common_face_fragment(e)}\n                ${a.oit_fragment(e)}\n\t\t\t\t${t?`\n                    ${a.depth_fragment_face(e)}\n                    ${a.picking_fragment(e)}\n                    ${a.picking_instancing_fragment(e)}\n                    ${a.highlight_fragment_face(e)}\n                    ${a.normal_fragment(e)}\n                    ${a.normal_depth_fragment(e)}\n                    ${a.shadowmap_fragment(e)}\n                    ${a.texcoord_fragment(e)}\n                    ${a.gpupos_fragment(e)}\n                    `:i}\n        \n        `;return`\n            ${$}\n            ${l.getMainFragmentStart(e)}\n                ${p}\n            ${l.getMainFragmentEnd(e)}\n        `}(t,r),o=function(e,t){let r=n._ShaderChunk,a=n._DeferredShaderChunk,[o,s]=b(e),u=`\n\n            ${n._DefaultShaderChunk.normal_viewposition_pars_vertex(e)}\n\n            ${r.clip_pars_vertex(e)}\n            ${r.map_pars_vertex(e)}\n            ${r.envmap_pars_vertex(e)}\n            ${o}\n            ${r.color_pars_vertex(e)}\n            ${r.morphtarget_pars_vertex(e)}\n            ${r.skinning_pars_vertex(e)}\n            ${t?i:r.shadowmap_pars_vertex(e)}\n            ${r.fog_pars_vertex(e)}\n\n            ${a.oit_pars_vertex(e)}\n            ${t?`\n                ${a.depth_pars_vertex(e)}\n                ${a.picking_pars_vertex(e)}\n                ${a.picking_instancing_pars_vertex(e)}\n                ${a.highlight_pars_vertex(e)}\n                ${a.texcoord_pars_vertex(e)}\n                ${a.gpupos_pars_vertex(e)}\n                `:i}\n        `,m=`\n            ${r.PDSFX_start_vertex(e)}\n\n            ${r.map_vertex(e)}\n            ${r.color_vertex(e)}\n  \n            ${r.morphtarget_vertex(e)}     \n            ${r.morphnormal_vertex(e)}\n            \n            ${r.skinbase_vertex(e)}\n            ${r.skinning_vertex(e)} \n            ${r.skinnormal_vertex(e)}\n            ${r.position_vertex(e)}\n\n            ${r.default_vertex_with_normal(e)}\n            ${r.defaultnormal_vertex(e)}\n\n            ${r.clip_vertex(e)}\n            ${r.fog_vertex(e)}\n\n            ${n._DefaultShaderChunk.normal_viewposition_vertex(e)}\n       \n            ${r._worldpos_vertex(e)}\n            ${r.envmap_vertex(e)}\n            ${s}\n            ${t?i:r.shadowmap_vertex(e)}\n            \n            ${a.oit_vertex(e)}\n            ${t?`\n                ${a.depth_vertex(e)}\n                ${a.picking_vertex(e)}\n                ${a.picking_instancing_vertex(e)}\n                ${a.highlight_vertex(e)}\n                ${a.texcoord_vertex(e)}\n                ${a.gpupos_vertex(e)}\n                `:i}\n            ${r.PDSFX_end_vertex(e)}\n        `;return`\n            ${u}\n            ${l.getMainVertexStart(e)}\n                ${m}\n            ${l.getMainVertexEnd(e)}\n        `}(t,r);return{vertexShader:o,fragmentShader:a}}))})),define("DS/ShaderBuilders/MeshBasicShaderBuilder",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a,o){"use strict";const i="",s=a.FunctionHandler,l=(n,e)=>e.highFrequencyColors?(n=>{var e={uniformName:n};return t.getHighFrequencyUniform(e)})(n):(n=>{var e={uniformName:n};return t.getUniform(e)})(n);let u=function(e,t){let u=n._ShaderChunk,m=n._DeferredShaderChunk,c=`\n\n            ${u.PDSFX_Color_pars_fragment(e)}\n            ${m._debug_common_pars_fragment(e)}\n            ${n._DefaultShaderChunk.normal_viewposition_pars_fragment(e)}\n            ${u.clip_pars_fragment(e)}\n\t\t\t${u.color_pars_fragment(e)}\n\t\t\t${u.map_pars_fragment(e)}\n            ${u.fog_pars_fragment(e)}\n\t\t\t${m.oit_pars_fragment(e)}\n\t\t\t${t?`\n                ${m.depth_pars_fragment(e)}\n                ${m.picking_pars_fragment(e)}\n                ${m.picking_instancing_pars_fragment(e)}\n                ${m.decal_normal_depth_pars_fragment(e)}\n                ${m.shadowmap_pars_fragment(e)}\n                ${m.highlight_pars_fragment(e)}\n                ${m.texcoord_pars_fragment(e)}\n                ${m.gpupos_pars_fragment(e)}\n                `:i}\n\t\t\t${u.postprocess_pars_fragment(e)}\n        `,$=`\n                ${((n=null)=>{var e={name:n};return o.vec3(e)})("diffuseToUse")}  = ${l("diffuse",e)}.rgb;\n                ${((n=null)=>{var e={name:n};return o.float(e)})("opacityToUse")}  = ${l("opacity",e)};\n                ${e.selectionMaterial?"opacityToUse = 1.0;":i}\n                ${u.uvmapping_fragment(e)}\n                ${u.map_fragment(e)}\n\t\t\t\t${u.color_fragment(e)}\n                if(${l("diffuse",e)}.w > 0.5) {\n                    diffuseToUse = ${l("diffuse",e)}.rgb;\n                }\n                ${e.PDSFX?`\n                    ${u.PDSFX_start_fragment(e)}\n                    ${u.PDSFX_uv_fragment(e)}\n                    ${u.PDSFX_mapping_uv_transform_fragment(e)}\n                    ${u.PDSFX_Color_backup_fragment(e)}\n\t\t\t\t    ${p="ComputeCommonValues",d=null,f=[],a.FunctionHandler.callFunction(p,d,f)}; \n                    ${u.PDSFX_discard_fragment(e)}\n                    ${u.PDSFX_Color_fragment(e)}\n                    ${u.PDSFX_Diffuse_Texel_fragment(e)}\n                    ${u.PDSFX_viewNormal_fragment(e)}\n                    ${u.PDSFX_viewPosition_fragment(e)}\n                    `:i}\n                ${(n=>r.getShaderOutput(n))("out0")} = ${((n=null,e=0)=>{var t={name:n,size:e};return o.vec4(t)})()}( diffuseToUse, opacityToUse );\n                ${n._DefaultShaderChunk.normal_viewposition_fragment(e)}\n\n                ${u.clip_fragment(e)}\n\t\t\t\t${u.alphatest_fragment(e)}\n               \n\t\t\t\t${u.postprocess_fragment(e)}\n\t\t\t\t${u.linear_to_gamma_fragment(e)}\n\n\t\t\t\t${u.PDSFX_end_fragment(e)}\n\t\t\t\t${u.fog_fragment(e)}\n\t\t\t\t${u.backgroundviewmode_lowlight_fragment(e)}\n                ${m._debug_common_face_fragment(e)}\n                ${m.oit_fragment(e)}\n\t\t\t\t${t?`\n                    ${m.depth_fragment_face(e)}\n                    ${m.picking_fragment(e)}\n                    ${m.picking_instancing_fragment(e)}\n                    ${m.highlight_fragment_face(e)}\n                    ${m.normal_fragment(e)}\n                    ${m.normal_depth_fragment(e)}\n                    ${m.shadowmap_fragment(e)}\n                    ${m.texcoord_fragment(e)}\n                    ${m.gpupos_fragment(e)}\n                    `:i}\n        \n        `;var p,d,f;return`\n            ${c}\n            ${s.getMainFragmentStart(e)}\n                ${$}\n            ${s.getMainFragmentEnd(e)}\n        `};return new e((function(e,t){let r=t.isDeferredMaterial,a=u(t,r),o=function(e,t){let r=n._ShaderChunk,a=n._DeferredShaderChunk,o=`\n\n            ${n._DefaultShaderChunk.normal_viewposition_pars_vertex(e)}\n\n            ${r.clip_pars_vertex(e)}\n            ${r.map_pars_vertex(e)}\n            ${r.color_pars_vertex(e)}\n            ${r.morphtarget_pars_vertex(e)}\n            ${r.skinning_pars_vertex(e)}\n\n            ${r.fog_pars_vertex(e)}\n            ${a.oit_pars_vertex(e)}\n            ${t?`\n                ${a.depth_pars_vertex(e)}\n                ${a.picking_pars_vertex(e)}\n                ${a.picking_instancing_pars_vertex(e)}\n                ${a.highlight_pars_vertex(e)}\n                ${a.texcoord_pars_vertex(e)}\n                ${a.gpupos_pars_vertex(e)}\n                `:i}\n        `,l=`\n            ${r.PDSFX_start_vertex(e)}\n            ${r.map_vertex(e)}\n            ${r.color_vertex(e)}\n            \n            ${r.morphtarget_vertex(e)}    \n            ${r.morphnormal_vertex(e)}\n            \n            ${r.skinbase_vertex(e)}\n            ${r.skinning_vertex(e)}       \n            ${r.skinnormal_vertex(e)}\n            ${r.position_vertex(e)}\n\n            ${r.default_vertex_with_normal(e)}\n            ${r.defaultnormal_vertex(e)}\n\n            ${r.clip_vertex(e)}\n            ${r.fog_vertex(e)}\n\n            ${n._DefaultShaderChunk.normal_viewposition_vertex(e)}\n            \n            ${a.oit_vertex(e)}\n            ${t?`\n                ${a.depth_vertex(e)}\n                ${a.picking_vertex(e)}\n                ${a.picking_instancing_vertex(e)}\n                ${a.highlight_vertex(e)}\n                ${a.texcoord_vertex(e)}\n                ${a.gpupos_vertex(e)}\n                `:i}\n            ${r.PDSFX_end_vertex(e)}\n        `;return`\n            ${o}\n            ${s.getMainVertexStart(e)}\n                ${l}\n            ${s.getMainVertexEnd(e)}\n        `}(t,r);return{vertexShader:o,fragmentShader:a}}))})),define("DS/ShaderBuilders/LatLongMapShaderBuilder",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a,o){"use strict";const i=a.ParameterUtils,s=a.FunctionHandler,l=a.BridgeFunctions,u=n=>i.parameterF(n),m=n=>i.parameterV2(n),c=n=>i.parameterV3(n),$=n=>i.parameterT2(n),p=(n,e,t)=>s.callFunction(n,e,t),d=n=>t.addUniform(n),f=n=>{var e={uniformName:n};return t.getUniform(e)},h=(n=null)=>{var e={name:n};return o.float(e)},v=(n=null)=>{var e={name:n};return o.vec2(e)},g=(n=null,e=0)=>{var t={name:n,size:e};return o.vec3(t)},x=(n=null,e=0)=>{var t={name:n,size:e};return o.vec4(t)},S=n=>r.getShaderOutput(n),y=n=>{var e={name:n,constant:!0};return o.float(e)};return new e((function(e,a){let o=n._ShaderChunk,i=n._DefaultShaderChunk;const _=(T={uniformName:"tEnvMap"},t.getTextureUniform(T));var T;let D=`\n\n            ${y("PI")} = 3.14159;\n            ${y("INV_PI")} = 0.31830988618;\n\n            ${d({uniformName:"tEnvMap",uniformType:"t2"})}\n            ${d({uniformName:"ambienceMatrix",uniformType:"m4"})}\n            ${d({uniformName:"blurCoef",uniformType:"f"})}\n            ${d({uniformName:"envMapExposure",uniformType:"f"})}\n            ${d({uniformName:"ambient",uniformType:"v3"})}\n            ${d({uniformName:"planeColor",uniformType:"v3"})}\n            ${d({uniformName:"invScreenSize",uniformType:"v2"})}\n            ${d({uniformName:"cameraSight",uniformType:"v3"})}\n            ${d({uniformName:"cameraUp",uniformType:"v3"})}\n            ${d({uniformName:"cameraRight",uniformType:"v3"})}\n            ${d({uniformName:"startOffset",uniformType:"v2"})}\n            ${d({uniformName:"endOffset",uniformType:"v2"})}\n            ${d({uniformName:"withPlane",uniformType:"f"})}\n\n            ${a.useHDR&&!a.useHDRFloat?`\n                ${d({uniformName:"envMapHDRSize",uniformType:"v2"})}\n                ${d({uniformName:"envMapHDRToMipsRatio",uniformType:"f"})}\n                ${i.ibl_sample_methods(a)}\n\n                ${((n,e,t)=>s.declareFunction(n,e,t))("sampleMipMapRoughness","v4",[m("uv"),u("mip"),u("coef"),$("map0"),$("map1"),m("textureSize"),m("texelSize")])}{\n                    ${x("color1")} ;\n                    ${x("color2")} ;\n                    ${v("uv1")} ;\n                    ${v("uv2")} ;\n                    ${v("textureSize2")} = textureSize * ${f("envMapHDRToMipsRatio")} * ${v()}(1.0,2.0);\n                    ${v("texelSize2")}  = texelSize / ${f("envMapHDRToMipsRatio")} * ${v()}(1.0,2.0);\n                    if (mip < 1.0) {\n                        color1 = ${p("texture2DBilinearRGBE","v4",[$("map0"),m("uv"),m("textureSize"),m("texelSize")])};\n                    } else {\n                        ${h("level1")}  = clamp(floor(mip) - 1.0, 0.0, 4.0);\n                        ${h("t10")}  = pow(2.0, -floor(log2(level1 + 1.0)));\n                        ${h("t11")}  = 2.0 - (level1 + 2.0) * t10;\n                        ${h("t12")}  = 0.5 * t10;\n\n                        uv1 = ${v()}(t11 + 1.5 * texelSize2.x + (2.0 * t12 - 3.0 * texelSize2.x) * uv.x, t12 + 1.5 * texelSize2.x + (t12 - 3.0 * texelSize2.x) * uv.y);\n                        color1 = ${p("texture2DBilinearRGBE","v4",[$("map1"),m("uv1"),m("textureSize2"),m("texelSize2")])};\n                    }\n\n                    ${h("level2")}  = clamp(floor(mip), 0.0, 5.0);\n                    ${h("t20")}  = pow(2.0, -floor(log2(level2 + 1.0)));\n                    ${h("t21")}  = 2.0 - (level2 + 2.0) * t20;\n                    ${h("t22")}  = 0.5 * t20;\n\n                    uv2 = ${v()}(t21 + 1.5 * texelSize2.x + (2.0 * t22 - 3.0 * texelSize2.x) * uv.x, t22 + 1.5 * texelSize2.x + (t22 - 3.0 * texelSize2.x) * uv.y);\n                    color2 = ${p("texture2DBilinearRGBE","v4",[$("map1"),m("uv2"),m("textureSize2"),m("texelSize2")])};\n\n                    return mix(color1, color2, coef);\n                }\n                `:""}\n\n            ${o.postprocess_pars_fragment(a)}\n            \n            ${s.getMainFragmentStart(a)}\n                ${v("screenUV")} = ${(n=>r.getShaderInput(n))("fragCoord")}.xy * ${f("invScreenSize")};\n                ${l.uvConvention("screenUV")};\n                ${v("screenOffset")}  = 2.0 * mix(${f("startOffset")}, ${f("endOffset")}, screenUV) - 1.0;\n                ${g("dir")}  = normalize(${f("cameraSight")} + screenOffset.x * ${f("cameraRight")} + screenOffset.y * ${f("cameraUp")});\n                dir = (${f("ambienceMatrix")} * ${x()}(dir,0.0)).xyz;\n                ${a.useHDR&&!a.useHDRFloat?"":"dir.y *= -1.0;"}\n                ${h("phi")}  = ${C="dir.y",P="dir.x",l.atan2(C,P)};\n                ${h("theta")}  = acos(dir.z);\n\n                ${v("texelCoord")}  = ${v()}(fract(0.5 + 0.5 * INV_PI * phi), 1.0 - INV_PI * theta);\n                ${h("plane")}  = step(texelCoord.y, 0.5) * ${f("withPlane")};\n\n                ${g("planeColor2")}  = ${p("convertToLinear","v3",[c(`${f("planeColor")}.xyz`)])};\n                ${S("out0")}.w = 1.0 + plane * 0.4;\n\n                ${g("mapColor")};\n                ${a.useHDR&&!a.useHDRFloat?`\n                    ${v("texelSize")} = vec2(1.0 / ${f("envMapHDRSize")});\n                    mapColor = ((${p("texture2DBilinearRGBE","v4",[$(_),m("texelCoord"),m(`${f("envMapHDRSize")}`),m("texelSize")])}.xyz) * (1.0 -plane)) + (plane * planeColor2);\n\n                    `:`mapColor = ${l.sample2DTexture(_,"texelCoord")}.xyz * (1.0 - plane) + (plane * planeColor2);`}\n\n                ${S("out0")}.x = mapColor.x;\n                ${S("out0")}.y = mapColor.y;\n                ${S("out0")}.z = mapColor.z;\n                ${!a.gammaOutput&&a.useSRGB?`\n                    ${g("convertedColor")} = ${p("convertToLinear","v3",[c("mapColor.xyz")])};\n                    ${S("out0")}.x = convertedColor.x;\n                    ${S("out0")}.y = convertedColor.y;\n                    ${S("out0")}.z = convertedColor.z;\n                    `:""}                \n                ${S("out0")} *= ${x()}(${f("ambient")} * ${f("envMapExposure")}, 1.0);\n                ${o.postprocess_fragment(a)}\n                ${a.gammaOutput&&a.useHDR?o.linear_to_gamma_fragment(a):""}\n\n            ${s.getMainFragmentEnd(a)}\n        `;var C,P;return{vertexShader:`\n\n            ${s.getMainVertexStart(a)}\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(a)}\n            ${s.getMainVertexEnd(a)}\n        `,fragmentShader:D}}))})),define("DS/ShaderBuilders/MultiDrawShaderBuilder",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a){"use strict";r.ParameterUtils;const o=r.FunctionHandler,i=(n,e,t)=>o.declareFunction(n,e,t),s=n=>e.addUniform(n),l=n=>{var t={uniformName:n};return e.getUniform(t)},u=n=>t.addVarying(n),m=(n=null)=>{var e={name:n};return a.float(e)};return{multidraw_pars_vertex:function(n){return n.WebGPU?`\n\t\t\t\t\t${i("get_draw_id","i",[])}{\n\t\t\t\t\t\t${n.doPlanarFace?"return 1;":"return 0;"}\n\t\t\t\t\t}\n\t\t\t\t`:n.extMultiDraw?`\n\t\t\t\t\t\t${u({varyingName:"_DS_draw_id",varyingType:"f"})}\n\t\t\t\t\t\t${i("get_draw_id","i",[])}{\n\t\t\t\t\t\t\treturn gl_DrawID; \n\t\t\t\t\t\t}\n\t\t\t\t\t`:n.emulatedMultiDraw?`\n\t\t\t\t\t\t${s({uniformName:"_DS_draw_id",uniformType:"i",locationName:"drawId"})}\n\t\t\t\t\t\t${i("get_draw_id","i",[])}{\n\t\t\t\t\t\t\treturn ${l("_DS_draw_id")}; \n\t\t\t\t\t\t}\n\t\t\t\t\t`:`\n\t\t\t\t\t${i("get_draw_id","i",[])}{\n\t\t\t\t\t\treturn 0; \n\t\t\t\t\t}\n\t\t\t\t`},multidraw_vertex:function(n){return!n.WebGPU&&n.extMultiDraw?`${e="_DS_draw_id",ShaderInOutUtils.getVarying(e,ShaderInOutUtils.ShaderStages.out)} = ${m()}(get_draw_id());`:"";var e},multidraw_pars_fragment:function(n){return n.WebGPU?`\n\t\t\t\t\t${i("get_draw_id","i",[])}{\n\t\t\t\t\t\t${n.doPlanarFace?"return 1;":"return 0;"}\n\t\t\t\t\t}\n\t\t\t\t`:n.extMultiDraw?`\n\t\t\t\t\t\t${u({varyingName:"_DS_draw_id",varyingType:"f"})}\n                        ${m("internal_draw_id")};\n\t\t\t\t\t\t${i("get_draw_id","i",[])}{\n\t\t\t\t\t\t\treturn ${((n=null)=>{var e={name:n};return a.int(e)})()}(floor(internal_draw_id)) + (fract(internal_draw_id) > 0.9 ? 1 : 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t`:n.emulatedMultiDraw?`\n\t\t\t\t\t\t${s({uniformName:"_DS_draw_id",uniformType:"i",locationName:"drawId"})}\n\t\t\t\t\t\t${i("get_draw_id","i",[])}{\n\t\t\t\t\t\t\treturn ${l("_DS_draw_id")}; \n\t\t\t\t\t\t}\n\t\t\t\t\t`:`\n\t\t\t\t\t${i("get_draw_id","i",[])}{\n\t\t\t\t\t\treturn 0; \n\t\t\t\t\t}\n\t\t\t\t`},multidraw_fragment:function(n){return!n.WebGPU&&n.extMultiDraw?`\n                        internal_draw_id = ${e="_DS_draw_id",ShaderInOutUtils.getVarying(e,ShaderInOutUtils.ShaderStages.in)};\n\t\t\t\t\t`:"";var e}}})),define("DS/ShaderBuilders/MeshLambertShaderBuilder",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a,o){"use strict";const i="",s=a.FunctionHandler,l=n=>t.addUniform(n),u=n=>{var e={uniformName:n};return t.getUniform(e)},m=n=>t.addLightUniform(n),c=n=>{var e={uniformName:n};return t.getLightUniform(e)},$=n=>{var e={uniformName:n};return t.getGlobalUniform(e)},p=(n,e)=>e.highFrequencyColors?(n=>t.addHighFrequencyUniform(n))(n):l(n),d=(n,e)=>e.highFrequencyColors?(n=>{var e={uniformName:n};return t.getHighFrequencyUniform(e)})(n):u(n),f=(n=null)=>{var e={name:n};return o.int(e)},h=(n=null)=>{var e={name:n};return o.float(e)},v=(n=null,e=0)=>{var t={name:n,size:e};return o.vec3(t)},g=(n=null,e=0)=>{var t={name:n,size:e};return o.vec4(t)},x=n=>r.addVarying(n),S=n=>r.getVarying(n,r.ShaderStages.in),y=n=>r.getVarying(n,r.ShaderStages.out);let _=function(e,t){let o=n._ShaderChunk,l=n._DeferredShaderChunk,u=`\n\n            ${l._debug_common_pars_fragment(e)}\n            ${o.PDSFX_Color_pars_fragment(e)}\n            ${x({varyingName:"vLightFront",varyingType:"v3"})}\n            ${x({varyingName:"vLightBack",varyingType:"v3"})}          \n            ${n._DefaultShaderChunk.normal_viewposition_pars_fragment(e)}\n            ${o.clip_pars_fragment(e)}\n\t\t\t${o.color_pars_fragment(e)}\n\t\t\t${o.map_pars_fragment(e)}\n\t\t\t${o.envmap_pars_fragment(e)}\n\t\t\t${t?i:o.shadowmap_pars_fragment(e)}\n\t\t\t${o.specularmap_pars_fragment(e)}\n            ${o.fog_pars_fragment(e)}\n\t\t\t${o.ao_pars_fragment(e)}\n\t\t\t${l.oit_pars_fragment(e)}\n\t\t\t${t?`\n                ${l.depth_pars_fragment(e)}\n                ${l.picking_pars_fragment(e)}\n                ${l.picking_instancing_pars_fragment(e)}\n                ${l.decal_normal_depth_pars_fragment(e)}\n                ${l.shadowmap_pars_fragment(e)}\n                ${l.highlight_pars_fragment(e)}\n                ${l.texcoord_pars_fragment(e)}\n                ${l.gpupos_pars_fragment(e)}\n                `:i}\n\t\t\t${o.postprocess_pars_fragment(e)}\n        `,m=`\n                ${v("diffuseToUse")}  = ${v()}(1.0, 1.0, 1.0);\n                ${h("opacityToUse")}  = ${d("opacity",e)};\n                ${e.selectionMaterial?"opacityToUse = 1.0;":i}\n                ${o.uvmapping_fragment(e)}\n                ${o.map_fragment(e)}\n\t\t\t\t${o.color_fragment(e)}\n                if(${d("diffuse",e)}.w > 0.5) {\n                    diffuseToUse = ${v()}(1.0, 1.0, 1.0);\n                }\n                if (${c="frontFacing",r.getShaderInput(c)}) {\n                    diffuseToUse.x *= ${S("vLightFront")}.x;\n                    diffuseToUse.y *= ${S("vLightFront")}.y;\n                    diffuseToUse.z *= ${S("vLightFront")}.z;\n                } else {\n                    diffuseToUse.x *= ${S("vLightBack")}.x;\n                    diffuseToUse.y *= ${S("vLightBack")}.y;\n                    diffuseToUse.z *= ${S("vLightBack")}.z;\n                }\n                ${e.PDSFX?`\n                    ${o.PDSFX_start_fragment(e)}\n                    ${o.PDSFX_uv_fragment(e)}\n                    ${o.PDSFX_mapping_uv_transform_fragment(e)}\n\t\t\t\t    ${((n,e,t)=>a.FunctionHandler.callFunction(n,e,t))("ComputeCommonValues","f",[])}; \n                    ${o.PDSFX_discard_fragment(e)}\n                    ${o.PDSFX_Diffuse_Texel_fragment(e)}\n                    ${o.PDSFX_viewNormal_fragment(e)}\n                    ${o.PDSFX_viewPosition_fragment(e)}\n                    `:i}\n                ${(n=>r.getShaderOutput(n))("out0")} = ${g()}( diffuseToUse, opacityToUse );\n                ${n._DefaultShaderChunk.normal_viewposition_fragment(e)}\n\n                ${o.clip_fragment(e)}\n\t\t\t\t${o.alphatest_fragment(e)}\n\t\t\t\t${o.specularmap_fragment(e)}\n\n\t\t\t\t${o.envmap_fragment(e)}\n\t\t\t\t${t?i:o.shadowmap_fragment_old(e)}\n               \n\t\t\t\t${o.ao_fragment(e)}\n\t\t\t\t${o.postprocess_fragment(e)}\n\t\t\t\t${o.linear_to_gamma_fragment(e)}\n\n\t\t\t\t${o.PDSFX_end_fragment(e)}\n\t\t\t\t${o.fog_fragment(e)}\n\t\t\t\t${o.backgroundviewmode_lowlight_fragment(e)}\n                ${l._debug_common_face_fragment(e)}\n\n                ${l.oit_fragment(e)}\n\t\t\t\t${t?`\n                    ${l.depth_fragment_face(e)}\n                    ${l.picking_fragment(e)}\n                    ${l.picking_instancing_fragment(e)}\n                    ${l.highlight_fragment_face(e)}\n                    ${l.normal_fragment(e)}\n                    ${l.normal_depth_fragment(e)}\n                    ${l.shadowmap_fragment(e)}\n                    ${l.texcoord_fragment(e)}\n                    ${l.gpupos_fragment(e)}\n                    `:i}\n        \n        `;var c;return`\n            ${u}\n            ${s.getMainFragmentStart(e)}\n                ${m}\n            ${s.getMainFragmentEnd(e)}\n        `},T=function(e,t){let r=n._ShaderChunk,a=n._DeferredShaderChunk,S=`\n            ${p({uniformName:"ambient",uniformType:"v3"},e)}\n            ${p({uniformName:"diffuse",uniformType:"v4"},e)}\n            ${l({uniformName:"emissive",uniformType:"v3"})}\n\n            ${e.useLighting?`\n                ${m({uniformName:"ambientLightColor",uniformType:"v4"})}             \n                `:i}\n            ${((n=null)=>{var e={name:n,addressSpace:"private"};return o.vec4(e)})("ambientLightColorToUse")} = ${g()}(1.0, 1.0, 1.0, 1.0);\n\n            ${e.wrapAround?l({uniformName:"wrapRGB",uniformType:"v3"}):i}\n\n            ${!t&&e.maxDirLights?`\n                ${m({uniformName:"directionalLightColor",uniformType:"fv4",size:e.maxDirLights})}\n                ${m({uniformName:"directionalLightDirection",uniformType:"fv4",size:e.maxDirLights})}\n                `:i}\n            ${!t&&e.maxPointLights?`\n                ${m({uniformName:"pointLightColor",uniformType:"fv4",size:e.maxPointLights})}\n                ${m({uniformName:"pointLightPosition",uniformType:"fv4",size:e.maxPointLights})}\n                `:i}\n            ${!t&&e.maxSpotLights?`\n                ${m({uniformName:"spotLightColor",uniformType:"fv4",size:e.maxSpotLights})}\n                ${m({uniformName:"spotLightPosition",uniformType:"fv4",size:e.maxSpotLights})}\n                ${m({uniformName:"spotLightDirection",uniformType:"fv4",size:e.maxSpotLights})}\n                `:i}\n        `,_=`\n            ${e.useLighting?`\n                ambientLightColorToUse = ${c("ambientLightColor")};            \n                `:i}\n            ${y("vLightFront")} = ${v()}( 0.0 );\n            ${y("vLightBack")} = ${v()}( 0.0 );\n\n            transformedNormal = normalize( transformedNormal );\n\n            ${!t&&e.maxDirLights?`\n                for( ${f("i")} = 0; i < ${e.maxDirLights}; i ++ ) {\n                    ${g("lDirection")}  = ${$("viewMatrix")} * ${g()}( ${c("directionalLightDirection")}[ i ].xyz, 0.0 );\n                    ${v("dirVector")}  = normalize( lDirection.xyz );\n\n                    ${h("dotProduct")}  = dot( transformedNormal, dirVector );\n                    ${v("directionalLightWeighting")}  = ${v()}( max( dotProduct, 0.0 ) );\n                    ${v("directionalLightWeightingBack")}  = ${v()}( max( -dotProduct, 0.0 ) );\n\n                    ${e.wrapAround?`\n                        ${v("directionalLightWeightingHalf")}  = ${v()}( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n                        ${v("directionalLightWeightingHalfBack")}  = ${v()}( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n                        directionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, ${u("wrapRGB")} );\n                        directionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, ${u("wrapRGB")} );\n                        `:i}\n\n                    ${y("vLightFront")} += ${c("directionalLightColor")}[ i ].xyz * directionalLightWeighting;\n                    ${y("vLightBack")} += ${c("directionalLightColor")}[ i ].xyz * directionalLightWeightingBack;\n                }\n                `:i}\n            ${!t&&e.maxPointLights?`\n                for( ${f("i")} = 0; i < ${maxPointLights}; i ++ ) {\n                    ${g("lPosition")}  = ${$("viewMatrix")} * ${g()}( ${c("pointLightPosition")}[ i ].xyz, 1.0 )\n                    ${v("lVector")}  = lPosition.xyz - mvPosition.xyz;\n\n                    ${h("lDistance")}  = 1.0;\n\n                    if ( ${c("pointLightPosition")}[ i ].w > 0.0 ) {\n                        lDistance = 1.0 - min( ( length( lVector ) / ${c("pointLightPosition")}[ i ].w ), 1.0 );\n                    }\n\n                    lVector = normalize( lVector );\n                    ${h("dotProduct")}  = dot( transformedNormal, lVector );\n                    ${v("pointLightWeighting")}  = ${v()}( max( dotProduct, 0.0 ) );\n                    ${v("pointLightWeightingBack")}  = ${v()}( max( -dotProduct, 0.0 ) );\n                    ${e.wrapAround?`\n                        ${v("pointLightWeightingHalf")}  = ${v()}( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n                        ${v("pointLightWeightingHalfBack")}  = ${v()}( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n                        pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, ${u("wrapRGB")} );\n                        pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, ${u("wrapRGB")} );\n                        `:i}\n                    ${y("vLightFront")} += ${c("pointLightColor")}[ i ].xyz * pointLightWeighting * lDistance;\n                    ${y("vLightBack")} += ${c("pointLightColor")}[ i ].xyz * pointLightWeightingBack * lDistance;\n                }\n                `:i}\n            ${!t&&e.maxSpotLights?`\n                for( ${f("i")} = 0; i < ${e.maxSpotLights}; i ++ ) {\n                    ${g("lPosition")}  = ${$("viewMatrix")} * ${g()}(  ${c("spotLightPosition")}[ i ].xyz, 1.0 );\n                    ${v("lVector")}  = lPosition.xyz - mvPosition.xyz;\n\n                    ${h("spotEffect")}  = dot( ${c("spotLightDirection")}[ i ].xyz, normalize( ${c("spotLightPosition")}[ i ].xyz - worldPosition.xyz ) );\n\n                    if ( spotEffect > ${c("spotLightPosition")}[ i ].w ) {\n                        spotEffect = 1.0 - smoothstep( ${c("spotLightDirection")}[ i ].w,${c("spotLightPosition")}[ i ].w,spotEffect );\n                        ${h("lDistance")}  = 1.0;\n                        if ( ${c("spotLightColor")}[ i ].w > 0.0 ) {\n                            lDistance = 1.0 - min( ( length( lVector ) / ${c("spotLightColor")}[ i ].w ), 1.0 );\n                        }\n                        lVector = normalize( lVector );\n                        ${h("dotProduct")}  = dot( transformedNormal, lVector );\n                        ${v("spotLightWeighting")}  = ${v()}( max( dotProduct, 0.0 ) );\n                        ${v("spotLightWeightingBack")}  = ${v()}( max( -dotProduct, 0.0 ) );\n                        ${e.wrapAround?`\n                            ${v("spotLightWeightingHalf")}  = ${v()}( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n                            ${v("spotLightWeightingHalfBack")}  = ${v()}( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n                            spotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, ${u("wrapRGB")} );\n                            spotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, ${u("wrapRGB")} );\n                            `:i}\n                        ${y("vLightFront")} += ${c("spotLightColor")}[ i ].xyz * spotLightWeighting * lDistance * spotEffect;\n                        ${y("vLightBack")} +=  ${c("spotLightColor")}[ i ].xyz * spotLightWeightingBack * lDistance * spotEffect;\n                    }\n                }\n                `:i}\n\n            ${y("vLightFront")} = ${y("vLightFront")}  * ${d("diffuse",e)}.rgb + ${d("ambient",e)} * ambientLightColorToUse.xyz + ${u("emissive")};\n            ${y("vLightBack")}  = ${y("vLightBack")} * ${d("diffuse",e)}.rgb + ${d("ambient",e)} * ambientLightColorToUse.xyz + ${u("emissive")};\n        `,T=`\n            ${x({varyingName:"vLightFront",varyingType:"v3"})}\n            ${x({varyingName:"vLightBack",varyingType:"v3"})}\n\n\n            ${n._DefaultShaderChunk.normal_viewposition_pars_vertex(e)}\n\n            ${r.clip_pars_vertex(e)}\n            ${r.map_pars_vertex(e)}\n            ${r.envmap_pars_vertex(e)}\n            ${S}\n            ${r.color_pars_vertex(e)}\n            ${r.morphtarget_pars_vertex(e)}\n            ${r.skinning_pars_vertex(e)}\n            ${t?i:r.shadowmap_pars_vertex(e)}\n            ${r.fog_pars_vertex(e)}\n\n            ${a.oit_pars_vertex(e)}\n            ${t?`\n                ${a.depth_pars_vertex(e)}\n                ${a.picking_pars_vertex(e)}\n                ${a.picking_instancing_pars_vertex(e)}\n                ${a.highlight_pars_vertex(e)}\n                ${a.texcoord_pars_vertex(e)}\n                ${a.gpupos_pars_vertex(e)}\n                `:i}\n        `,D=`\n            ${r.PDSFX_start_vertex(e)}\n\n            ${r.map_vertex(e)}\n            ${r.color_vertex(e)}\n\n            ${r.morphtarget_vertex(e)}  \n            ${r.morphnormal_vertex(e)}\n\n            ${r.skinbase_vertex(e)}\n            ${r.skinning_vertex(e)}  \n            ${r.skinnormal_vertex(e)}  \n            ${r.position_vertex(e)}\n\n            ${r.default_vertex_with_normal(e)}\n            ${r.defaultnormal_vertex(e)}\n\n            ${r.clip_vertex(e)}\n            ${r.fog_vertex(e)}\n\n            ${n._DefaultShaderChunk.normal_viewposition_vertex(e)}\n       \n            ${r._worldpos_vertex(e)}\n            ${r.envmap_vertex(e)}\n            ${_}\n            ${t?i:r.shadowmap_vertex(e)}\n            \n            ${a.oit_vertex(e)}\n            ${t?`\n                ${a.depth_vertex(e)}\n                ${a.picking_vertex(e)}\n                ${a.picking_instancing_vertex(e)}\n                ${a.highlight_vertex(e)}\n                ${a.texcoord_vertex(e)}\n                ${a.gpupos_vertex(e)}\n                `:i}\n            ${r.PDSFX_end_vertex(e)}\n        `;return`\n            ${T}\n            ${s.getMainVertexStart(e)}\n                ${D}\n            ${s.getMainVertexEnd(e)}\n        `};return new e((function(n,e){let t=e.isDeferredMaterial,r=_(e,t);return{vertexShader:T(e,t),fragmentShader:r}}))})),define("DS/ShaderBuilders/FiniteTransitionEnvMapShaderBuilder",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a,o){"use strict";const i=a.ParameterUtils,s=a.FunctionHandler,l=a.BridgeFunctions,u=n=>i.parameterF(n),m=n=>i.parameterV2(n),c=n=>i.parameterV3(n),$=n=>i.parameterT2(n),p=(n,e,t)=>s.declareFunction(n,e,t),d=(n,e,t)=>s.callFunction(n,e,t),f=n=>t.addUniform(n),h=n=>{var e={uniformName:n};return t.getUniform(e)},v=n=>{var e={uniformName:n};return t.getTextureUniform(e)},g=n=>{var e={uniformName:n};return t.getGlobalUniform(e)},x=(n=null)=>{var e={name:n};return o.float(e)},S=(n=null)=>{var e={name:n};return o.vec2(e)},y=(n=null,e=0)=>{var t={name:n,size:e};return o.vec3(t)},_=(n=null,e=0)=>{var t={name:n,size:e};return o.vec4(t)},T=(n=null)=>{var e={name:n};return o.mat4(e)},D=n=>{var e={name:n,constant:!0};return o.float(e)},C=n=>r.addVarying(n),P=n=>r.getVarying(n,r.ShaderStages.in),N=n=>r.getVarying(n,r.ShaderStages.out),b=n=>r.getShaderOutput(n);return new e((function(e,t){let r=n._ShaderChunk,a=n._DefaultShaderChunk;const o=v("tEnvMap"),M=v("tEnvMap2");let U=`\n            ${t.useLatLongMap?`\n                ${f({uniformName:"tEnvMap",uniformType:"t2"})}\n                ${f({uniformName:"tEnvMap2",uniformType:"t2"})}\n                `:`\n                ${f({uniformName:"tEnvMap",uniformType:"tc"})}\n                ${f({uniformName:"tEnvMap2",uniformType:"tc"})}\n                `}\n\n            ${f({uniformName:"transitionCoef",uniformType:"f"})}\n            ${f({uniformName:"envMapExposure",uniformType:"f"})}\n            ${f({uniformName:"ambient",uniformType:"v3"})}\n            ${f({uniformName:"groundRadius",uniformType:"f"})}\n            ${f({uniformName:"groundRadius2",uniformType:"f"})}\n            ${f({uniformName:"groundScale",uniformType:"f"})}\n            ${f({uniformName:"groundScale2",uniformType:"f"})}\n            ${f({uniformName:"ambienceMatrix",uniformType:"m4"})}\n            ${f({uniformName:"ambienceMatrix2",uniformType:"m4"})}\n\n            ${C({varyingName:"vViewPosition",varyingType:"v3"})}\n            ${C({varyingName:"vViewGroundPosition",varyingType:"v3"})}\n            ${C({varyingName:"vViewGroundPosition2",varyingType:"v3"})}\n\n            ${D("PI")} = 3.14159;\n            ${D("INV_PI")} = 0.31830988618;\n\n            ${t.useHDR&&!t.useHDRFloat?`\n                ${f({uniformName:"envMapHDRSize",uniformType:"v2"})}\n                ${f({uniformName:"envMapHDRSize2",uniformType:"v2"})}\n                ${a.ibl_sample_methods(t)}\n                `:""}\n\n            ${p("MapNormalToTextureCoordinate","v2",[c("iNormal")])} {\n                ${x("phi")}  = ${w="iNormal.y",V="iNormal.x",l.atan2(w,V)};\n                ${x("theta")}  = acos(iNormal.z);\n                return ${S()}(fract(0.5 + 0.5 * INV_PI * phi), 1.0 - INV_PI * theta);\n            }\n\n            ${p("IntersectSphereFar","f",[c("iSphereCenter"),u("iSphereRadius"),c("iRayDir")])} {\n                ${x("B")}   = 2.0*dot(iRayDir, -iSphereCenter);\n                ${x("C")}   = dot(iSphereCenter, iSphereCenter) - iSphereRadius*iSphereRadius;\n                ${x("disc")}   = B*B - 4.0*C;\n                if (disc < 0.0) {\n                    return -1.0;\n                }\n                return  (-B + sqrt(disc)) / 2.0;\n            }\n\n            ${r.postprocess_pars_fragment(t)}\n\n            ${p("getN","v3",[c("isphereCenter"),u("isphereRadius"),c("inRay")])}{\n                ${y("rayDir")}       = inRay;\n                ${x("t")} =  ${d("IntersectSphereFar","f",[c("isphereCenter"),u("isphereRadius"),c("rayDir")])};\n                if (t>0.0) {\n                    ${y("hitPos")}  =  t*rayDir;\n                    ${y("sn")}  = (hitPos - isphereCenter);\n                    rayDir = normalize(sn);\n                }\n                return rayDir;\n            }\n            \n            ${s.getMainFragmentStart(t)}\n                ${y("viewRay")}  = normalize(${P("vViewPosition")});\n                ${y("viewSphereCenter")}   = ${P("vViewGroundPosition")};\n                ${y("viewSphereCenter2")}   = ${P("vViewGroundPosition2")};\n\n                ${x("sphereRadius")}   = ${h("groundRadius")} * ${h("groundScale")};\n                ${x("sphereRadius2")}   = ${h("groundRadius2")} * ${h("groundScale2")};\n\n                ${y("viewN")}  = ${d("getN","v3",[c("viewSphereCenter"),u("sphereRadius"),c("viewRay")])};\n                ${y("viewN2")}  = ${d("getN","v3",[c("viewSphereCenter2"),u("sphereRadius2"),c("viewRay")])};\n\n\t\t\t\t${y("n")}  = (${_()}(viewN,0.0)*${g("viewMatrix")}).xyz;\n                ${y("n2")}  = (${_()}(viewN2,0.0)*${g("viewMatrix")}).xyz;\n\n                n = (${h("ambienceMatrix")} * ${_()}(n, 0.0)).xyz;\n                n2 = (${h("ambienceMatrix2")} * ${_()}(n2, 0.0)).xyz;\n\n                ${y("mapColor")};\n                ${t.useLatLongMap?`\n                    ${t.useHDR?"":"n.y *= -1.0;n2.y *= -1.0;"}\n                    ${S("coords")}  = ${d("MapNormalToTextureCoordinate","v2",[c("n")])};\n                    ${S("coords2")}  = ${d("MapNormalToTextureCoordinate","v2",[c("n2")])};\n                    ${t.useHDR&&!t.useHDRFloat?`\n                        ${S("texelSize")}  = 1.0 / ${h("envMapHDRSize")};\n                        ${S("texelSize2")}  = 1.0 / ${h("envMapHDRSize2")};\n                        ${y("c1")} = ${d("texture2DBilinearRGBE","v4",[$(o),m("coords"),m(`${h("envMapHDRSize")}`),m("texelSize")])}.xyz;\n                        ${y("c2")} = ${d("texture2DBilinearRGBE","v4",[$(M),m("coords2"),m(`${h("envMapHDRSize2")}`),m("texelSize2")])}.xyz;\n                        mapColor = c2*${h("transitionCoef")}+c1*(1.0-${h("transitionCoef")});\n                        `:`\n                        ${y("c1")} = ${l.sample2DTexture(o,"coords")}.xyz;\n                        ${y("c2")} = ${l.sample2DTexture(M,"coords2")}.xyz;\n                        mapColor = c2*${h("transitionCoef")}+c1*(1.0-${h("transitionCoef")});\n                        `}\n                    `:`\n                    ${y("c1")} = ${l.sampleCubeTexture(o,`${y()}(n.x, -n.z,n.y)`)}.xyz;\n                    ${y("c2")} = ${l.sampleCubeTexture(M,`${y()}(n2.x, -n2.z,n2.y)`)}.xyz;\n                    mapColor = c2*${h("transitionCoef")}+c1*(1.0-${h("transitionCoef")});\n                    `}\n                ${b("out0")}.x = mapColor.x;\n                ${b("out0")}.y = mapColor.y;\n                ${b("out0")}.z = mapColor.z;\n                ${b("out0")}.w = 1.0;\n                ${!t.gammaOutput&&t.useSRGB?`\n                    ${y("convertedColor")} = ${d("convertToLinear","v3",[c("mapColor.xyz")])};\n                    ${b("out0")}.x = convertedColor.x;\n                    ${b("out0")}.y = convertedColor.y;\n                    ${b("out0")}.z = convertedColor.z;\n                    `:""}\n                ${b("out0")} *= ${_()}(${h("ambient")} * ${h("envMapExposure")}, 1.0);\n                ${r.postprocess_fragment(t)}\n                ${t.gammaOutput&&t.useHDR?r.linear_to_gamma_fragment(t):""}\n            ${s.getMainFragmentEnd(t)}\n        `;var w,V;var z,F;return{vertexShader:`\n\n\t\t\t${f({uniformName:"groundPosition",uniformType:"v3"})}\n            ${f({uniformName:"groundPositionLowPart",uniformType:"v3"})}\n            ${f({uniformName:"groundPosition2",uniformType:"v3"})}\n            ${f({uniformName:"groundPosition2LowPart",uniformType:"v3"})}\n\n            ${C({varyingName:"vViewPosition",varyingType:"v3"})}\n            ${C({varyingName:"vViewGroundPosition",varyingType:"v3"})}\n            ${C({varyingName:"vViewGroundPosition2",varyingType:"v3"})}\n\n\t\t\t${p("getViewFromWorldPosition","v3",[c("worldPos"),c("worldPosLowPart")])}{\n                ${T("mat")} = ${T()}(1.0, 0.0, 0.0, 0.0,\n                                            0.0, 1.0, 0.0, 0.0,\n                                            0.0, 0.0, 1.0, 0.0,\n                                            0.0, 0.0, 0.0, 1.0);\n                mat[3][0]=worldPos.x;\n                mat[3][1]=worldPos.y;\n                mat[3][2]=worldPos.z;\n                ${y("origin")} = ${y()}(0.0);\n\t\t\t\treturn ${d("computeModelViewPositionCustom","v4",[c("origin"),(z="m4",F="mat",i.parameter(z,F)),c("worldPosLowPart")])}.xyz;\n            }\n\n            ${s.getMainVertexStart(t)}\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(t)}\n\t\t\t\t${N("vViewPosition")} = ${d("computeModelViewPosition","v4",[c("position_")])}.xyz;\n\t\t\t\t${N("vViewGroundPosition")} = ${d("getViewFromWorldPosition","v3",[c(h("groundPosition")),c(h("groundPositionLowPart"))])};\n\t\t\t\t${N("vViewGroundPosition2")} = ${d("getViewFromWorldPosition","v3",[c(h("groundPosition2")),c(h("groundPosition2LowPart"))])};\n            ${s.getMainVertexEnd(t)}\n        `,fragmentShader:U}}))})),define("DS/ShaderBuilders/PostPro/PostProContext",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/ShaderBuilder"],(function(n,e){"use strict";return class{constructor(n,t,r,a=0){if(!(n instanceof e))throw"Invalid Operation Exception: shaderBuilder must be of type ShaderBuilder";this._shaderBuilder=n,this._uniformHandler=t,this._defines={},Object.assign(this._defines,r),this._extraInput=a}getShaderBuilder(){return this._shaderBuilder}getUniformHandler(){return new this._uniformHandler(this._extraInput)}getDefines(){var n={};return Object.assign(n,this._defines),n}}})),define("DS/ShaderBuilders/PostPro/PostProUniformHandler",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/ShaderBuilder"],(function(n,e){"use strict";return class{constructor(n=0,e=!1){this.inputs=[];for(let t=0;t<n+1;t++)this.inputs.push({name:"tInput"+(0!==t||0!==n||e?t:""),value:null,linked:!1})}loadUniforms(n,e,t,r,a,o,i){for(let n=0;n<this.inputs.length;n++){var s=this.inputs[n];r[s.name]&&e.loadTexture(t,r[s.name],s.value)}}fillUBO(n,e,t){const r=n.layout;for(let e=0;e<this.inputs.length;e++){var a=this.inputs[e];r[a.name]&&n.setTexture(r[a.name],a.value)}}getInput(n=0){return n>=0&&n<this.inputs.length?this.inputs[n]:null}setInput(n,e=0){let t=this.getInput(e);t&&!t.linked&&(t.value=n)}setLinkedInput(n,e){let t=this.getInput(e);t&&(t.value=n,t.linked=!0)}clone(){throw"Not Implemented Exception"}}})),define("DS/ShaderBuilders/PostPro/CompareShaderBuilders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PostPro/PostProUniformHandler","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/PostPro/PostProContext","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a,o,i,s){"use strict";const l=i.ParameterUtils,u=i.FunctionHandler,m=i.BridgeFunctions,c=n=>a.addUniform(n),$=n=>{var e={uniformName:n};return a.getUniform(e)},p=n=>l.parameterF(n),d=n=>l.parameterV2(n),f=n=>l.parameterV4(n),h=(n,e,t)=>u.callFunction(n,e,t),v=(n=null,e=0)=>{var t={name:n,size:e};return s.float(t)},g=(n=null,e=0)=>{var t={name:n,size:e};return s.vec2(t)},x=(n=null,e=0)=>{var t={name:n,size:e};return s.vec4(t)},S=n=>o.addVarying(n),y=n=>o.getVarying(n,o.ShaderStages.out),_=(n,e)=>{return m.sample2DTexture((t={uniformName:n},a.getTextureUniform(t)),e);var t};class T extends e{constructor(){super(3),this.realProjectionMatrixInverse=new n.Matrix4,this.tolerance=1e-4}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform1f(r.tolerance,this.tolerance),t.uniformMatrix4fv(r.realProjectionMatrixInverse,!1,e.float32Matrix4x4Temp.setDoubles(this.realProjectionMatrixInverse.elements))}fillUBO(n,e,t){super.fillUBO(n,e,t);const r=n.layout;n.setF(r.tolerance,this.tolerance),n.setM4(r.realProjectionMatrixInverse,this.realProjectionMatrixInverse)}clone(){var n=new T;return n.tolerance=this.tolerance,n.realProjectionMatrixInverse=this.realProjectionMatrixInverse,n}}function D(e){return`           \n            ${S({varyingName:"vUv",varyingType:"v2"})}\n\n            ${u.getMainVertexStart(e)}\n                ${y("vUv")} = uv.xy;\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(e)}\n            ${u.getMainVertexEnd(e)}\n        `}return new r(new t((function(n,e){var t=e.customDefines;const r=o.getShaderOutput("out0");let a=`\n            \n            ${S({varyingName:"vUv",varyingType:"v2"})}\n\n            ${t.POSTPRO?c({uniformName:"tScene",uniformType:"t2",locationName:"tInput0"}):""}\n            ${c({uniformName:"tCommonColor",uniformType:"t2",locationName:"tInput1"})}\n            ${c({uniformName:"tDepthOld",uniformType:"t2",locationName:"tInput2"})}\n            ${c({uniformName:"tDepthNew",uniformType:"t2",locationName:"tInput3"})}\n            ${c({uniformName:"realProjectionMatrixInverse",uniformType:"m4"})}\n            ${c({uniformName:"tolerance",uniformType:"f"})}\n\n            ${i="getLinearDepth",s="f",l=[d("iUV"),p("iDepth")],u.declareFunction(i,s,l)}{\n                ${g("xy")} = iUV * 2.0 - 1.0;\n\n                ${v("depth")} = ${m.getDepthWithConvention("iDepth")};\n                ${x("posProjected")} = ${x()}(xy, depth, 1.0);\n                ${x("posVS")}  = ${$("realProjectionMatrixInverse")} * posProjected;\n                return posVS.z / posVS.w;\n            }\n\n            ${u.getMainFragmentStart(e)}\n                ${g("screenUV")} = ${(n=>o.getVarying(n,o.ShaderStages.in))("vUv")};\n\n                ${x("_common")} = ${_("tCommonColor","screenUV")};\n                ${v("depthOld")} = ${h("unpackRGBA","f",[f(_("tDepthOld","screenUV"))])};\n                ${v("depthNew")} = ${h("unpackRGBA","f",[f(_("tDepthNew","screenUV"))])};\n\n                ${1===t.MODE?`\n                    ${v("isDifferent")} = step(depthOld*depthNew, 0.0) - step(abs(depthOld) + abs(depthNew), 0.0);\n                    `:`\n                    ${v("diff")}  = abs(${h("getLinearDepth","f",[d("screenUV"),p("depthOld")])} - ${h("getLinearDepth","f",[d("screenUV"),p("depthNew")])});\n                    ${v("isDifferent")} = step(${$("tolerance")}, diff);\n                    `}\n\n                ;\n                ${t.POSTPRO?`\n                    ${x("color")} = ${_("tScene","screenUV")};\n                    color = mix(vec4(mix(color.rgb, _common.rgb, _common.a), color.a), color, isDifferent);\n                    `:`\n                    ${x("color")}  = vec4(_common.rgb, _common.a * (1.0 - isDifferent));\n                    `}\n\n                ${r} = color;           \n            ${u.getMainFragmentEnd(e)}\n        `;var i,s,l;return{vertexShader:D(e),fragmentShader:a}}),"CompareModel"),T,{POSTPRO:1,MODE:0})})),define("DS/ShaderBuilders/PostPro/PreConvolutionShaderBuilders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PostPro/PostProUniformHandler","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/PostPro/PostProContext","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a,o,i,s){"use strict";const l="",u=i.ParameterUtils,m=i.FunctionHandler,c=i.BridgeFunctions,$=n=>a.addUniform(n),p=n=>{var e={uniformName:n};return a.getUniform(e)},d=n=>u.parameterF(n),f=n=>u.parameterV2(n),h=n=>u.parameterV3(n),v=n=>u.parameterV4(n),g=(n,e,t)=>m.declareFunction(n,e,t),x=(n,e,t)=>m.callFunction(n,e,t),S=(n=null,e=0)=>{var t={name:n,size:e};return s.int(t)},y=(n=null,e=0)=>{var t={name:n,size:e};return s.float(t)},_=(n=null,e=0)=>{var t={name:n,size:e,constant:!0};return s.float(t)},T=(n=null,e=0)=>{var t={name:n,size:e};return s.vec2(t)},D=(n=null,e=0)=>{var t={name:n,size:e};return s.vec3(t)},C=(n=null,e=0)=>{var t={name:n,size:e};return s.vec4(t)},P=n=>o.addVarying(n),N=n=>o.getVarying(n,o.ShaderStages.in),b=n=>o.getVarying(n,o.ShaderStages.out),M=(n,e)=>{return c.sample2DTexture((t={uniformName:n},a.getTextureUniform(t)),e);var t},U=(n,e)=>c.modulo(n,e),w=(n,e)=>c.atan2(n,e);class V extends e{constructor(n=0){super(n),this.roughness=0}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform1f(r.roughness,this.roughness)}fillUBO(n,e,t){super.fillUBO(n,e,t);const r=n.layout;n.setF(r.roughness,this.roughness)}clone(){var n=new V;return n.roughness=this.roughness,n}}class z extends V{constructor(){super(1),this.firstSample=0}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform1i(r.firstSample,this.firstSample)}fillUBO(n,e,t){super.fillUBO(n,e,t);const r=n.layout;n.setI(r.firstSample,this.firstSample)}clone(){var n=new z;return n.empty=this.empty,n.firstSample=this.firstSample,n}}const F={NB_SAMPLES:256,NB_SAMPLES_IT:256,DP_SCALE:1.2,LOD_CST:7.707519,MODE:0,MAX_LOD:9,INPUT_ENCODING:"RGBE"};function I(e,t){const r=e.customDefines,a=0===r.MODE,o=1===r.MODE,i=2===r.MODE,s=3===r.MODE,u=4===r.MODE;let m;switch(r.INPUT_ENCODING){case"RGBE":m=`\n                return ${x("RGBEtoRGB","v3",[v("texel")])};\n                `;break;case"RGB":m="\n                    return texel.rgb;\n                ";break;case"LogLUV":m=`\n                \n                    return ${x("LogLUVtoRGB","v3",[v("texel")])};\n                `;break;case"RGBM":m=`\n                \n                    return ${x("RGBMtoRGB","v3",[v("texel")])};\n                `}return`\n        \n        ${P({varyingName:"vUv",varyingType:"v2"})}\n        ${t?`\n            ${$({uniformName:"tEnvMap",uniformType:"t2",locationName:"tInput0"})}\n            ${$({uniformName:"tPrevEnvMap",uniformType:"t2",locationName:"tInput1"})}\n            ${$({uniformName:"firstSample",uniformType:"i"})}\n            `:`\n            ${$({uniformName:"tEnvMap",uniformType:"t2",locationName:"tInput"})}\n            `}\n        ${$({uniformName:"roughness",uniformType:"f"})}\n\n        ${_("CLAMP_VALUE")} = 1000.0;\n        ${_("PI")}  = 3.14159265358979323846264;\n        ${_("INV_GOLDEN_RATIO")}  = 0.6180339887;\n        ${_("dpScale")} = ${r.DP_SCALE};\n        ${_("fMAX_LOD")} = ${y()}(${r.MAX_LOD});\n\n        \n        ${n._DefaultShaderChunk.ibl_sample_methods(e)}\n        \n        ${g("ComputeIndex","f",[d("id"),d("N")])}{\n            ${y("val")}  = id * N * 24.0;\n            ${y("n")} = val / N;\n            ${y("m")} = ${U("val","N")};\n            return n + m;\n        }\n\n        ${g("LowDiscrepancy2D","v2",[d("i"),d("N")])}\n        {\n            ${y("id")}  = ${x("ComputeIndex","f",[d("i"),d("N")])};\n            return ${T()}(fract((id + 0.5) / N* INV_GOLDEN_RATIO), fract(id * INV_GOLDEN_RATIO));\n        }\n\n        ${g("vLogComplex","v2",[d("value")])}{\n            ${y("real")}  = log(abs(value));\n            ${y("im")}  = ${w("0.0","value")};\n            return ${T()}(real,im);\n        }\n\n        ${g("invComplex","v2",[f("value")])}{\n            return ${T()}(value.x,-value.y)/(value.x * value.x + value.y * value.y);\n        }\n        \n        ${g("AshikminDistribution","f",[d("NoH"),d("sheenValue")])}{          \n            // cos^2\n            ${y("cosine2")}  = max(NoH * NoH,1e-6);\n            // sin^2\n            ${y("sine2")}  = max(1.0-cosine2,1e-6);\n            //\n            ${y("D")}  = 1.0;\n            ${y("normalisationTerm")}  = 1.0;\n            ${y("a2")}  = sheenValue * sheenValue;\n            normalisationTerm *= 1.0/(4.0*a2+1.0);\n            // sin^4\n            ${y("sine4")}  = max(sine2 * sine2,1e-6);\n            // cotan^2\n            ${y("cotan2")}  = cosine2/sine2;\n            ${y("value")}  = -cotan2 / a2;\n            // result\n            D = 1.0+4.0 * exp(value)/ sine4;\n            return D * normalisationTerm;\n        }\n\n        ${g("GetLightVector","v3",[h("N"),h("H")])}{\n            ${s?"return H;":"return 2.0 * dot(N, H) * H - N;"}\n        }\n\n        ${g("GetWeight","f",[d("NoL")])}{\n            if (NoL > 0.0) {            \n                ${a||s?"return NoL;":"return 1.0;"}\n            }\n            return 0.0;\n        }\n\n        ${g("ImportanceSample","v3",[f("Xi"),d("roughness")])}{\n\n            ${D("H")} ;\n            ${y("Phi")}  = 2.0 * PI * Xi.x;\n            ${a?`            \n                ${y("a")}  = roughness * roughness;\n                ${y("a2")}  = a*a;\n                ${y("CosTheta")}  = sqrt((1.0 - Xi.y) / (1.0 + (a2 - 1.0) * Xi.y));\n                ${y("SinTheta")}  = sqrt(1.0 - CosTheta * CosTheta);\n                `:l}\n            // OLD WAY\n            //#if MODE == 1 // Velvet \n                //${y("a")}  = roughness * roughness;    \n                //${y("interiorTerm")}  = 4.0*a*exp(1.0/a)/(4.0*a*Xi.y + Xi.y - 1.0);\n                //${T("exteriorTerm")}  = a*vLogComplex(interiorTerm);\n                //${T("value")}  = invComplex(exteriorTerm);\n                //${y("val")}  = min(length(value),1.0);\n                //${y("SinTheta")}  = sqrt(val);\n                //${y("CosTheta")}  = sqrt(1.0 - val);\n            //#endif\n            ${i?`         \n                ${y("a")}  = roughness * roughness;   \n                ${y("a2")}  = a*a;\n                // theta = asin(sqrt(8*a2*log(1-iY)/(8*a2*log(1-iY)-1)))\n                ${y("loga")}  = 8.0*a2*log(1.0-Xi.y);\n                ${y("value")}  = loga / (loga - 1.0);\n                ${y("SinTheta")}  = sqrt(value);\n                ${y("CosTheta")}  = sqrt(1.0 - value);\n                `:l}\n            ${s||o?`\n                ${y("value")}  = Xi.y;\n                ${y("SinTheta")}  = sqrt(value);\n                ${y("CosTheta")}  = sqrt(1.0 - value);\n                `:l}\n            ${u?`\n                ${y("a")}  = roughness;\t\t\n                a = max(a, 1e-3);\n                ${y("SinTheta")}  = pow(Xi.y, a / (2.0 * a + 1.0));\n                ${y("CosTheta")}  = sqrt(1.0 - SinTheta*SinTheta);\n                `:l}\n\n            H.x = SinTheta * cos(Phi);\n            H.y = SinTheta * sin(Phi);\n            H.z = CosTheta;\n            return H;\n        }\n\n        ${g("TangentToWorld","v3",[h("Vec"),h("TangentZ")])}{\n\n            ${D("UpVector")}  = ${D()}(1,0,0);\n            if (abs(TangentZ.z) < 0.999) {\n                UpVector = ${D()}(0,0,1);\n            }\n            ${D("TangentX")}  = normalize(cross(UpVector, TangentZ));\n            ${D("TangentY")}  = cross(TangentZ, TangentX);\n\n            return TangentX * Vec.x + TangentY * Vec.y + TangentZ * Vec.z;\n        }\n\n        ${g("computeLODFromDirection","f",[h("dir"),d("pdf")])}{\n\n            ${y("d")}  = 2.0 * dpScale;\n            d *= (1.0 + abs(dir.z));\n            d *= d;\n\n            ${y("lod")}  = 0.5 * log2(pdf * d);\n            \n            return max(${r.LOD_CST} - lod, 0.0);\n        }\n\n        ${g("sampleLatLongFromLocation","v3",[h("dir")])}{\n\n            ${y("theta")}  = acos(dir.z);\n            ${y("phi")}  = ${w("dir.y","dir.x")};\n\n            ${y("u")}  = 0.5 + 0.5 * phi / PI;\n            ${y("v")}  = theta / PI;\n\n            ${C("texel")}  = ${M("tEnvMap",`${T()}(u, v)`)};\n            ${m}\n        }\n\n\n        ${g("ImportanceSamplePDF","v4",[f("Xi"),d("roughness")])}{\n\n            ${D("H")};\n            ${y("Phi")}  = 2.0 * PI * Xi.x;\n            ${y("D")}  = 0.0;\n            ${y("normalisationTerm")}  = 1.0/PI;\n            \n            ${a?`  \n                ${y("a")}  = roughness * roughness;\n                ${y("a2")}  = a*a;\n                ${y("CosTheta")}  = sqrt((1.0 - Xi.y) / (1.0 + (a2 - 1.0) * Xi.y));\n                ${y("SinTheta")}  = sqrt(1.0 - CosTheta * CosTheta);\n\n                ${y("d")}  = (a2 - 1.0) * CosTheta*CosTheta + 1.0;\n                D = a2 / (PI * d * d);\n                `:l}\n            // OLD WAY\n            //#if MODE == 1 // Velvet\n                //${y("a")}  = roughness * roughness;\n                //${y("interiorTerm")}  = 4.0*a*exp(1.0/a)/(4.0*a*Xi.y + Xi.y - 1.0);\n                //${T("exteriorTerm")}  = a*vLogComplex(interiorTerm);\n                //${T("value")}  = invComplex(exteriorTerm);\t\t\n                //${y("val")}  = min(length(value),1.0);\n                //${y("SinTheta")}  = sqrt(val);\n                //${y("CosTheta")}  = sqrt(1.0-val);\n\n                // cos^2\n                //${y("cosine2")}  = max(CosTheta*CosTheta,1e-6);\n                // sin^2\n                //${y("sine2")}  = max(SinTheta*SinTheta,1e-6);\n                //normalisationTerm *= 1.0/(1.0 + 4.0*a);\n                // sin^4\n                //${y("sine4")}  = max(sine2 * sine2,1e-6);\n                // cotan^2\n                //${y("cotan2")}  = cosine2/sine2;\n                //${y("value2")}  = -cotan2 / a;\n                // result\n                //D = 1.0 + 4.0 * exp(value2)/ sine4;\n                //D *= normalisationTerm;\n            //#endif\n            \n            ${i?`\n                ${y("a")}  = roughness * roughness;\n                ${y("a2")}  = a*a;\n                // theta = asin(sqrt(8*a2*log(1-iY)/(8*a2*log(1-iY)-1)))\n                ${y("loga")}  = 8.0*a2*log(1.0-Xi.y);\n                ${y("value")}  = loga / (loga - 1.0);\n                ${y("SinTheta")}  = sqrt(value);\n                ${y("CosTheta")}  = sqrt(1.0 - value);\n\n                // cos^2\n                ${y("cosine2")}  = max(CosTheta*CosTheta,1e-6);\n                // sin^2\n                ${y("sine2")}  = max(SinTheta*SinTheta,1e-6);\n                normalisationTerm *= 1.0/(8.0*a2);\n                // cos^4\n                ${y("cosine4")}  = max(cosine2 * cosine2,1e-6);\n                // cotan^2\n                ${y("tan2")}  = sine2/cosine2;\n                ${y("value2")}  = -tan2/(a2*8.0);\n                // result\n                D = exp(value2) / cosine4 ;\n                D *= normalisationTerm ;\n                `:l}\n            ${s||o?`\n                ${y("value")}  = Xi.y;\n                ${y("SinTheta")}  = sqrt(value);\n                ${y("CosTheta")}  = sqrt(1.0 - value);\n                D = normalisationTerm;\n                `:l}\n            ${u?`\n                ${y("a")}  = roughness;\t\t\n                a = max(a, 1e-3);\n                ${y("SinTheta")}  = max(pow(Xi.y, a / (2.0 * a + 1.0)),1e-3);\n                ${y("CosTheta")}  = sqrt(1.0 - SinTheta*SinTheta);\n                normalisationTerm *= 0.5;\n                // result\n                D = (2.0 + 1.0 / a) * pow(SinTheta, 1.0 / a) ;\n                D *= normalisationTerm ;\n                `:l}\n\n            ${y("PDF")}  = D * CosTheta;\n\n            H.x = SinTheta * cos(Phi);\n            H.y = SinTheta * sin(Phi);\n            H.z = CosTheta;\n\n            return ${C()}(H, PDF);\n        }\n\n        ${g("sampleDualParaboloidFromLocation","v3",[h("dir"),d("lod")])}{\n\n            ${T("st")}  = ${T()}(0.5);\n\n            if (dir.z < 0.0) {\n\n                st *= 0.5 * (1.0 - dir.xy / (dpScale * (1.0 - dir.z)));\n\n            } else {\n\n                st *= 0.5 * (1.0 + dir.xy / (dpScale * (1.0 + dir.z)));\n                st.x += 0.5;\n            }\n\n            ${y("mipValue")}  = floor(lod);\n            ${y("mipNextValue")}  = mipValue + 1.0;\n            ${y("mipCoef")}  = fract(lod);\n\n            if (lod >= fMAX_LOD) {\n\n                mipValue = fMAX_LOD;\n                mipNextValue = fMAX_LOD;\n                mipCoef = 1.0;\n            }\n\n            ${D("color1")} ;\n            ${D("color2")} ;\n\n            ${T("uv1")}   = st;\n            ${T("uv2")}   = st;\n\n            ${y("scale1")}  = pow(2.0, -mipValue);\n            ${y("scale2")}  = pow(2.0, -mipNextValue);\n\n            uv1 *= scale1;\n            uv2 *= scale2;\n\n            uv1.y += 1.0 - scale1;\n            uv2.y += 1.0 - scale2;\n\n            color1 = ${M("tEnvMap","uv1")}.xyz;\n            color2 = ${M("tEnvMap","uv2")}.xyz;\n\n            return mix(color1, color2, mipCoef);\n        }\n\n        ${g("GetFilteredColor","v3",[h("L"),v("perturbedZ_PDF"),h("H"),h("N"),d("roughness"),d("NoL")])}{\t\t\n            ${y("factor")} = perturbedZ_PDF.w;\n            ${s?l:"factor /= (4.0 * clamp(dot(L,H),1e-6,1.0));"}\n            ${y("lod")}  = ${x("computeLODFromDirection","f",[h("L"),d("factor")])};\n            ${D("filteredColor")} = ${x("sampleDualParaboloidFromLocation","v3",[h("L"),d("lod")])};\n            filteredColor  = min(filteredColor, ${D()}(CLAMP_VALUE));\n            ${o?`\n                ${y("NoH")} = clamp(dot(N,H),1e-6,1.0);\n                filteredColor *= ${x("AshikminDistribution","f",[d("NoH"),d("roughness")])};\n                `:l}\n            return filteredColor;\n        }\n        `}function R(n){return`\n            ${T("screenUV")} = ${N("vUv")};\n            ${y("sampledRoughness")} = ${p("roughness")};\n            ${y("phi")}  = PI * (2.0 * screenUV.x - 1.0);\n            ${y("theta")}  = PI * screenUV.y;\n\n            // Cartesian components\n            ${D("N")};\n            N.x = sin(theta) * cos(phi);\n            N.y = sin(theta) * sin(phi);\n            N.z = cos(theta);\n        `}function A(e){return`           \n            ${P({varyingName:"vUv",varyingType:"v2"})}\n\n            ${m.getMainVertexStart(e)}\n                ${b("vUv")} = uv.xy;\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(e)}\n            ${m.getMainVertexEnd(e)}\n        `}return{Normal:new r(new t((function(n,e){const t=e.customDefines.NB_SAMPLES,r=o.getShaderOutput("out0");let a=`\n\n            ${I(e,!1)}\n\n            ${g("prefilterEnvMap","v3",[d("roughness"),h("N")])}{\n\n                ${D("filteredColor")} ;\n                ${y("weight")}  = 0.0;\n\n                ${y("fSamples")} = ${y()}(${t});\n                ${D("clampValue")} = ${D()}(CLAMP_VALUE);\n                for (${S("i")} = 0; i < ${t}; i++) {\n                    ${y("fI")} = ${y()}(i);\n                    ${T("E")} = ${x("LowDiscrepancy2D","v2",[d("fI"),d("fSamples")])};\n                    ${D("perturbedZ")}  = ${x("ImportanceSample","v3",[f("E"),d("roughness")])};\n                    ${D("H")}  = ${x("TangentToWorld","v3",[h("perturbedZ"),h("N")])};\n                    ${D("L")}  = ${x("GetLightVector","v3",[h("N"),h("H")])};\n\n                    ${y("NoL")}  = clamp(dot(N, L), 0.0, 1.0);\n\n                    ${y("w")}  = ${x("GetWeight","f",[d("NoL")])};\n                    filteredColor += w * min(${x("sampleLatLongFromLocation","v3",[h("L")])}, clampValue);\n                    weight += w;\n                }\n\n                return filteredColor / max(weight, 0.001);\n            }\n\n            ${m.getMainFragmentStart(e)}\n                ${R()}\n                ${r} = ${C()}(${x("prefilterEnvMap","v3",[d("sampledRoughness"),h("N")])}, 1.0);           \n            ${m.getMainFragmentEnd(e)}\n        `;return{vertexShader:A(e),fragmentShader:a}}),"PreConvolution"),V,F),FIS:new r(new t((function(n,e){const t=e.customDefines.NB_SAMPLES,r=o.getShaderOutput("out0");let a=`\n\n            ${I(e,!1)}\n\n            ${g("prefilterEnvMap","v3",[d("roughness"),h("N")])}{\n\n                ${D("filteredColor")} ;\n                ${y("weight")}  = 0.0;\n\n                ${y("fSamples")} = ${y()}(${t});\n                for (${S("i")} = 0; i < ${t}; i++) {\n                    ${y("fI")} = ${y()}(i);\n                    ${T("E")} = ${x("LowDiscrepancy2D","v2",[d("fI"),d("fSamples")])};\n                    ${C("perturbedZ_PDF")}  = ${x("ImportanceSamplePDF","v4",[f("E"),d("roughness")])};\n                    ${D("H")}  = ${x("TangentToWorld","v3",[h("perturbedZ_PDF.xyz"),h("N")])};\n                    ${D("L")}  = ${x("GetLightVector","v3",[h("N"),h("H")])};\n\n                    ${y("NoL")}  = clamp(dot(N, L), 0.0, 1.0);\n\n                    ${y("w")}  = ${x("GetWeight","f",[d("NoL")])};\n                    filteredColor += w * ${x("GetFilteredColor","v3",[h("L"),v("perturbedZ_PDF"),h("H"),h("N"),d("roughness"),d("NoL")])};\n                    weight += w;\n                }\n\n                return filteredColor / max(weight, 0.001);\n            }\n\n            ${m.getMainFragmentStart(e)}\n                ${R()}\n                ${r} = ${C()}(${x("prefilterEnvMap","v3",[d("sampledRoughness"),h("N")])}, 1.0);    \n            ${m.getMainFragmentEnd(e)}\n        `;return{vertexShader:A(e),fragmentShader:a}}),"PreConvolutionFIS"),V,F),Iterative:new r(new t((function(n,e){var t=e.customDefines;const r=t.NB_SAMPLES,a=t.NB_SAMPLES_IT,i=o.getShaderOutput("out0");let s=`\n\n            ${I(e,!0)}\n            \n            ${g("prefilterEnvMap","v4",[d("roughness"),h("N")])} {\n\n                ${D("filteredColor")} ;\n                ${y("weight")}  = 0.0;\n\n                ${y("fSamples")} = ${y()}(${r});\n                for (${S("i")} = 0; i < ${a}; i++) {\n                    ${y("fI")}  = ${y()}(${p("firstSample")} + i);\n                    ${T("E")} = ${x("LowDiscrepancy2D","v2",[d("fI"),d("fSamples")])};\n                    ${C("perturbedZ_PDF")}  = ${x("ImportanceSamplePDF","v4",[f("E"),d("roughness")])};\n                    ${D("H")}  = ${x("TangentToWorld","v3",[h("perturbedZ_PDF.xyz"),h("N")])};\n                    ${D("L")}  = ${x("GetLightVector","v3",[h("N"),h("H")])};\n\n                    ${y("NoL")}  = clamp(dot(N, L), 0.0, 1.0);\n\n                    ${y("w")}  = ${x("GetWeight","f",[d("NoL")])};\n                    filteredColor += w * ${x("GetFilteredColor","v3",[h("L"),v("perturbedZ_PDF"),h("H"),h("N"),d("roughness"),d("NoL")])};\n                    weight += w;\n                }\n\n                return ${C()}(filteredColor / max(weight, 0.001),max(weight, 0.001));\n            }\n\n            ${m.getMainFragmentStart(e)}\n                ${R()}\n                \n\t\t\t\t${C("prevTex")}  = ${M("tPrevEnvMap","screenUV")};\n\t\t\t\t${C("res")}  = ${x("prefilterEnvMap","v4",[d("sampledRoughness"),h("N")])};\n                ${i} = ${C()}((prevTex.rgb * prevTex.a + res.rgb * res.a) / (prevTex.a + res.a), prevTex.a + res.a);      \n            ${m.getMainFragmentEnd(e)}\n        `;return{vertexShader:A(e),fragmentShader:s}}),"PreConvolutionIT"),z,F)}})),define("DS/ShaderBuilders/PostPro/DownSamplingShaderBuilders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PostPro/PostProUniformHandler","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/PostPro/PostProContext","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a,o,i,s){"use strict";i.ParameterUtils;const l=i.FunctionHandler,u=i.BridgeFunctions,m=n=>a.addUniform(n),c=n=>{var e={uniformName:n};return a.getUniform(e)},$=(n=null,e=0)=>{var t={name:n,size:e};return s.int(t)},p=(n=null,e=0)=>{var t={name:n,size:e};return s.float(t)},d=(n=null,e=0)=>{var t={name:n,size:e};return s.vec2(t)},f=(n=null,e=0)=>{var t={name:n,size:e};return s.vec3(t)},h=(n=null,e=0)=>{var t={name:n,size:e};return s.vec4(t)},v=n=>o.addVarying(n),g=n=>o.getVarying(n,o.ShaderStages.in),x=n=>o.getVarying(n,o.ShaderStages.out),S=(n,e)=>{return u.sample2DTexture((t={uniformName:n},a.getTextureUniform(t)),e);var t};class y extends e{constructor(){super(),this.invSize=new n.Vector2(512,512)}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform2f(r.invSize,this.invSize.x,this.invSize.y)}fillUBO(n,e,t){super.fillUBO(n,e,t);const r=n.layout;n.setV2(r.invSize,this.invSize)}clone(){var n=new y;return n.invSize=this.invSize,n}}function _(e){return`\n            ${v({varyingName:"vUv",varyingType:"v2"})}\n\n            ${l.getMainVertexStart(e)}\n\n                ${x("vUv")} = uv.xy;\n\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(e)}\n            ${l.getMainVertexEnd(e)}\n\n        `}class T extends e{constructor(n){super(n)}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i)}fillUBO(n,e,t){super.fillUBO(n,e,t)}clone(){return new T}}var D=new Map;return{DownSamplingBlur:new r(new t((function(n,e){e.customDefines;const t=o.getShaderOutput("out0");let r=`\n            \n            ${v({varyingName:"vUv",varyingType:"v2"})}\n          \n            ${m({uniformName:"tInput",uniformType:"t2"})}\n            ${m({uniformName:"invSize",uniformType:"v2"})}\n\n            ${l.getMainFragmentStart(e)}\n                // varying storage\n                ${d("screenUV")} = ${g("vUv")};\n                ${d("factor")} = ${c("invSize")};\n\n                ${f("result")} = ${f()}(0.0, 0.0, 0.0);\n                ${p("total")} = 0.0;\n\n                for (${$("i")} = -2; i <= 2; i++) {\n                    for (${$("j")} = -2; j <= 2; j++) {\n                        ${d("offset")}  = 1.0 * factor * ${d()}(${p()}(i), ${p()}(j));\n                        ${p("weight")}  = 1.0 / (1.0 + dot(offset, offset));\n                        result += weight * ${S("tInput","screenUV + offset")}.xyz;\n                        total += weight;\n                    }\n                }\n                result /= total;\n                ${t} = ${h()}(result, 1.0);\n            ${l.getMainFragmentEnd(e)}\n        `;return{vertexShader:_(e),fragmentShader:r}}),"DownsamplingBlur"),y,{}),DownSamplingBlurWithAlpha:new r(new t((function(n,e){e.customDefines;const t=o.getShaderOutput("out0");let r=`\n            \n            ${v({varyingName:"vUv",varyingType:"v2"})}\n          \n            ${m({uniformName:"tInput",uniformType:"t2"})}\n            ${m({uniformName:"invSize",uniformType:"v2"})}\n\n            ${l.getMainFragmentStart(e)}\n                // varying storage\n                ${d("screenUV")} = ${g("vUv")};\n                ${d("factor")} = ${c("invSize")};\n\n                ${h("result")} = ${h()}(0.0, 0.0, 0.0, 0.0);\n                ${p("totalRGB")} = 0.0;\n                ${p("totalA")} = 0.0;\n\n                for (${$("i")} = -2; i <= 2; i++) {\n                    for (${$("j")} = -2; j <= 2; j++) {\n                        ${d("offset")}  = 1.0 * factor * ${d()}(${p()}(i), ${p()}(j));\n                        ${p("weightRGB")}  = 1.0 / (1.0 + dot(offset, offset));\n                        ${p("weightA")}  = 1.0;\n                        ${h("sampledValue")} = ${S("tInput","screenUV + offset")};\n                        result += ${h()}(weightRGB * sampledValue.rgb, weightA * sampledValue.a);\n                        totalRGB += weightRGB;\n                        totalA += weightA;\n                    }\n                }\n                result.r /= totalRGB;\n                result.g /= totalRGB;\n                result.b /= totalRGB;\n                result.a /= totalA;\n                ${t} = result;\n            ${l.getMainFragmentEnd(e)}\n        `;return{vertexShader:_(e),fragmentShader:r}}),"DownsamplingBlurWithAlpha"),y,{}),MergeMips:function(n){if(0===n)throw"Invalid Operation Exception: expected mips in MergeMipsShader, got 0";if(D.has(n))return D.get(n);var e=new r(new t((function(e,t){t.customDefines;const r=o.getShaderOutput("out0");let a=m({uniformName:"tMip0",uniformType:"t2",locationName:"tInput0"}),i=`\n                if (screenUV.y < 0.5) {\n                    ${d("factor")} = ${d()}(1.0, 2.0);\n                    ${r} = ${S("tMip0","factor * screenUV")};\n                    ${l.getEarlyFragmentEnd()}\n                }\n            `;for(let e=0;e<n;e++){const n=e+2,t="tMip"+(e+1);a=`\n                    ${a}\n                    ${m({uniformName:t,uniformType:"t2",locationName:"tInput"+(e+1)})}\n                `;const o=Math.pow(2,-n),s=1/o,u=2*o;i=`\n                    ${i}\n                    if (screenUV.y < ${1-o} && screenUV.x < ${u}) {\n                        ${d("uv")} = ${d()}(screenUV.x * ${p()}(${s/2}), (screenUV.y - ${1-u}) * ${p()}(${s}));\n                        ${r} = ${S(t,"uv")};\n                        ${l.getEarlyFragmentEnd()}\n                    }\n                `}let s=`\n                \n                ${v({varyingName:"vUv",varyingType:"v2"})}\n              \n                ${a}\n    \n                ${l.getMainFragmentStart(t)}\n                    // varying storage\n                    ${d("screenUV")} = ${g("vUv")};\n                    ${r} = ${h()}(0.0, 0.0, 0.0, 1.0);\n                    \n                    ${i}\n                ${l.getMainFragmentEnd(t)}\n            `;return{vertexShader:_(t),fragmentShader:s}}),"MergeMips"+n),T,{},n);return D.set(n,e),e}}})),define("DS/ShaderBuilders/PostPro/TAAShaderBuilders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PostPro/PostProUniformHandler","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/PostPro/PostProContext","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a,o,i,s){"use strict";const l=i.ParameterUtils,u=i.FunctionHandler,m=i.BridgeFunctions,c=n=>a.addUniform(n),$=n=>{var e={uniformName:n};return a.getUniform(e)},p=n=>l.parameterV2(n),d=n=>l.parameterV3(n),f=n=>l.parameterV4(n),h=(n,e,t)=>u.declareFunction(n,e,t),v=(n,e,t)=>u.callFunction(n,e,t),g=(n=null,e=0)=>{var t={name:n,size:e};return s.float(t)},x=(n=null,e=0)=>{var t={name:n,size:e};return s.vec2(t)},S=(n=null,e=0)=>{var t={name:n,size:e,constant:!0};return s.vec2(t)},y=(n=null,e=0)=>{var t={name:n,size:e};return s.vec3(t)},_=(n=null,e=0)=>{var t={name:n,size:e};return s.vec4(t)},T=n=>o.addVarying(n),D=n=>o.getVarying(n,o.ShaderStages.in),C=n=>o.getVarying(n,o.ShaderStages.out),P=(n,e)=>{return m.sample2DTexture((t={uniformName:n},a.getTextureUniform(t)),e);var t};class N extends e{constructor(){super(1),this.screenSize=new n.Vector2(512,512),this.prevMap=null,this.numIteration=0,this.previousViewProjectionMatrix=new n.Matrix4,this.currentViewProjectionMatrix=new n.Matrix4,this.currentProjectionMatrixInverse=new n.Matrix4,this.currentViewMatrixInverse=new n.Matrix4}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform2f(r.screenSize,this.screenSize.x,this.screenSize.y),e.loadTexture(t,r.prevMap,this.prevMap),t.uniform1f(r.numIteration,this.numIteration),t.uniformMatrix4fv(r.previousViewProjectionMatrix,!1,e.float32Matrix4x4Temp.setDoubles(this.previousViewProjectionMatrix.elements)),t.uniformMatrix4fv(r.currentViewProjectionMatrix,!1,e.float32Matrix4x4Temp.setDoubles(this.currentViewProjectionMatrix.elements)),t.uniformMatrix4fv(r.currentProjectionMatrixInverse,!1,e.float32Matrix4x4Temp.setDoubles(this.currentProjectionMatrixInverse.elements)),t.uniformMatrix4fv(r.currentViewMatrixInverse,!1,e.float32Matrix4x4Temp.setDoubles(this.currentViewMatrixInverse.elements))}fillUBO(n,e,t){super.fillUBO(n,e,t);const r=n.layout;n.setV2(r.screenSize,this.screenSize),n.setTexture(r.prevMap,this.prevMap),n.setF(r.numIteration,this.numIteration),n.setM4(r.previousViewProjectionMatrix,this.previousViewProjectionMatrix),n.setM4(r.currentViewProjectionMatrix,this.currentViewProjectionMatrix),n.setM4(r.currentProjectionMatrixInverse,this.currentProjectionMatrixInverse),n.setM4(r.currentViewMatrixInverse,this.currentViewMatrixInverse)}clone(){var n=new N;return n.screenSize=this.screenSize,n.prevMap=this.prevMap,n.numIteration=this.numIteration,n.previousViewProjectionMatrix=this.previousViewProjectionMatrix,n.currentViewProjectionMatrix=this.currentViewProjectionMatrix,n.currentProjectionMatrixInverse=this.currentProjectionMatrixInverse,n.currentViewMatrixInverse=this.currentViewMatrixInverse,n}}function b(e){return`\n            \n            ${T({varyingName:"vUv",varyingType:"v2"})}\n            \n\n            ${u.getMainVertexStart(e)}\n\n                ${C("vUv")} = uv.xy;\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(e)}\n            ${u.getMainVertexEnd(e)}\n        `}class M extends e{constructor(){super(1)}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i)}fillUBO(n,e,t){super.fillUBO(n,e,t)}clone(){return new M}}return{TAA:new r(new t((function(n,e){var t=e.customDefines;const r="tScene",a="tNormalDepth",i=o.getShaderOutput("out0");function l(n,t,r){return e.renderToFloatTexture?`\n                    ${n} = ${P(a,`uv + ${x()}(${t},${r})`)}.w; \n                    if (${n} < 0.1) {\n                        ${n} = 1.0;\n                    }\n                `:`\n                    ${n} = ${v("unpackForFloat16","f",[p(`${P(a,`uv + ${x()}(${t},${r})`)}.zw`)])}; \n                    if (${n} < 0.1) {\n                        ${n} = 1.0;\n                    }\n                `}function C(n,e,t){return`\n                ${l(n,e,t)}\n                ${function(n,e,t){return`\n            if (${n} < dmin.z) {\n                dmin = ${y()}(${e}, ${t}, ${n});\n            }`}(n,e,t)}\n            `}let N=`\n                \n            ${c({uniformName:"tScene",uniformType:"t2",locationName:"tInput0"})}\n            ${c({uniformName:"tNormalDepth",uniformType:"t2",locationName:"tInput1"})}    \n            \n            ${c({uniformName:"screenSize",uniformType:"v2"})}    \n            ${c({uniformName:"prevMap",uniformType:"t2"})}    \n            ${c({uniformName:"numIteration",uniformType:"f"})}  \n            ${c({uniformName:"previousViewProjectionMatrix",uniformType:"m4"})}  \n            ${c({uniformName:"currentViewProjectionMatrix",uniformType:"m4"})}  \n            ${c({uniformName:"currentProjectionMatrixInverse",uniformType:"m4"})}  \n            ${c({uniformName:"currentViewMatrixInverse",uniformType:"m4"})}      \n     \n            ${T({varyingName:"vUv",varyingType:"v2"})}\n    \n            ${S("positiveY")} = ${x()}(0.0, 1.0);\n            ${S("positiveX")} = ${x()}(1.0, 0.0);\n            ${S("negativeY")} = ${x()}(0.0, -1.0);\n            ${S("negativeX")} = ${x()}(-1.0, 0.0);\n\n            ${h("luminance_RGB","f",[d("iColor")])} {\n                ${y("luminance_weight")} = ${y()}(0.176204, 0.812985, 0.0108109);\n                return dot(iColor, luminance_weight);\n            }\n\n            ${h("getPositionWS","v3",[d("ndc")])} {\n                ${_("vertexPositionProjected")}  = ${_()}(ndc, 1.0);\n                ${_("vertexPositionVS")}  = ${$("currentProjectionMatrixInverse")} * vertexPositionProjected;\n                vertexPositionVS.x /= vertexPositionVS.w;\n                vertexPositionVS.y /= vertexPositionVS.w;\n                vertexPositionVS.z /= vertexPositionVS.w;\n                vertexPositionVS.w = 1.0;\n                return (${$("currentViewMatrixInverse")} * vertexPositionVS).xyz;\n            }\n\n            ${h("closestFragment","v3",[p("uv"),p("texelSize")])} {\n\n                ${g("d")};\n                ${x("size")}  = 2.0 * texelSize;\n                ${y("dmin")}  = ${y()}(0.0, 0.0, 0.0);\n\n                ${l("dmin.z","0.0"," 0.0")}\n                ${C("d","-size.x","size.y")}\n                ${C("d","size.x","size.y")}\n                ${C("d","-size.x","-size.y")}\n                ${C("d","size.x","-size.y")}\n                ${t.CLOSEST_9TAP?`\n                    ${C("d","0.0","size.y")}\n                    ${C("d","-size.x","0.0")}\n                    ${C("d","size.x","0.0")}\n                    ${C("d","0.0","-size.y")}\n                    `:""}\n                return ${y()}(uv + dmin.xy, dmin.z);\n            }\n\n\n            ${h("clip_aabb_opti","v4",[f("minimum"),f("maximum"),f("color")])} {\n\n                ${((n=null,e=0)=>{var t={name:n,size:e,constant:!0};return s.float(t)})("eps")} = 0.00000001;\n                ${_("center")}  = 0.5 * (maximum + minimum);\n                ${_("extents")}  = 0.5 * (maximum - minimum) + eps;\n                ${_("offset")}  = color - center;\n                ${_("ts")}  = abs(offset / extents);\n                ${g("t")} = max(max(ts.r, ts.g), max(ts.b, ts.a));\n                return center + offset / max(1.0, t);\n            }\n\n            ${h("taa","v4",[p("ssVel"),p("texelSize"),p("uv")])} {\n\n                ${_("tl")}  = ${P(r,"uv + texelSize * (negativeX + positiveY)")};\n                ${_("t")}   = ${P(r,"uv + texelSize * (positiveY)")};\n                ${_("tr")}  = ${P(r,"uv + texelSize * (positiveX + positiveY)")};\n                ${_("ml")}  = ${P(r,"uv + texelSize * (negativeX)")};\n                ${_("m")}   = ${P(r,"uv")};\n                ${_("mr")}  = ${P(r,"uv + texelSize * (positiveX )")};\n                ${_("bl")}  = ${P(r,"uv + texelSize * (negativeX + negativeY)")};\n                ${_("b")}   = ${P(r,"uv + texelSize * (negativeY)")};\n                ${_("br")}  = ${P(r,"uv + texelSize * (positiveX + negativeY)")};\n                // sharpen\n                // https://github.com/Unity-Technologies/PostProcessing/blob/v1/PostProcessing/Resources/Shaders/TAA.cginc#L143\n                // reduces blurring, but increases flickering with dense geometry\n                ${_("corners")}  = 2.0 * (tr + bl + br + tl) - 2.0 * m;\n                m += (m - (corners * 0.166667)) * 2.718282 * 0.3;\n                m = max(${_()}(0.0), m);\n                // Brian Karis neighbourhood rounding: http://advances.realtimerendering.com/s2014/epic/TemporalAA.pptx\n                // average of rounded pattern with cross pattern\n                ${_("cmin5")}  = min(mr, min(m, min(ml, min(t, b))));\n                ${_("cmin")}  = min(cmin5, min(tl, min(tr, min(bl, br))));\n                ${_("cmax5")}  = max(mr, max(m, max(ml, max(t, b))));\n                ${_("cmax")}  = max(cmax5, max(tl, max(tr, max(bl, br))));\n                cmin = 0.5 * (cmin + cmin5);\n                cmax = 0.5 * (cmax + cmax5);\n                ${_("previousColor")}  = ${P("prevMap","uv - ssVel")};\n                previousColor = ${v("clip_aabb_opti","v4",[f("cmin"),f("cmax"),f("previousColor")])};\n                ${g("lum0")}  = ${v("luminance_RGB","f",[d("m.rgb")])};\n                ${g("lum1")}  = ${v("luminance_RGB","f",[d("previousColor.rgb")])};\n                ${g("diff")}  = abs(lum0 - lum1) / max(lum0, max(lum1, 0.2));\n                ${g("unbiased_weight")}  = 1.0 - diff;\n                ${g("feedback")}  = mix(${t.FEEDBACK_MIN}, ${t.FEEDBACK_MAX}, unbiased_weight * unbiased_weight);\n                return mix(m, previousColor, feedback);\n            }\n\n            ${h("computeSSVelocity","v2",[d("wsPos")])}{\n\n                ${_("ssCurrentPos")}  = ${$("currentViewProjectionMatrix")} * ${_()}(wsPos, 1.0);\n                ${_("ssPrevPos")}  =   ${$("previousViewProjectionMatrix")} * ${_()}(wsPos, 1.0);\n                ${x("ndcCurrent")}  = ssCurrentPos.xy / ssCurrentPos.w;\n                ${x("ndcPrev")}  = ssPrevPos.xy / ssPrevPos.w;\n\n                if(ndcPrev.x >= 1.0 || ndcPrev.x <= -1.0 || ndcPrev.x >= 1.0 || ndcPrev.y <= -1.0) {\n\n                    return ${x()}(0.0);\n                }\n                ${x("velocity")} = 0.5 * (ndcCurrent - ndcPrev);\n                ${m.uvConvention("velocity")};\n                return velocity;\n            }\n\n\n            ${u.getMainFragmentStart(e)}\n                ${x("TAAUV")} = ${D("vUv")};\n                ${g("curIteration")} = ${$("numIteration")};\n                if (curIteration > 0.0) {\n\n\t\t\t\t   ${_("prevColor")}  = ${P("prevMap","TAAUV")};\n\t\t\t\t   ${_("currColor")}  = ${P(r,"TAAUV")};\n\t\t\t\t   ${i} = ${_()}((prevColor * curIteration + currColor) / (curIteration + 1.0));\n                   ${u.getEarlyFragmentEnd()}\n                }\n\n                ${x("texelSize")}  = ${x()}(1.0) / ${$("screenSize")};\n                ${y("closest")}  = ${v("closestFragment","v3",[p("TAAUV"),p("texelSize")])};\n\n                if (closest.z == 0.0) {\n                    ${i} =  ${P(r,"TAAUV")};\n                    ${u.getEarlyFragmentEnd()}\n                }\n                closest.x = 2.0 * closest.x - 1.0;\n                closest.y = 2.0 * closest.y - 1.0;\n                closest.z = ${m.getDepthWithConvention("closest.z")};\n                ${y("ws")} = ${v("getPositionWS","v3",[d("closest")])};\n                ${x("ssVel")}  = ${v("computeSSVelocity","v2",[d("ws")])};\n                ${i} = ${v("taa","v4",[p("ssVel"),p("texelSize"),p("TAAUV")])};\n            ${u.getMainFragmentEnd(e)}\n        `;return{vertexShader:b(e),fragmentShader:N}}),"TAA"),N,{FEEDBACK_MIN:.88,FEEDBACK_MAX:.97,CLOSEST_9TAP:1}),Transfer:new r(new t((function(n,e){e.customDefines;const t=o.getShaderOutput("out0");let r=`\n                \n            ${c({uniformName:"tScene",uniformType:"t2",locationName:"tInput0"})}\n            ${c({uniformName:"tBlend",uniformType:"t2",locationName:"tInput1"})}\n     \n            ${T({varyingName:"vUv",varyingType:"v2"})}\n\n            ${u.getMainFragmentStart(e)}\n                ${x("blendUV")} = ${D("vUv")};\n\n                ${t} = ${P("tBlend","blendUV")};\n            ${u.getMainFragmentEnd(e)}\n        `;return{vertexShader:b(e),fragmentShader:r}}),"TAA_Transfer"),M,{})}})),define("DS/ShaderBuilders/PostPro/SMAAShaderBuilders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PostPro/PostProUniformHandler","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/PostPro/PostProContext","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a,o,i,s){"use strict";const l=i.ParameterUtils,u=i.FunctionHandler,m=i.BridgeFunctions,c=n=>a.addUniform(n),$=n=>{var e={uniformName:n};return a.getUniform(e)},p=n=>l.parameterF(n),d=n=>l.parameterV2(n),f=(n,e,t)=>u.declareFunction(n,e,t),h=(n,e,t)=>u.callFunction(n,e,t),v=(n=null,e=0,t="")=>{var r={name:n,size:e,addressSpace:t};return s.bool(r)},g=(n=null,e=0,t="")=>{var r={name:n,size:e,addressSpace:t};return s.int(r)},x=(n=null,e=0)=>{var t={name:n,size:e,constant:!0};return s.int(t)},S=(n=null,e=0,t="")=>{var r={name:n,size:e,addressSpace:t};return s.float(r)},y=(n=null,e=0)=>{var t={name:n,size:e,constant:!0};return s.float(t)},_=(n=null,e=0,t="")=>{var r={name:n,size:e,addressSpace:t};return s.vec2(r)},T=(n=null,e=0)=>_(n,e,"private"),D=(n=null,e=0)=>{var t={name:n,size:e,constant:!0};return s.vec2(t)},C=(n=null,e=0,t="")=>{var r={name:n,size:e,addressSpace:t};return s.vec3(r)},P=(n=null,e=0,t="")=>{var r={name:n,size:e,addressSpace:t};return s.vec4(r)},N=n=>o.addVarying(n),b=n=>o.getVarying(n,o.ShaderStages.in),M=n=>o.getVarying(n,o.ShaderStages.out),U=(n,e)=>{return m.sample2DTexture((t={uniformName:n},a.getTextureUniform(t)),e);var t};class w extends e{constructor(){super(),this.screenWidth=800,this.screenHeight=600}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform1f(r.screenWidth,this.screenWidth),t.uniform1f(r.screenHeight,this.screenHeight)}fillUBO(n,e,t){super.fillUBO(n,e,t);const r=n.layout;n.setF(r.screenWidth,this.screenWidth),n.setF(r.screenHeight,this.screenHeight)}clone(){var n=new w;return n.screenHeight=this.screenHeight,n.screenWidth=this.screenWidth,n}}class V extends e{constructor(){super(),this.areaTex=null,this.searchTex=null,this.screenWidth=800,this.screenHeight=600}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform1f(r.screenWidth,this.screenWidth),t.uniform1f(r.screenHeight,this.screenHeight),e.loadTexture(t,r.areaTex,this.areaTex),e.loadTexture(t,r.searchTex,this.searchTex)}fillUBO(n,e,t){super.fillUBO(n,e,t);const r=n.layout;n.setF(r.screenWidth,this.screenWidth),n.setF(r.screenHeight,this.screenHeight),n.setTexture(r.areaTex,this.areaTex),n.setTexture(r.searchTex,this.searchTex)}clone(){var n=new V;return n.areaTex=this.areaTex,n.searchTex=this.searchTex,n.screenHeight=this.screenHeight,n.screenWidth=this.screenWidth,n}}class z extends e{constructor(){super(1),this.screenWidth=800,this.screenHeight=600}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform1f(r.screenWidth,this.screenWidth),t.uniform1f(r.screenHeight,this.screenHeight)}fillUBO(n,e,t){super.fillUBO(n,e,t);const r=n.layout;n.setF(r.screenWidth,this.screenWidth),n.setF(r.screenHeight,this.screenHeight)}clone(){var n=new z;return n.screenHeight=this.screenHeight,n.screenWidth=this.screenWidth,n}}return{EdgeDetection:new r(new t((function(e,t){t.customDefines;let r=`\n            ${N({varyingName:"vUv",varyingType:"v2"})}\n            ${N({varyingName:"offset0",varyingType:"v4"})}\n            ${N({varyingName:"offset1",varyingType:"v4"})}\n            ${N({varyingName:"offset2",varyingType:"v4"})}\n     \n            ${c({uniformName:"screenHeight",uniformType:"f"})}\n            ${c({uniformName:"screenWidth",uniformType:"f"})}\n\n            ${u.getMainVertexStart(t)}\n                ${_("SMAA_PIXEL_SIZE")} = ${_()}(1.0 / ${$("screenWidth")}, 1.0 / ${$("screenHeight")});\n\n                ${M("vUv")} = uv.xy;\n\n                ${M("offset0")} = uv.xyxy + SMAA_PIXEL_SIZE.xyxy * ${P()}(-1.0, 0.0, 0.0, 1.0);\n                ${M("offset1")} = uv.xyxy + SMAA_PIXEL_SIZE.xyxy * ${P()}( 1.0, 0.0, 0.0, -1.0);\n                ${M("offset2")} = uv.xyxy + SMAA_PIXEL_SIZE.xyxy * ${P()}(-2.0, 0.0, 0.0, -2.0);\n\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(t)}\n            ${u.getMainVertexEnd(t)}\n\n        `;const a="tScene",i=o.getShaderOutput("out0");return{vertexShader:r,fragmentShader:`\n            \n            ${N({varyingName:"vUv",varyingType:"v2"})}\n            ${N({varyingName:"offset0",varyingType:"v4"})}\n            ${N({varyingName:"offset1",varyingType:"v4"})}\n            ${N({varyingName:"offset2",varyingType:"v4"})}\n\n            \n            ${c({uniformName:"tScene",uniformType:"t2",locationName:"tInput"})}\n\n            ${y("SMAA_THRESHOLD")} = 0.1;\n\n            ${u.getMainFragmentStart(t)}\n                // varying storage\n                ${_("SMAA_edges_uv")} = ${b("vUv")};\n                ${P("lumaUVs")} = ${b("offset0")};\n                ${P("delta1UVs")} = ${b("offset1")};\n                ${P("delta2UVs")} = ${b("offset2")};\n\n                // Calculate the threshold:\n                ${_("threshold")} = ${_()}(SMAA_THRESHOLD, SMAA_THRESHOLD);\n\n                // Calculate lumas:\n                ${C("weights")} = ${C()}(0.2126,0.7152,0.0722);\n                ${S("L")} = dot(${U(a,"SMAA_edges_uv")}.rgb, weights);\n                ${S("Lleft")}  = dot(${U(a,"lumaUVs.xy")}.rgb, weights);\n                ${S("Ltop")}  = dot(${U(a,"lumaUVs.zw")}.rgb, weights);\n\n                // We do the usual threshold:\n                ${_("delta1")};\n                delta1  = abs(L - ${_()}(Lleft, Ltop));\n                ${_("edges")}  = step(threshold, delta1);\n                \n                // Calculate right and bottom deltas:\n                ${_("delta2")};\n                ${S("Lright")} = dot(${U(a,"delta1UVs.xy")}.rgb, weights);\n                ${S("Lbottom")} = dot(${U(a,"delta1UVs.zw")}.rgb, weights);\n                delta2 = abs(L - ${_()}(Lright, Lbottom));\n\n                // Calculate the maximum delta in the direct neighborhood:\n                ${_("maxDelta")}   = max(delta1, delta2);\n                maxDelta       = max(maxDelta.xx, maxDelta.yy);\n\n                // Calculate left-left and top-top deltas:\n                ${S("Lleftleft")}  = dot(${U(a,"delta2UVs.xy")}.rgb, weights);\n                ${S("Ltoptop")}    = dot(${U(a,"delta2UVs.zw")}.rgb, weights);\n                delta2       = abs(${_()}(Lleft, Ltop) - ${_()}(Lleftleft, Ltoptop));\n\n                // Calculate the final maximum delta:\n                maxDelta = max(maxDelta.xy, delta2.xy);\n\n                \n                // Each edge with a delta in luma of less than 50% of the maximum luma\n                // surrounding this pixel is discarded. This allows to eliminate spurious\n                // crossing edges, and is based on the fact that, if there is too much\n                // contrast in a direction, that will hide contrast in the other\n                // neighbors.\n                // This is done after the discard intentionally as this situation doesn't\n                // happen too frequently (but it's important to do as it prevents some\n                // edges from going undetected).\n                 \n\n                edges *= step(0.5 * maxDelta, delta1.xy);\n\n                ${i} = ${P()}(edges.x, edges.y, 0.0, 1.0);\n            ${u.getMainFragmentEnd(t)}\n        `}}),"SMAA_Edge_Detection"),w,{}),BlendingWeights:new r(new t((function(e,t){t.customDefines;let r=`\n            \n            ${N({varyingName:"vUv",varyingType:"v2"})}\n            ${N({varyingName:"offset",varyingType:"v4"})}\n    \n            ${c({uniformName:"screenHeight",uniformType:"f"})}\n            ${c({uniformName:"screenWidth",uniformType:"f"})}\n\n\n            ${y("SMAA_MAX_SEARCH_STEPS")} = 8.0;\n\n            ${u.getMainVertexStart(t)}\n\n                ${_("SMAA_PIXEL_SIZE")}  = ${_()}(1.0/${$("screenWidth")}, 1.0/${$("screenHeight")});\n\n                ${M("vUv")} = uv.xy;\n\n                // We will use these offsets for the searches later on (see @PSEUDO_GATHER4):\n                ${M("offset")} = uv.xyxy + SMAA_PIXEL_SIZE.xyxy * ${P()}(-0.25, 0.125,  1.25, 0.125);\n\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(t)}\n\n            ${u.getMainVertexEnd(t)}\n        `;const a="tEdges",i="areaTex",s=o.getShaderOutput("out0");return{vertexShader:r,fragmentShader:`\n            ${N({varyingName:"vUv",varyingType:"v2"})}\n            ${T("SMAA_weights_uv")};\n            ${N({varyingName:"offset",varyingType:"v4"})}\n\n            \n            ${c({uniformName:"tEdges",uniformType:"t2",locationName:"tInput"})}\n            ${c({uniformName:"searchTex",uniformType:"t2"})}\n            ${c({uniformName:"areaTex",uniformType:"t2"})}  \n            ${c({uniformName:"screenHeight",uniformType:"f"})}\n            ${c({uniformName:"screenWidth",uniformType:"f"})}\n\n            ${T("SMAA_PIXEL_SIZE")} ;\n\n            ${x("SMAA_FORCE_DIAGONAL_DETECTION")}    = 1;\n            ${x("SMAA_FORCE_CORNER_DETECTION")}      = 1;\n            ${x("SMAA_AREATEX_MAX_DISTANCE")}        = 16;\n            ${x("SMAA_AREATEX_MAX_DISTANCE_DIAG")}   = 20;\n            ${y("SMAA_AREATEX_SUBTEX_SIZE")}        = 1.0 / 7.0;\n            ${D("SMAA_AREATEX_PIXEL_SIZE")}         = ${_()}(1.0 / 160.0, 1.0/ 560.0);\n\n            //HIGH SMAA parameters\n            ${y("SMAA_THRESHOLD")}                = 0.1;\n            ${x("SMAA_MAX_SEARCH_STEPS")}          = 16;\n            ${x("SMAA_MAX_SEARCH_STEPS_DIAG")}     = 8;\n            ${x("SMAA_CORNER_ROUNDING")}           = 25;\n\n            ${D("positiveY")} = ${_()}(0.0, 1.0);\n            ${D("positiveX")} = ${_()}(1.0, 0.0);\n            ${D("negativeY")} = ${_()}(0.0, -1.0);\n            ${D("negativeX")} = ${_()}(-1.0, 0.0);\n\n            // Horizontal/Vertical Search Functions\n            \n            // This allows to determine how much length should we add in the last step\n            // of the searches. It takes the bilinearly interpolated edge (see\n            // @PSEUDO_GATHER4), and adds 0, 1 or 2, depending on which edges and\n            // crossing edges are active.\n            \n            ${f("SMAASearchLength","f",[d("e"),p("bias"),p("scale")])} {\n                ${_("coord")} = e;\n                coord.r = bias + e.r * scale;\n                coord.g = 1.0 - e.y;\n                return  255.0*${U("searchTex","coord")}.r;\n            }\n\n            \n            // Horizontal/vertical search functions for the 2nd pass.\n            \n            ${f("SMAASearchXLeft","f",[])} {\n\n                ${_("texcoord")}  = SMAA_weights_uv + SMAA_PIXEL_SIZE * (0.25 * negativeX + 0.125 * positiveY);\n\n                ${S("end")} = (SMAA_weights_uv.x - 0.25 * SMAA_PIXEL_SIZE.x) - 2.0 * SMAA_PIXEL_SIZE.x * ${S()}(SMAA_MAX_SEARCH_STEPS);\n\n                ${_("e")} = ${_()}(0.0, 1.0);\n\n                for(${g("i")}= 0;i<SMAA_MAX_SEARCH_STEPS;i++){\n                    if((texcoord.x > end) && (e.g > 0.8281) && (e.r == 0.0)){\n                        e = ${U(a,"texcoord")}.rg;\n                        texcoord.x -= 2.0 * SMAA_PIXEL_SIZE.x;\n                    }else {\n                        break;\n                    }\n                }\n\n                texcoord.x += 3.25 * SMAA_PIXEL_SIZE.x;\n                texcoord.x -= SMAA_PIXEL_SIZE.x * ${h("SMAASearchLength","f",[d("e"),p("0.0"),p("0.5")])};\n\n                return texcoord.x  ;\n            }\n\n            ${f("SMAASearchXRight","f",[])} {\n\n                ${_("texcoord")}  = SMAA_weights_uv + SMAA_PIXEL_SIZE * (1.25 * positiveX + 0.125 * positiveY);\n\n                ${S("end")}  = (SMAA_weights_uv.x + 1.25 * SMAA_PIXEL_SIZE.x) + 2.0 * SMAA_PIXEL_SIZE.x * ${S()}(SMAA_MAX_SEARCH_STEPS);\n\n                ${_("e")} = ${_()}(0.0, 1.0);\n\n                for(${g("i")} = 0;i<SMAA_MAX_SEARCH_STEPS;i++){\n                    if((texcoord.x < end) && (e.g > 0.8281) && (e.r == 0.0)){\n                        e = ${U(a,"texcoord")}.rg;\n                        texcoord.x += 2.0 * SMAA_PIXEL_SIZE.x;\n                    }else {\n                        break;\n                    }\n                }\n\n                texcoord.x -= 3.25 * SMAA_PIXEL_SIZE.x;\n                texcoord.x += SMAA_PIXEL_SIZE.x * ${h("SMAASearchLength","f",[d("e"),p("0.5"),p("0.5")])};\n                return texcoord.x;\n            }\n\n            ${f("SMAASearchYDown","f",[])} {\n\n                ${_("texcoord")}  = SMAA_weights_uv + SMAA_PIXEL_SIZE * (0.125 * negativeX + 1.25 * negativeY);\n\n                ${S("end")}  = (SMAA_weights_uv.y - 1.25 * SMAA_PIXEL_SIZE.y) - 2.0 * SMAA_PIXEL_SIZE.y * ${S()}(SMAA_MAX_SEARCH_STEPS);\n\n                ${_("e")} = ${_()}(1.0, 0.0);\n\n                for(${g("i")} = 0;i<SMAA_MAX_SEARCH_STEPS;i++){\n                    if((texcoord.y > end) && (e.r > 0.8281) && (e.g == 0.0)){\n                        e = ${U(a,"texcoord")}.rg;\n                        texcoord.y -= 2.0 * SMAA_PIXEL_SIZE.y;\n                    }else {\n                        break;\n                    }\n                }\n\n                texcoord.y += 1.25 * SMAA_PIXEL_SIZE.y;\n                texcoord.y -= SMAA_PIXEL_SIZE.y * ${h("SMAASearchLength","f",[d("e.gr"),p("0.5"),p("0.5")])};\n                return texcoord.y ;\n            }\n\n            ${f("SMAASearchYUp","f",[])} {\n                ${_("texcoord")} = SMAA_weights_uv + SMAA_PIXEL_SIZE * (0.125 * negativeX + 0.25 * positiveY);\n\n                ${S("end")} = (SMAA_weights_uv.y + 0.25 * SMAA_PIXEL_SIZE.y) + 2.0 * SMAA_PIXEL_SIZE.y * ${S()}(SMAA_MAX_SEARCH_STEPS);\n                ${_("e")} = ${_()}(1.0, 0.0);\n\n                for(${g("i")} = 0;i<SMAA_MAX_SEARCH_STEPS;i++){\n                    if((texcoord.y < end) && (e.r > 0.8281) && (e.g == 0.0)){\n                        e = ${U(a,"texcoord")}.rg;\n                        texcoord.y += 2.0 * SMAA_PIXEL_SIZE.y;\n                    }else {\n                        break;\n                    }\n                }\n\n                texcoord.y -= 3.25 * SMAA_PIXEL_SIZE.y;\n                texcoord.y += SMAA_PIXEL_SIZE.y * ${h("SMAASearchLength","f",[d("e.gr"),p("0.0"),p("0.5")])};\n                return texcoord.y ;\n            }\n\n            ${f("_round","v2",[d("inVec")])} {\n                ${_("absBiasInVec")} = abs(inVec) + 0.5;\n               return floor(absBiasInVec) * sign(inVec);\n            }\n\n            \n            // Ok, we have the distance and both crossing edges. So, what are the areas\n            // at each side of current edge?\n            \n            ${f("SMAAArea","v2",[d("dist"),p("e1"),p("e2")])} {\n                ${_("inVec")} = 4.0 * ${_()}(e1, e2);\n                ${_("texcoord")} = ${S()}(SMAA_AREATEX_MAX_DISTANCE) * ${h("_round","v2",[d("inVec")])}  + dist;\n\n                texcoord = SMAA_AREATEX_PIXEL_SIZE * texcoord + (0.5 * SMAA_AREATEX_PIXEL_SIZE);\n                texcoord.y = 1.0-texcoord.y;\n                return ${U(i,"texcoord")}.rg;\n            }\n\n            // Corner Detection Functions\n            ${f("SMAADetectHorizontalCornerPattern","v2",[d("weights"),d("texcoord"),d("d")])} {\n                ${_("res")} = weights;\n               if (SMAA_CORNER_ROUNDING < 100 || SMAA_FORCE_CORNER_DETECTION == 1 ){\n                   ${P("coords")} = ${P()}(d.x, 0.0, d.y, 0.0)*SMAA_PIXEL_SIZE.xyxy+ texcoord.xyxy;\n                   ${_("e")};\n                   e.r = ${U(a,"coords.xy + negativeY")}.r;\n                   ${v("left")} = abs(d.x) < abs(d.y);\n                   e.g = ${U(a,"coords.xy + 2.0 * positiveY")}.r;\n                   if (left) {\n                    res *= clamp(${S()}(SMAA_CORNER_ROUNDING) / 100.0 + 1.0 - e,${_()}(0.0),${_()}(1.0));\n                    }\n\n                   e.r = ${U(a,"coords.zw + negativeY + positiveX")}.r;\n                   e.g = ${U(a,"coords.zw + 2.0 * positiveY + positiveX")}.r;\n                   if (!left) {\n                      res *= clamp(${S()}(SMAA_CORNER_ROUNDING) / 100.0 + 1.0 - e,${_()}(0.0),${_()}(1.0));\n                    }\n               }\n               return res;\n            }\n\n\n            ${f("SMAADetectVerticalCornerPattern","v2",[d("weights"),d("texcoord"),d("d")])} {\n                ${_("res")} = weights;\n               if (SMAA_CORNER_ROUNDING < 100 || SMAA_FORCE_CORNER_DETECTION == 1){\n                   ${P("coords")} = ${P()}(0.0, d.x, 0.0, d.y)*SMAA_PIXEL_SIZE.xyxy + texcoord.xyxy;\n                   ${_("e")};\n                   e.r = ${U(a,"coords.xy + positiveX")}.g;\n                   ${v("left")} = abs(d.x) < abs(d.y);\n                   e.g = ${U(a,"coords.xy + 2.0 * negativeX")}.g;\n                   if (left) {\n                    res *= clamp(${S()}(SMAA_CORNER_ROUNDING) / 100.0 + 1.0 - e,${_()}(0.0),${_()}(1.0));\n                    }\n\n                   e.r = ${U(a,"coords.zw + negativeY + positiveX")}.g;\n                   e.g = ${U(a,"coords.zw + 2.0 * negativeX + negativeY")}.g;\n                   if (!left) {\n                      res *= clamp(${S()}(SMAA_CORNER_ROUNDING) / 100.0 + 1.0 - e,${_()}(0.0),${_()}(1.0));\n                    }\n            \t}\n                return res;\n            }\n\n            \n            // Similar to SMAAArea, this calculates the area corresponding to a certain\n            // diagonal distance and crossing edges 'e'.\n            \n            ${f("SMAAAreaDiag","v2",[d("dist"),d("e")])} {\n               ${_("texcoord")} = ${S()}(SMAA_AREATEX_MAX_DISTANCE_DIAG) * e + dist;\n\n                // We do a scale and bias for mapping to texel space:\n               texcoord = SMAA_AREATEX_PIXEL_SIZE * texcoord + (0.5 * SMAA_AREATEX_PIXEL_SIZE);\n\n                // Diagonal areas are on the second half of the texture:\n               texcoord.x += 0.5;\n               texcoord.y = 1.0 - texcoord.y;\n\n               return ${U(i,"texcoord")}.rg;\n            }\n\n            \n            // These functions allows to perform diagonal pattern searches.\n            \n            ${f("SMAASearchDiag1","f",[d("texcoord"),d("dir"),p("c")])} {\n                ${_("coord")} = texcoord;\n                coord += dir * SMAA_PIXEL_SIZE;\n               ${_("e")} = ${_()}(0.0, 0.0);\n               ${g("j")};\n\n               for (${g("i")} = 0; i < SMAA_MAX_SEARCH_STEPS_DIAG; i++) {\n                   j = i;\n                   e = ${U(a,"coord")}.rg;\n                   if (dot(e, ${_()}(1.0, 1.0)) < 1.9) {\n                    break;\n                    }\n                   coord += dir * SMAA_PIXEL_SIZE;\n               }\n\n               return ${S()}(j) + ${S()}(e.g > 0.9) * c;\n            }\n\n            ${f("SMAASearchDiag2","f",[d("texcoord"),d("dir"),p("c")])} {\n                ${_("coord")} = texcoord;\n                coord += dir * SMAA_PIXEL_SIZE;\n               ${_("e")} = ${_()}(0.0, 0.0);\n               ${g("j")};\n\n               for (${g("i")} = 0; i < SMAA_MAX_SEARCH_STEPS_DIAG; i++) {\n                   j = i;\n                   e.g = ${U(a,"coord")}.g;\n                   e.r = ${U(a,"coord + SMAA_PIXEL_SIZE * positiveX")}.r;\n                   if (dot(e, ${_()}(1.0, 1.0)) < 1.9) {\n                    break;\n                    }\n                   coord += dir * SMAA_PIXEL_SIZE;\n               }\n\n               return ${S()}(j) + ${S()}(e.g > 0.9) * c;\n            }\n\n            \n            // This searches for diagonal patterns and returns the corresponding weights.\n            \n            ${f("SMAACalculateDiagWeights","v2",[d("texcoord"),d("e")])} {\n                ${_("weights")}  = ${_()}(0.0, 0.0);\n\n                ${_("d")} ;\n                d.x = 0.0;\n                if (e.r > 0.0) {\n                    d.x = ${h("SMAASearchDiag1","f",[d("texcoord"),d(`${_()}(-1.0, -1.0)`),p("1.0")])};\n                }\n                d.y = ${h("SMAASearchDiag1","f",[d("texcoord"),d(`${_()}(1.0, 1.0)`),p("0.0")])};\n\n                if (d.r + d.g > 2.0) {\n                    ${P("coords")} = ${P()}(-d.r, -d.r, d.g, d.g) * SMAA_PIXEL_SIZE.xyxy + texcoord.xyxy;\n\n                    ${P("c")};\n\n                    c.x = ${U(a,"coords.xy + negativeX * SMAA_PIXEL_SIZE")}.g;\n                    c.y = ${U(a,"coords.xy")}.r;\n                    c.z = ${U(a,"coords.zw + positiveX * SMAA_PIXEL_SIZE")}.g;\n                    c.w = ${U(a,"coords.zw + (positiveX + positiveY) * SMAA_PIXEL_SIZE")}.r;\n\n                    ${_("e2")} = 2.0 * c.xz + c.yw;\n                    ${S("t")} = ${S()}(SMAA_MAX_SEARCH_STEPS_DIAG) - 1.0;\n                    e2 *= step(d.rg, ${_()}(t, t));\n\n                    weights += ${h("SMAAAreaDiag","v2",[d("d"),d("e2")])};\n\n                }\n\n                d.x = ${h("SMAASearchDiag2","f",[d("texcoord"),d(`${_()}(-1.0, 1.0)`),p("0.0")])};\n                ${S("right")}  = ${U(a,"texcoord + positiveX * SMAA_PIXEL_SIZE")}.r;\n                d.y = 0.0;\n                if (right > 0.0) {\n                    d.y = ${h("SMAASearchDiag2","f",[d("texcoord"),d(`${_()}(1.0, -1.0)`),p("1.0")])};\n                }\n\n                if (d.r + d.g > 2.0) { \n                    ${P("coords")} = vec4(-d.r, d.r, d.g, -d.g)* SMAA_PIXEL_SIZE.xyxy+ texcoord.xyxy;\n\n                    ${P("c")};\n                    c.x  = ${U(a,"coords.xy  + negativeX * SMAA_PIXEL_SIZE")}.g;\n                    c.y  = ${U(a,"coords.xy  + positiveY * SMAA_PIXEL_SIZE")}.r;\n                    ${_("zw")} = ${U(a,"coords.zw  + positiveX * SMAA_PIXEL_SIZE")}.gr;\n                    c.z = zw.x;\n                    c.w = zw.y;\n                    ${_("e2")} = 2.0 * c.xz + c.yw;\n                    ${S("t")} = ${S()}(SMAA_MAX_SEARCH_STEPS_DIAG) - 1.0;\n                    e2 *= step(d.rg, ${_()}(t, t));\n\n                    weights += ${h("SMAAAreaDiag","v2",[d("d"),d("e2")])}.gr;\n                }\n\n                return weights;\n            }\n\n\n            ${u.getMainFragmentStart(t)}\n                SMAA_weights_uv = ${b("vUv")};\n                SMAA_PIXEL_SIZE = ${_()}(1.0/${$("screenWidth")}, 1.0/${$("screenHeight")});\n            \n            \t${_("pixcoord")}  = SMAA_weights_uv / SMAA_PIXEL_SIZE;\n\n                ${P("weights")}  = ${P()}(0.0, 0.0, 0.0, 0.0);\n\n                ${_("e")} = ${U(a,"SMAA_weights_uv")}.rg;\n\n                if (e.g > 0.0) { // Edge at north\n                    ${_("weiRG")};\n                    if (SMAA_MAX_SEARCH_STEPS_DIAG > 0 || SMAA_FORCE_DIAGONAL_DETECTION == 1) {\n                        // Diagonals have both north and west edges, so searching for them in\n                        // one of the boundaries is enough.\n                        weiRG = ${h("SMAACalculateDiagWeights","v2",[d("SMAA_weights_uv"),d("e")])};\n                        weights.r = weiRG.r;\n                        weights.g = weiRG.g;\n                    }\n\n                    // We give priority to diagonals, so if we find a diagonal we skip\n                    // horizontal/vertical processing.\n                    if (dot(weights.rg, ${_()}(1.0, 1.0)) == 0.0) {\n\n                        // Find the distance to the left:\n                        ${_("d")};\n                        ${_("coords")} ;\n                        coords.x = ${h("SMAASearchXLeft","f",[])};\n                        coords.y = SMAA_weights_uv.y + 0.25 * SMAA_PIXEL_SIZE.y ;\n                        d.x = coords.x;\n\n                        ${S("e1")}  = ${U(a,"coords")}.r;\n\n                        // Find the distance to the right:\n                        coords.x = ${h("SMAASearchXRight","f",[])};\n                        d.y = coords.x;\n\n                        // We want the distances to be in pixel units (doing this here allow to\n                        // better interleave arithmetic and memory accesses):\n                        d =  (d / SMAA_PIXEL_SIZE.x) - pixcoord.x ;\n\n                        // SMAAArea below needs a sqrt, as the areas texture is compressed quadratically:\n                        ${_("sqrt_d")}  = sqrt(abs(d));\n\n                        // Fetch the right crossing edges:\n                        ${S("e2")} = ${U(a,"coords + positiveX * SMAA_PIXEL_SIZE")}.r;\n\n\n                        // Ok, we know how this pattern looks like, now it is time for getting\n                        // the actual area:\n                        weiRG = ${h("SMAAArea","v2",[d("sqrt_d"),p("e1"),p("e2")])};\n                        weights.r = weiRG.r;\n                        weights.g = weiRG.g;\n\n                        // Fix corners:\n                        ${_("cornerPatternH")} = ${h("SMAADetectHorizontalCornerPattern","v2",[d("weights.rg"),d("SMAA_weights_uv"),d("d")])};\n                        weights.r = cornerPatternH.x;\n                        weights.g = cornerPatternH.y;\n\n                   } else { \n                        // Skip vertical processing.\n                        e.r = 0.0;\n                   }\n\n               }\n\n               // Edge at west\n               if (e.r > 0.0) { \n                   ${_("d")};\n\n                    // Find the distance to the top:\n                   ${_("coords")} ;\n                   coords.y = ${h("SMAASearchYUp","f",[])};\n                   coords.x = ${b("offset")}.x;\n                   d.x = coords.y;\n\n                    // Fetch the top crossing edges:\n                   ${S("e1")}  =  ${U(a,"coords")}.g;\n\n                    // Find the distance to the bottom:\n                   coords.y = ${h("SMAASearchYDown","f",[])};\n                   d.y = coords.y;\n\n                    // We want the distances to be in pixel units:\n                   d = d / SMAA_PIXEL_SIZE.y - pixcoord.y;\n\n                    // SMAAArea below needs a sqrt, as the areas texture is compressed quadratically:\n                   ${_("sqrt_d")}  = sqrt(abs(d));\n\n                    // Fetch the bottom crossing edges:\n                   ${S("e2")} =  ${U(a,"coords + positiveY * SMAA_PIXEL_SIZE")}.g;\n\n                    // Get the area for this direction:\n                    ${_("weiBA")} = ${h("SMAAArea","v2",[d("sqrt_d"),p("e1"),p("e2")])};\n                   weights.b = weiBA.x;\n                   weights.a = weiBA.y;\n\n                    // Fix corners:\n                   ${_("cornerPatternV")} = ${h("SMAADetectVerticalCornerPattern","v2",[d("weights.ba"),d("SMAA_weights_uv"),d("d")])};\n                   weights.b = cornerPatternV.x;\n                   weights.a = cornerPatternV.y;\n\n               }\n               ${s} = weights;\n\n            ${u.getMainFragmentEnd(t)}\n        `}}),"SMAA_Blending_Weights"),V,{}),FinalBlending:new r(new t((function(e,t){t.customDefines;let r=`\n            ${N({varyingName:"vUv",varyingType:"v2"})}\n\n            ${u.getMainVertexStart(t)}\n\n                ${M("vUv")} = uv.xy;\n\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(t)}\n            ${u.getMainVertexEnd(t)}\n\n        `;const a="tScene",i="tWeights",s=o.getShaderOutput("out0");return{vertexShader:r,fragmentShader:`\n            \n            ${N({varyingName:"vUv",varyingType:"v2"})}\n\n     \n            ${c({uniformName:"screenHeight",uniformType:"f"})}\n            ${c({uniformName:"screenWidth",uniformType:"f"})}\n            \n            ${c({uniformName:"tScene",uniformType:"t2",locationName:"tInput0"})}\n            ${c({uniformName:"tWeights",uniformType:"t2",locationName:"tInput1"})}\n\n            \n            ${D("positiveY")} = ${_()}(0.0, 1.0);\n            ${D("positiveX")} = ${_()}(1.0, 0.0);\n            ${D("negativeY")} = ${_()}(0.0, -1.0);\n            ${D("negativeX")} = ${_()}(-1.0, 0.0);\n\n            ${u.getMainFragmentStart(t)}\n                ${_("SMAA_PIXEL_SIZE")} = ${_()}(1.0 / ${$("screenWidth")}, 1.0 / ${$("screenHeight")});\n                // varying storage\n                ${_("SMAA_blend_uv")} = ${b("vUv")};\n\n                // Fetch the blending weights for current pixel:\n                ${P("topLeft")}  = ${U(i,"SMAA_blend_uv")};\n                ${S("bottom")}  = ${U(i,"SMAA_blend_uv.xy + SMAA_PIXEL_SIZE.xy * negativeY")}.g;\n                ${S("right")}  = ${U(i,"SMAA_blend_uv.xy + SMAA_PIXEL_SIZE.xy * positiveX")}.a;\n                ${P("a")} = ${P()}(topLeft.r, bottom, topLeft.b, right);\n    \n                // Up to 4 lines can be crossing a pixel (one in each edge). So, we perform\n                // a weighted average, where the weight of each line is 'a' cubed, which\n                // favors blending and works well in practice.\n                ${P("w")} = a * a * a;\n    \n                // There is some blending weight with a value greater than 0.0?\n                ${S("sum")} = dot(w, ${P()}(1.0));\n                ${P("CurrentColor")} = ${U(a,"SMAA_blend_uv")};\n                if (sum > 0.0) {\n                    ${P("color")}  = ${P()}(0.0);\n    \n                    // Add the contributions of the possible 4 lines that can cross this pixel:\n                    ${P("ColorLeft")} = ${U(a,"SMAA_blend_uv + SMAA_PIXEL_SIZE.xy * negativeX")};\n                    ${P("ColorTop")} = ${U(a,"SMAA_blend_uv + SMAA_PIXEL_SIZE.xy * positiveY")};\n                    ${P("ColorRight")} = ${U(a,"SMAA_blend_uv + SMAA_PIXEL_SIZE.xy * positiveX")};\n                    ${P("ColorBottom")} = ${U(a,"SMAA_blend_uv + SMAA_PIXEL_SIZE.xy * negativeY")};\n    \n                    color += mix(CurrentColor, ColorTop, a.r) * w.r;\n                    color += mix(CurrentColor, ColorBottom, a.g) * w.g;\n                    color += mix(CurrentColor, ColorLeft, a.b) * w.b;\n                    color += mix(CurrentColor, ColorRight, a.a) * w.a;\n    \n                    // Normalize the resulting color and we are finished!\n                    ${s} = color / sum;\n                } else {\n                    ${s} = CurrentColor;\n                }\n            ${u.getMainFragmentEnd(t)}\n        `}}),"SMAA_Blending"),z,{})}})),define("DS/ShaderBuilders/PostPro/VolumeRenderingShaderBuilders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PostPro/PostProUniformHandler","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/PostPro/PostProContext","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a,o,i,s){"use strict";const l=i.ParameterUtils,u=i.FunctionHandler,m=i.BridgeFunctions,c=n=>a.addUniform(n),$=n=>{var e={uniformName:n};return a.getUniform(e)},p=n=>l.parameterF(n),d=n=>l.parameterV2(n),f=n=>l.parameterV3(n),h=n=>l.parameterV4(n),v=(n,e,t)=>u.declareFunction(n,e,t),g=(n,e,t)=>u.callFunction(n,e,t),x=(n=null,e=0)=>{var t={name:n,size:e};return s.int(t)},S=(n=null,e=0)=>{var t={name:n,size:e};return s.float(t)},y=(n=null,e=0)=>{var t={name:n,size:e,addressSpace:"private"};return s.float(t)},_=(n=null,e=0)=>{var t={name:n,size:e,constant:!0};return s.float(t)},T=(n=null,e=0)=>{var t={name:n,size:e};return s.vec2(t)},D=(n=null,e=0)=>{var t={name:n,size:e};return s.vec3(t)},C=(n=null,e=0)=>{var t={name:n,size:e,addressSpace:"private"};return s.vec3(t)},P=(n=null,e=0)=>{var t={name:n,size:e};return s.vec4(t)},N=n=>o.addVarying(n),b=n=>o.getVarying(n,o.ShaderStages.in),M=n=>o.getVarying(n,o.ShaderStages.out),U=(n,e)=>{return m.sample2DTexture((t={uniformName:n},a.getTextureUniform(t)),e);var t},w=(n,e)=>m.modulo(n,e);class V extends e{constructor(){super(1)}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i)}fillUBO(n,e,t){super.fillUBO(n,e,t)}clone(){return new V}}class z extends e{constructor(){super(1),this.nbCol=0,this.map0=null,this.mapDim=new n.Vector3,this.minDisplayValue=0,this.maxDisplayValue=1,this.rangeDisplayValue=1,this.minTileValue=0,this.maxTileValue=1,this.rangeTileValue=1,this.isoValue=.1,this.uTMK=128,this.attenuationCoeff=.01,this.attenuationScale=1,this.colorMap=null,this.transferFctMap=null,this.gridSize=new n.Vector3,this.realProjectionMatrixInverse=new n.Matrix4,this.realModelViewMatrix=new n.Matrix4,this.realModelViewMatrixInverse=new n.Matrix4,this.clipPlaneEquation=new n.Vector4,this.debugChunkBox=new n.Vector4,this.renderIteration=0}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform1f(r.nbCol,this.nbCol),e.loadTexture(t,r.map0,this.map0),t.uniform3f(r.mapDim,this.mapDim.x,this.mapDim.y,this.mapDim.z),t.uniform1f(r.minDisplayValue,this.minDisplayValue),t.uniform1f(r.maxDisplayValue,this.maxDisplayValue),t.uniform1f(r.rangeDisplayValue,this.rangeDisplayValue),t.uniform1f(r.minTileValue,this.minTileValue),t.uniform1f(r.maxTileValue,this.maxTileValue),t.uniform1f(r.rangeTileValue,this.rangeTileValue),t.uniform1f(r.isoValue,this.isoValue),t.uniform1f(r.uTMK,this.uTMK),t.uniform1f(r.attenuationCoeff,this.attenuationCoeff),t.uniform1f(r.attenuationScale,this.attenuationScale),e.loadTexture(t,r.colorMap,this.colorMap),e.loadTexture(t,r.transferFctMap,this.transferFctMap),t.uniform3f(r.gridSize,this.gridSize.x,this.gridSize.y,this.gridSize.z),t.uniformMatrix4fv(r.realProjectionMatrixInverse,!1,e.float32Matrix4x4Temp.setDoubles(this.realProjectionMatrixInverse.elements)),t.uniformMatrix4fv(r.realModelViewMatrix,!1,e.float32Matrix4x4Temp.setDoubles(this.realModelViewMatrix.elements)),t.uniformMatrix4fv(r.realModelViewMatrixInverse,!1,e.float32Matrix4x4Temp.setDoubles(this.realModelViewMatrixInverse.elements)),t.uniform4f(r.clipPlaneEquation,this.clipPlaneEquation.x,this.clipPlaneEquation.y,this.clipPlaneEquation.z,this.clipPlaneEquation.w),t.uniform4f(r.debugChunkBox,this.debugChunkBox.x,this.debugChunkBox.y,this.debugChunkBox.z,this.debugChunkBox.w),t.uniform1f(r.renderIteration,this.renderIteration)}fillUBO(n,e,t){super.fillUBO(n,e,t);const r=n.layout;n.setV3(r.mapDim,this.mapDim),n.setF(r.minDisplayValue,this.minDisplayValue),n.setF(r.maxDisplayValue,this.maxDisplayValue),n.setF(r.rangeDisplayValue,this.rangeDisplayValue),n.setF(r.minTileValue,this.minTileValue),n.setF(r.maxTileValue,this.maxTileValue),n.setF(r.rangeTileValue,this.rangeTileValue),n.setF(r.isoValue,this.isoValue),n.setF(r.uTMK,this.uTMK),n.setF(r.attenuationCoeff,this.attenuationCoeff),n.setF(r.attenuationScale,this.attenuationScale),n.setTexture(r.colorMap,this.colorMap),n.setTexture(r.transferFctMap,this.transferFctMap),n.setV3(r.gridSize,this.gridSize),n.setM4(r.realProjectionMatrixInverse,this.realProjectionMatrixInverse),n.setM4(r.realModelViewMatrix,this.realModelViewMatrix),n.setM4(r.realModelViewMatrixInverse,this.realModelViewMatrixInverse),r.clipPlaneEquation&&n.setV4(r.clipPlaneEquation,this.clipPlaneEquation),n.setV4(r.debugChunkBox,this.debugChunkBox),n.setF(r.renderIteration,this.renderIteration)}clone(){return new z}}function F(e){return`           \n            ${N({varyingName:"vUv",varyingType:"v2"})}\n\n            ${u.getMainVertexStart(e)}\n                ${M("vUv")} = uv.xy;\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(e)}\n            ${u.getMainVertexEnd(e)}\n        `}return{Transfer:new r(new t((function(n,e){var t=e.customDefines;const r=o.getShaderOutput("out0");let a=`\n            \n            ${N({varyingName:"vUv",varyingType:"v2"})}\n            ${c({uniformName:"tScene",uniformType:"t2",locationName:"tInput0"})}\n            ${c({uniformName:"tVolume",uniformType:"t2",locationName:"tInput1"})}\n\n\n            ${u.getMainFragmentStart(e)}\n                ${T("screenUV")} = ${b("vUv")};\n\n                ${D("finalColor")};\n                ${S("finalAlpha")};\n\n                ${P("mainMap")} = ${U("tScene","screenUV")};\n                ${P("volumeMap")} = ${U("tVolume","screenUV")};\n\n                // for classic volume rendering\n                ${D("volumeCol")}  = volumeMap.rgb;\n                ${S("alpha")}  = 1.0 - volumeMap.a;\n                ${P("volume")}  = ${P()}(volumeCol / (alpha + 0.0000001), alpha);\n\n                ${t.ISO_SURFACE>0?"\n                    finalAlpha = mix(mainMap.a, 1.0, volumeMap.a);\n                    finalColor = mix(mainMap.rgb * mainMap.a, volumeMap.rgb, volumeMap.a) / finalAlpha;\n                    ":"\n                    finalAlpha = mix(mainMap.a, 1.0, volume.a);\n                    finalColor = mix(mainMap.rgb * mainMap.a, volume.rgb, volume.a) / finalAlpha;\n                    "}\n\n                ${r} = ${P()}(finalColor, finalAlpha);\n            ${u.getMainFragmentEnd(e)}\n        `;return{vertexShader:F(e),fragmentShader:a}}),"VolRTransfer"),V,{ISO_SURFACE:!1}),RenderChunk:new r(new t((function(n,e){var t=e.customDefines;const r=!!t.USE_CLIP_PLANE,a=t.CHUNK_SIZE,i=t.MAP_INVSIZE,s=t.MAX_STEPS,l=n=>g("sampleVolTex","f",[f(n)]),M=o.getShaderOutput("out0");let V=`\n            \n            ${N({varyingName:"vUv",varyingType:"v2"})}\n\n            ${c({uniformName:"tInput",uniformType:"t2",locationName:"tInput0"})}\n            ${c({uniformName:"tNormalDepth",uniformType:"t2",locationName:"tInput1"})}\n            ${c({uniformName:"realProjectionMatrixInverse",uniformType:"m4"})}\n            ${c({uniformName:"realModelViewMatrix",uniformType:"m4"})}\n            ${c({uniformName:"realModelViewMatrixInverse",uniformType:"m4"})}\n\n            ${r?c({uniformName:"clipPlaneEquation",uniformType:"v4"}):""}\n         \n            ${c({uniformName:"gridSize",uniformType:"v3"})}\n            ${c({uniformName:"uTMK",uniformType:"f"})}\n            ${c({uniformName:"attenuationCoeff",uniformType:"f"})}\n            ${c({uniformName:"attenuationScale",uniformType:"f"})}\n            ${c({uniformName:"colorMap",uniformType:"t2"})}\n            ${c({uniformName:"transferFctMap",uniformType:"t2"})}\n            ${c({uniformName:"nbCol",uniformType:"f"})}\n            ${c({uniformName:"mapDim",uniformType:"v3"})}\n            ${c({uniformName:"map0",uniformType:"t2"})}\n            ${c({uniformName:"minDisplayValue",uniformType:"f"})}\n            ${c({uniformName:"maxDisplayValue",uniformType:"f"})}\n            ${c({uniformName:"rangeDisplayValue",uniformType:"f"})}\n            ${c({uniformName:"minTileValue",uniformType:"f"})}\n            ${c({uniformName:"maxTileValue",uniformType:"f"})}\n            ${c({uniformName:"rangeTileValue",uniformType:"f"})}\n            ${c({uniformName:"isoValue",uniformType:"f"})}\n            ${c({uniformName:"debugChunkBox",uniformType:"v4"})}\n            ${c({uniformName:"renderIteration",uniformType:"f"})}\n        \n            ${_("TM_MIN")} = 0.05;\n            ${_("EPS")} = 0.0001;\n            ${_("PI")} = 3.14159265;\n            ${_("HALFPI")} = 1.57079633;\n            ${_("ROOTTHREE")} = 1.73205081;\n\n            ${y("stepSize")};\n            ${y("stepSizeModel")};\n            ${_("randomStep")} = 1.0 / 64.0;\n            ${y("depthVS")};\n            ${C("weight")} = ${D()}(1.0, 0.32, 0.08);\n            ${C("lightColor")} = ${D()}(1.0, 1.0, 1.0);\n            ${C("lightPos")} = ${D()}(100.0, 100.0, 100.0);\n            ${_("shininess")} = 40.0;\n\n            ${v("fetchDepthVS","f",[d("uv")])} {\n\n                ${P("normalDepth")}  = ${U("tNormalDepth","uv")};\n\n                // [0.0, 1.0]\n                ${e.renderToFloatTexture?`\n                    ${S("depth")} = normalDepth.w; \n                    `:`\n                    ${S("depth")}  = ${g("unpackForFloat16","f",[d("normalDepth.zw")])};\n                    `}\n\n                if (depth == 0.0) { depth = 1.0; };\n                depth = ${m.getDepthWithConvention("depth")};\n                ${P("vertexPositionProjected")}  = ${P()}(uv * 2.0 - 1.0, depth, 1.0);\n                ${P("vertexPositionVS")}  = ${$("realProjectionMatrixInverse")} * vertexPositionProjected;\n                return vertexPositionVS.z / vertexPositionVS.w;\n            }\n\n            ${v("sampleVolTex","f",[f("pos")])} {\n\n              ${S("rowID")} = floor(pos.z / ${$("nbCol")});\n              ${S("rowID2")}  = rowID;\n              ${S("colID")}  = ${w("floor(pos.z)",$("nbCol"))};\n              ${S("colID2")}  = ${w("ceil(pos.z)",$("nbCol"))};\n              if (colID2 == 0.0) { rowID2 = rowID2 + 1.0; }\n\n              ${S("x1")}  = colID  * ${a} + pos.x + 0.5;\n              ${S("x2")}  = colID2 * ${a} + pos.x + 0.5;\n              ${S("y1")}  = rowID  * ${a} + pos.y + 0.5;\n              ${S("y2")}  = rowID2 * ${a} + pos.y + 0.5;\n\n              ${T("mapUV")}   = ${T()}(x1 * ${i}, 1.0 - y1 * ${i});\n              ${T("mapUV2")}  = ${T()}(x2 * ${i}, 1.0 - y2 * ${i});\n\n              ${S("alpha1")}  = ${U("map0","mapUV")}.r;\n              ${S("alpha2")}  = ${U("map0","mapUV2")}.r;\n\n              return mix(alpha1, alpha2, fract(pos.z));\n            }\n            ${t.ISO_SURFACE>0?`\n                ${v("add_lighting","v4",[p("value"),f("loc"),f("step"),f("rd")])} {\n\n                    ${D("V")}  = normalize(rd);\n    \n                    // Calculate normal vector from gradient\n                    ${D("N")} ;\n                    ${S("val1")} , val2;\n                    val1 = ${l(`loc + ${D()}(-step.x, 0.0, 0.0)`)};\n                    val2 = ${l(`loc + ${D()}(+step.x, 0.0, 0.0)`)};\n                    N.x = val1 - val2;\n                    value = max(max(val1, val2), value);\n                    val1 = ${l(`loc + ${D()}(0.0, -step.y, 0.0)`)};\n                    val2 = ${l(`loc + ${D()}(0.0, +step.y, 0.0)`)};\n                    N.y = val1 - val2;\n                    value = max(max(val1, val2), value);\n                    val1 = ${l(`loc + ${D()}(0.0, 0.0, -step.z)`)};\n                    val2 = ${l(`loc + ${D()}(0.0, 0.0, +step.z)`)};\n                    N.z = val1 - val2;\n                    value = max(max(val1, val2), value);\n    \n                    ${S("gm")}  = length(N); // gradient magnitude\n                    N /= gm;\n    \n                    // Flip normal so it points towards viewer\n                    ${S("Nselect")}  = ${S()}(dot(N, rd) > 0.0);\n                    // ==\tNselect * N - (1.0-Nselect)*N;\n                    N = (2.0 * Nselect - 1.0) * N; \n    \n                    // Init colors\n                    ${D("ambient_color")}  = ${D()}(0.0);\n                    ${D("diffuse_color")}  = ${D()}(0.0);\n                    ${D("specular_color")}  = ${D()}(0.0);\n    \n                    // Get light direction (make sure to prevent zero devision)\n                    ${D("L")}  = normalize(rd);\n                    ${S("lightEnabled")}  = ${S()}(length(L) > 0.0);\n                    L = normalize(L + (1.0 - lightEnabled));\n    \n                    // Calculate lighting properties\n                    ${S("lambertTerm")}  = clamp(dot(N, L), 0.0, 1.0);\n                    ${D("H")}  = normalize(L+rd); // Halfway vector\n                    ${S("specularTerm")}  = pow(max(dot(H, N), 0.0), shininess);\n    \n                    // Calculate mask\n                    ${S("mask1")}  = lightEnabled;\n    \n                    // Calculate colors\n                    ambient_color += mask1 * ambient_color;\n                    diffuse_color += mask1 * lambertTerm;\n                    specular_color += mask1 * specularTerm * specular_color;\n    \n                    // Calculate final color by componing different components\n                    ${D("color")}  = ${U("colorMap",`vec2(${$("rangeTileValue")}, 0.5)`)}.rgb;\n                    return ${P()}(color * (ambient_color + diffuse_color) + specular_color, 1.0);\n                }\n    \n                ${v("raymarchIso","v4",[f("ro"),f("rd"),h("prevData")])} {\n    \n                  ${D("ratio")}  = (${$("mapDim")} - ${D()}(1.0)) / ${$("gridSize")};\n                  ${t.RANDOM_STEP?`\n                    ${S("offset")}  = 1.0 + 0.8 * ${$("renderIteration")} * randomStep;\n                    `:`\n                    ${S("offset")}  = 1.0;\n                    `}\n                  ${D("stepModel")}  = offset * rd * stepSizeModel;\n                  ${D("stepGrid")}  = stepModel * ratio;\n                  ${D("posModel")}  = ro;\n                  ${D("posGrid")}  = (ro + 0.5 * ${$("gridSize")}) * ratio;\n                  ${D("dStep")}  = 1.5 / ${$("mapDim")};\n    \n                  ${D("col")}  = prevData.rgb;\n                  ${S("tm")}  = prevData.a;\n    \n                  if (tm > 0.5) { return prevData; }\n    \n                  for (${x("i")}=0; i<${s}; i++) {\n    \n                    ${S("density")}  = ${l("posGrid.xyz")};\n                    ${S("remappedDensity")}  = (density - ${$("minDisplayValue")}) / ${$("rangeDisplayValue")};\n                    remappedDensity = min(max(remappedDensity, 0.0), 1.0);\n    \n                    if (remappedDensity > ${$("rangeTileValue")}) {\n    \n                        ${D("interPosGrid")}  = posGrid - 1.0 * stepGrid;\n                        ${D("interPosModel")}  = posModel - 1.0 * stepModel;\n                        ${D("smallStepGrid")}  = 0.25 * stepGrid;\n                        ${D("smallStepModel")}  = 0.25 * stepModel;\n    \n                        for (${x("i")}=0; i<4; i++) {\n    \n                            density = ${l("interPosGrid.xyz")};\n                            remappedDensity = (density - ${$("minDisplayValue")}) / ${$("rangeDisplayValue")};\n                            remappedDensity = min(max(remappedDensity, 0.0), 1.0);\n    \n                            if (remappedDensity > ${$("rangeTileValue")}) {\n    \n                                return ${g("add_lighting","v4",[p("remappedDensity"),f("interPosGrid"),f("dStep"),f("rd")])};\n                            }\n    \n                            interPosGrid += smallStepGrid;\n                            interPosModel += smallStepModel;\n                        }\n                    }\n    \n                    posGrid += stepGrid;\n                    posModel += stepModel;\n    \n                    if (tm < 0.0 || posGrid.x > ${$("mapDim")}.x - 1.0 || posGrid.x < 0.0 || posGrid.y > ${$("mapDim")}.y - 1.0 || posGrid.y < 0.0 || posGrid.z > ${$("mapDim")}.z - 1.0 || posGrid.z < 0.0)\n                      break;\n    \n                    ${P("posVS")} = ${$("realModelViewMatrix")}  *  ${P()}(posModel, 1.0);\n                    if (posVS.z < depthVS) { break; }\n                  }\n    \n                  return ${P()}(0.0);\n                }\n                `:`\n                \n\n            ${v("raymarch","v4",[f("ro"),f("rd"),h("prevData")])} {\n\n                ${D("ratio")}  = (${$("mapDim")} - ${D()}(1.0)) / ${$("gridSize")};\n                ${t.RANDOM_STEP?`\n                  ${S("offset")}  = 1.0 + 0.8 * ${$("renderIteration")} * randomStep;\n                  `:`\n                  ${S("offset")}  = 1.0;\n                  `}\n  \n                ${D("posModel")}  = ro;\n                ${D("posGrid")}  = (ro + 0.5 * ${$("gridSize")}) * ratio;\n  \n                ${D("stepModel")}  = offset * rd * stepSizeModel;\n                ${D("stepGrid")}  = stepModel * ratio;\n  \n                ${D("col")}  = prevData.rgb;\n                ${S("tm")}  = prevData.a;\n  \n                for (${x("i")}=0; i<${s}; i++) {\n  \n                  ${P("posVS")} = ${$("realModelViewMatrix")} * ${P()}(posModel, 1.0);\n                  if (posVS.z < depthVS) { break; }\n  \n                  // clipping plane\n  \n                  ${r?`\n                      ${S("clipDist")}  = dot(posVS.xyz, ${$("clipPlaneEquation")}.xyz) + ${$("clipPlaneEquation")}.w;\n                      if (clipDist >= 0.0) {\n                      `:""}\n  \n                      ${S("normalizedDensity")}  = ${l("posGrid.xyz")};\n                      ${S("density")}  = ${$("minTileValue")} + normalizedDensity * ${$("rangeTileValue")};\n                      ${S("remappedDensity")}  = (density - ${$("minDisplayValue")}) / ${$("rangeDisplayValue")};\n                      // clamp [0 + 0.5/180, 1 - 0.5/180]\n                      remappedDensity = min(max(remappedDensity, 0.0028), 0.997); \n                      ${T("mapUV")} = ${T()}(remappedDensity, 0.5);\n                      ${D("color")}  = ${U("colorMap","mapUV")}.rgb;\n                      ${S("opacity")}  = ${U("transferFctMap","mapUV")}.r;\n                      opacity *= step(${$("minDisplayValue")}, density) * step(-${$("maxDisplayValue")}, -density);\n  \n                      ${S("dtm")}  = exp( -${$("uTMK")} * stepSizeModel * ${$("attenuationCoeff")} * ${$("attenuationScale")} * opacity );\n                      tm *= dtm;\n                      col += (1.0 - dtm) * color * tm;\n  \n                  ${r?"\n                      }\n                      ":""}\n  \n                  posGrid += stepGrid;\n                  posModel += stepModel;\n  \n                  if (tm < 0.0 || posGrid.x > ${$("mapDim")}.x - 1.0 || posGrid.x < 0.0 || posGrid.y > ${$("mapDim")}.y - 1.0 || posGrid.y < 0.0 || posGrid.z > ${$("mapDim")}.z - 1.0 || posGrid.z < 0.0) {\n                      break;\n                  }\n                }\n                return ${P()}(col, tm);\n              }\n                `}\n           \n\n            ${u.getMainFragmentStart(e)}\n                ${T("screenUV")} = ${b("vUv")};\n\n                ${P("outColor")} = ${U("tInput","screenUV")};\n\n                ${P("clipVec")} = ${P()}(screenUV * 2.0 - 1.0, 0.0, 1.0);\n                ${P("posVS")} = ${$("realProjectionMatrixInverse")} * clipVec;\n                posVS.x /= posVS.w;\n                posVS.y /= posVS.w;\n                posVS.z /= posVS.w;\n                posVS.w = 1.0;\n                ${D("rd")}  = (${$("realModelViewMatrixInverse")}  * posVS).xyz;\n                ${D("ro")}  = (${$("realModelViewMatrixInverse")} * ${P()}(0.0, 0.0, 0.0, 1.0)).xyz;\n                rd = normalize(rd - ro);\n\n                ${D("rad")}  = 0.5 * ${$("gridSize")};\n\n                ${D("m")}  = 1.0 / rd;\n                ${D("n")}  = m * ro;\n                ${D("k")}  = abs(m) * rad;\n                ${D("t1")}  = -n - k;\n                ${D("t2")}  = -n + k;\n\n                ${S("tN")}  = max(max(t1.x, t1.y), t1.z);\n                ${S("tF")}  = min(min(t2.x, t2.y), t2.z);\n\n                if(tN <= tF && tF >= 0.0) { // intersection with the grid\n\n                    ${D("intersect")}  = ro + tN * rd;\n                    ${P("intersectVS")} = ${$("realModelViewMatrix")}  * ${P()}(intersect, 1.0);\n\n                    depthVS = fetchDepthVS(screenUV);\n\n                    if (intersectVS.z >= depthVS) { // no occlusion with the scene\n\n                        stepSize = max(${$("mapDim")}.x, max(${$("mapDim")}.y, ${$("mapDim")}.z)) * ROOTTHREE / ${S()}(${s});\n                        stepSizeModel = max(${$("gridSize")}.x, max(${$("gridSize")}.y, ${$("gridSize")}.z)) * ROOTTHREE / ${S()}(${s});\n\n                        ${t.ISO_SURFACE>0?`     \n                            outColor = ${g("raymarchIso","v4",[f("intersect"),f("rd"),h("outColor")])} + ${$("debugChunkBox")};\n                            `:`\n                            outColor = ${g("raymarch","v4",[f("intersect"),f("rd"),h("outColor")])} + ${$("debugChunkBox")};            \n                            `}\n                    }\n                }\n\n                ${M} = outColor;           \n            ${u.getMainFragmentEnd(e)}\n        `;return{vertexShader:F(e),fragmentShader:V}}),"VolRRenderChunk"),z,{MAX_STEPS:"256",CHUNK_SIZE:"64.0",MAP_INVSIZE:"0.001953125",USE_CLIP_PLANE:!1,RANDOM_STEP:!0,ISO_SURFACE:0})}})),define("DS/ShaderBuilders/PostPro/MergeShaderBuilders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PostPro/PostProUniformHandler","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/PostPro/PostProContext","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a,o,i,s){"use strict";const l="",u=i.ParameterUtils,m=i.FunctionHandler,c=i.BridgeFunctions,$=n=>a.addUniform(n),p=n=>{var e={uniformName:n};return a.getUniform(e)},d=n=>{var e={uniformName:n};return a.getTextureUniform(e)},f=n=>u.parameterF(n),h=n=>u.parameterV2(n),v=n=>u.parameterV3(n),g=n=>u.parameterT2(n),x=(n,e,t)=>m.declareFunction(n,e,t),S=(n,e,t)=>m.callFunction(n,e,t),y=(n=null,e=0)=>{var t={name:n,size:e};return s.float(t)},_=(n=null,e=0)=>{var t={name:n,size:e};return s.vec2(t)},T=(n=null,e=0)=>{var t={name:n,size:e};return s.vec3(t)},D=(n=null,e=0)=>{var t={name:n,size:e};return s.vec4(t)},C=n=>o.addVarying(n),P=n=>o.getVarying(n,o.ShaderStages.in),N=n=>o.getVarying(n,o.ShaderStages.out),b=(n,e)=>c.sample2DTexture(n,e);class M extends e{constructor(e=0){super(e,!0);for(var t=0;t<this.inputs.length;t++)this["offset"+t]=new n.Vector2,this["scale"+t]=new n.Vector2}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i);for(var s=0;s<this.inputs.length;s++)t.uniform2f(r["offset"+s],this["offset"+s].x,this["offset"+s].y),t.uniform2f(r["scale"+s],this["scale"+s].x,this["scale"+s].y)}fillUBO(n,e,t){super.fillUBO(n,e,t);const r=n.layout;for(var a=0;a<this.inputs.length;a++)n.setV2(r["offset"+a],this["offset"+a]),n.setV2(r["scale"+a],this["scale"+a])}clone(){return new M}}function U(e){return`\n        ${C({varyingName:"vUv",varyingType:"v2"})}\n\n        ${m.getMainVertexStart(e)}\n            ${N("vUv")} = uv.xy;\n            ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(e)}\n        ${m.getMainVertexEnd(e)}\n\n    `}function w(n,e,t,r){return function(a,i){i.customDefines;let s="",l="",u="";for(let e=0;e<n.length;e++){const t=n[e];s=`\n                    ${s}\n                    ${$({uniformName:"tInput"+e,uniformType:"t2"})}\n                    ${$({uniformName:"offset"+e,uniformType:"v2"})}\n                    ${$({uniformName:"scale"+e,uniformType:"v2"})}\n                `;const r="inputUV"+e;l=`\n                    ${l}\n                    ${_(r)} = (screenUV - ${p("offset"+e)}) / ${p("scale"+e)};\n                `,u=`\n                    ${u} if (${r}.x > 0.0 && ${r}.y > 0.0 && ${r}.x < 1.0 && ${r}.y < 1.0) {\n                        color = ${t(d("tInput"+e),r,i)};\n                    } else\n                `,e===n.length-1&&(u=`\n                        ${u}{\n                            color = ${D()}(0.0);\n                        }\n                    `)}const c=o.getShaderOutput("out0");let f=`\n                \n                ${C({varyingName:"vUv",varyingType:"v2"})}\n                \n                ${s}\n\n                ${t(a,i)}\n    \n                ${m.getMainFragmentStart(i)}\n                    ${_("screenUV")} = ${P("vUv")};\n                    ${D("color")};\n                    ${r(a,i)}\n\n                    ${l}\n                    ${u}\n\n                    ${c} = ${e("color",i)};\n                ${m.getMainFragmentEnd(i)}\n            `;return{vertexShader:U(i),fragmentShader:f}}}return{ShadowMerge4:new r(new t(function(){function n(n,e){const t=b(n,e),r=`${T()}(${t}.w)`;return`${D()}(${r}, 0.7)`}return w([n,n,n,n],(n=>n),(()=>l),(()=>l))}(),"ShadowMerge4"),M,{},3),DisplayMerge4:new r(new t(function(){function n(n,e){const t=b(n,e),r=`${T()}(${t}.xyz)`;return`${D()}(${r}, 1.0)`}return w([n,n,function(n,e){const t=b(n,e),r=`${T()}(${t}.w)`;return`${D()}(${r}, 1.0)`},n],(n=>n),(()=>l),(()=>l))}(),"DisplayMerge4"),M,{},3),IrradianceMerge1:new r(new t(w([function(n,e){const t=b(n,e),r=`${T()}(${t}.xyz)`;return`${D()}(${a=r,`pow(${a}, ${T()}(1.0 / 2.2))`}, 1.0)`;var a}],(n=>n),(()=>l),(()=>l)),"IrradianceMerge1"),M,{},0),RoughnessMipsMerge:new r(new t(function(){function e(n,e){const t=`${_()}(1.0 - ${e}.x, ${e}.y)`,r=b(n,t);return`${D()}(${r}.xyz, 1.0)`}return w([e,e,e,e,e,e,e],(function(n,e){switch(e.customDefines.OUTPUT_ENCODING){case"RGB":return`${D()}(${n}.xyz, 1.0)`;case"LogLUV":return`\n                        ${S("RGBtoLogLUV","v4",[v(`${n}.xyz`)])}\n                    `;case"RGBM":return`\n                        ${S("RGBtoRGBM","v4",[v(`${n}.xyz`)])}\n                    `;default:return`\n                        ${S("RGBtoRGBE","v4",[v(`${n}.xyz`)])}\n                    `}}),(function(e,t){return`        \n                ${n._DefaultShaderChunk.ibl_sample_methods(t)}\n            `}),(()=>l))}(),"RoughnessMipsMerge"),M,{OUTPUT_ENCODING:"RGBE"},6),RoughnessCustomMipsMerge:new r(new t(function(){function e(n){return function(e,t){return`${S("getColor","v4",[f(`${n}`),h(t)])}`}}let t=[()=>`${D()}(0.0)`,e(.04911045206),e(.08973030532),e(.1639473341),e(.29955017162),e(.54731176821),e(.99999999999),function(n,e,t){var r=t.customDefines;const a=`${_()}(1.0 - ${e}.x, ${e}.y)`,o=p("size7");let i;"RGBE"===r.INPUT_ENCODING?i=(n,e,t)=>S("texture2DBilinearRGBE","v4",[g(n),h(e),h(t),h(`1.0 / ${t}`)]):"LogLUV"===r.INPUT_ENCODING?i=(n,e,t)=>S("texture2DBilinearLogLUV","v4",[g(n),h(e),h(t),h(`1.0 / ${t}`)]):"RGB"===r.INPUT_ENCODING?i=(n,e,t)=>b(n,e):"RGBM"===r.INPUT_ENCODING&&(i=(n,e,t)=>S("texture2DBilinearRGBM","v4",[g(n),h(e),h(t),h(`1.0 / ${t}`)]));const s=i(n,a,o);return`${D()}(${s}.xyz, 1.0)`}];return w(t,(function(n,e){switch(e.customDefines.OUTPUT_ENCODING){case"RGB":return`${D()}(${n}.xyz, 1.0)`;case"LogLUV":return`\n                        ${S("RGBtoLogLUV","v4",[v(`${n}.xyz`)])}\n                    `;case"RGBM":return`\n                        ${S("RGBtoRGBM","v4",[v(`${n}.xyz`)])}\n                    `;default:return`\n                        ${S("RGBtoRGBE","v4",[v(`${n}.xyz`)])}\n                    `}}),(function(e,r){var a=r.customDefines;let o,i,s="";for(let n=0;n<t.length;n++)s=`\n                    ${s}\n                    ${$({uniformName:"size"+n,uniformType:"v2"})}\n                `;"RGBE"===a.INPUT_ENCODING?o=(n,e,t)=>S("texture2DBilinearRGBE","v4",[g(n),h(e),h(t),h(`1.0 / ${t}`)]):"LogLUV"===a.INPUT_ENCODING?o=(n,e,t)=>S("texture2DBilinearLogLUV","v4",[g(n),h(e),h(t),h(`1.0 / ${t}`)]):"RGB"===a.INPUT_ENCODING?o=(n,e,t)=>b(n,e):"RGBM"===a.INPUT_ENCODING&&(o=(n,e,t)=>S("texture2DBilinearRGBM","v4",[g(n),h(e),h(t),h(`1.0 / ${t}`)])),"RGBE"===a.ZERO_ENCODING?i=(n,e,t)=>S("texture2DBilinearRGBE","v4",[g(n),h(e),h(t),h(`1.0 / ${t}`)]):"LogLUV"===a.ZERO_ENCODING?i=(n,e,t)=>S("texture2DBilinearLogLUV","v4",[g(n),h(e),h(t),h(`1.0 / ${t}`)]):"RGB"===a.ZERO_ENCODING?i=(n,e,t)=>b(n,e):"RGBM"===a.ZERO_ENCODING&&(i=(n,e,t)=>S("texture2DBilinearRGBM","v4",[g(n),h(e),h(t),h(`1.0 / ${t}`)]));const u=a.MAPPING,m=0===u,c=1===u,v=2===u,T=3===u,C=`${y()}(${a.MIP_OFFSET})`;return`\n\n                ${s}\n\n                ${n._DefaultShaderChunk.ibl_sample_methods(r)}\n\n                ${x("roughnessToMips","f",[f("roughness")])}{\n                    ${y("mip")} ;\n                    ${m?`mip = roughness * (6.0 - ${C});`:l}           \n                    ${c?`\n                        if (roughness == 0) {\n                            mip = 0.0;\n                        } else {\n                            mip =  (6.0 - ${C} ) + 1.15 * log2(roughness);\n                        }\n                        `:l}\n                    \n                    ${v?`mip = (1.0 - roughness) * (6.0 - ${C});`:l}\n                    ${T?`\n                        if (roughness == 1) {\n                            mip = 6.0 - ${C};\n                        } else {\n                            mip = (6.0 - ${C} ) + 1.15 * log2(1.0 - roughness);\n                        }`:l}\n                    return mip + ${C};\n                } \n\n                ${x("getColor","v4",[f("roughness"),h("iUv")])} {\n                    ${y("mipValue")}  = ${S("roughnessToMips","f",[f("roughness")])};\n                    ${y("leftMip")}  = floor(mipValue);\n                    ${y("factor")}  = fract(mipValue);\n                    ${_("uv")} = iUv;\n                    uv.x = 1.0 - uv.x;\n                    ${D("color")} ;\n                    if (leftMip == 0.0) {             \n                        color = mix(${i(d("tInput0"),"uv",p("size0"))}, ${o(d("tInput1"),"uv",p("size1"))}, factor);\n                    }\n                    if (leftMip == 1.0) {\n                        color = mix(${o(d("tInput1"),"uv",p("size1"))}, ${o(d("tInput2"),"uv",p("size2"))}, factor);\n                    }\n                    if (leftMip == 2.0) {\n                        color = mix(${o(d("tInput2"),"uv",p("size2"))}, ${o(d("tInput3"),"uv",p("size3"))}, factor);\n                    }\n                    if (leftMip == 3.0) {\n                        color = mix(${o(d("tInput3"),"uv",p("size3"))}, ${o(d("tInput4"),"uv",p("size4"))}, factor);\n                    }\n                    if (leftMip == 4.0) {\n                        color = mix(${o(d("tInput4"),"uv",p("size4"))}, ${o(d("tInput5"),"uv",p("size5"))}, factor);\n                    }\n                    if (leftMip == 5.0) {\n                        color = mix(${o(d("tInput5"),"uv",p("size5"))}, ${o(d("tInput6"),"uv",p("size6"))}, factor);\n                    }            \n                    if (leftMip == 6.0) {\n                        color = ${o(d("tInput6"),"uv",p("size6"))};\n                    }\n                    return ${D()}(color.xyz, 1.0);\n                }\n            `}),(function(n,e){return"screenUV.x = 1.0 - screenUV.x;"}))}(),"RoughnessCustomMipsMerge"),class extends M{constructor(e=0){super(e);for(var t=0;t<this.inputs.length;t++)this["size"+t]=new n.Vector2}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i);for(var s=0;s<this.inputs.length;s++)t.uniform2f(r["size"+s],this["size"+s].x,this["size"+s].y)}fillUBO(n,e,t){super.fillUBO(n,e,t);const r=n.layout;for(var a=0;a<this.inputs.length;a++)n.setV2(r["size"+a],this["size"+a])}clone(){return new M}},{MAPPING:0,OUTPUT_ENCODING:"RGBE",MIP_OFFSET:0,INPUT_ENCODING:"RGBE",ZERO_ENCODING:"RGBE"},7)}})),define("DS/ShaderBuilders/PostPro/StereoShaderBuilders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PostPro/PostProUniformHandler","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/PostPro/PostProContext","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a,o,i,s){"use strict";i.ParameterUtils;const l=i.FunctionHandler,u=i.BridgeFunctions,m=n=>a.addUniform(n),c=n=>{var e={uniformName:n};return a.getUniform(e)},$=n=>{var e={uniformName:n};return a.getTextureUniform(e)},p=(n=null,e=0)=>{var t={name:n,size:e};return s.vec2(t)},d=(n=null,e=0)=>{var t={name:n,size:e};return s.vec4(t)},f=n=>o.addVarying(n),h=n=>o.getVarying(n,o.ShaderStages.in),v=n=>o.getVarying(n,o.ShaderStages.out),g=(n,e)=>u.sample2DTexture($(n),e);class x extends e{constructor(){super(),this.tLeftEye=null,this.tRightEye=null}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),e.loadTexture(t,r.tLeftEye,this.tLeftEye),e.loadTexture(t,r.tRightEye,this.tRightEye)}fillUBO(n,e,t){super.fillUBO(n,e,t);const r=n.layout;n.setTexture(r.tLeftEye,this.tLeftEye),n.setTexture(r.tRightEye,this.tRightEye)}clone(){return new x}}function S(e){return`           \n            ${f({varyingName:"vUv",varyingType:"v2"})}\n\n            ${l.getMainVertexStart(e)}\n                ${v("vUv")} = uv.xy;\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(e)}\n            ${l.getMainVertexEnd(e)}\n        `}class y extends x{constructor(){super(),this.scale=new n.Vector2(1,1),this.scaleIn=new n.Vector2(1,1),this.leftLensCenter=new n.Vector2(0,0),this.hmdWarpParam=new n.Vector4(1,0,0,0),this.chromAbParam=new n.Vector4(1,0,0,0)}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i)}fillUBO(n,e,t){super.fillUBO(n,e,t)}clone(){return new y}}class _ extends e{constructor(){super(),this.tEye=null,this.eyeToSourceUVScale=new n.Vector2(.33333333,.3333333),this.eyeToSourceUVOffset=new n.Vector2(.5,.5)}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),e.loadTexture(t,r.tEye,this.tEye),t.uniform2f(r.eyeToSourceUVScale,this.eyeToSourceUVScale.x,this.eyeToSourceUVScale.y),t.uniform2f(r.eyeToSourceUVOffset,this.eyeToSourceUVOffset.x,this.eyeToSourceUVOffset.y)}fillUBO(n,e,t){super.fillUBO(n,e,t);const r=n.layout;n.setTexture(r.tEye,this.tEye),n.setV2(r.eyeToSourceUVScale,this.eyeToSourceUVScale),n.setV2(r.eyeToSourceUVOffset,this.eyeToSourceUVOffset)}clone(){return new _}}return{LeftRight:new r(new t((function(n,e){e.customDefines;const t=o.getShaderOutput("out0");let r=`\n            \n            ${f({varyingName:"vUv",varyingType:"v2"})}\n            ${m({uniformName:"tLeftEye",uniformType:"t2"})}\n            ${m({uniformName:"tRightEye",uniformType:"t2"})}\n  \n\n            ${l.getMainFragmentStart(e)}\n                ${p("screenUV")} = ${h("vUv")};\n\n                if(screenUV.x < 0.5) {\n                    ${p("uvLeft")} = ${p()}(screenUV.x*2.0, screenUV.y);\n                    ${t} = ${g("tLeftEye","uvLeft")};\n                } else {\n                    ${p("uvRight")} = ${p()}((screenUV.x-0.5)*2.0, screenUV.y);\n                    ${t} = ${g("tRightEye","uvRight")};\n                }   \n            ${l.getMainFragmentEnd(e)}\n        `;return{vertexShader:S(e),fragmentShader:r}}),"LeftRightStereo"),x,{}),Anaglyph:new r(new t((function(n,e){e.customDefines;const t=o.getShaderOutput("out0");let r=`\n            \n            ${f({varyingName:"vUv",varyingType:"v2"})}\n            ${m({uniformName:"tLeftEye",uniformType:"t2"})}\n            ${m({uniformName:"tRightEye",uniformType:"t2"})}\n  \n\n            ${l.getMainFragmentStart(e)}\n                ${p("screenUV")} = ${h("vUv")};\n\n                \n                ${d("cr")}  = ${g("tLeftEye","screenUV")};\n                ${d("cl")}  = ${g("tRightEye","screenUV")};\n                ${t} = vec4(cl.r, cr.g, cr.b, 1.0);\n            ${l.getMainFragmentEnd(e)}\n        `;return{vertexShader:S(e),fragmentShader:r}}),"AnaglyphStereo"),x,{}),OculusDK1:new r(new t((function(n,e){e.customDefines;const t=o.getShaderOutput("out0");let r=`\n            \n            ${f({varyingName:"vUv",varyingType:"v2"})}\n            ${m({uniformName:"tLeftEye",uniformType:"t2"})}\n            ${m({uniformName:"tRightEye",uniformType:"t2"})}\n            ${m({uniformName:"scale",uniformType:"v2"})}\n            ${m({uniformName:"scaleIn",uniformType:"v2"})}\n            ${m({uniformName:"leftLensCenter",uniformType:"v2"})}\n            ${m({uniformName:"hmdWarpParam",uniformType:"v4"})}\n            ${m({uniformName:"chromAbParam",uniformType:"v4"})}\n  \n\n            ${l.getMainFragmentStart(e)}\n                ${p("screenUV")} = ${h("vUv")};\n\n                \n                if(screenUV.x >= 0.5) {\n                    ${p("lensCenter")}  = ${c("leftLensCenter")};\n                    // range from [0,1] to [-1,1]\n                    ${p("uv")}  = (${p()}((screenUV.x-0.5)*2.0, screenUV.y)*2.0)-1.0;\n                    ${p("theta")}  = (uv-lensCenter)*${c("scaleIn")};\n                    ${((n=null,e=0)=>{var t={name:n,size:e};return s.float(t)})("rSq")}  = theta.x*theta.x + theta.y*theta.y;\n                    ${p("rvector")}  = theta*(${c("hmdWarpParam")}.x + ${c("hmdWarpParam")}.y*rSq + ${c("hmdWarpParam")}.z*rSq*rSq + ${c("hmdWarpParam")}.w*rSq*rSq*rSq);\n                    ${p("rBlue")}  = rvector * (${c("chromAbParam")}.z + ${c("chromAbParam")}.w * rSq);\n                    ${p("tcBlue")}  = lensCenter + ${c("scale")} * rBlue;\n                    // range from [-1,1] to [0,1]\n                    tcBlue = (tcBlue+1.0)/2.0;\n                    if (any(bvec2(clamp(tcBlue, ${p()}(0.0,0.0), ${p()}(1.0,1.0))-tcBlue))) {\n                        ${t} = ${d()}(0.0, 0.0, 0.0, 1.0);\n                        ${l.getEarlyFragmentEnd()}\n                    }\n                    ${p("tcGreen")}  = lensCenter + ${c("scale")} * rvector;\n                    // range from [-1,1] to [0,1]\n                    tcGreen = (tcGreen+1.0)/2.0;\n                    ${p("rRed")}  = rvector * (${c("chromAbParam")}.x + ${c("chromAbParam")}.y * rSq);\n                    ${p("tcRed")}  = lensCenter + ${c("scale")} * rRed;\n                    // range from [-1,1] to [0,1]\n                    tcRed = (tcRed+1.0)/2.0; \n                    ${t} = ${d()}(${g("tLeftEye","tcRed")}.r, ${g("tLeftEye","tcGreen")}.g, ${g("tLeftEye","tcBlue")}.b, 1.0);\n                } else {\n                    ${p("lensCenter")}  = -${c("leftLensCenter")};\n                    // range from [0,1] to [-1,1]\n                    ${p("uv")}  = (${p()}(screenUV.x*2.0, screenUV.y)*2.0)-1.0; \n                    ${p("theta")}  = (uv-lensCenter)*${c("scaleIn")};\n                    float rSq = theta.x*theta.x + theta.y*theta.y;\n                    ${p("rvector")}  = theta*(${c("hmdWarpParam")}.x + ${c("hmdWarpParam")}.y*rSq + ${c("hmdWarpParam")}.z*rSq*rSq + ${c("hmdWarpParam")}.w*rSq*rSq*rSq);\n                    ${p("rBlue")}  = rvector * (${c("chromAbParam")}.z + ${c("chromAbParam")}.w * rSq);\n                    ${p("tcBlue")}  = (lensCenter + ${c("scale")} * rBlue);\n                    tcBlue = (tcBlue+1.0)/2.0; // range from [-1,1] to [0,1]\n                    if (any(bvec2(clamp(tcBlue, ${p()}(0.0,0.0), ${p()}(1.0,1.0))-tcBlue))) {\n                        ${t} = ${d()}(0.0, 0.0, 0.0, 1.0);\n                        ${l.getEarlyFragmentEnd()}\n                    }\n                    ${p("tcGreen")}  = lensCenter + ${c("scale")} * rvector;\n                    tcGreen = (tcGreen+1.0)/2.0; // range from [-1,1] to [0,1]\n                    ${p("rRed")}  = rvector * (${c("chromAbParam")}.x + ${c("chromAbParam")}.y * rSq);\n                    ${p("tcRed")}  = lensCenter + ${c("scale")} * rRed;\n                    tcRed = (tcRed+1.0)/2.0; // range from [-1,1] to [0,1]\n                    ${t} = ${d()}(${g("tRightEye","tcRed")}.r, ${g("tRightEye","tcGreen")}.g, ${g("tRightEye","tcBlue")}.b, 1.0);\n\n                }\n            ${l.getMainFragmentEnd(e)}\n        `;return{vertexShader:S(e),fragmentShader:r}}),"OculusDK1Stereo"),y,{}),OculusDK2:new r(new t((function(e,t){t.customDefines;const r=o.getShaderOutput("out0"),a=$("tEye");let i=`         \n            ${f({varyingName:"uvr",varyingType:"v2"})}\n            ${f({varyingName:"uvg",varyingType:"v2"})}\n            ${f({varyingName:"uvb",varyingType:"v2"})}\n\n            ${m({uniformName:"tEye",uniformType:"t2"})}\n  \n\n            ${l.getMainFragmentStart(t)}\n                ${r} = ${d()}(${g(a,h("uvr"))}.r, ${g(a,h("uvg"))}.g, ${g(a,h("uvb"))}.b, 1.0);\n            ${l.getMainFragmentEnd(t)}\n        `;return{vertexShader:`     \n            ${f({varyingName:"uvr",varyingType:"v2"})}\n            ${f({varyingName:"uvg",varyingType:"v2"})}\n            ${f({varyingName:"uvb",varyingType:"v2"})}\n            ${m({uniformName:"eyeToSourceUVScale",uniformType:"v2"})}\n            ${m({uniformName:"eyeToSourceUVOffset",uniformType:"v2"})}\n\n            ${l.getMainVertexStart(t)}\n                ${v("uvr")} = uv.xy * ${c("eyeToSourceUVScale")} + ${c("eyeToSourceUVOffset")};\n                ${v("uvg")} = uv2.xy * ${c("eyeToSourceUVScale")} + ${c("eyeToSourceUVOffset")};\n                ${v("uvb")} = tangent.xy * ${c("eyeToSourceUVScale")} + ${c("eyeToSourceUVOffset")};\n                ${t.WebGPU?"":`\n                    ${v("uvr")}.y = 1.0 - ${v("uvr")}.y;\n                    ${v("uvg")}.y = 1.0 - ${v("uvg")}.y;\n                    ${v("uvb")}.y = 1.0 - ${v("uvb")}.y;                    \n                    `}\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(t)}\n            ${l.getMainVertexEnd(t)}\n        `,fragmentShader:i}}),"OculusDK2Stereo"),_,{})}})),define("DS/ShaderBuilders/PostPro/ImageOperationShaderBuilders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PostPro/PostProUniformHandler","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/PostPro/PostProContext","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a,o,i,s){"use strict";const l=i.ParameterUtils,u=i.FunctionHandler,m=i.BridgeFunctions,c=n=>a.addUniform(n),$=n=>{var e={uniformName:n};return a.getUniform(e)},p=n=>l.parameterV2(n),d=n=>l.parameterV3(n),f=(n,e,t)=>u.declareFunction(n,e,t),h=(n,e,t)=>u.callFunction(n,e,t),v=(n=null,e=0)=>{var t={name:n,size:e};return s.int(t)},g=(n=null,e=0)=>{var t={name:n,size:e};return s.float(t)},x=(n=null,e=0)=>{var t={name:n,size:e};return s.vec2(t)},S=(n=null,e=0)=>{var t={name:n,size:e};return s.vec3(t)},y=(n=null,e=0)=>{var t={name:n,size:e};return s.vec4(t)},_=n=>o.addVarying(n),T=n=>o.getVarying(n,o.ShaderStages.in),D=n=>o.getVarying(n,o.ShaderStages.out),C=(n,e)=>{return m.sample2DTexture((t={uniformName:n},a.getTextureUniform(t)),e);var t},P=n=>i.FunctionHandler.getMainVertexStart(n),N=n=>i.FunctionHandler.getMainVertexEnd(n),b=n=>i.FunctionHandler.getMainFragmentStart(n),M=n=>i.FunctionHandler.getMainFragmentEnd(n);class U extends e{constructor(n=0){super(n)}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i)}fillUBO(n,e,t){super.fillUBO(n,e,t)}clone(){return new U}}class w extends U{constructor(){super(),this.threshold=1,this.invSize=new n.Vector2(512,512)}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform1f(r.threshold,this.threshold),t.uniform2f(r.invSize,this.invSize.x,this.invSize.y)}fillUBO(n,e,t){super.fillUBO(n,e,t);const r=n.layout;n.setF(r.threshold,this.threshold),n.setV2(r.invSize,this.invSize)}clone(){var n=new w;return n.threshold=this.threshold,n.invSize=this.invSize,n}}class V extends U{constructor(){super(1),this.invSize=new n.Vector2(512,512)}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform2f(r.invSize,this.invSize.x,this.invSize.y)}fillUBO(n,e,t){super.fillUBO(n,e,t);const r=n.layout;n.setV2(r.invSize,this.invSize)}clone(){var n=new V;return n.invSize=this.invSize,n}}class z extends U{constructor(){super(0),this.tInputSize=new n.Vector2(512,512),this.currentSize=new n.Vector2(512,512)}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform2f(r.currentSize,this.currentSize.x,this.currentSize.y),t.uniform2f(r.tInputSize,this.tInputSize.x,this.tInputSize.y)}fillUBO(n,e,t){super.fillUBO(n,e,t);const r=n.layout;n.setV2(r.currentSize,this.currentSize),n.setV2(r.tInputSize,this.tInputSize)}clone(){return new z}}function F(e){return`\n            ${_({varyingName:"vUv",varyingType:"v2"})}\n\n            ${P(e)}\n                ${D("vUv")} = uv.xy;\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(e)}\n            ${N(e)}\n        `}return{FlipX:new r(new t((function(n,e){e.customDefines;const t=o.getShaderOutput("out0");let r=`\n            \n            ${_({varyingName:"vUv",varyingType:"v2"})}\n            \n            ${c({uniformName:"tInput",uniformType:"t2"})}\n\n            ${b(e)}\n                ${x("screenUV")} = ${T("vUv")};\n                screenUV.x = 1.0 - screenUV.x;\n\n                ${y("color")} = ${C("tInput","screenUV")};\n                ${t} = color;\n            ${M(e)}\n        `;return{vertexShader:F(e),fragmentShader:r}}),"FlipX"),U,{}),FlipY:new r(new t((function(n,e){e.customDefines;const t=o.getShaderOutput("out0");let r=`\n            \n            ${_({varyingName:"vUv",varyingType:"v2"})}\n            \n            ${c({uniformName:"tInput",uniformType:"t2"})}\n\n            ${b(e)}\n                ${x("screenUV")} = ${T("vUv")};\n                screenUV.y = 1.0 - screenUV.y;\n\n                ${y("color")} = ${C("tInput","screenUV")};\n                ${t} = color;\n            ${M(e)}\n        `;return{vertexShader:F(e),fragmentShader:r}}),"FlipY"),U,{}),Threshold:new r(new t((function(n,e){const t=e.customDefines.FIREFLY>0,r="tInput",a=o.getShaderOutput("out0");let i=`\n            \n            ${_({varyingName:"vUv",varyingType:"v2"})}\n            \n            ${c({uniformName:"tInput",uniformType:"t2"})}\n            ${c({uniformName:"threshold",uniformType:"f"})}\n            ${c({uniformName:"invSize",uniformType:"v2"})}\n\n            ${t?`\n                ${f("WeighedAverageColor","v4",[p("uv"),p("offset")])} {\n                    ${x("coord")} = uv + offset * ${$("invSize")};\n                    ${y("color")} = ${C(r,"coord")};\n                    color.a = 1.0;\n                    ${g("luminance")} = dot(color.rgb, ${S()}(0.3, 0.6, 0.1));\n                    return color / (1.0 + luminance);\n                }\n\n                ${f("isNan","b",[d("val")])} {\n                    return !( val.x < 0.0 || 0.0 < val.x || val.x == 0.0 ) || !( val.y < 0.0 || 0.0 < val.y || val.y == 0.0 ) || !( val.z < 0.0 || 0.0 < val.z || val.z == 0.0 );\n                }\n            `:""}\n\n            ${u.getMainFragmentStart(e)}\n                ${x("screenUV")} = ${T("vUv")};\n\n                ${t?`\n                ${y("color")} = ${y()}(0.0);\n\n                color += ${h("WeighedAverageColor","v4",[p("screenUV"),p(`${x()}(0.0, 0.0)`)])};\n                color += ${h("WeighedAverageColor","v4",[p("screenUV"),p(`${x()}(1.0, 0.0)`)])};\n                color += ${h("WeighedAverageColor","v4",[p("screenUV"),p(`${x()}(1.0, 1.0)`)])};\n                color += ${h("WeighedAverageColor","v4",[p("screenUV"),p(`${x()}(0.0, 1.0)`)])};\n\n                color.x /= color.w;\n                color.y /= color.w;\n                color.z /= color.w;\n                if (${h("isNan","b",[d("color.xyz")])}) {\n                    color = ${y()}(0.0);\n                }\n                ${g("luminance")} = dot(color.rgb, ${S()}(0.3, 0.6, 0.1));\n                if (luminance < ${$("threshold")}) {\n                    color = ${y()}(0.0);\n                }\n                ${a} = ${y()}(color.xyz, 1.0);\n            `:`\n                    ${y("color")} = ${C(r,"screenUV")};\n                    ${g("lum")} = dot(color.rgb, ${S()}(0.2126, 0.7152, 0.0722));\n                    ${g("lum2")} = clamp(lum - ${$("threshold")}, 0.0, 1.0);\n                    color.r *= lum2;\n                    color.g *= lum2;\n                    color.b *= lum2;\n                    ${a} = color;\n                `}\n            ${u.getMainFragmentEnd(e)}\n        `;return{vertexShader:F(e),fragmentShader:i}}),"Threshold"),w,{FIREFLY:0}),Up:new r(new t((function(n,e){var t=e.customDefines;const r=o.getShaderOutput("out0"),a=t.ADD_TEXTURE>0;function i(n){return C("tInput",`screenUV + ${n} * ${$("invSize")}`)}let s=`\n            \n            ${_({varyingName:"vUv",varyingType:"v2"})}\n            \n            ${c({uniformName:"tInput",uniformType:"t2",locationName:"tInput0"})}\n            ${a?c({uniformName:"tAdd",uniformType:"t2",locationName:"tInput1"}):""}\n\n            ${c({uniformName:"invSize",uniformType:"v2"})}\n\n            ${u.getMainFragmentStart(e)}\n                ${x("screenUV")} = ${T("vUv")};\n\n                ${y("color")} = ${i(`${x()}(0.0, 0.0)`)} * 0.25;\n\n                color += ${i(`${x()}(-1.0, -1.0)`)} * 0.0625;\n                color += ${i(`${x()}(1.0, -1.0)`)} * 0.0625;\n                color += ${i(`${x()}(1.0, 1.0)`)} * 0.0625;\n                color += ${i(`${x()}(-1.0, 1.0)`)} * 0.0625;\n           \n                color += ${i(`${x()}(0.0, -1.0)`)} * 0.125;\n                color += ${i(`${x()}(0.0, 1.0)`)} * 0.125;\n                color += ${i(`${x()}(1.0, 0.0)`)} * 0.125;\n                color += ${i(`${x()}(-1.0, 0.0)`)} * 0.125;\n\n                ${a?`\n                    color += ${C("tAdd","screenUV")};\n                    `:""}\n                \n\n                ${r} = color;\n            ${u.getMainFragmentEnd(e)}\n        `;return{vertexShader:F(e),fragmentShader:s}}),"Up"),V,{ADD_TEXTURE:0}),Down:new r(new t((function(n,e){var t=e.customDefines;const r=o.getShaderOutput("out0"),a=t.ADD_TEXTURE>0;function i(n){return C("tInput",`screenUV + ${n} * ${$("invSize")}`)}let s=`\n            \n            ${_({varyingName:"vUv",varyingType:"v2"})}\n            \n            ${c({uniformName:"tInput",uniformType:"t2",locationName:"tInput0"})}\n            ${a?c({uniformName:"tAdd",uniformType:"t2",locationName:"tInput1"}):""}\n\n            ${c({uniformName:"invSize",uniformType:"v2"})}\n\n            ${u.getMainFragmentStart(e)}\n                ${x("screenUV")} = ${T("vUv")};\n\n                ${y("color")} = ${i(`${x()}(0.0, 0.0)`)} * 0.125;\n                color += ${i(`${x()}(-1.0, -1.0)`)} * 0.125;\n                color += ${i(`${x()}(1.0, -1.0)`)} * 0.125;\n                color += ${i(`${x()}(1.0, 1.0)`)} * 0.125;\n                color += ${i(`${x()}(-1.0, 1.0)`)} * 0.125;\n           \n                color += ${i(`${x()}(-2.0, 0.0)`)} * 0.0625;\n                color += ${i(`${x()}(2.0, 0.0)`)} * 0.0625;\n                color += ${i(`${x()}(0.0, -2.0)`)} * 0.0625;\n                color += ${i(`${x()}(0.0, 2.0)`)} * 0.0625;\n                \n                color += ${i(`${x()}(-2.0, -2.0)`)} * 0.03125;\n                color += ${i(`${x()}(2.0, -2.0)`)} * 0.03125;\n                color += ${i(`${x()}(2.0, 2.0)`)} * 0.03125;\n                color += ${i(`${x()}(-2.0, 2.0)`)} * 0.03125;\n\n                ${a?`\n                    color += ${C("tAdd","screenUV")};\n                    `:""}\n                \n\n                ${r} = color;\n            ${u.getMainFragmentEnd(e)}\n        `;return{vertexShader:F(e),fragmentShader:s}}),"Down"),V,{ADD_TEXTURE:0}),Nothing:new r(new t((function(n,e){const t=o.getShaderOutput("out0");let r=`\n\n            ${_({varyingName:"vUv",varyingType:"v2"})}\n            \n            ${c({uniformName:"tInput",uniformType:"t2"})}\n\n            ${b(e)}\n                ${x("screenUV")} = ${T("vUv")};\n                ${y("color")} = ${C("tInput","screenUV")};\n                ${t} = color;\n            ${M(e)}\n        `;return{vertexShader:F(e),fragmentShader:r}}),"Nothing"),U,{}),PixelSum:new r(new t((function(n,e){var t=e.customDefines;const r=o.getShaderOutput("out0");let a=`\n            \n            ${_({varyingName:"vUv",varyingType:"v2"})}\n            \n            ${c({uniformName:"tInput",uniformType:"t2"})}\n            ${c({uniformName:"tInputSize",uniformType:"v2"})}\n            ${c({uniformName:"currentSize",uniformType:"v2"})}\n\n            ${u.getMainFragmentStart(e)}\n                ${x("screenUV")} = ${T("vUv")};\n                ${x("currentPixel")} = floor(screenUV * ${$("currentSize")});\n\n                ${x("sums")} = ${x()}(0.0);\n                ${x("loopSize")}  = ${x()}(${g()}(${t.LOOP_SIZE_X}),${g()}(${t.LOOP_SIZE_Y}));\n\n                ${x("uvDiffuse")}  = (0.5+currentPixel*loopSize)/${$("tInputSize")};\n\n                ${x("currUv")} ;\n\n                if(currentPixel.x<(${$("currentSize")}.x-1.0)){\n\t\t\t\t\tfor(${v("i")}=0;i<${t.LOOP_SIZE_X};i++){\n\t\t\t\t\t\tcurrUv = uvDiffuse + ${x()}(${g()}(i)/${$("tInputSize")}.x,0.0);\n\t\t\t\t\t\tif(currentPixel.y<(${$("currentSize")}.y-1.0)){\n\t\t\t\t\t\t\tfor(${v("j")}=0;j<${t.LOOP_SIZE_Y};j++){\n\t\t\t\t\t\t\t\tcurrUv.y += 1.0/${$("tInputSize")}.y;\n\t\t\t\t\t\t\t\tsums+=${C("tInput","currUv")}.rg;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tfor(${v("j")}=0;j<${t.LOOP_SIZE_Y_FINAL};j++){\n\t\t\t\t\t\t\t\tcurrUv.y += 1.0/${$("tInputSize")}.y;\n\t\t\t\t\t\t\t\tsums+=${C("tInput","currUv")}.rg;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tfor(${v("i")}=0;i<${t.LOOP_SIZE_X_FINAL};i++){\n\t\t\t\t\t\tcurrUv = uvDiffuse + ${x()}(${g()}(i)/${$("tInputSize")}.x,0.0);\n\t\t\t\t\t\tif(currentPixel.y<(${$("currentSize")}.y-1.0)){\n\t\t\t\t\t\t\tfor(${v("j")}=0;j<${t.LOOP_SIZE_Y};j++){\n\t\t\t\t\t\t\t\tcurrUv.y += 1.0/${$("tInputSize")}.y;\n\t\t\t\t\t\t\t\tsums+=${C("tInput","currUv")}.rg;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tfor(${v("j")}=0;j<${t.LOOP_SIZE_Y_FINAL};j++){\n\t\t\t\t\t\t\t\tcurrUv.y += 1.0/${$("tInputSize")}.y;\n\t\t\t\t\t\t\t\tsums+=${C("tInput","currUv")}.rg;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n                ${r} = ${y()}(sums, 0.0, 1.0);\n            ${u.getMainFragmentEnd(e)}\n        `;return{vertexShader:F(e),fragmentShader:a}}),"PixelSum"),z,{LOOP_SIZE_X:0,LOOP_SIZE_Y:0,LOOP_SIZE_X_FINAL:0,LOOP_SIZE_Y_FINAL:0})}})),define("DS/ShaderBuilders/PostPro/MirrorShaderBuilders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PostPro/PostProUniformHandler","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/PostPro/PostProContext","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a,o,i,s){"use strict";i.ParameterUtils;const l=i.FunctionHandler,u=i.BridgeFunctions,m=n=>a.addUniform(n),c=n=>{var e={uniformName:n};return a.getTextureUniform(e)},$=(n=null,e=0)=>{var t={name:n,size:e};return s.float(t)},p=(n=null,e=0)=>{var t={name:n,size:e};return s.vec3(t)},d=(n=null,e=0)=>{var t={name:n,size:e};return s.vec4(t)},f=n=>o.addVarying(n),h=(n,e)=>u.sample2DTexture(c(n),e),v=(n,e)=>{return u.sample2DTextureMultisampled(c(n),e,(t="sampleIndex",o.getShaderInput(t)));var t};class g extends e{constructor(){super(1),this.reflectivity=.3}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform1f(r.reflectivity,this.reflectivity)}fillUBO(n,e,t){super.fillUBO(n,e,t);const r=n.layout;n.setF(r.reflectivity,this.reflectivity)}clone(){var n=new g;return n.reflectivity=this.reflectivity,n}}return{Blend:new r(new t((function(e,t){var r=t.customDefines;let i=`\n            ${f({varyingName:"vUv",varyingType:"v2"})}\n\n            ${l.getMainVertexStart(t)}\n                ${u="vUv",o.getVarying(u,o.ShaderStages.out)} = uv.xy;\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(t)}\n            ${l.getMainVertexEnd(t)}\n\n        `;var u;const g="tScene",x=c("tReflectedScene"),S=o.getShaderOutput("out0"),y=t.antialias?"t2ms":"t2",_=t.antialias?v(g,"screenUV"):h(g,"screenUV");let T=`\n            \n            ${f({varyingName:"vUv",varyingType:"v2"})}\n            \n            ${r.POSTPRO?m({uniformName:"tScene",uniformType:y,locationName:"tInput0"}):""}\n            ${m({uniformName:"tReflectedScene",uniformType:"t2",locationName:"tInput1"})}\n\n            ${m({uniformName:"reflectivity",uniformType:"f"})}\n\n            ${l.getMainFragmentStart(t)}\n                ${((n=null,e=0)=>{var t={name:n,size:e};return s.vec2(t)})("screenUV")} = ${(n=>o.getVarying(n,o.ShaderStages.in))("vUv")};\n\n                ${d("reflectedScene")} = ${h(x,"screenUV")};\n                ${$("blend")} = 1.0 - ${(n=>{var e={uniformName:n};return a.getUniform(e)})("reflectivity")};\n                ${$("srcAlpha")} = (1.0 - blend) * reflectedScene.w;\n\n                ${r.POSTPRO?`\n\t\t\t\t\t${d("mirrorPlane")} = ${_};\n\t\t\t\t\t${p("mirrorPlaneColor")} = mirrorPlane.xyz;\n                    ${p("mirrorMix")}  = (1.0 - blend) * reflectedScene.xyz + blend * mirrorPlaneColor;\n\n                    ${S} = ${d()}(mirrorMix * reflectedScene.w + mirrorPlaneColor * (1.0 - reflectedScene.w), srcAlpha + (1.0-srcAlpha)*mirrorPlane.w);\n                    `:`\n                    ${S} = ${d()}(reflectedScene.rgb, srcAlpha);\n                    `}\n            ${l.getMainFragmentEnd(t)}\n        `;return{vertexShader:i,fragmentShader:T}}),"MirrorBlend"),g,{POSTPRO:1})}})),define("DS/ShaderBuilders/PostPro/SSAOShaderBuilders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PostPro/PostProUniformHandler","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/PostPro/PostProContext","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a,o,i,s){"use strict";const l="",u=i.ParameterUtils,m=i.FunctionHandler,c=i.BridgeFunctions,$=n=>a.addUniform(n),p=n=>{var e={uniformName:n};return a.getUniform(e)},d=n=>u.parameterI(n),f=n=>u.parameterF(n),h=n=>u.parameterV2(n),v=n=>u.parameterV3(n),g=n=>u.parameterV4(n),x=(n,e,t)=>m.declareFunction(n,e,t),S=(n,e,t)=>m.callFunction(n,e,t),y=(n=null,e=0)=>{var t={name:n,size:e};return s.int(t)},_=(n=null,e=0)=>{var t={name:n,size:e,constant:!0};return s.int(t)},T=(n=null,e=0)=>{var t={name:n,size:e};return s.float(t)},D=(n=null,e=0)=>{var t={name:n,size:e,constant:!0};return s.float(t)},C=(n=null,e=0)=>{var t={name:n,size:e};return s.vec2(t)},P=(n=null,e=0)=>{var t={name:n,size:e};return s.vec3(t)},N=(n=null,e=0)=>{var t={name:n,size:e};return s.vec4(t)},b=(n=null)=>{var e={name:n};return s.bvec2(e)},M=(n=null)=>{var e={name:n};return s.bvec4(e)},U=n=>o.addVarying(n),w=n=>o.getVarying(n,o.ShaderStages.in),V=n=>o.getVarying(n,o.ShaderStages.out),z=n=>o.getShaderInput(n),F=()=>i.FunctionHandler.getEarlyFragmentEnd(),I=(n,e)=>{return c.sample2DTexture((t={uniformName:n},a.getTextureUniform(t)),e);var t},R=(n,e)=>c.modulo(n,e),A={ADAPTATIVE_RADIUS:!0};class L extends e{constructor(){super(),this.realProjectionMatrix=new n.Matrix4,this.realProjectionMatrixInverse=new n.Matrix4,this.nbSamples=16,this.tRandomTexture=null,this.radius=.5,this.minRadius=.01,this.maxRadius=.2,this.thresholdAngle=.045,this.invSize=new n.Vector2(1/800,1/600),this.attenuation=1}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniformMatrix4fv(r.realProjectionMatrix,!1,e.float32Matrix4x4Temp.setDoubles(this.realProjectionMatrix.elements)),t.uniformMatrix4fv(r.realProjectionMatrixInverse,!1,e.float32Matrix4x4Temp.setDoubles(this.realProjectionMatrixInverse.elements)),t.uniform1i(r.nbSamples,this.nbSamples),e.loadTexture(t,r.tRandomTexture,this.tRandomTexture),t.uniform1f(r.radius,this.radius),t.uniform1f(r.minRadius,this.minRadius),t.uniform1f(r.maxRadius,this.maxRadius),t.uniform1f(r.thresholdAngle,this.thresholdAngle),t.uniform2f(r.invSize,this.invSize.x,this.invSize.y),t.uniform1f(r.attenuation,this.attenuation)}fillUBO(n,e,t){super.fillUBO(n,e,t);const r=n.layout;n.setM4(r.realProjectionMatrix,this.realProjectionMatrix),n.setM4(r.realProjectionMatrixInverse,this.realProjectionMatrixInverse),n.setI(r.nbSamples,this.nbSamples),n.setTexture(r.tRandomTexture,this.tRandomTexture),n.setF(r.radius,this.radius),n.setF(r.minRadius,this.minRadius),n.setF(r.maxRadius,this.maxRadius),n.setF(r.thresholdAngle,this.thresholdAngle),n.setV2(r.invSize,this.invSize),n.setF(r.attenuation,this.attenuation)}clone(){var n=new L;return n.realProjectionMatrix=this.realProjectionMatrix,n.realProjectionMatrixInverse=this.realProjectionMatrixInverse,n.nbSamples=this.nbSamples,n.tRandomTexture=this.tRandomTexture,n.radius=this.radius,n.minRadius=this.minRadius,n.maxRadius=this.maxRadius,n.thresholdAngle=this.thresholdAngle,n.invSize=this.invSize,n.attenuation=this.attenuation,n}}class B extends L{constructor(){super(),this.samplingPoints=null}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform4fv(r.samplingPoints,this.samplingPoints)}fillUBO(n,e,t){super.fillUBO(n,e,t);const r=n.layout;n.setFlatV4Array(r.samplingPoints,this.samplingPoints)}clone(){var n=new B;return n.realProjectionMatrix=this.realProjectionMatrix,n.realProjectionMatrixInverse=this.realProjectionMatrixInverse,n.nbSamples=this.nbSamples,n.tRandomTexture=this.tRandomTexture,n.radius=this.radius,n.minRadius=this.minRadius,n.maxRadius=this.maxRadius,n.thresholdAngle=this.thresholdAngle,n.invSize=this.invSize,n.attenuation=this.attenuation,n.samplingPoints=this.samplingPoints,n}}class E extends L{constructor(){super(),this.firstSample=0}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform1i(r.firstSample,this.firstSample)}fillUBO(n,e,t){super.fillUBO(n,e,t);const r=n.layout;n.setI(r.firstSample,this.firstSample)}clone(){var n=new E;return n.realProjectionMatrix=this.realProjectionMatrix,n.realProjectionMatrixInverse=this.realProjectionMatrixInverse,n.nbSamples=this.nbSamples,n.tRandomTexture=this.tRandomTexture,n.radius=this.radius,n.minRadius=this.minRadius,n.maxRadius=this.maxRadius,n.thresholdAngle=this.thresholdAngle,n.invSize=this.invSize,n.attenuation=this.attenuation,n.firstSample=this.firstSample,n}}function k(e){return`          \n            ${U({varyingName:"vUv",varyingType:"v2"})}\n            \n            ${m.getMainVertexStart(e)}\n\n                ${V("vUv")} = uv.xy;\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(e)}\n            ${m.getMainVertexEnd(e)}\n        `}function O(n){return`\n        \n        ${$({uniformName:"tNormalDepth",uniformType:"t2",locationName:"tInput"})}\n        ${$({uniformName:"realProjectionMatrix",uniformType:"m4"})}\n        ${$({uniformName:"realProjectionMatrixInverse",uniformType:"m4"})}\n        ${$({uniformName:"invSize",uniformType:"v2"})}\n        ${$({uniformName:"radius",uniformType:"f"})}\n        ${$({uniformName:"minRadius",uniformType:"f"})}\n        ${$({uniformName:"maxRadius",uniformType:"f"})}\n        ${$({uniformName:"nbSamples",uniformType:"i"})}\n        ${$({uniformName:"thresholdAngle",uniformType:"f"})}\n        ${$({uniformName:"attenuation",uniformType:"f"})}\n\n        ${U({varyingName:"vUv",varyingType:"v2"})}\n\n        ${_("MAX_SAMPLES")} = 32;\n\n        ${_("kernelSize")}  = 32;\n        ${D("PI")} = 3.14159265358979323846264;\n        ${D("one_over_tan_225")}  = 2.414213562373095;\n\n        ${x("getScreenPos","v2",[v("pos")])}{\n\n          ${N("offset")}  = ${p("realProjectionMatrix")} * ${N()}(pos, 1.0);\n          offset.x /= offset.w;\n          offset.y /= offset.w;\n          offset.x = offset.x * 0.5 + 0.5;\n          offset.y = offset.y * 0.5 + 0.5;\n          \n          ${c.uvConvention("offset")}\n\n          return offset.xy;\n        }\n\n        ${x("computePointVS","v3",[h("iUV"),v("iPos")])} {\n\n            ${N("normalDepth")}  = ${I("tNormalDepth","iUV")};\n            ${T("z")};\n            ${n.renderToFloatTexture?"\n                z = normalDepth.w;\n                ":`\n                z = ${S("unpackForFloat16","f",[h("normalDepth.zw")])};\n                `}\n\n            ${M("inScreen4")}  = ${M()}(iUV.x >= 0.0, iUV.x <= 1.0, iUV.y >= 0.0, iUV.y <= 1.0);\n            ${b("inScreen")}  = ${b()}(all(inScreen4), z > 0.0);\n\n            if (!all(inScreen)) {return ${P()}(iPos.x, iPos.y, iPos.z - 1.0); }\n            \n            ${C("projSpaceXY")} = iUV;\n            ${c.uvConvention("projSpaceXY")}\n\n            ${C("xy")}  = projSpaceXY * 2.0 - 1.0;\n            ${T("depth")} = ${c.getDepthWithConvention("z")};\n            ${N("vertexPositionProjected")}  = ${N()}(xy, depth, 1.0);\n            ${N("vertexPositionVS")}  = ${p("realProjectionMatrixInverse")}  * vertexPositionProjected;\n            vertexPositionVS.x /= vertexPositionVS.w;\n            vertexPositionVS.y /= vertexPositionVS.w;\n            vertexPositionVS.z /= vertexPositionVS.w;\n\n            return vertexPositionVS.xyz;\n        }\n\n        ${x("ComputeAO","f",[v("iSamplePos"),v("iPos"),v("iNormal"),f("iAtt")])}{\n\n            ${P("dir")}  = iSamplePos - iPos;\n            ${T("l2")}     = dot(dir, dir);\n            ${T("occ")}  = 0.0;\n            if (l2 > 0.0) {\n                ${T("angle")}  = dot(iNormal, dir) / sqrt(l2);\n                if (angle > ${p("thresholdAngle")}) {\n\n                    occ = 1.0 / (1.0 + l2 * iAtt);\n\n                    angle = 1.0 - angle;\n                    angle *= angle;\n                    angle *= angle;\n                    occ *= (1.0 - angle);\n                }\n            }\n\n            return occ;\n\n        }\n        `}function G(n){const e=o.getShaderOutput("out0");var t=n.customDefines;return`\n        \n            ${C("screenPos")} = ${w("vUv")};\n\n            ${e} = ${N()}(1.0);\n\n            ${N("normalDepth")}  = ${I("tNormalDepth","screenPos")};\n            ${T("z")};\n            ${P("normal")};\n            ${n.renderToFloatTexture?"\n                z = normalDepth.w;\n                normal = normalDepth.xyz * 2.0 - 1.0;\n                ":`\n                z = ${S("unpackForFloat16","f",[h("normalDepth.zw")])};\n                normal = ${S("decodeOct22Normal","v3",[h("normalDepth.xy")])};\n                `}\n\n            if ( z < 0.1 ) { \n                ${F()} \n            }\n            ${C("projSpaceXY")} = screenPos;           \n            ${c.uvConvention("projSpaceXY")}\n            ${C("xy")}  = projSpaceXY * 2.0 - 1.0;\n\n            ${T("depth")} = ${c.getDepthWithConvention("z")};\n            ${N("vertexPositionProjected")}  = ${N()}(xy, depth, 1.0);\n            ${N("vertexPositionVS")}  = ${p("realProjectionMatrixInverse")} * vertexPositionProjected;\n            vertexPositionVS.x /= vertexPositionVS.w;\n            vertexPositionVS.y /= vertexPositionVS.w;\n            vertexPositionVS.z /= vertexPositionVS.w;\n            vertexPositionVS.w = 1.0;\n\n            ${P("origin")}  = vertexPositionVS.xyz;\n\n            // projRadius is in homogeneous coords\n            // we presuppose that fov/2 is 22.5 degrees...\n\n            ${T("projRadius")}  = 0.5 * ${p("realProjectionMatrix")}[0][0] * ${p("radius")};\n            // perspective case\n            if (${p("realProjectionMatrix")}[3][3] < 0.5) { \n                projRadius /= -origin.z;\n            }\n            ${T("scaleRadius")}  = 1.0;\n\n            ${t.ADAPTATIVE_RADIUS?`scaleRadius = min(${p("maxRadius")}, max(projRadius, ${p("minRadius")})) / projRadius;`:l}\n\n            ${T("newRadius")}  = scaleRadius * ${p("radius")};\n\n            ${T("att")}  = ${p("attenuation")} / (newRadius * newRadius);\n\n            ${T("occ")} = 0.0;\n        `}return{Iterative:new r(new t((function(n,e){e.customDefines;const t=o.getShaderOutput("out0");var r=`\n            \n        ${$({uniformName:"tRandomTexture",uniformType:"t2"})}\n        ${$({uniformName:"firstSample",uniformType:"i"})}\n\n        ${x("random","f",[v("scale"),f("seed"),g("fragCoord")])} {\n            return fract(sin(dot(fragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n        }\n\n        ${x("Random1D","f",[f("seed"),g("fragCoord")])} {\n            ${P("scale")} = ${P()}(12.9898, 78.233, 151.7182);\n            return ${S("random","f",[v("scale"),f("seed"),g("fragCoord")])};\n        }\n\n        ${x("HaltonSequenceShift","f",[d("n"),d("base"),f("shift")])} {\n\n            ${T("val")}  = 0.0;\n            ${T("invBase")}  = 1.0 / ${T()}(base);\n            ${T("invBi")}  = invBase;\n            ${y("nn")} = n;\n\n            // glsl limitation\n            for (${y("i")} = 0; i < 32; i++) { \n                if (nn == 0) {\n                    break;\n                }\n                ${T("d_i")}  = ${R(`${T()}(nn)`,`${T()}(base)`)};\n                val += ${T()}(d_i) * invBi;\n                nn /= base;\n                invBi *= invBase;\n            }\n\n            return fract(val + shift);\n        }\n\n        ${x("LowDiscrepancy3DShift","v3",[d("index"),h("shift")])} {\n\n            ${y("yy")} = index / 64;\n            ${T("xx")}  = ${R(`${T()}(index)`,"64.0")};\n            ${C("offset")}  = vec2(xx, ${T()}(yy));\n            ${P("res")}  = ${I("tRandomTexture","0.015625 * (offset + 0.5)")}.xyz;\n\n            return fract(res + shift.xyx);\n        }\n\n        // random normalized vector\n\n        ${x("uniformlySampleSphere","v3",[h("E")])} {\n\n            ${T("z")} = 1.0 - 2.0 * E.x;\n            ${T("r")}  = sqrt(1.0 - z * z);\n            ${T("angle")}  = 6.283185307179586 * E.y;\n\n            return ${P()}(r * cos(angle), r * sin(angle), z);\n        }\n\n        ${x("precomputeRandom1D","v4",[h("shift"),d("index")])} {\n            ${y("offset")} = ${p("firstSample")};\n            ${P("E")} = ${S("LowDiscrepancy3DShift","v3",[d("offset + index + 1"),h("shift")])};\n            ${P("sampleSphere")} = ${S("uniformlySampleSphere","v3",[h("E.xy")])};\n            return ${N()}(sampleSphere, E.z);\n        }\n\n        ${O(e)}\n\n        ${x("ComputeSampleSSAO","f",[h("uv"),v("iSamplingPt"),v("iPos"),v("iNormal"),f("iRadius"),f("iAtt"),f("iRandomZ")])} {\n\n            ${T("occ")}  = 0.0;\n\n            \n            ${P("rayDir")}  = iSamplingPt;\n\n            ${T("delta")}  = iRadius * sign(dot(iSamplingPt, iNormal)) * iRandomZ;\n            \n            ${P("newPt")}   = delta * rayDir + iPos;\n\n            ${C("coord")}  = ${S("getScreenPos","v2",[v("newPt")])};\n\n            ${C("tmp")}  = coord - uv;\n            coord = uv + sign(tmp.xy) * max(${p("invSize")}.xy, abs(tmp.xy));\n\n            ${P("samplePos")} = ${S("computePointVS","v3",[h("coord"),v("newPt")])};\n\n            if (samplePos.z > newPt.z) {\n\n                occ = ${S("ComputeAO","f",[v("samplePos"),v("iPos"),v("iNormal"),f("iAtt")])};\n            }\n\n            return occ;\n        }\n        \n\n        ${m.getMainFragmentStart(e)}\n\n            ${G(e)};\n            ${T("seed")} = ${z("fragCoord")}.x + ${z("fragCoord")}.y;\n            ${T("randomX")} = ${S("Random1D","f",[f("seed"),g(z("fragCoord"))])};\n            ${T("randomY")} = ${S("Random1D","f",[f("seed"),g(z("fragCoord"))])};\n            ${C("shift")}  = ${C()}(randomX, randomY);\n            for (${y("i")} = 0; i < MAX_SAMPLES; i++) {\n                if (i == ${p("nbSamples")}) {\n                    break;\n                }           \n                ${N("randVec")}  = ${S("precomputeRandom1D","v4",[h("shift"),d("i")])};    \n                occ += ${S("ComputeSampleSSAO","f",[h("screenPos"),v("randVec.xyz"),v("origin"),v("normal"),f("newRadius"),f("att"),f("randVec.w")])};\n            }\n            occ /= max(${T()}(${p("nbSamples")}), 1.0);\n\n            ${t} = ${N()}(${P()}(1.0 - occ), 1.0);\n\n        ${m.getMainFragmentEnd(e)}\n        `;return{vertexShader:k(e),fragmentShader:r}}),"SSAO_Iterative"),E,A),Direct:new r(new t((function(n,e){e.customDefines;const t=o.getShaderOutput("out0");var r=`\n        \n        ${$({uniformName:"tRandomTexture",uniformType:"t2"})}\n        ${$({uniformName:"samplingPoints",uniformType:"fv4",size:32})}\n\n        ${x("modI","f",[f("a"),f("b")])} {\n\n            ${T("m")} = a - floor((a + 0.5) / b) * b;\n            return floor(m + 0.5);\n        }\n\n        ${x("precomputeRandom1D","v3",[h("coords")])} {\n\n            ${T("modIx")} = ${S("modI","f",[f("coords.x"),f("5.0")])};\n            ${T("modIy")} = ${S("modI","f",[f("coords.y"),f("5.0")])};\n            ${C("s")} = 0.2 * (${C()}(modIx, modIy) + 0.5);\n            return ${I("tRandomTexture","s")}.xyz;\n        }\n\n        ${O(e)}\n\n        ${x("ComputeSampleSSAO","f",[h("uv"),v("iSamplingPt"),v("iPos"),v("iNormal"),f("iRadius"),f("iAtt"),v("iRandomVec")])} {\n\n            ${T("occ")}  = 0.0;\n\n            ${P("rayDir")}  = reflect(iSamplingPt, iRandomVec);\n\n            ${T("delta")}  = iRadius * sign(dot(rayDir, iNormal));\n            \n            ${P("newPt")}   = delta * rayDir + iPos;\n\n            ${C("coord")}  = ${S("getScreenPos","v2",[v("newPt")])};\n\n            ${C("tmp")}  = coord - uv;\n            coord = uv + sign(tmp.xy) * max(${p("invSize")}.xy, abs(tmp.xy));\n\n            ${P("samplePos")} = ${S("computePointVS","v3",[h("coord"),v("newPt")])};\n            if (samplePos.z > newPt.z) {\n                occ = ${S("ComputeAO","f",[v("samplePos"),v("iPos"),v("iNormal"),f("iAtt")])};\n            }\n\n            return occ;\n        }\n\n        ${m.getMainFragmentStart(e)}\n\n            ${G(e)}\n            ${C("seed")} = ${z("fragCoord")}.xy;\n            ${P("randVec")}  = ${S("precomputeRandom1D","v3",[h("seed")])};\n            for (${y("i")} = 0; i < MAX_SAMPLES; i++) {\n                if (i == ${p("nbSamples")}) {\n                    break;\n                }\n                ${P("samplingPoint")} = ${p("samplingPoints")}[i].xyz;\n                occ += ${S("ComputeSampleSSAO","f",[h("screenPos"),v("samplingPoint"),v("origin"),v("normal"),f("newRadius"),f("att"),v("randVec")])};\n            }\n            occ /= max(${T()}(${p("nbSamples")}), 1.0);\n\n            ${t} = ${N()}(${P()}(1.0 - occ), 1.0);\n\n        ${m.getMainFragmentEnd(e)}\n        `;return{vertexShader:k(e),fragmentShader:r}}),"SSAO_Direct"),B,A)}})),define("DS/ShaderBuilders/PostPro/FlareShaderBuilders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PostPro/PostProUniformHandler","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/PostPro/PostProContext","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a,o,i,s){"use strict";const l=i.ParameterUtils,u=i.FunctionHandler,m=i.BridgeFunctions,c=n=>a.addUniform(n),$=n=>{var e={uniformName:n};return a.getUniform(e)},p=n=>l.parameterV2(n),d=n=>l.parameterV3(n),f=n=>l.parameterT2(n),h=(n=null,e=0)=>{var t={name:n,size:e};return s.float(t)},v=(n=null,e=0)=>{var t={name:n,size:e,constant:!0};return s.float(t)},g=(n=null,e=0)=>{var t={name:n,size:e};return s.vec2(t)},x=(n=null,e=0)=>{var t={name:n,size:e};return s.vec3(t)},S=(n=null,e=0)=>{var t={name:n,size:e};return s.vec4(t)},y=n=>o.addVarying(n),_=(n,e)=>{return m.sample2DTexture((t={uniformName:n},a.getTextureUniform(t)),e);var t};class T extends e{constructor(){super(1),this.tLensColor=null,this.tLensDirt=null,this.invSize=new n.Vector2(1,1)}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform2f(r.invSize,this.invSize.x,this.invSize.y),e.loadTexture(t,r.tLensDirt,this.tLensDirt),e.loadTexture(t,r.tLensDirt,this.tLensDirt)}fillUBO(n,e,t){super.fillUBO(n,e,t);const r=n.layout;n.setV2(r.invSize,this.invSize),n.setTexture(r.tLensColor,this.tLensColor),n.setTexture(r.tLensDirt,this.tLensDirt)}clone(){return new T}}return{FinalBlending:new r(new t((function(e,t){const r=o.getShaderOutput("out0");let a=`   \n            ${y({varyingName:"vUv",varyingType:"v2"})}\n\n            ${(n=>i.FunctionHandler.getMainVertexStart(n))(t)}\n                ${l="vUv",o.getVarying(l,o.ShaderStages.out)} = uv.xy;\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(t)}\n            ${(n=>i.FunctionHandler.getMainVertexEnd(n))(t)}\n        `;var l;let m=`\n\n            ${y({varyingName:"vUv",varyingType:"v2"})}\n            \n            ${c({uniformName:"tDiffuse",uniformType:"t2",locationName:"tInput0"})}\n            ${c({uniformName:"tBlur",uniformType:"t2",locationName:"tInput1"})}\n            ${c({uniformName:"tLensColor",uniformType:"t2"})}\n            ${c({uniformName:"tLensDirt",uniformType:"t2"})}\n            ${c({uniformName:"invSize",uniformType:"v2"})}\n\n            \n            ${v("ghostDispersal")} = 0.25;\n            ${((n=null,e=0)=>{var t={name:n,size:e,constant:!0};return s.int(t)})("ghosts")}  = 8;\n            ${v("distortion")} = 5.0;\n            ${v("haloWidth")} = 1.0;\n            ${v("one_over_sqrt2")} = 0.70710678;\n\n            ${((n,e,t)=>u.declareFunction(n,e,t))("textureDistorted","v4",[f("tex"),p("texcoord"),p("direction"),d("distortion")])}{\n\n               return ${S()}(\n                  ${_("tex","texcoord + direction * distortion.r")}.r,\n                  ${_("tex","texcoord + direction * distortion.g")}.g,\n                  ${_("tex","texcoord + direction * distortion.b")}.b,\n                  1.0\n               );\n\n            }\n\n            ${(n=>i.FunctionHandler.getMainFragmentStart(n))(t)}\n                ${g("screenUV")} = ${(n=>o.getVarying(n,o.ShaderStages.in))("vUv")};\n                ${S("color")} = ${_("tDiffuse","screenUV")};\n\n                ${g("flippedUV")}  = ${g()}(1.0) - screenUV;\n                ${g("uvToCenter")}  = ${g()}(0.5) - flippedUV;\n                ${x("distort")}  = ${x()}(-${$("invSize")}.x * distortion, 0.0, ${$("invSize")}.x * distortion);\n\n                // ghosts\n\n                ${g("ghostVec")}  = uvToCenter * ghostDispersal;\n\n                ${S("flare")}  = ${S()}(0.0);\n\n                for (${((n=null,e=0)=>{var t={name:n,size:e};return s.int(t)})("i")} = 0; i < ghosts; i++) {\n\n                    ${g("offset")}  = fract(flippedUV + ghostVec * ${h()}(i));\n\n                    ${h("ghostHeight")}  = length(${g()}(0.5) - offset) / one_over_sqrt2;\n                    ghostHeight = pow(1.0 - ghostHeight, 10.0);\n\n                    flare += ${((n,e,t)=>u.callFunction(n,e,t))("textureDistorted","v4",[f("tBlur"),p("offset"),p("normalize(ghostVec)"),d("distort")])} * ghostHeight;\n\n                }\n\n                flare *= ${_("tLensColor",`${g()}(length(uvToCenter) / one_over_sqrt2, 0.5)`)};\n\n                ${h("dirt")}  = ${_("tLensDirt","screenUV")}.r;\n                flare *= ${S()}(0.5) + dirt;\n                ${r} = ${S()}(color.rgb + flare.rgb, color.a);\n            ${(n=>i.FunctionHandler.getMainFragmentEnd(n))(t)}\n        `;return{vertexShader:a,fragmentShader:m}}),"Flare"),T,{})}})),define("DS/ShaderBuilders/PostPro/MSAAShaderBuilders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PostPro/PostProUniformHandler","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/PostPro/PostProContext","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a,o,i,s){"use strict";i.ParameterUtils;const l=i.FunctionHandler,u=i.BridgeFunctions,m=n=>a.addUniform(n),c=(n=null,e=0)=>{var t={name:n,size:e};return s.vec2(t)},$=(n=null,e=0)=>{var t={name:n,size:e};return s.vec4(t)},p=n=>o.addVarying(n),d=n=>o.getVarying(n,o.ShaderStages.in),f=n=>o.getVarying(n,o.ShaderStages.out),h=(n,e)=>{return u.sample2DTexture((t={uniformName:n},a.getTextureUniform(t)),e);var t};class v extends e{constructor(){super(),this.prevMap=null,this.numIteration=0}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),e.loadTexture(t,r.prevMap,this.prevMap),t.uniform1f(r.numIteration,this.numIteration)}fillUBO(n,e,t){super.fillUBO(n,e,t);const r=n.layout;n.setTexture(r.prevMap,this.prevMap),n.setF(r.numIteration,this.numIteration)}clone(){var n=new v;return n.prevMap=this.prevMap,n.numIteration=this.numIteration,n}}class g extends e{constructor(){super(1)}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i)}fillUBO(n,e,t){super.fillUBO(n,e,t)}clone(){return new g}}return{Blending:new r(new t((function(e,t){t.customDefines;let r=`\n            ${p({varyingName:"vUv",varyingType:"v2"})}\n\n            ${l.getMainVertexStart(t)}\n\n                ${f("vUv")} = uv.xy;\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(t)}\n            ${l.getMainVertexEnd(t)}\n\n        `;const i=o.getShaderOutput("out0");var u,v;return{vertexShader:r,fragmentShader:`\n                \n            ${m({uniformName:"tScene",uniformType:"t2",locationName:"tInput"})}\n            ${m({uniformName:"prevMap",uniformType:"t2"})}\n            ${m({uniformName:"numIteration",uniformType:"f"})}\n     \n            ${p({varyingName:"vUv",varyingType:"v2"})}\n\n            ${l.getMainFragmentStart(t)}\n                ${((n=null,e=0)=>{var t={name:n,size:e};return s.float(t)})("iteration")} = ${u="numIteration",v={uniformName:u},a.getUniform(v)};\n                ${c("blendUV")} = ${d("vUv")};\n\n                ${$("prevColor")}  = ${h("prevMap","blendUV")};\n                ${$("currColor")}  = ${h("tScene","blendUV")};\n\n                ${i} = ${$()}((prevColor * iteration + currColor) / (iteration + 1.0));\n            ${l.getMainFragmentEnd(t)}\n        `}}),"MSAA_Blend"),v,{}),Transfer:new r(new t((function(e,t){t.customDefines;let r=`\n            ${p({varyingName:"vUv",varyingType:"v2"})}\n\n            ${l.getMainVertexStart(t)}\n\n                ${f("vUv")} = uv.xy;\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(t)}\n            ${l.getMainVertexEnd(t)}\n\n        `;const a=o.getShaderOutput("out0");return{vertexShader:r,fragmentShader:`\n                \n            ${m({uniformName:"tScene",uniformType:"t2",locationName:"tInput0"})}\n            ${m({uniformName:"tBlend",uniformType:"t2",locationName:"tInput1"})}\n     \n            ${p({varyingName:"vUv",varyingType:"v2"})}\n\n            ${l.getMainFragmentStart(t)}\n                ${c("blendUV")} = ${d("vUv")};\n\n                ${a} = ${h("tBlend","blendUV")};\n            ${l.getMainFragmentEnd(t)}\n        `}}),"MSAA_Transfer"),g,{})}})),define("DS/ShaderBuilders/PostPro/CompositeShaderBuilders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PostPro/PostProUniformHandler","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/PostPro/PostProContext","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a,o,i,s){"use strict";const l="",u=i.ParameterUtils,m=i.FunctionHandler,c=i.BridgeFunctions,$=n=>a.addUniform(n),p=n=>{var e={uniformName:n};return a.getUniform(e)},d=n=>u.parameterF(n),f=n=>u.parameterV3(n),h=(n,e,t)=>m.declareFunction(n,e,t),v=(n,e,t)=>m.callFunction(n,e,t),g=(n=null,e=0)=>{var t={name:n,size:e};return s.int(t)},x=(n=null,e=0)=>{var t={name:n,size:e};return s.float(t)},S=(n=null,e=0)=>{var t={name:n,size:e,constant:!0};return s.float(t)},y=(n=null,e=0)=>{var t={name:n,size:e};return s.vec2(t)},_=(n=null,e=0)=>{var t={name:n,size:e};return s.vec3(t)},T=(n=null,e=0)=>{var t={name:n,size:e};return s.vec4(t)},D=n=>o.addVarying(n),C=n=>o.getVarying(n,o.ShaderStages.out),P=n=>o.getBuiltin(n,o.ShaderStages.out),N=n=>o.getBuiltin(n,o.ShaderStages.in),b=(n,e)=>{return c.sample2DTexture((t={uniformName:n},a.getTextureUniform(t)),e);var t};class M extends e{constructor(){super(1),this.gradingMap=null,this.gradingDepth=16,this.brightness=0,this.gamma=2.2,this.FILMIC_NRE_A=.22,this.FILMIC_NRE_B=.3,this.FILMIC_NRE_C=.1,this.FILMIC_NRE_D=.2,this.FILMIC_NRE_E=.01,this.FILMIC_NRE_F=.3,this.FILMIC_NRE_W=11.2,this.crushblacks=0,this.burnhighlights=0,this.saturation=1,this.colorCorrection=new n.Vector3(1,1,1),this.power=0,this.sensorSize=35,this.screenRatio=1,this.focalLength=38.6}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),e.loadTexture(t,r.gradingMap,this.gradingMap),t.uniform1f(r.gradingDepth,this.gradingDepth),t.uniform1f(r.brightness,this.brightness),t.uniform1f(r.gamma,this.gamma),r.FILMIC_NRE_A&&(t.uniform1f(r.FILMIC_NRE_A,this.FILMIC_NRE_A),t.uniform1f(r.FILMIC_NRE_B,this.FILMIC_NRE_B),t.uniform1f(r.FILMIC_NRE_C,this.FILMIC_NRE_C),t.uniform1f(r.FILMIC_NRE_D,this.FILMIC_NRE_D),t.uniform1f(r.FILMIC_NRE_E,this.FILMIC_NRE_E),t.uniform1f(r.FILMIC_NRE_F,this.FILMIC_NRE_F),t.uniform1f(r.FILMIC_NRE_W,this.FILMIC_NRE_W)),r.crushblacks&&(t.uniform1f(r.crushblacks,this.crushblacks),t.uniform1f(r.burnhighlights,this.burnhighlights),t.uniform1f(r.saturation,this.saturation),t.uniform3f(r.colorCorrection,this.colorCorrection.x,this.colorCorrection.y,this.colorCorrection.z)),t.uniform1f(r.power,this.power),t.uniform1f(r.sensorSize,this.sensorSize),t.uniform1f(r.screenRatio,this.screenRatio),t.uniform1f(r.focalLength,this.focalLength)}fillUBO(n,e,t){super.fillUBO(n,e,t);const r=n.layout;r.gradingMap&&(n.setTexture(r.gradingMap,this.gradingMap),n.setF(r.gradingDepth,this.gradingDepth)),n.setF(r.brightness,this.brightness),n.setF(r.gamma,this.gamma),r.FILMIC_NRE_A&&(n.setF(r.FILMIC_NRE_A,this.FILMIC_NRE_A),n.setF(r.FILMIC_NRE_B,this.FILMIC_NRE_B),n.setF(r.FILMIC_NRE_C,this.FILMIC_NRE_C),n.setF(r.FILMIC_NRE_D,this.FILMIC_NRE_D),n.setF(r.FILMIC_NRE_E,this.FILMIC_NRE_E),n.setF(r.FILMIC_NRE_F,this.FILMIC_NRE_F),n.setF(r.FILMIC_NRE_W,this.FILMIC_NRE_W)),r.crushblacks&&(n.setF(r.crushblacks,this.crushblacks),n.setF(r.burnhighlights,this.burnhighlights),n.setF(r.saturation,this.saturation),n.setV3(r.colorCorrection,this.colorCorrection)),n.setF(r.power,this.power),n.setF(r.sensorSize,this.sensorSize),n.setF(r.screenRatio,this.screenRatio),n.setF(r.focalLength,this.focalLength)}clone(){return new M}}function U(n){return`           \n            ${D({varyingName:"vUv",varyingType:"v2"})}\n\n            ${m.getMainVertexStart(n)}\n                ${T("pos")} = vec4( sign( position_.xy ), 0.0, 1.0 );\n                ${C("vUv")} = 0.5 * pos.xy + 0.5;\n                ${n.WebGPU?`${C("vUv")}=${y()}(${C("vUv")}.x,1.0-${C("vUv")}.y);`:l}\n                ${P("position")} = pos;\n            ${m.getMainVertexEnd(n)}\n        `}const w={NONE:-1,FILMIC:0,PHOTOGRAPHIC:1,UNCHARTED:2,REINHARD:3},V={NONE:-1,GAMMA_SIMPLE:0,GAMMA:1,SRGB:2};const z={USE_AUTO_EXPOSURE:0,COLOR_GRADING:!1,COLOR_TONEMAP:w.NONE,COLOR_CORRECTION:V.GAMMA_SIMPLE};return{CompositingShader:new r(new t((function(n,e){var t=e.customDefines;const r=o.getShaderOutput("out0"),a=t.COLOR_CORRECTION===V.GAMMA_SIMPLE,i=t.COLOR_CORRECTION===V.GAMMA,s=t.COLOR_CORRECTION===V.SRGB,u=t.COLOR_TONEMAP===w.FILMIC,c=t.COLOR_TONEMAP===w.PHOTOGRAPHIC,C=t.COLOR_TONEMAP===w.UNCHARTED,P=t.COLOR_TONEMAP===w.REINHARD;let M=`\n            \n            ${D({varyingName:"vUv",varyingType:"v2"})}\n\n            ${$({uniformName:"tScene",uniformType:"t2",locationName:"tInput0"})}\n            \n            ${$({uniformName:"brightness",uniformType:"f"})}\n            ${t.USE_AUTO_EXPOSURE>0?`\n                ${$({uniformName:"tAutoExposure",uniformType:"t2",locationName:"tInput1"})}\n                `:l}\n\n            ${t.COLOR_GRADING?`          \n                ${$({uniformName:"gradingMap",uniformType:"t2"})}\n                ${$({uniformName:"gradingDepth",uniformType:"f"})}\n                `:l}\n\n            ${$({uniformName:"gamma",uniformType:"f"})}\n            \n            ${$({uniformName:"power",uniformType:"f"})}\n            ${$({uniformName:"sensorSize",uniformType:"f"})}\n            ${$({uniformName:"screenRatio",uniformType:"f"})}\n            ${$({uniformName:"focalLength",uniformType:"f"})}\n\n            ${u?`\n                ${$({uniformName:"FILMIC_NRE_A",uniformType:"f"})}\n                ${$({uniformName:"FILMIC_NRE_B",uniformType:"f"})}\n                ${$({uniformName:"FILMIC_NRE_C",uniformType:"f"})}\n                ${$({uniformName:"FILMIC_NRE_D",uniformType:"f"})}\n                ${$({uniformName:"FILMIC_NRE_E",uniformType:"f"})}\n                ${$({uniformName:"FILMIC_NRE_F",uniformType:"f"})}\n                ${$({uniformName:"FILMIC_NRE_W",uniformType:"f"})}\n                `:l}\n\n            ${c?`\n                ${h("luminance_RGB","f",[f("iColor")])} {\n                    return dot(iColor,${_()}(0.176204,0.812985,0.0108109));\n                }\n                \n                ${$({uniformName:"crushblacks",uniformType:"f"})}\n                ${$({uniformName:"burnhighlights",uniformType:"f"})}\n                ${$({uniformName:"saturation",uniformType:"f"})}\n                ${$({uniformName:"colorCorrection",uniformType:"v3"})}\n                `:l}\n\n            ${C?`\n                ${S("A")} = 0.15;\n                ${S("B")} = 0.50;\n                ${S("C")} = 0.10;\n                ${S("D")} = 0.20;\n                ${S("E")} = 0.02;\n                ${S("F")} = 0.20;\n                ${S("W")} = 11.2;\n                ${h("Uncharted2Tonemap","v3",[f("x")])} {\n                    return ( ( x * ( A * x + C * B ) + D * E ) / ( x * ( A * x + B ) + D * F ) ) - E / F;\n                }\n                `:l}\n\n            ${S("dither")} = 0.004;\n\n            ${h("random","f",[f("scale"),d("seed"),f("seed2")])} {\n                return fract(sin(dot(seed2 + seed, scale)) * 43758.5453 + seed);\n            }\n\n            ${h("Random3D","v3",[d("seed"),f("seed2")])} {\n                ${_("res")};\n\n                res.x = ${v("random","f",[f(`${_()}(12.9898, 78.233, 151.7182)`),d("seed"),f("seed2")])};\n                res.y = ${v("random","f",[f(`${_()}(63.7264, 10.873, 623.6736)`),d("seed"),f("seed2")])};\n                res.z = ${v("random","f",[f(`${_()}(125.5736, 34.485, 437.2873)`),d("seed"),f("seed2")])};\n\n                return res;\n            }\n\n            ${S("fAutoExposureCount")} = ${x()}(${t.USE_AUTO_EXPOSURE});\n\n            ${m.getMainFragmentStart(e)}\n                ${y("screenUV")} = ${z="vUv",o.getVarying(z,o.ShaderStages.in)};\n\n                ${T("inColorSampled")} = ${b("tScene","screenUV")};\n                ${x("inColorAlpha")} = inColorSampled.a;\n                ${_("inColor")} = inColorSampled.rgb * pow(2.0, ${p("brightness")});\n                ${t.USE_AUTO_EXPOSURE>0?`\n                    ${y("ae_uv")} = ${y()}(0.0);\n                    ${y("sums")} = ${y()}(0.0);\n                    for (${g("i")} = 0; i < ${t.USE_AUTO_EXPOSURE}; i++) {\n                        ae_uv.x = (0.5+${x()}(i))/fAutoExposureCount;\n                        for (${g("j")} = 0; j < ${t.USE_AUTO_EXPOSURE}; j++) {\n                            ae_uv.y = (0.5+${x()}(j))/fAutoExposureCount;\n                            sums += ${b("tAutoExposure","ae_uv")}.rg;\n                        }\n                    }\n                    inColor *= 0.2176/exp(sums.x/sums.y);\n                    // NB: 0.217 = 0.5^(1/2.2) by this way after gamma correction of 2.2 we have a default luminance of 0.5 \n                    `:l}\n                // Vignetting\n                ${y("pos")} = (screenUV - 0.5) * 0.5;\n                pos.y = pos.y * ${p("screenRatio")};\n\n                ${x("f2")} = ${p("focalLength")} * ${p("focalLength")};\n                ${x("s2")} = ${p("sensorSize")} * ${p("sensorSize")};\n                ${x("vignetting")}  = pow(f2/(s2*(pos.x*pos.x+pos.y*pos.y)+f2),${p("power")});\n                \n                inColor *= vignetting;\n                inColorAlpha = max(inColorAlpha, (1.0-sqrt(vignetting)));\n\n                // Tone Mapping\n\n                ${_("outColor")} = inColor;\n\n                ${P?"\n                    outColor = inColor / (1.0 + inColor);\n                    ":l}\n                ${u?`\n                    ${T("tmpCol")}  = ${T()}(inColor.xyz, FILMIC_NRE_W);\n                    tmpCol = ((tmpCol*(FILMIC_NRE_A*tmpCol+FILMIC_NRE_C*FILMIC_NRE_B)+FILMIC_NRE_D*FILMIC_NRE_E)\n                            /(tmpCol*(FILMIC_NRE_A*tmpCol+FILMIC_NRE_B)+FILMIC_NRE_D*FILMIC_NRE_F))\n                            -FILMIC_NRE_E/FILMIC_NRE_F;\n                    outColor = tmpCol.xyz/tmpCol.w;\n                    `:l}\n                ${C?`\n                    ${x("ExposureBias")} = 2.0;\n                    ${_("curr")} = ${v("Uncharted2Tonemap","v3",[f("ExposureBias * inColor")])};\n                    ${_("whiteScale")}  = 1.0 / ${v("Uncharted2Tonemap","v3",[f(`${_("W")}`)])};\n                    outColor = curr * whiteScale;\n                    `:l}\n                ${c?`\n                    ${_("c")} = inColor * ${p("colorCorrection")};\n                    c *= (c*${p("burnhighlights")}+1.0)/(c+1.0);\n                    ${x("lumC")} = ${v("luminance_RGB","f",[f("c")])};\n                    c = mix(${_()}(lumC),c,${p("saturation")});\n                    lumC = ${v("luminance_RGB","f",[f("c")])};\n                    if (lumC < 1.0) {\n                        ${_("_crushblacks")} = ${_()}(2.0 * ${p("crushblacks")} +1.0);\n                        lumC = sqrt(lumC);\n                        ${x("oms2")}  = 1.0 - lumC;\n                        c = c*lumC + pow(c,_crushblacks)*oms2;\n                    }\n                    outColor = c;\n                    `:l}\n\n                // Gamma\n                ${a?"\n                    outColor = sqrt( outColor );\n                    ":l}\n                ${i?`\n                    outColor = pow( outColor, ${_()}( 1.0 / ${p("gamma")} ) );\n                    `:l}\n                ${s?"\n                    if (outColor.r < 0.0031308) {\n                        outColor.r = outColor.r*12.92;\n                    } else {\n                        outColor.r = 1.055*pow(outColor.r,1.0/2.4)-0.055;;\n                    }\n                    if (outColor.g < 0.0031308) {\n                        outColor.g = outColor.g*12.92;\n                    } else {\n                        outColor.g = 1.055*pow(outColor.g,1.0/2.4)-0.055;;\n                    }\n                    if (outColor.b < 0.0031308) {\n                        outColor.b = outColor.b*12.92;\n                    } else {\n                        outColor.b = 1.055*pow(outColor.b,1.0/2.4)-0.055;;\n                    }\n                    ":l}\n                // Color Grading\n\n                ${t.COLOR_GRADING?`\n                    //NRE does this I don't know why and can't make it work with it\n                    //float threshold = gradingDepth/(gradingDepth-1.0);\n                    ${x("gradingDepth_")} = ${p("gradingDepth")};\n                    ${x("threshold")}  = (gradingDepth_-1.0)/gradingDepth_;\n                    ${x("halfTexelOffset")}  = 0.5/gradingDepth_;\n                    ${x("r")} = clamp (outColor.r,0.0,1.0) * threshold + halfTexelOffset;\n                    ${x("g")} = clamp (outColor.g,0.0,1.0) * threshold + halfTexelOffset;\n                    ${x("b")} = clamp (outColor.b,0.0,1.0) *(gradingDepth_ - 1.0);\n                    ${x("bFloor")}  = floor(b);\n                    ${x("bFract")}  = b-bFloor;\n                    ${y("uv1")}  = ${y()}((bFloor+r)/(gradingDepth_),g);\n                    ${y("uv2")}  = ${y()}((bFloor+1.0+r)/(gradingDepth_),g);\n                    ${_("c1")}  = ${b("gradingMap","uv1")}.rgb;\n                    ${_("c2")}  = ${b("gradingMap","uv2")}.rgb;\n                    outColor = bFract*c2+(1.0-bFract)*c1;\n                    `:l}\n\n                // Dithering\n                outColor += 2.0 * dither * (${v("Random3D","v3",[d("screenUV.x + screenUV.y"),f(`${N("fragCoord")}.xyz`)])} - 0.5);\n                //\n                ${r} = ${T()}(outColor, inColorAlpha);           \n            ${m.getMainFragmentEnd(e)}\n        `;var z;return{vertexShader:U(e),fragmentShader:M}}),"Compositing"),M,z),ToneMapEnum:w,ColorCorrectionEnum:V}})),define("DS/ShaderBuilders/PostPro/BlendingShaderBuilders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PostPro/PostProUniformHandler","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/PostPro/PostProContext","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a,o,i,s){"use strict";const l="",u=i.ParameterUtils,m=i.FunctionHandler,c=i.BridgeFunctions,$=n=>s.dereference(n),p=n=>a.addUniform(n),d=n=>{var e={uniformName:n};return a.getUniform(e)},f=n=>u.parameterF(n),h=n=>u.parameterV2(n),v=n=>u.parameterV3(n),g=n=>u.parameterV4(n),x=n=>u.parameterInOutV2(n),S=n=>u.parameterInOutV4(n),y=n=>u.parameterRefV2(n),_=n=>u.parameterRefV3(n),T=n=>u.parameterRefV4(n),D=(n,e,t)=>m.declareFunction(n,e,t),C=(n,e,t)=>m.callFunction(n,e,t),P=(n=null)=>{var e={name:n};return s.bool(e)},N=(n=null)=>{var e={name:n};return s.int(e)},b=(n=null,e=0)=>{var t={name:n,size:e};return s.float(t)},M=(n=null,e=0)=>{var t={name:n,size:e};return s.vec2(t)},U=(n=null,e=0)=>{var t={name:n,size:e};return s.vec3(t)},w=(n=null,e=0)=>{var t={name:n,size:e};return s.vec4(t)},V=(n=null)=>{var e={name:n};return s.bvec4(e)},z=n=>o.addVarying(n),F=n=>o.getVarying(n,o.ShaderStages.in),I=n=>o.getVarying(n,o.ShaderStages.out),R=(n,e)=>{return c.sample2DTexture((t={uniformName:n},a.getTextureUniform(t)),e);var t};function A(e){return`          \n            ${z({varyingName:"vUv",varyingType:"v2"})}\n\n            ${m.getMainVertexStart(e)}\n                ${I("vUv")} = uv.xy;\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(e)}\n            ${m.getMainVertexEnd(e)}\n\n        `}class L extends e{constructor(){super(1),this.invSize=new n.Vector2(1,1),this.realProjectionMatrixInverse=new n.Matrix4,this.near=1,this.far=1e3,this.edlRadius=1.4,this.edlStrength=.4,this.samplingPoints=null}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform2f(r.invSize,this.invSize.x,this.invSize.y),t.uniformMatrix4fv(r.realProjectionMatrixInverse,!1,e.float32Matrix4x4Temp.setDoubles(this.realProjectionMatrixInverse.elements)),t.uniform1f(r.near,this.near),t.uniform1f(r.far,this.far),t.uniform1f(r.edlRadius,this.edlRadius),t.uniform1f(r.edlStrength,this.edlStrength),t.uniform4fv(r.samplingPoints,this.samplingPoints)}fillUBO(n,e,t){super.fillUBO(n,e,t);const r=n.layout;n.setV2(r.invSize,this.invSize),n.setM4(r.realProjectionMatrixInverse,this.realProjectionMatrixInverse),n.setF(r.near,this.near),n.setF(r.far,this.far),n.setF(r.edlRadius,this.edlRadius),n.setF(r.edlStrength,this.edlStrength),n.setFlatV2Array(r.samplingPoints,this.samplingPoints)}clone(){var n=new L;return n.invSize=this.invSize,n.realProjectionMatrixInverse=this.realProjectionMatrixInverse,n.near=this.near,n.far=this.far,n.edlRadius=this.edlRadius,n.edlStrength=this.edlStrength,n.samplingPoints=this.samplingPoints,n}}class B extends e{constructor(){super(1),this.offset=new n.Vector2(0,0),this.invSize=new n.Vector2(1,1),this.alphaMul=1,this.alphaAdd=0}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform2f(r.offset,this.offset.x,this.offset.y),t.uniform2f(r.invSize,this.invSize.x,this.invSize.y),t.uniform1f(r.alphaMul,this.alphaMul),t.uniform1f(r.alphaAdd,this.alphaAdd)}fillUBO(n,e,t){super.fillUBO(n,e,t);const r=n.layout;n.setV2(r.offset,this.offset),n.setV2(r.invSize,this.invSize),n.setF(r.alphaMul,this.alphaMul),n.setF(r.alphaAdd,this.alphaAdd)}clone(){var n=new B;return n.offset=this.offset,n.invSize=this.invSize,n.alphaAdd=this.alphaAdd,n.alphaMul=this.alphaMul,n}}class E extends B{constructor(){super(),this.blendWeight=1}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform1f(r.blendWeight,this.blendWeight)}fillUBO(n,e,t){super.fillUBO(n,e,t);const r=n.layout;n.setF(r.blendWeight,this.blendWeight)}clone(){var n=new E;return n.blendWeight=this.blendWeight,n}}class k extends e{constructor(){super(0),this.alphaMul=1,this.alphaAdd=0}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform1f(r.alphaMul,this.alphaMul),t.uniform1f(r.alphaAdd,this.alphaAdd)}fillUBO(n,e,t){super.fillUBO(n,e,t);const r=n.layout;n.setF(r.alphaMul,this.alphaMul),n.setF(r.alphaAdd,this.alphaAdd)}clone(){var n=new k;return n.alphaAdd=this.alphaAdd,n.alphaMul=this.alphaMul,n}}const O={POSTPRO:1},G={EDL:!1};return{TextureAlphaBlend:new r(new t((function(n,e){var t=e.customDefines;const r=o.getShaderOutput("out0");let a=`\n            \n            ${z({varyingName:"vUv",varyingType:"v2"})}\n            \n            ${t.POSTPRO?p({uniformName:"tScene",uniformType:"t2",locationName:"tInput0"}):l}\n            ${p({uniformName:"tBlendingTexture",uniformType:"t2",locationName:"tInput1"})}\n\n            ${p({uniformName:"offset",uniformType:"v2"})}\n            ${p({uniformName:"invSize",uniformType:"v2"})}\n            ${p({uniformName:"alphaAdd",uniformType:"f"})}\n            ${p({uniformName:"alphaMul",uniformType:"f"})}\n\n            ${m.getMainFragmentStart(e)}\n                ${M("screenUV")} = (${F("vUv")} - ${d("offset")}) * ${d("invSize")};\n                ${w("sampling")} = ${R("tBlendingTexture","screenUV")};\n                ${U("color")} = sampling.rgb;\n                ${b("alpha")} = sampling.a;\n\n                ${t.POSTPRO?`               \n\t\t\t\t\t${w("sceneSampling")} = ${R("tScene","screenUV")};\n                    ${r} = ${w()}(color * alpha + (1.0 - alpha) * sceneSampling.rgb, alpha + sceneSampling.a * (1.0 - alpha));\n                    `:`\n                    ${r} = ${w()}(color, alpha);\n                    `}\n                ${b("finalAlpha")} = ${d("alphaMul")} * ${r}.a + ${d("alphaAdd")};\n                ${r} = ${w()}(${r}.rgb, finalAlpha);\n            ${m.getMainFragmentEnd(e)}\n        `;return{vertexShader:A(e),fragmentShader:a}}),"TextureAlphaBlend"),B,O),TextureAlphaBlend2:new r(new t((function(n,e){var t=e.customDefines;const r="tScene",a=o.getShaderOutput("out0");let i=`\n            ${z({varyingName:"vUv",varyingType:"v2"})}\n\n            ${t.POSTPRO?p({uniformName:"tScene",uniformType:"t2",locationName:"tInput0"}):l}\n            ${p({uniformName:"tBlendingTexture",uniformType:"t2",locationName:"tInput1"})}\n\n            ${p({uniformName:"offset",uniformType:"v2"})}\n            ${p({uniformName:"invSize",uniformType:"v2"})}\n            ${p({uniformName:"alphaAdd",uniformType:"f"})}\n            ${p({uniformName:"alphaMul",uniformType:"f"})}\n\n            ${m.getMainFragmentStart(e)}\n                ${t.COPY?`\n                    ${M("screenUV")} = (${F("vUv")} - ${d("offset")});\n                    ${a} = ${R(r,"screenUV")};\n                    `:`\n                    ${M("screenUV")} = (${F("vUv")} - ${d("offset")});\n                    ${w("sampling")} = ${R("tBlendingTexture","screenUV")};\n                    //sampling = vec4(sampling.rgb / sampling.w, sign(sampling.w));\n\n                    ${U("color")} = clamp(sampling.rgb, vec3(0.0), vec3(1.0));\n                    ${b("alpha")} = clamp(sampling.a, 0.0, 1.0);\n\n                    ${t.POSTPRO?`\n                        ${w("sceneSampling")} = ${R(r,"screenUV")};\n                        ${a} = ${w()}(color * alpha + (1.0 - alpha) * sceneSampling.rgb, alpha + sceneSampling.a * (1.0 - alpha));\n                        `:`\n                        ${a} = ${w()}(color, alpha);\n                        `}\n                    ${b("finalAlpha")} = ${d("alphaMul")} * ${a}.a + ${d("alphaAdd")};\n                    ${a} = ${w()}(${a}.rgb, finalAlpha);\n                    `}\n            ${m.getMainFragmentEnd(e)}\n        `;return{vertexShader:A(e),fragmentShader:i}}),"TextureAlphaBlend2"),B,{POSTPRO:1,COPY:!1}),TextureAlphaBlend3:new r(new t((function(n,e){var t=e.customDefines;const r=o.getShaderOutput("out0");let a=`\n            ${z({varyingName:"vUv",varyingType:"v2"})}\n\n            ${t.POSTPRO?p({uniformName:"tScene",uniformType:"t2",locationName:"tInput0"}):l}\n            ${p({uniformName:"tBlendingTexture",uniformType:"t2",locationName:"tInput1"})}\n\n            ${p({uniformName:"offset",uniformType:"v2"})}\n            ${p({uniformName:"invSize",uniformType:"v2"})}\n            ${p({uniformName:"alphaAdd",uniformType:"f"})}\n            ${p({uniformName:"alphaMul",uniformType:"f"})}\n            ${p({uniformName:"blendWeight",uniformType:"f"})}\n\n            ${m.getMainFragmentStart(e)}\n\n                ${M("screenUV")} = (${F("vUv")} - ${d("offset")});\n                ${w("sampling")} = ${R("tBlendingTexture","screenUV")};\n\n                ${t.EFFECTONLY?`\n                    ${U("color")} = vec3(sampling.rgb);\n                    ${r} = ${w()}(color, 1.0);\n                    `:`\n                    ${U("color")} = vec3(0.0);\n                    ${b("alpha")} = clamp(1.0 - sampling.r, 0.0, 1.0);\n                    ${w("sceneSampling")} = ${R("tScene","screenUV")};\n                    ${r} = ${w()}(color * alpha + (1.0 - alpha) * sceneSampling.rgb, alpha + sceneSampling.a * (1.0 - alpha));\n                    `}\n                ${b("finalAlpha")} = ${d("alphaMul")} * ${r}.a + ${d("alphaAdd")};\n                ${r} = ${w()}(${r}.rgb, finalAlpha);\n\n            ${m.getMainFragmentEnd(e)}\n        `;return{vertexShader:A(e),fragmentShader:a}}),"TextureAlphaBlend3"),E,{POSTPRO:1,EFFECTONLY:!1}),CopyBlend:new r(new t((function(n,e){var t=e.customDefines;const r=o.getShaderOutput("out0");let a=`\n            \n            ${z({varyingName:"vUv",varyingType:"v2"})}\n            \n            ${t.POSTPRO?p({uniformName:"tInput",uniformType:"t2"}):l}\n            ${p({uniformName:"alphaAdd",uniformType:"f"})}\n            ${p({uniformName:"alphaMul",uniformType:"f"})}\n\n            ${m.getMainFragmentStart(e)}\n                ${M("screenUV")} = ${F("vUv")};\n\n                ${t.POSTPRO?`               \n\t\t\t\t\t${w("sceneSampling")} = ${R("tInput","screenUV")};\n                    ${r} = ${w()}(sceneSampling.rgb, sceneSampling.a);\n                    `:`\n                    ${r} = ${w()}(0.0);\n                    `}\n                ${b("finalAlpha")} = ${d("alphaMul")} * ${r}.a + ${d("alphaAdd")};\n                ${r} = ${w()}(${r}.rgb, finalAlpha);\n            ${m.getMainFragmentEnd(e)}\n        `;return{vertexShader:A(e),fragmentShader:a}}),"CopyBlend"),k,O),PointCloudEDL:new r(new t((function(n,e){e.customDefines;const t=o.getShaderOutput("out0");let r=`\n\n            ${z({varyingName:"vUv",varyingType:"v2"})}\n            ${p({uniformName:"invSize",uniformType:"v2"})}\n            ${p({uniformName:"tAccum",uniformType:"t2",locationName:"tInput0"})}\n            ${p({uniformName:"tNormalDepth",uniformType:"t2",locationName:"tInput1"})}\n            ${p({uniformName:"near",uniformType:"f"})}\n            ${p({uniformName:"far",uniformType:"f"})}\n            ${p({uniformName:"realProjectionMatrixInverse",uniformType:"m4"})}\n            ${p({uniformName:"edlRadius",uniformType:"f"})}\n            ${p({uniformName:"edlStrength",uniformType:"f"})}\n            ${p({uniformName:"samplingPoints",uniformType:"fv4",size:8})}\n\n            ${D("getDepth","f",[h("iUV")])} {\n\n                ${b("depth")} = ${C("unpackRGBA","f",[g(R("tNormalDepth","iUV"))])};\n                if (depth == 0.0) { depth = 1.0; }\n                return depth;\n            }\n\n            ${D("getLinearDepth","f",[h("iUV")])} {\n\n                ${b("depth")} = ${C("unpackRGBA","f",[g(R("tNormalDepth","iUV"))])};\n                if (depth == 0.0) { depth = 1.0; }\n\n                return ${d("near")} * ${d("far")} / (${d("far")} - depth * (${d("far")} - ${d("near")}));\n            }\n\n            ${D("getLinearAndNormalizedDepth","f",[h("iUV")])} {\n\n                ${b("depth")} = ${C("getDepth","f",[h("iUV")])};\n                return depth * ${d("near")} / (${d("far")} - depth * (${d("far")} - ${d("near")}));\n            }\n\n            ${D("computeObscurance","f",[h("uv"),f("depth")])} {\n\n                ${M("uvRadius")} = ${d("edlRadius")} * ${d("invSize")};\n                ${b("sum")} = 0.0;\n\n                for (${N("i")} = 0; i < 8; i++) {\n\n                    ${M("neighbour")} = ${d("samplingPoints")}[i].xy;\n                    ${M("uvNeighbor")} = uv + uvRadius * neighbour;\n                    ${b("neighbourDepth")} = ${C("getLinearAndNormalizedDepth","f",[h("uvNeighbor")])};\n                    sum += max(0.0, depth - neighbourDepth);\n\n                }\n                return sum / 8.0;\n            }\n\n            ${m.getMainFragmentStart(e)}\n\n                ${M("screenUV")} = ${F("vUv")};\n\n                ${b("depth")} = ${C("getLinearAndNormalizedDepth","f",[h("screenUV")])};\n                ${b("edl")} = ${C("computeObscurance","f",[h("screenUV"),f("depth")])};\n                ${b("shade")} = exp(-edl * 300.0 * ${d("edlStrength")});\n\n                ${t} = vec4(0.0, 0.0, 0.0, 1.0 - shade);\n\n            ${m.getMainFragmentEnd(e)}\n        `;return{vertexShader:A(e),fragmentShader:r}}),"PointCloudEDL"),L,G),PointCloudResolve:new r(new t((function(n,e){var t=e.customDefines;const r=o.getShaderOutput("out0");let a=`\n\n            ${z({varyingName:"vUv",varyingType:"v2"})}\n            ${p({uniformName:"invSize",uniformType:"v2"})}\n            ${p({uniformName:"tAccum",uniformType:"t2",locationName:"tInput0"})}\n            ${p({uniformName:"tNormalDepth",uniformType:"t2",locationName:"tInput1"})}\n            ${p({uniformName:"near",uniformType:"f"})}\n            ${p({uniformName:"far",uniformType:"f"})}\n            ${p({uniformName:"realProjectionMatrixInverse",uniformType:"m4"})}\n            ${p({uniformName:"edlRadius",uniformType:"f"})}\n            ${p({uniformName:"edlStrength",uniformType:"f"})}\n            ${p({uniformName:"samplingPoints",uniformType:"fv4",size:8})}\n\n            ${D("getDepth","f",[h("iUV")])} {\n\n                ${b("depth")} = ${C("unpackRGBA","f",[g(R("tNormalDepth","iUV"))])};\n                if (depth == 0.0) { depth = 1.0; }\n                return depth;\n            }\n\n            ${D("getLinearDepth","f",[h("iUV")])} {\n\n                ${b("depth")} = ${C("unpackRGBA","f",[g(R("tNormalDepth","iUV"))])};\n                if (depth == 0.0) { depth = 1.0; }\n\n                //${M("xy")} = iUV * 2.0 - 1.0;\n                //${w("posProjected")} = ${w()}(xy, 2.0 * depth - 1.0, 1.0);\n                //${w("posVS")}  = ${d("realProjectionMatrixInverse")} * posProjected;\n                //return -posVS.z / posVS.w;\n                return ${d("near")} * ${d("far")} / (${d("far")} - depth * (${d("far")} - ${d("near")}));\n            }\n\n            ${D("getLinearAndNormalizedDepth","f",[h("iUV")])} {\n\n                //${b("depth")} = ${C("getLinearDepth","f",[h("iUV")])};\n                //return (depth - ${d("near")}) / (${d("far")} - ${d("near")});\n                ${b("depth")} = ${C("getDepth","f",[h("iUV")])};\n                return depth * ${d("near")} / (${d("far")} - depth * (${d("far")} - ${d("near")}));\n            }\n\n            ${D("computeObscurance","f",[h("uv"),f("depth")])} {\n\n                ${M("uvRadius")} = ${d("edlRadius")} * ${d("invSize")};\n                ${b("sum")} = 0.0;\n\n                for (${N("i")} = 0; i < 8; i++) {\n\n                    ${M("neighbour")} = ${d("samplingPoints")}[i].xy;\n                    ${M("uvNeighbor")} = uv + uvRadius * neighbour;\n                    ${b("neighbourDepth")} = ${C("getLinearAndNormalizedDepth","f",[h("uvNeighbor")])};\n                    //neighbourDepth = (neighbourDepth == 1.0) ? 0.0 : neighbourDepth;\n                    //if(neighbourDepth != 0.0) {\n                        //if(depth == 0.0) {\n                        //    sum += 100.0;\n                        //}\n                        //else {\n                            sum += max(0.0, depth - neighbourDepth);\n                        //}\n                    //}\n\n                }\n                return sum / 8.0;\n            }\n\n            ${m.getMainFragmentStart(e)}\n\n                ${M("screenUV")} = ${F("vUv")};\n                ${w("colorAccum")} = ${R("tAccum","screenUV")};\n                //float depth = getDepth(screenUV);\n\n                ${t.EDL?`\n                        ${b("depth")} = ${C("getLinearAndNormalizedDepth","f",[h("screenUV")])}; //getDepth(screenUV);\n                        //if (depth > 0.999) { discard; }\n                        ${b("edl")} = ${C("computeObscurance","f",[h("screenUV"),f("depth")])};\n                        ${b("shade")} = exp(-edl * 300.0 * ${d("edlStrength")});\n\n                        ${r} = vec4(shade * colorAccum.rgb / colorAccum.w, sign(colorAccum.w + edl - 0.0001));\n                    `:`\n                    //${r} = vec4(colorAccum.rgb / colorAccum.w, sign(depth));\n                    ${r} = vec4(colorAccum.rgb / colorAccum.w, sign(colorAccum.w));\n                    `}\n            ${m.getMainFragmentEnd(e)}\n        `;return{vertexShader:A(e),fragmentShader:a}}),"PointCloudResolve"),L,G),PointCloudResolveAndFillHoles:new r(new t((function(n,e){var t=e.customDefines;const r=o.getShaderOutput("out0");let a=`\n            \n            ${z({varyingName:"vUv",varyingType:"v2"})}\n            ${p({uniformName:"invSize",uniformType:"v2"})}\n\n            //${t.POSTPRO?p({uniformName:"tScene",uniformType:"t2",locationName:"tInput0"}):l}\n            ${p({uniformName:"tAccum",uniformType:"t2",locationName:"tInput0"})}\n            ${p({uniformName:"tNormalDepth",uniformType:"t2",locationName:"tInput1"})}\n            ${p({uniformName:"near",uniformType:"f"})}\n            ${p({uniformName:"far",uniformType:"f"})}\n            ${p({uniformName:"realProjectionMatrixInverse",uniformType:"m4"})}\n            ${p({uniformName:"edlRadius",uniformType:"f"})}\n            ${p({uniformName:"edlStrength",uniformType:"f"})}\n            ${p({uniformName:"samplingPoints",uniformType:"fv4",size:8})}\n\n            ${D("getPointVS","v3",[h("iUV")])} {\n\n                ${b("depth")} = ${C("unpackRGBA","f",[g(R("tNormalDepth","iUV"))])};\n\n                depth = ${c.getDepthWithConvention("depth")};\n                ${M("xy")} = iUV * 2.0 - 1.0;\n                ${w("posProjected")} = ${w()}(xy, depth, 1.0);\n                ${w("posVS")} = ${d("realProjectionMatrixInverse")} * posProjected;\n                posVS.x /= posVS.w;\n                posVS.y /= posVS.w;\n                posVS.z /= posVS.w;\n\n                return posVS.xyz;\n            }\n\n            ${D("getDepth","f",[h("iUV")])} {\n\n                return ${C("unpackRGBA","f",[g(R("tNormalDepth","iUV"))])};\n            }\n\n            ${D("getLinearDepth","f",[h("iUV")])} {\n\n                ${b("depth")} = ${C("unpackRGBA","f",[g(R("tNormalDepth","iUV"))])};\n                if (depth == 0.0) { depth = 1.0; }\n                \n                depth = ${c.getDepthWithConvention("depth")};\n                ${M("xy")} = iUV * 2.0 - 1.0;\n                ${w("posProjected")} = ${w()}(xy, depth, 1.0);\n                ${w("posVS")}  = ${d("realProjectionMatrixInverse")} * posProjected;\n                return -posVS.z / posVS.w;\n            }\n\n            ${D("getLinearDepth2","f",[f("iDepth"),h("iUV")])} {\n\n                //${M("xy")} = iUV * 2.0 - 1.0;\n\n                //${w("posProjected")} = ${w()}(xy, 2.0 * iDepth - 1.0, 1.0);\n                //${w("posVS")}  = ${d("realProjectionMatrixInverse")} * posProjected;\n                //return -posVS.z / posVS.w;\n                return ${d("near")} * ${d("far")} / (${d("far")} - iDepth * (${d("far")} - ${d("near")}));\n            }\n\n            ${D("getLinearAndNormalizedDepth","f",[h("iUV")])} {\n\n                //${b("depth")} = ${C("getLinearDepth","f",[h("iUV")])};\n                //return (depth - ${d("near")}) / (${d("far")} - ${d("near")});\n                ${b("depth")} = ${C("getDepth","f",[h("iUV")])};\n                if (depth == 0.0) { depth = 1.0; }\n                return depth * ${d("near")} / (${d("far")} - depth * (${d("far")} - ${d("near")}));\n            }\n\n            ${D("getLinearAndNormalizedDepth2","f",[f("iDepth"),h("iUV")])} {\n\n                //${b("depth")} = ${C("getLinearDepth2","f",[f("iDepth"),h("iUV")])};\n                //return (depth - ${d("near")}) / (${d("far")} - ${d("near")});\n                return iDepth * ${d("near")} / (${d("far")} - iDepth * (${d("far")} - ${d("near")}));\n            }\n\n            ${D("computeObscurance","f",[h("uv"),f("depth")])} {\n\n                ${M("uvRadius")} = ${d("edlRadius")} * ${d("invSize")};\n                ${b("sum")} = 0.0;\n\n                for(${N("i")} = 0; i < 8; i++) {\n\n                    ${M("neighbour")} = ${d("samplingPoints")}[i].xy;\n                    ${M("uvNeighbor")} = uv + uvRadius * neighbour;\n                    ${b("neighbourDepth")} = ${C("getLinearAndNormalizedDepth","f",[h("uvNeighbor")])};\n                    //neighbourDepth = (neighbourDepth == 1.0) ? 0.0 : neighbourDepth;\n                    //if(neighbourDepth != 0.0) {\n                    //    if(depth == 0.0) {\n                    //        sum += 100.0;\n                    //    }\n                    //    else {\n                            sum += max(0.0, depth - neighbourDepth);\n                    //    }\n                    //}\n\n                }\n                return sum / 8.0;\n            }\n\n            //bool isNear(float depth1, float depth2) {\n                \n            //    return abs(depth1 - depth2) < 0.1;\n            //}\n\n            ${D("isNear","b",[v("pos1"),v("pos2")])} {\n\n                ${U("diff")} = pos2 - pos1;\n                return dot(diff, diff) < 1.0;\n            }\n\n            ${D("computeBarycentricCoords","b",[(i="coords",u.parameterInOutV3(i)),h("uv"),h("uv1"),h("uv2"),h("uv3")])} {\n            //bool computeBarycentricCoords(out vec3 coords, vec2 uv, vec2 uv1, vec2 uv2, vec2 uv3) {\n\n                ${M("texSize")} = 1.0 / ${d("invSize")};\n                ${M("v1")} = texSize * (uv  - uv3);\n                ${M("v2")} = texSize * (uv1 - uv3);\n                ${M("v3")} = texSize * (uv2 - uv3);\n                ${b("det")} = v2.x * v3.y - v3.x * v2.y;\n\n                if (det < 0.0001) {\n                    return false;\n                }\n\n                coords.x = (v3.y * v1.x - v3.x * v1.y) / det;\n                coords.y = (v2.x * v1.y - v2.y * v1.x) / det;\n                coords.z = 1.0 - coords.x - coords.y;\n                return (coords.x >= 0.0);\n            }\n\n            ${D("computeCoordsDistance","v2",[h("uv"),h("uv1"),h("uv2")])} {\n\n                ${M("texSize")} = 1.0 / ${d("invSize")};\n                ${M("v1")} = texSize * (uv - uv1);\n                ${M("v2")} = texSize * (uv - uv2);\n                ${b("l1")} = length(v1);\n                ${b("l2")} = length(v2);\n                return vec2(l2 / (l1 + l2), l1 / (l1 + l2));\n            }\n\n            ${D("fillLineBool","b",[S("outColor"),h("uv"),h("uv1"),h("uv2")])} {\n            //bool fillLineBool(out vec4 outColor, vec2 uv, vec2 uv1, vec2 uv2) {\n\n                ${U("pos1")} = ${C("getPointVS","v3",[h("uv1")])};\n                ${U("pos2")} = ${C("getPointVS","v3",[h("uv2")])};\n\n                if (!${C("isNear","b",[v("pos1"),v("pos2")])}) {\n\n                    return false;\n\n                } else {\n\n                    ${w("color1")} = ${R("tAccum","uv1")};\n                    ${w("color2")} = ${R("tAccum","uv2")};\n                    color1 = vec4(color1.rgb / color1.w, 1.0);\n                    color2 = vec4(color2.rgb / color2.w, 1.0);\n\n                    ${M("coords")} = ${C("computeCoordsDistance","v2",[h("uv"),h("uv1"),h("uv2")])};\n                    ${$("outColor")} = coords.x * color1 + coords.y * color2;\n\n                    return true;\n                }\n            }\n\n            ${D("fillLine",null,[S("outColor"),h("uv"),h("uv1"),h("uv2")])} {\n            //void fillLine(out vec4 outColor, vec2 uv, vec2 uv1, vec2 uv2) {\n\n                ${U("pos1")} = ${C("getPointVS","v3",[h("uv1")])};\n                ${U("pos2")} = ${C("getPointVS","v3",[h("uv2")])};\n                ${w("color1")} = ${R("tAccum","uv1")};\n                ${w("color2")} = ${R("tAccum","uv2")};\n                color1 = vec4(color1.rgb / color1.w, 1.0);\n                color2 = vec4(color2.rgb / color2.w, 1.0);\n\n                if (!${C("isNear","b",[v("pos1"),v("pos2")])}) {\n\n                    ${P("isFar")} = pos1.z > pos2.z;\n                    if (isFar) {\n                        ${$("outColor")} = color1;\n                    } else {\n                        ${$("outColor")} = color2;\n                    }\n\n                } else {\n\n                    ${M("coords")} = ${C("computeCoordsDistance","v2",[h("uv"),h("uv1"),h("uv2")])};\n                    ${$("outColor")} = coords.x * color1 + coords.y * color2;\n                }\n            }\n\n            ${D("fillTriangle","b",[S("outColor"),h("uv"),h("uv1"),h("uv2"),h("uv3")])} {\n            //bool fillTriangle(out vec4 outColor, vec2 uv, vec2 uv1, vec2 uv2, vec2 uv3) {\n\n                ${U("pos1")} = ${C("getPointVS","v3",[h("uv1")])};\n                ${U("pos2")} = ${C("getPointVS","v3",[h("uv2")])};\n\n                if (!${C("isNear","b",[v("pos1"),v("pos2")])}) {\n                    return false;\n                }\n                ${U("pos3")} = ${C("getPointVS","v3",[h("uv3")])};\n                if (!${C("isNear","b",[v("pos1"),v("pos3")])}) {\n                    return false;\n                }\n                if (!${C("isNear","b",[v("pos2"),v("pos3")])}) {\n                    return false;\n                }\n\n                ${U("coords")};\n                if (!${C("computeBarycentricCoords","b",[_("coords"),h("uv"),h("uv1"),h("uv2"),h("uv3")])}) { //computeBarycentricCoords(coords, uv, uv1, uv2, uv3)) {\n                    return false;\n                }\n\n                ${w("color1")} = ${R("tAccum","uv1")};\n                ${w("color2")} = ${R("tAccum","uv2")};\n                ${w("color3")} = ${R("tAccum","uv3")};\n                color1 = ${w()}(color1.rgb / color1.w, 1.0); //vec4(color1.rgb / color1.w, 1.0);\n                color2 = vec4(color2.rgb / color2.w, 1.0);\n                color3 = vec4(color3.rgb / color3.w, 1.0);\n\n                ${$("outColor")} = coords[0] * color1 + coords[1] * color2 + coords[2] * color3;\n\n                return true;\n            }\n\n            ${D("isValidPattern","b",[x("coords"),h("uv"),h("offset"),f("depth")])} {\n            //bool isValidPattern(out vec2 coords, vec2 uv, vec2 offset, float depth) {\n\n                ${((n=null)=>{var e={name:n,constant:!0};return s.int(e)})("maxValid")} = 3;\n                ${b("minDepth")} = depth;\n                ${N("nbValid")} = 0;\n\n                for (${N("ii")} = 1; ii <= 7; ii++) {\n\n                    if (nbValid < maxValid) {\n                        ${M("offsetUV")} = (${b()}(ii) * offset) + uv;\n                        ${V("inScreen4")} = ${V()}(offsetUV.x >= 0.0, offsetUV.x <= 1.0, offsetUV.y >= 0.0, offsetUV.y <= 1.0);\n                        if (!all(inScreen4)) { break; }\n                        \n                        //float localDepth = ${R("tNormalDepth","offsetUV")}.w;\n                        ${b("localDepth")} = ${C("getDepth","f",[h("offsetUV")])};\n                        if (localDepth == 0.0) { localDepth = 1.0; }\n                        //float j = m(t);\n                        if (localDepth < minDepth) {\n                            ${$("coords")} = offsetUV;\n                            nbValid++;\n                            minDepth = localDepth;// - 0.05;\n                        }\n                    }\n                }\n\n                return (nbValid != 0);\n            }\n\n            ${D("isValidPatternSmall","b",[x("coords"),h("uv"),h("offset"),f("depth")])} {\n            //bool isValidPatternSmall(out vec2 coords, vec2 uv, vec2 offset, float depth) {\n\n                for (${N("ii")} = 1; ii <= 2; ii++) {\n\n                    ${M("offsetUV")} = (${b()}(ii) * offset) + uv;\n                    //float localDepth = ${R("tNormalDepth","offsetUV")}.w;\n                    ${b("localDepth")} = ${C("getDepth","f",[h("offsetUV")])};\n                    if (localDepth == 0.0) { localDepth = 1.0; }\n                    //float j = m(t);\n                    if (localDepth < depth) {\n                        ${$("coords")} = offsetUV;\n                        return true;\n                    }\n                }\n\n                return false;\n            }\n\n            ${m.getMainFragmentStart(e)}\n\n                ${M("screenUV")} = ${F("vUv")};\n\n                ${b("depth")} = ${C("getDepth","f",[h("screenUV")])};\n                ${b("depthModif")} = depth;\n                if (depthModif == 0.0) { depthModif = 1.0; }\n                //if (depthModif == 0.0) { discard; }\n                \n                ${w("colorAccum")} = ${R("tAccum","screenUV")};\n\n                ${t.EDL?`\n                    ${b("linearDepth")} = ${C("getLinearAndNormalizedDepth2","f",[f("depthModif"),h("screenUV")])};\n                    ${b("edl")} = ${C("computeObscurance","f",[h("screenUV"),f("linearDepth")])};\n                    ${b("shade")} = exp(-edl * 300.0 * ${d("edlStrength")});\n                    `:l}\n\n                //float j = m(eo);\n                //float depthModif = j - 0.05;\n                ${w("outColor")};\n                ${b("dx")} = ${d("invSize")}.x;\n                ${b("dy")} = ${d("invSize")}.y;\n                ${M("coords0")};\n                ${M("coords1")};\n                ${M("coords2")};\n                ${M("coords3")};\n                ${M("coords4")};\n                ${M("coords5")};\n                ${M("coords6")};\n                ${M("coords7")};\n                ${M("offset0")} = ${M()}(0, -dy);\n                ${M("offset1")} = ${M()}(dx, -dy);\n                ${M("offset2")} = ${M()}(dx, 0);\n                ${M("offset3")} = ${M()}(dx, dy);\n                ${M("offset4")} = ${M()}(0, dy);\n                ${M("offset5")} = ${M()}(-dx, dy);\n                ${M("offset6")} = ${M()}(-dx, 0);\n                ${M("offset7")} = ${M()}(-dx, -dy);\n                //isValidPattern(coords0, screenUV, vec2(  0,-dy), depthModif);\n                ${P("y0")}   = ${C("isValidPattern","b",[y("coords0"),h("screenUV"),h("offset0"),f("depthModif")])};\n                ${P("x1y0")} = ${C("isValidPattern","b",[y("coords1"),h("screenUV"),h("offset1"),f("depthModif")])};\n                ${P("x1")}   = ${C("isValidPattern","b",[y("coords2"),h("screenUV"),h("offset2"),f("depthModif")])};\n                ${P("x1y1")} = ${C("isValidPattern","b",[y("coords3"),h("screenUV"),h("offset3"),f("depthModif")])};\n                ${P("y1")}   = ${C("isValidPattern","b",[y("coords4"),h("screenUV"),h("offset4"),f("depthModif")])};\n                ${P("x0y1")} = ${C("isValidPattern","b",[y("coords5"),h("screenUV"),h("offset5"),f("depthModif")])};\n                ${P("x0")}   = ${C("isValidPattern","b",[y("coords6"),h("screenUV"),h("offset6"),f("depthModif")])};\n                ${P("x0y0")} = ${C("isValidPattern","b",[y("coords7"),h("screenUV"),h("offset7"),f("depthModif")])};\n\n                ${P("success")} = false;\n\n                //if (y0 || x1y0 || x1 || x1y1 || y1 || x0y1 || x0 || x0y0) {\n                //if (y0 && x1y1 && x0y1) {\n                //if (depthModif==1.0 && y0) {\n                //if (y0) {\n                //    outColor = vec4(1.0, 0.0, 0.0, 1.0);\n                //} else {\n                //    outColor = vec4(colorAccum.rgb / colorAccum.w, 1.0);\n                //}\n                //if (y0 || x1y0 || x1 || x1y1 || y1 || x0y1 || x0 || x0y0) {\n                //    outColor = vec4(colorAccum.rgb / colorAccum.w, 1.0);\n                //} else {\n                //    outColor = vec4(0.0, 1.0, 0.0, 1.0);\n                //}\n                //if (depthModif>=0.1) {\n                //    outColor = vec4(1.0, 0.0, 0.0, 1.0);\n                //} else {\n                //    outColor = vec4(0.0, 1.0, 0.0, 1.0);\n                //}\n                //${r} = vec4(pow(depthModif,5.0),0.0,0.0,1.0);\n                //outColor = vec4(screenUV, 0.0, 1.0);\n                //${r} = outColor;\n                //return;\n\n                if (y0 && x1y1 && x0y1) {\n                    success = ${C("fillTriangle","b",[T("outColor"),h("screenUV"),h("coords0"),h("coords3"),h("coords5")])};\n                }\n                if (!success && x1y0 && y1 && x0) {\n                    success = ${C("fillTriangle","b",[T("outColor"),h("screenUV"),h("coords1"),h("coords4"),h("coords6")])};\n                }\n                if (!success && x1 && x0y1 && x0y0) {\n                    success = ${C("fillTriangle","b",[T("outColor"),h("screenUV"),h("coords2"),h("coords5"),h("coords7")])};\n                }\n                if (!success && x1y1 && x0 && y0) {\n                    success = ${C("fillTriangle","b",[T("outColor"),h("screenUV"),h("coords3"),h("coords6"),h("coords0")])};\n                }\n                if (!success && y0 && y1) {\n                    success = ${C("fillLineBool","b",[T("outColor"),h("screenUV"),h("coords0"),h("coords4")])};\n                }\n                if (!success && x1y0 && x0y1) {\n                    success = ${C("fillLineBool","b",[T("outColor"),h("screenUV"),h("coords1"),h("coords5")])};\n                }\n                if (!success && x1 && x0) {\n                    success = ${C("fillLineBool","b",[T("outColor"),h("screenUV"),h("coords2"),h("coords6")])};\n                }\n                if (!success && x1y1 && x0y0) {\n                    success = ${C("fillLineBool","b",[T("outColor"),h("screenUV"),h("coords3"),h("coords7")])};\n                }\n\n                if (!success) {\n\n                    y0 = ${C("isValidPatternSmall","b",[y("coords0"),h("screenUV"),h("offset0"),f("depthModif")])};\n                    x1 = ${C("isValidPatternSmall","b",[y("coords2"),h("screenUV"),h("offset2"),f("depthModif")])};\n                    y1 = ${C("isValidPatternSmall","b",[y("coords4"),h("screenUV"),h("offset4"),f("depthModif")])};\n                    x0 = ${C("isValidPatternSmall","b",[y("coords6"),h("screenUV"),h("offset6"),f("depthModif")])};\n\n                    if (y0 && y1) {\n                        ${C("fillLine",null,[T("outColor"),h("screenUV"),h("coords0"),h("coords4")])};\n                        success = true;\n                    } else if (x1 && x0) {\n                        ${C("fillLine",null,[T("outColor"),h("screenUV"),h("coords2"),h("coords6")])};\n                        success = true;\n                    }\n                }\n\n                if (!success) {\n                    //outColor = vec4(colorAccum.rgb / colorAccum.w, sign(depth));\n                    \n                    ${t.EDL?`\n                        ${b("sh")} = 1.0 + (shade - 1.0) * sign(depth);\n                        outColor = vec4(sh * colorAccum.rgb / colorAccum.w, sign(colorAccum.w + edl - 0.0001));\n                        `:"outColor = vec4(colorAccum.rgb / colorAccum.w, sign(colorAccum.w));"}\n\n                } else {\n\n                    ${t.EDL?`\n                        ${b("sh")} = 1.0 + (shade - 1.0) * sign(depth);\n                        outColor *= ${w()}(sh, sh, sh, 1.0);\n                        `:l}\n                }\n\n                ${r} = outColor;\n\n            ${m.getMainFragmentEnd(e)}\n        `;var i;return{vertexShader:A(e),fragmentShader:a}}),"PointCloudResolveAndFillHoles"),L,G)}})),define("DS/ShaderBuilders/PostPro/BloomShaderBuilders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PostPro/PostProUniformHandler","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/PostPro/PostProContext","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a,o,i,s){"use strict";i.ParameterUtils;const l=i.FunctionHandler,u=i.BridgeFunctions,m=n=>a.addUniform(n),c=(n=null,e=0)=>{var t={name:n,size:e};return s.float(t)},$=(n=null,e=0)=>{var t={name:n,size:e};return s.vec2(t)},p=(n=null,e=0)=>{var t={name:n,size:e};return s.vec3(t)},d=(n=null,e=0)=>{var t={name:n,size:e};return s.vec4(t)},f=n=>o.addVarying(n),h=n=>o.getVarying(n,o.ShaderStages.in),v=n=>o.getVarying(n,o.ShaderStages.out),g=(n,e)=>{return u.sample2DTexture((t={uniformName:n},a.getTextureUniform(t)),e);var t};class x extends e{constructor(){super(5),this.bloomFactor=0}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform1f(r.bloomFactor,this.bloomFactor)}fillUBO(n,e,t){super.fillUBO(n,e,t);const r=n.layout;n.setF(r.bloomFactor,this.bloomFactor)}clone(){return new x}}function S(e){return`           \n            ${f({varyingName:"vUv",varyingType:"v2"})}\n\n            ${l.getMainVertexStart(e)}\n                ${v("vUv")} = uv.xy;\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(e)}\n            ${l.getMainVertexEnd(e)}\n        `}return{Blending:new r(new t((function(n,e){e.customDefines;const t=o.getShaderOutput("out0");let r=`\n            \n            ${f({varyingName:"vUv",varyingType:"v2"})}\n\n            ${m({uniformName:"tInput0",uniformType:"t2"})}\n            ${m({uniformName:"tInput1",uniformType:"t2"})}\n            ${m({uniformName:"tInput2",uniformType:"t2"})}\n            ${m({uniformName:"tInput3",uniformType:"t2"})}\n            ${m({uniformName:"tInput4",uniformType:"t2"})}\n            ${m({uniformName:"tInput5",uniformType:"t2"})}\n\n\n            ${l.getMainFragmentStart(e)}\n                ${$("screenUV")} = ${h("vUv")};\n                ${d("color")} = ${g("tInput0","screenUV")};\n                ${d("bloom1")}  = ${g("tInput1","screenUV")};\n                ${d("bloom2")}  = ${g("tInput2","screenUV")};\n                ${d("bloom3")}  = ${g("tInput3","screenUV")};\n                ${d("bloom4")}  = ${g("tInput4","screenUV")};\n                ${d("bloom5")}  = ${g("tInput5","screenUV")};\n\n                ${p("bloom")}  = 0.5 * bloom1.rgb + 0.5 * bloom2.rgb + 0.5 * bloom3.rgb + 0.5 * bloom4.rgb + 0.5 * bloom5.rgb;\n\n                ${c("bloomFactor")}  = 0.9;\n\t\t\t\t${p("result")}  = color.rgb + bloomFactor * bloom;\n\t\t\t\t${c("maxComponent")}  = max(result.x, max(result.y, result.z));\n\t\t\t    if (maxComponent > 1.0) { result /= maxComponent; }\n\n                ${t} = ${d()}(result, color.a);           \n            ${l.getMainFragmentEnd(e)}\n        `;return{vertexShader:S(e),fragmentShader:r}}),"BloomBlend"),x,{}),Mix:new r(new t((function(n,e){var t=e.customDefines;const r=o.getShaderOutput("out0");let i=`\n            \n            ${f({varyingName:"vUv",varyingType:"v2"})}\n\n            ${m({uniformName:"tInput0",uniformType:"t2"})}\n            ${t.USE_BLOOM>=1?`\n                ${m({uniformName:"tInput1",uniformType:"t2"})}\n                ${t.USE_BLOOM>=2?`\n                    ${m({uniformName:"tInput2",uniformType:"t2"})}\n                    ${m({uniformName:"tInput3",uniformType:"t2"})}\n                    ${m({uniformName:"tInput4",uniformType:"t2"})}\n                    ${m({uniformName:"tInput5",uniformType:"t2"})}\n                    `:""}\n                `:""}\n            ${m({uniformName:"bloomFactor",uniformType:"f"})}\n\n\n            ${l.getMainFragmentStart(e)}\n                ${$("screenUV")} = ${h("vUv")};\n                ${d("color")} = ${g("tInput0","screenUV")};\n                ${p("rgb")} = color.rgb;\n                ${c("factor")} = ${s="bloomFactor",u={uniformName:s},a.getUniform(u)};\n                ${t.USE_BLOOM>=1?`\n                    ${d("bloom1")}  = ${g("tInput1","screenUV")};\n                    ${t.USE_BLOOM>=2?`\n                        ${d("bloom2")}  = ${g("tInput2","screenUV")};\n                        ${d("bloom3")}  = ${g("tInput3","screenUV")};\n                        ${d("bloom4")}  = ${g("tInput4","screenUV")};\n                        ${d("bloom5")}  = ${g("tInput5","screenUV")};\n\n                        ${p("bloom")}  = 0.5 * bloom1.rgb + 0.5 * bloom2.rgb + 0.5 * bloom3.rgb + 0.5 * bloom4.rgb + 0.5 * bloom5.rgb;\n                        rgb += factor * bloom;\n                        `:"\n                        rgb += factor * bloom1.rgb;\n                        "}\n                    `:""}\n                ${r} = ${d()}(rgb, color.a);           \n            ${l.getMainFragmentEnd(e)}\n        `;var s,u;return{vertexShader:S(e),fragmentShader:i}}),"BloomMix"),x,{USE_BLOOM:0})}})),define("DS/ShaderBuilders/PostPro/SkyScatteringShaderBuilders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PostPro/PostProUniformHandler","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/PostPro/PostProContext","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a,o,i,s){"use strict";const l=i.ParameterUtils,u=i.FunctionHandler,m=i.BridgeFunctions,c=n=>s.dereference(n),$=n=>a.addUniform(n),p=n=>{var e={uniformName:n};return a.getUniform(e)},d=n=>{var e={uniformName:n};return a.getTextureUniform(e)},f=(n,e)=>l.parameterStruct(n,e),h=n=>l.parameterB(n),v=n=>l.parameterInOutB(n),g=n=>l.parameterF(n),x=n=>l.parameterInOutF(n),S=n=>l.parameterRefF(n),y=n=>l.parameterV2(n),_=n=>l.parameterV3(n),T=n=>l.parameterInOutV3(n),D=n=>l.parameterRefV3(n),C=n=>l.parameterV4(n),P=n=>l.parameterInOutV4(n),N=n=>l.parameterRefV4(n),b=n=>l.parameterT2(n),M=n=>f("densityProfileLayer",n),U=n=>f("densityProfile",n),w=(n,e,t)=>u.declareFunction(n,e,t),V=(n,e,t)=>u.callFunction(n,e,t),z=(n=null,e=0)=>{var t={name:n,size:e};return s.bool(t)},F=(n=null,e=0)=>{var t={name:n,size:e};return s.float(t)},I=(n=null,e=0)=>{var t={name:n,size:e,constant:!0};return s.float(t)},R=(n=null,e=0)=>{var t={name:n,size:e};return s.vec2(t)},A=(n=null,e=0)=>{var t={name:n,size:e};return s.vec3(t)},L=(n=null,e=0)=>{var t={name:n,size:e};return s.vec4(t)},B=n=>o.addVarying(n),E=n=>o.getVarying(n,o.ShaderStages.in),k=n=>o.getVarying(n,o.ShaderStages.out),O=(n,e)=>m.sample2DTexture(n,e),G=(n,e)=>m.modulo(n,e),H=new n.Vector3(.0058,.0135,.0331),X=new n.Vector3(1.474,1.8504,1.91198),W=new n.Vector2(1/256,1/64),j=new n.Vector4(1/8,1/32,1/128,1/32),q=new n.Vector4(8,32,128,32);class Z extends e{constructor(){super(4),this.atmBottom=6370,this.atmTop=6470,this.rayleighScattering=H,this.mieScattering=.003996,this.transInvSize=W,this.scatteringInvSize=j,this.scatteringSize=q}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform1f(r.atmBottom,this.atmBottom),t.uniform1f(r.atmTop,this.atmTop),t.uniform3f(r.rayleighScattering,this.rayleighScattering.x,this.rayleighScattering.y,this.rayleighScattering.z),t.uniform1f(r.mieScattering,this.mieScattering),t.uniform2f(r.transInvSize,this.transInvSize.x,this.transInvSize.y),t.uniform4f(r.scatterInvSize,this.scatteringInvSize.x,this.scatteringInvSize.y,this.scatteringInvSize.z,this.scatteringInvSize.w),t.uniform4f(r.scatterSize,this.scatteringSize.x,this.scatteringSize.y,this.scatteringSize.z,this.scatteringSize.w)}fillUBO(n,e,t){super.fillUBO(n,e,t);const r=n.layout;n.setF(r.atmBottom,this.atmBottom),n.setF(r.atmTop,this.atmTop),n.setV3(r.rayleighScattering,this.rayleighScattering),n.setF(r.mieScattering,this.mieScattering),n.setV2(r.transInvSize,this.transInvSize),n.setV4(r.scatterInvSize,this.scatteringInvSize),n.setV4(r.scatterSize,this.scatteringSize)}clone(){return new Z}}function Y(n){return`\n            ${$({uniformName:"atmBottom",uniformType:"f"})}\n            ${$({uniformName:"atmTop",uniformType:"f"})}\n            ${$({uniformName:"rayleighScattering",uniformType:"v3"})}\n            ${$({uniformName:"mieScattering",uniformType:"f"})}           \n            //\n            ${$({uniformName:"tDiffuse",uniformType:"t2",locationName:"tInput0"})}\n            ${$({uniformName:"tDepth",uniformType:"t2",locationName:"tInput1"})}\n            ${$({uniformName:"tTrans",uniformType:"t2",locationName:"tInput2"})}\n            ${$({uniformName:"transInvSize",uniformType:"v2"})}\n            ${$({uniformName:"tIrr",uniformType:"t2",locationName:"tInput3"})}\n            ${$({uniformName:"tScatter",uniformType:"t2",locationName:"tInput4"})}\n            ${$({uniformName:"scatterSize",uniformType:"v4"})}\n            ${$({uniformName:"scatterInvSize",uniformType:"v4"})}\n\n            ${I("PI")} = 3.14159265358979323846264;\n\n            ${w("SafeSqrt","f",[g("a")])}{\n\t\t\t    return sqrt(max(a, 0.0));\n\t\t\t}\n\t\t\t\n            ${w("ClampDistance","f",[g("d")])}{\n\t\t\t\treturn max(d, 0.0);\n\t\t\t}\n\t\t\t\n            ${w("ClampCosine","f",[g("mu")])}{\n\t\t\t    return clamp(mu, -1.0, 1.0);\n\t\t\t}\n\t\t\t\n            ${w("ClampRadius","f",[g("r")])}{\n\t\t\t    return clamp(r, ${p("atmBottom")}, ${p("atmTop")});\n\t\t\t}\n\t\t\t\n            ${w("GetTextureCoordFromUnitRange","f",[g("x"),g("inv_size")])}{\n\t\t\t\treturn 0.5 * inv_size + x * (1.0 - inv_size);\n\t\t\t}\n            ${w("GetUnitRangeFromTextureCoord","f",[g("u"),g("inv_size")])}{\n\t\t\t\treturn (u - 0.5 * inv_size) / (1.0 - inv_size);\n\t\t\t}\n\t\t\t\n            ${w("DistanceToTopAtmosphereBoundary","f",[g("r"),g("mu")])}{\n\t\t\t    ${F("discriminant")}  = r * r * (mu * mu - 1.0) + ${p("atmTop")} * ${p("atmTop")};\n                ${F("safe")} = ${V("SafeSqrt","f",[g("discriminant")])};\n\t\t\t    return ${V("ClampDistance","f",[g("-r * mu + safe")])};\n\t\t\t}\n\t\t\t\n            ${w("DistanceToBottomAtmosphereBoundary","f",[g("r"),g("mu")])}{\n\t\t\t    ${F("discriminant")}  = r * r * (mu * mu - 1.0) +${p("atmBottom")} * ${p("atmBottom")};\n                ${F("safe")} = ${V("SafeSqrt","f",[g("discriminant")])};\n\t\t\t    return ${V("ClampDistance","f",[g("-r * mu + safe")])};\n\t\t\t}\n\t\t\t\n            ${w("GetLayerDensity","f",[M("layer"),g("altitude")])}{\n\t\t\t    ${F("density")}  = layer.exp_term * exp(layer.exp_scale * altitude) + layer.linear_term * altitude + layer.constant_term;\n\t\t\t    return clamp(density, 0.0, 1.0);\n\t\t\t}\n\t\t\t\n            ${w("GetProfileDensity","f",[U("profile"),g("altitude")])}{\n                if (altitude < profile.layer0.width) {\n                    return ${V("GetLayerDensity","f",[M("profile.layer0"),g("altitude")])};\n                }\n                return ${V("GetLayerDensity","f",[M("profile.layer1"),g("altitude")])};\n\t\t\t}\n\t\t\t\n            ${w("RayIntersectsGround","b",[g("r"),g("mu")])}{\n\t\t\t    return mu < 0.0 && r * r * (mu * mu - 1.0) + ${p("atmBottom")} * ${p("atmBottom")} >= 0.0;\n\t\t\t}\n\t\t\t\n            ${w("GetTransmittanceTextureUvFromRMu","v2",[g("r"),g("mu"),y("invSize")])}{\n                ${F("atmBottom2")} = ${p("atmBottom")} * ${p("atmBottom")};\n                ${F("atmTop2")} = ${p("atmTop")} * ${p("atmTop")};\n\t\t\t    // Distance to top atmosphere boundary for a horizontal ray at ground level.\n\t\t\t    ${F("H")} = sqrt(atmTop2 - atmBottom2);\n\t\t\t    // Distance to the horizon.\n                ${F("rhoInput")} = r * r - atmBottom2;\n\t\t\t    ${F("rho")} = ${V("SafeSqrt","f",[g("rhoInput")])};\n\t\t\t    // Distance to the top atmosphere boundary for the ray (r,mu), and its minimum\n\t\t\t    // and maximum values over all mu - obtained for (r,1) and (r,mu_horizon).\n\t\t\t    ${F("d")}  = ${V("DistanceToTopAtmosphereBoundary","f",[g("r"),g("mu")])};\n\t\t\t    ${F("d_min")}  = ${p("atmTop")} - r;\n\t\t\t    ${F("d_max")}  = rho + H;\n\t\t\t    ${F("x_mu")}  = (d - d_min) / (d_max - d_min);\n\t\t\t    ${F("x_r")}  = rho / H;\n                ${R("uv")} = ${R()}(0.0, 0.0);\n                uv.x = ${V("GetTextureCoordFromUnitRange","f",[g("x_mu"),g("invSize.x")])};\n                uv.y = ${V("GetTextureCoordFromUnitRange","f",[g("x_r"),g("invSize.y")])};\n\t\t\t    return uv;\n\t\t\t}\n\t\t\t\n            ${w("GetTransmittanceToTopAtmosphereBoundary","v3",[b("transmittance_texture"),g("r"),g("mu"),y("invSize")])}{\n\t\t\t    ${R("uv")} = ${V("GetTransmittanceTextureUvFromRMu","v2",[g("r"),g("mu"),y("invSize")])};\n\t\t\t    return ${O("transmittance_texture","uv")}.rgb;\n\t\t\t}\n        `}function J(n){return`\n            ${I("g_HR")}  = 0.8*pow(10.0,7.0);\n            ${I("g_HM")}  = 0.12*pow(10.0,7.0);\n                \n            ${I("g_EpsilonInScatter")}  = 0.004;\n\n            ${$({uniformName:"miePhaseG",uniformType:"f"})}\n\n            ${$({uniformName:"viewAltitude",uniformType:"f"})}           \n            ${$({uniformName:"sunDirection",uniformType:"v3"})}\n            \n            ${$({uniformName:"nightHazeColor",uniformType:"v3"})}\n            ${$({uniformName:"nightHazeSkyPower",uniformType:"f"})}\n            ${$({uniformName:"nightHazeSkyIntensity",uniformType:"f"})}\n            ${$({uniformName:"nightHazeFogIntensity",uniformType:"f"})}\n\n            ${w("GetScatteringTextureUvwzFromRMuMuSNu","v4",[g("r"),g("mu"),g("mu_s"),g("nu"),h("ray_r_mu_intersects_ground")])}{\n\n                // Distance to top atmosphere boundary for a horizontal ray at ground level.\n                ${L("invScatterSize")} = 1.0 / ${p("scatterSize")};\n                ${F("atmBottom2")} = ${p("atmBottom")} * ${p("atmBottom")};\n                ${F("atmTop2")} = ${p("atmTop")} * ${p("atmTop")};\n                ${F("H")} = sqrt(atmTop2 - atmBottom2);\n                // Distance to the horizon.\n                ${F("rho")} = ${V("SafeSqrt","f",[g("r * r - atmBottom2")])};\n                ${F("u_r")}   = ${V("GetTextureCoordFromUnitRange","f",[g("rho / H"),g("invScatterSize.w")])};\n\n                // Discriminant of the quadratic equation for the intersections of the ray\n                // (r,mu) with the ground (see RayIntersectsGround).\n                ${F("r_mu")}  = r * mu;\n                ${F("discriminant")}  = r_mu * r_mu - r * r + atmBottom2;\n                ${F("u_mu")} ;\n                if (ray_r_mu_intersects_ground) {\n                    // Distance to the ground for the ray (r,mu), and its minimum and maximum\n                    // values over all mu - obtained for (r,-1) and (r,mu_horizon).\n                    ${F("d")}  = -r_mu - ${V("SafeSqrt","f",[g("discriminant")])};\n                    ${F("d_min")}  = r - ${p("atmBottom")};\n                    ${F("d_max")}  = rho;\n                    ${F("d_use")} = 0.0;\n                    if (d_max != d_min) {\n                        d_use = (d - d_min) / (d_max - d_min);\n                    }\n                    u_mu = 0.5 - 0.5 * ${V("GetTextureCoordFromUnitRange","f",[g("d_use"),g("2.0 * invScatterSize.z")])};\n                } else {\n                    // Distance to the top atmosphere boundary for the ray (r,mu), and its\n                    // minimum and maximum values over all mu - obtained for (r,1) and\n                    // (r,mu_horizon).\n                    ${F("d")}  = -r_mu + ${V("SafeSqrt","f",[g("discriminant + H * H")])};\n                    ${F("d_min")}  = ${p("atmTop")} - r;\n                    ${F("d_max")}  = rho + H;\n                    u_mu = 0.5 + 0.5 * ${V("GetTextureCoordFromUnitRange","f",[g("(d - d_min) / (d_max - d_min)"),g("2.0* invScatterSize.z")])};\n                }\n                //Weird\n                ${F("d")}  = ${V("DistanceToTopAtmosphereBoundary","f",[g(p("atmBottom")),g("mu_s")])};\n                ${F("d_min")}  = ${p("atmTop")} - ${p("atmBottom")};\n                ${F("d_max")}  = H;\n                ${F("a")}  = (d - d_min) / (d_max - d_min);\n                ${F("mu_s_min")} =-0.207912;\n                ${F("A")}  =-2.0 * mu_s_min * ${p("atmBottom")} / (d_max - d_min);\n                ${F("u_mu_s")}  =  ${V("GetTextureCoordFromUnitRange","f",[g("max(1.0 - a / A, 0.0) / (1.0 + a)"),g("invScatterSize.y")])};\n\n                ${F("u_nu")}  = (nu + 1.0) / 2.0;\n                return ${L()}(u_nu, u_mu_s,1.0- u_mu, u_r);\n\t\t\t}\n\n\t\t\t${w("GetExtrapolatedSingleMieScattering","v3",[C("scattering")])}{\n\t\t\t    return scattering.rgb * scattering.a / max(scattering.r,0.0001) *\n\t\t\t\t\t(${p("rayleighScattering")}.r / ${p("rayleighScattering")});\n\t\t\t}\n\t\t\t\n\t\t\t//VALIDATED\n\t\t\t${w("texture4D","v4",[b("scattering_texture"),g("r"),g("mu"),g("mu_s"),g("nu")])}{\n\t\t\t\t\n                ${F("atmBottom2")} = ${p("atmBottom")} * ${p("atmBottom")};\n                ${F("atmTop2")} = ${p("atmTop")} * ${p("atmTop")};\n                ${L("invScatterSize")} = 1.0 / ${p("scatterSize")};\n\t\t\t    //NRE CODE //slighly different but overall same\n\t\t\t\t${F("h")}        = sqrt(max(0.0, atmTop2 - atmBottom2));\n\t\t\t\t${F("rho")}      = sqrt(max(0.0, r * r - atmBottom2));\n\t\t\t\t\n\t\t\t\t${F("rmu")}      = r * mu;\n\t\t\t\t${F("delta")}    = rmu * rmu - r * r + atmBottom2;\n                ${L("cst")} = ${L()}(-1.0, h*h, h, 0.5 + 0.5 *invScatterSize.z);\n                if (rmu < 0.0 && delta > 0.0) {\n                    cst =  ${L()}(1.0, 0.0, 0.0, 0.5 - 0.5* invScatterSize.z);\n                }\n\t\t\t\t${F("uR")}       = 0.5 *invScatterSize.w + rho / h * (1.0 - invScatterSize.w);\n\t\t\t\t${F("uMu")}      = cst.w + (rmu * cst.x + sqrt(max(0.0, delta + cst.y)) ) / (rho + cst.z) * (0.5 - invScatterSize.z);\n\t\t\t\t${F("uMuS")}     = 0.5 *invScatterSize.y + (atan(max(mu_s, -0.1975) * 5.34962349919) / 1.1 + 0.74) * 0.5 * (1.0 - invScatterSize.y);\n\t\t\t\t${F("uNu")}      = 0.5 * (nu + 1.0);\n\t\t\t  \n                ${L("uvwz")}  = ${L()}(uNu,uMuS,1.0-uMu,uR);\n                \n                ${F("tex_coord_x")}  = uvwz.x * (${p("scatterSize")}.x-1.0);\n                ${F("tex_x")}  = floor(tex_coord_x);\n                ${F("lerpx")}  = tex_coord_x - tex_x;\n                ${F("tex_coord_y")}  = uvwz.w * (${p("scatterSize")}.w-1.0);\n                ${F("tex_y")}  = floor(tex_coord_y);\n                ${F("lerpy")}  = tex_coord_y - tex_y;\n                ${R("uv0")}  = ${R()}((tex_x + uvwz.z) *invScatterSize.x,((tex_y + uvwz.y) *invScatterSize.w));\n                ${R("uv1")}  = ${R()}((tex_x + 1.0 + uvwz.z) *invScatterSize.x,((tex_y + uvwz.y) *invScatterSize.w));\n                ${R("uv2")}  = ${R()}((tex_x + uvwz.z) *invScatterSize.x,((tex_y +1.0 + uvwz.y) *invScatterSize.w));\n                ${R("uv3")}  = ${R()}((tex_x + 1.0 + uvwz.z) *invScatterSize.x,((tex_y +1.0+ uvwz.y) *invScatterSize.w));\n                ${L("combined_scattering")}  = (\n                            ${O("scattering_texture","uv0")} * (1.0 - lerpx) + \n                            ${O("scattering_texture","uv1")} * lerpx\n                        )*(1.0 -lerpy)\n                        +\n                        (\n                            ${O("scattering_texture","uv2")} * (1.0 - lerpx) + \n                            ${O("scattering_texture","uv3")} * lerpx\n                        )*(lerpy);\n                                                \n\t\t\t\treturn combined_scattering;\n\t\t\t}\n\t\t\t\n            ${w("GetCombinedScattering","v4",[b("scattering_texture"),g("r"),g("mu"),g("mu_s"),g("nu"),T("ioNightHaze")])}{\n\t\t\t\t\n\t\t\t\t${F("muHorizon")}  = -sqrt(max(0.0, 1.0 - (${p("atmBottom")} / r) * (${p("atmBottom")} /r)));\n\t\t\t\t\n\t\t\t\t// Night haze\n\t\t\t\t${A("surfacePos")}  = ${A()}(0.0,0.0,${p("atmBottom")});\n\t\t\t\t${A("nightHaze")} = ${A()}(1.0-abs(mu - muHorizon));\n\t\t\t\tnightHaze = ${p("nightHazeColor")}*pow(abs(nightHaze), vec3(${p("nightHazeSkyPower")})) * ${p("nightHazeSkyIntensity")};\n\t\t\t\tnightHaze *= smoothstep(${p("atmTop")}-${p("atmBottom")}, 0.0, ${p("viewAltitude")});\n\t\t\t\tnightHaze = clamp(nightHaze, ${A()}(0.0, 0.0, 0.0),${A()}(1.0, 1.0, 1.0));\n                ${c("ioNightHaze")} = nightHaze;\n\t\t\t\t\n\t\t\t\treturn ${V("texture4D","v4",[b("scattering_texture"),g("r"),g("mu"),g("mu_s"),g("nu")])};\n\t\t\t}\n\t\t\t\n            ${w("RayleighPhaseFunction","f",[g("nu")])} {\n                ${F("k")}  = 3.0 / (16.0 * PI);\n                return k * (1.0 + nu * nu);\n\t\t\t}\n\t\t\t\n            ${w("MiePhaseFunction","f",[g("g"),g("nu")])} {\n                ${F("k")} = 3.0 / (8.0 * PI);\n                ${F("a")}  = (1.0 - g * g);\n                ${F("b")}  = (2.0 + g * g);\n                ${F("c")}  = 1.0 + g * g;\n                ${F("d")}  = 2.0 * g * nu;\n                ${F("e")}  = (1.0 + nu * nu);\n                return k * e * a * pow(abs(c - d), -1.5) / b;\n\t\t\t}\n\t\t\t\n            ${w("OpticalDepth","f",[g("iH"),g("iR"),g("iMu"),g("iD")])} {\n\t\t\t\t${F("a")}      = sqrt(max(0.0, (0.5/iH)*iR));\n\t\t\t\t${R("a01")}     = a*${R()}(iMu, iMu+iD/iR);\n\t\t\t\t${R("a01s")}    = sign(a01);\n\t\t\t\t${R("a01sq")}   = a01*a01;\n\t\t\t\t${F("x")}      = ${n.WebGPU?"select(0.0, exp(a01sq.x), a01s.y > a01s.x)":"a01s.y > a01s.x ? exp(a01sq.x) : 0.0"};\n\t\t\t\t${R("y")}       = a01s / (2.3193*abs(a01) + sqrt(max(${R()}(0.0), 1.52*a01sq + 4.0))) * ${R()}(1.0, exp(-iD/iH*(iD/(2.0*iR)+iMu)));\n\n\t\t\t\treturn sqrt(max(0.0, (6.2831*iH)*iR)) * exp((${p("atmBottom")}-iR)/iH) * (x + dot(y, ${R()}(1.0, -1.0)));\n\t\t\t}\n\t\t\t\n            ${w("AnalyticTransmittance","v3",[g("iR"),g("iMu"),g("iD")])} {\n                ${F("opticalRayleigh")} = ${V("OpticalDepth","f",[g("g_HR"),g("iR"),g("iMu"),g("iD")])};\n                ${F("opticalMie")} = ${V("OpticalDepth","f",[g("g_HM"),g("iR"),g("iMu"),g("iD")])};\n\t\t\t\treturn exp(-${p("rayleighScattering")} * opticalRayleigh - ${p("mieScattering")} * opticalMie);\n\t\t\t}\n\t\t\t\n            ${w("IntersectAtmosphere","b",[_("pos"),_("dir"),x("distToAtmosphere"),x("distInAtmosphere")])} {\n\t\t\t\t${A("l")} = -pos;\n\t\t\t\t${F("l2")}  = dot(l,l);\n\t\t\t\t${F("s")}  = dot(l,dir);\n\t\t\t\t${F("r2")}  = ${p("atmTop")}*${p("atmTop")};\n\t\t\t\t\n\t\t\t\tif (l2<=r2){\n\t\t\t\t\t${F("m2")}  = l2 - (s * s);\n\t\t\t\t\t${F("q")}   = sqrt(max(0.0, r2 - m2));\n\t\t\t\t\t${c("distInAtmosphere")} = s + q;\n\t\t\t\t\t${c("distToAtmosphere")} = 0.0;\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(s>=0.0){\n\t\t\t\t\t${F("m2")}  = l2 - (s * s);\n\t\t\t\t\tif(m2 <= r2){\n\t\t\t\t\t\t${F("q")}  = sqrt(max(0.0, r2 - m2));\n\t\t\t\t\t\t${c("distToAtmosphere")} = s - q;\n\t\t\t\t\t\t${c("distInAtmosphere")} = (s + q) - ${c("distToAtmosphere")};\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}else{\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n            ${w("getScatteringFromWorldParams","v4",[b("scattering_texture"),_("point"),_("view_ray"),_("sun_direction"),g("distance"),T("transmittance"),T("nightHaze")])} {\n\t\t\t\t// Compute the r, mu, mu_s and nu parameters needed for the texture lookups.\n\t\t\t\t${F("r")}  = length(point);\n\t\t\t\t${F("rmu")}  = dot(point, view_ray);\n\t\t\t\t${F("mu")}  = rmu / r;\n\t\t\t\t${F("mu_s")}  = dot(point, sun_direction) / r;\n\t\t\t\t${F("nu")}  = dot(view_ray, sun_direction);\n\t\t\t\t${c("transmittance")} = ${V("AnalyticTransmittance","v3",[g("r"),g("mu"),g("distance")])};\n\t\t\t\t\n\t\t\t\treturn ${V("GetCombinedScattering","v4",[b("scattering_texture"),g("r"),g("mu"),g("mu_s"),g("nu"),T("nightHaze")])};\n\t\t\t}\n\t\t\t\n            ${w("ApplyMieRayleigh","v3",[P("scattering"),g("mu_s"),g("nu")])}{\n\t\t\t\t//NRE COPIED PARAMS\n                ${F("SunSize")}      = 10000.0;\n                ${F("sunFactor")}    = 0.001*SunSize;\n                //1.0 for hdr gen\n                ${F("g_MieBoost")}   = 0.0;\n                ${F("lerpFactor")}   = (max((1.0-sunFactor), nu)-(1.0-sunFactor))*(1.0/sunFactor);\n                ${F("theta")}        = smoothstep(0.0, 2.0, pow(lerpFactor, 8.0));\n                ${F("sunBoost")}     = 2.0+g_MieBoost*theta;\n                ${F("sunScatteringIntensity")}  = 60.0;\n                \n                ${c("scattering")}.w *= smoothstep(0.0,0.02,mu_s);\n                ${A("single_mie_scattering")}  = ${V("GetExtrapolatedSingleMieScattering","v3",[C(`${c("scattering")}`)])};\n                \n                ${F("miePhaseG_")} = ${p("miePhaseG")};\n                ${A("InScattering")} = max((${c("scattering")}.xyz * ${V("RayleighPhaseFunction","f",[g("nu")])} + single_mie_scattering * ${V("MiePhaseFunction","f",[g("miePhaseG_"),g("nu")])} * sunBoost), ${A()}(0.0, 0.0, 0.0));\n                InScattering *= sunScatteringIntensity;\n                //NRE impl \n                return InScattering*0.6;\n\t\t\t}\n\t\t\t\n            ${w("GetSkyScattering","v3",[b("transmittance_texture"),b("scattering_texture"),T("cameraPos"),_("view_ray"),_("sun_direction"),T("nightHaze")])} {\n\t\t\t  \n                ${F("distance_to_atmosphere")}  = 0.0;\n                ${F("distance_in_atmosphere")}  = 0.0;\n                \n                ${A("cameraPos_")} = ${c("cameraPos")};\n                ${z("goThroughAtmosphere")} = ${V("IntersectAtmosphere","b",[_("cameraPos_"),_("view_ray"),S("distance_to_atmosphere"),S("distance_in_atmosphere")])};\n                \n                if(!goThroughAtmosphere){\n                    // If the view ray does not intersect the atmosphere, simply return 0.\n                    return ${A()}(0.0);\n                }\n                \n                ${c("cameraPos")} = ${c("cameraPos")} + view_ray * distance_to_atmosphere;\n                \n                ${A("transmittance")} ;\n                \n                cameraPos_ = ${c("cameraPos")};\n                ${L("scattering")}  = ${V("getScatteringFromWorldParams","v4",[b("scattering_texture"),_("cameraPos_"),_("view_ray"),_("sun_direction"),g("distance_in_atmosphere"),D("transmittance"),T("nightHaze")])};\n                \n                ${F("nu")}  = dot(view_ray, sun_direction);\n\t\t\t\t${F("mu_s")}  = dot(${c("cameraPos")}, sun_direction) / length(${c("cameraPos")});\n                \n                return ${V("ApplyMieRayleigh","v3",[N("scattering"),g("mu_s"),g("nu")])};\n\t\t\t}\n\t\t\t\n            ${w("GetSkyScatteringWithDepth","v3",[b("scattering_texture"),T("cameraPos"),_("view_ray"),_("sun_direction"),_("pointPos"),T("attenuation")])}{\n\t\t\t\t${F("distance_to_atmosphere")}  = 0.0;\n\t\t\t\t${F("distance_in_atmosphere")}  = 0.0;\n\t\t\t\t  \n                ${A("cameraPos_")} = ${c("cameraPos")};\n\t\t\t\t${z("goThroughAtmosphere")} =  ${V("IntersectAtmosphere","b",[_("cameraPos_"),_("view_ray"),S("distance_to_atmosphere"),S("distance_in_atmosphere")])};\n\t\t\t\t  \n\t\t\t\t${F("distanceToObject")}  = distance(${c("cameraPos")}, pointPos);\n\t\t\t\t  \n\t\t\t\tif(!goThroughAtmosphere || distanceToObject<distance_to_atmosphere){\n\t\t\t\t    // If no atmosphere in front of object\n\t\t\t    \treturn ${A()}(0.0);\n\t\t\t\t}\n\t\t\t\t  \n\t\t\t\t${c("cameraPos")} = ${c("cameraPos")} + view_ray * distance_to_atmosphere;\n\t\t\t\tdistanceToObject -= distance_to_atmosphere;\n\t\t\t\t  \n\t\t\t\t${A("nightHaze")};//useless\n\t\t\t\t  \n\t\t\t\t${L("scattering")}  =  ${V("getScatteringFromWorldParams","v4",[b("scattering_texture"),_(`${c("cameraPos")}`),_("view_ray"),_("sun_direction"),g("distance_in_atmosphere"),T("attenuation"),D("nightHaze")])};\n\t\t\t\t  \n\t\t\t\t${F("mu_s")}  = dot(${c("cameraPos")}, sun_direction) / length(${c("cameraPos")});\n\t\t\t\t${F("nu")}  = dot(view_ray, sun_direction);\n\t\t\t\t  \n\t\t\t\tif(distanceToObject < distance_in_atmosphere){\n\t\t\t\t\t${F("heightEndPos")}  = length(pointPos);\n\t\t\t\t\t${F("musEndPos")}     = dot(pointPos, sun_direction) / heightEndPos;\t\n\t\t\t\t\t${F("muEndPos")}  = dot(pointPos, view_ray) / heightEndPos;\n\t\t\t\t\t${L("scatteringPoint")}  = ${V("getScatteringFromWorldParams","v4",[b("scattering_texture"),_("pointPos"),_("view_ray"),_("sun_direction"),g("distanceToObject"),T("attenuation"),D("nightHaze")])};\n\t\t\t\t\tscattering = max(scattering - attenuation.rgbr * scatteringPoint, ${L()}(0.0, 0.0, 0.0, 0.0));\n\t\t\t\t}\n\t\t\t\t  \n\t\t\t\treturn ${V("ApplyMieRayleigh","v3",[N("scattering"),g("mu_s"),g("nu")])};\n\t\t\t}\n\t\t\t\n            ${w("Irradiance","v3",[b("tIrr"),g("iAlt"),g("iCosSunZenithAngle")])}{\n\t\t\t    ${F("uR")}     = (iAlt - ${p("atmBottom")}) / (${p("atmTop")} - ${p("atmBottom")});\n\t\t\t\t${F("uMuS")}   = (iCosSunZenithAngle + 0.2) / (1.0 + 0.2);\n                ${R("uv")} = ${R()}(uMuS, 1.0-uR);\n\t\t\t\treturn ${O("tIrr","uv")}.rgb;\n\t\t\t}\n\n\t\t\t// transmittance(=transparency) of atmosphere for infinite ray (alt,cosRayZenithAngle)\n\t\t\t// (cosRayZenithAngle=cos(view zenith angle)), intersections with ground ignored\n            ${w("Transmittance","v3",[b("tTrans"),g("iAlt"),g("iCosRayZenithAngle")])}{\n\t\t\t\t${F("uR")} = sqrt(max(0.0, (iAlt - ${p("atmBottom")}) / (${p("atmTop")} - ${p("atmBottom")})));\n                ${F("uMu")} = atan((iCosRayZenithAngle + 0.15) / (1.0 + 0.15) * tan(1.5)) / 1.5;\n                ${R("uv")} = ${R()}(uMu, 1.0-uR);\n\t\t\t\treturn ${O("tTrans","uv")}.rgb;\n\t\t\t}\n\t\t\t\n\t\t\t\n            ${w("GetReflectedLight","v3",[b("tIrradiance"),b("tTransmittance"),_("iSurfaceColor"),_("iSurfacePos"),_("iCameraPos"),_("sunDirection"),_("iAttenuation")])}{\n\t\t\t\t\n\t\t\t\t// irradiance at surface position due to sky light\n\t\t\t\t${F("surfacePosHeight")} \t= length(iSurfacePos);\t\t\n\t\t\t\t${F("dotSunSphere")}       = dot(iSurfacePos, sunDirection) / surfacePosHeight;\n                // CK added saturate\t\n\t\t\t\t${F("musSurfacePos")}      = clamp(dotSunSphere,0.0,1.0);\n\n\t\t\t\t${A("irradianceSurface")}   =  ${V("Irradiance","v3",[b("tIrradiance"),g("surfacePosHeight"),g("musSurfacePos")])};\n\t\t\t\t \n\t\t\t\t// attenuate direct sun light on its path from top of atmosphere to surface position\n\t\t\t\t${A("attenuationSunLight")}  = ${V("Transmittance","v3",[b("tTransmittance"),g("surfacePosHeight"),g("musSurfacePos")])};\n\t\t\t\t\n\t\t\t\t${F("sunScatteringIntensity")}  = 60.0;\n\t\t\t\t${A("reflectedLight")}  = iSurfaceColor * (attenuationSunLight + irradianceSurface) * sunScatteringIntensity * (0.1 / PI);\n\t\t\t  \n\t\t\t\t// factor to avoid discontinuities on the atmosphere boundary (and black materials above atmosphere)\n\t\t\t\t${F("inSpaceFactor")}  = smoothstep(${p("atmBottom")}+(${p("atmTop")}-${p("atmBottom")})*0.2, ${p("atmTop")}, surfacePosHeight);\n\t\t\t\treflectedLight = mix(reflectedLight, iSurfaceColor, inSpaceFactor);\n\n\t\t\t    ${F("cameraAlt")}                = length(iCameraPos) - ${p("atmBottom")};\n\t\t\t\t${F("planetSunlightFactor")}     = smoothstep(-0.05,  0.05, dotSunSphere);\n                // to avoid too much yellow in space (on shadow boundaries)\n\t\t\t\t${F("planetSunlightFactorBis")}  = smoothstep(-0.05,  0.2,  dotSunSphere); \n\t\t\t\t${F("bisFactor")}                = smoothstep(300.0, 1000.0, cameraAlt);\n\t\t\t\tplanetSunlightFactor = (1.0-bisFactor)*planetSunlightFactor + planetSunlightFactorBis*bisFactor;\n\t\t\t\n\t\t\t\t// Fog applied at night \n\t\t\t\t${A("fogColor")}      = ${p("nightHazeColor")} * ${p("nightHazeFogIntensity")};\n\t\t\t\t${F("fogDensity")}   = 0.009;\n\t\t\t\t${F("fogFactor")}    = 1.0 - 1.0 / pow(exp(length(iSurfacePos-iCameraPos) * fogDensity), 2.0);\n\t\t\t\tfogFactor *= smoothstep(100.0, 0.0, cameraAlt);\n\n\t\t\t\t${A("surfaceColor")} = (1.0-fogFactor) * iSurfaceColor + fogFactor * fogColor;\n\t\t\t\n\t\t\t\treturn planetSunlightFactor * reflectedLight + (1.0-planetSunlightFactor) * surfaceColor;\n\t\t\t}\n        `}function K(n){return`\n            ${s.createStruct({structName:"densityProfileLayer",attributes:[{type:"f",name:"width"},{type:"f",name:"exp_term"},{type:"f",name:"exp_scale"},{type:"f",name:"linear_term"},{type:"f",name:"constant_term"}]})}\n            ${s.createStruct({structName:"densityProfile",attributes:[{type:"densityProfileLayer",name:"layer0"},{type:"densityProfileLayer",name:"layer1"}]})}\n        \n            ${s.struct({name:"rayleighDensity",structName:"densityProfile",addressSpace:"private"})};\n            ${s.struct({name:"mieDensity",structName:"densityProfile",addressSpace:"private"})};\n            \n            ${s.struct({name:"flR",structName:"densityProfileLayer",addressSpace:"private"})};\n            ${s.struct({name:"slR",structName:"densityProfileLayer",addressSpace:"private"})};\n            \n            ${s.struct({name:"flM",structName:"densityProfileLayer",addressSpace:"private"})};\n            ${s.struct({name:"slM",structName:"densityProfileLayer",addressSpace:"private"})};\n        `}function Q(e){return`           \n            ${B({varyingName:"vUv",varyingType:"v2"})}\n\n            ${u.getMainVertexStart(e)}\n                ${k("vUv")} = uv.xy;\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(e)}\n            ${u.getMainVertexEnd(e)}\n        `}class nn extends Z{constructor(){super(),this.mieExtinction=444e-8,this.absorptionExtinction=0}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform1f(r.mieExtinction,this.mieExtinction),t.uniform1f(r.absorptionExtinction,this.absorptionExtinction)}fillUBO(n,e,t){super.fillUBO(n,e,t);const r=n.layout;n.setF(r.mieExtinction,this.mieExtinction),n.setF(r.absorptionExtinction,this.absorptionExtinction)}clone(){return new nn}}class en extends Z{constructor(){super(),this.solarIrradiance=X,this.angularRadius=.004675}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform1f(r.angularRadius,this.angularRadius),t.uniform3f(r.solarIrradiance,this.solarIrradiance.x,this.solarIrradiance.y,this.solarIrradiance.z)}fillUBO(n,e,t){super.fillUBO(n,e,t);const r=n.layout;n.setF(r.angularRadius,this.angularRadius),n.setV3(r.solarIrradiance,this.solarIrradiance)}clone(){return new en}}class tn extends Z{constructor(){super(),this.sunDirection=new n.Vector3(-1,-1,1),this.viewAltitude=1,this.miePhaseG=.8,this.nightHazeColor=new n.Vector3(.25,.34,.49),this.nightHazeSkyPower=.6,this.nightHazeSkyIntensity=.15,this.nightHazeFogIntensity=.15}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform1f(r.viewAltitude,this.viewAltitude),t.uniform1f(r.miePhaseG,this.miePhaseG),t.uniform1f(r.nightHazeSkyPower,this.nightHazeSkyPower),t.uniform1f(r.nightHazeSkyIntensity,this.nightHazeSkyIntensity),t.uniform1f(r.nightHazeFogIntensity,this.nightHazeFogIntensity),t.uniform3f(r.sunDirection,this.sunDirection.x,this.sunDirection.y,this.sunDirection.z),t.uniform3f(r.nightHazeColor,this.nightHazeColor.x,this.nightHazeColor.y,this.nightHazeColor.z)}fillUBO(n,e,t){super.fillUBO(n,e,t);const r=n.layout;n.setF(r.viewAltitude,this.viewAltitude),n.setF(r.miePhaseG,this.miePhaseG),n.setF(r.nightHazeSkyPower,this.nightHazeSkyPower),n.setF(r.nightHazeSkyIntensity,this.nightHazeSkyIntensity),n.setF(r.nightHazeFogIntensity,this.nightHazeFogIntensity),n.setV3(r.sunDirection,this.sunDirection),n.setV3(r.nightHazeColor,this.nightHazeColor)}clone(){return new tn}}class rn extends tn{constructor(){super(),this.texturesLoaded=0,this.near=0,this.far=0,this.screenToView=new n.Vector4,this.invView=new n.Matrix4}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform1f(r.texturesLoaded,this.texturesLoaded),t.uniform1f(r.near,this.near),t.uniform1f(r.far,this.far),t.uniform4f(r.screenToView,this.screenToView.x,this.screenToView.y,this.screenToView.z,this.screenToView.w),t.uniformMatrix4fv(r.invView,!1,e.float32Matrix4x4Temp.setDoubles(this.invView.elements))}fillUBO(n,e,t){super.fillUBO(n,e,t);const r=n.layout;n.setF(r.texturesLoaded,this.texturesLoaded),n.setF(r.near,this.near),n.setF(r.far,this.far),n.setV4(r.screenToView,this.screenToView),n.setM4(r.invView,this.invView)}clone(){return new rn}}return{ComputeTransmittance:new r(new t((function(n,e){e.customDefines;const t=o.getShaderOutput("out0");let r=`\n            \n            ${B({varyingName:"vUv",varyingType:"v2"})}\n            ${$({uniformName:"mieExtinction",uniformType:"f"})}\n            ${$({uniformName:"absorptionExtinction",uniformType:"f"})}\n\n            ${K()}\n            ${Y()}\n\n            \n\t\t\t${w("ComputeOpticalLengthToTopAtmosphereBoundary","f",[U("profile"),g("r"),g("mu")])}{\n                // Number of intervals for the numerical integration.\n                ${I("SAMPLE_COUNT")}  = 500.0;\n                // The integration step, i.e. the length of each integration interval.\n                ${F("dx")} = ${V("DistanceToTopAtmosphereBoundary","f",[g("r"),g("mu")])} / SAMPLE_COUNT;\n                // Integration loop.\n                ${F("result")}  = 0.0;\n                for (${F("i")}  = 0.0; i <= SAMPLE_COUNT; i++) {\n                    ${F("d_i")}  = i * dx;\n                    // Distance between the current sample point and the planet center.\n                    ${F("r_i")}  = sqrt(d_i * d_i + 2.0 * r * mu * d_i + r * r);\n                    // Number density at the current sample point (divided by the number density\n                    // at the bottom of the atmosphere, yielding a dimensionless number).\n                    ${F("alt")} = r_i - ${p("atmBottom")};\n                    ${F("y_i")}  = ${V("GetProfileDensity","f",[U("profile"),g("alt")])};\n                    // Sample weight (from the trapezoidal rule).\n                    ${F("weight_i")}  = 1.0;\n                    if (i == 0.0 || i == SAMPLE_COUNT) {\n                        weight_i = 0.5;\n                    }\n                    result += y_i * weight_i * dx;\n                }\n                return result;\n\t\t\t}\n\t\t\t\n            ${w("ComputeTransmittanceToTopAtmosphereBoundary","v3",[g("r"),g("mu")])} {\n                ${A("rayleigh")} = ${p("rayleighScattering")} * ${V("ComputeOpticalLengthToTopAtmosphereBoundary","f",[U("rayleighDensity"),g("r"),g("mu")])};\n                ${A("mie")} = ${A()}(${p("mieScattering")}) * ${V("ComputeOpticalLengthToTopAtmosphereBoundary","f",[U("mieDensity"),g("r"),g("mu")])};\n\t\t\t\t//a decommenter si ozone prise en compte\n                // ${A("absorption")} = absorptionExtinction * ComputeOpticalLengthToTopAtmosphereBoundary(atmosphere.absorption_density, r, mu);\n\t\t\t    return exp(-(rayleigh+mie));\n\t\t\t}\t\t\n\t\t\t\n            ${w("GetRMuFromTransmittanceTextureUv","v2",[y("uv")])}{\n                ${R("invSize")} = ${p("transInvSize")};\n                ${F("x_mu")}  = ${V("GetUnitRangeFromTextureCoord","f",[g("uv.x"),g("invSize.x")])};\n                ${F("x_r")}  = ${V("GetUnitRangeFromTextureCoord","f",[g("uv.y"),g("invSize.y")])};\n                \n                // Distance to top atmosphere boundary for a horizontal ray at ground level.\n                ${F("H")}  = sqrt(${p("atmTop")} * ${p("atmTop")} - ${p("atmBottom")} * ${p("atmBottom")});\n                // Distance to the horizon, from which we can compute r:\n                ${F("rho")}  = H * x_r;\n                ${F("r")} = sqrt(rho * rho + ${p("atmBottom")} * ${p("atmBottom")});\n                // Distance to the top atmosphere boundary for the ray (r,mu), and its minimum\n                // and maximum values over all mu - obtained for (r,1) and (r,mu_horizon) -\n                // from which we can recover mu:\n                ${F("d_min")}  = ${p("atmTop")} - r;\n                ${F("d_max")}  = rho + H;\n                ${F("d")}  = d_min + x_mu * (d_max - d_min);\n                ${F("mu")} = 1.0;\n                if (d != 0.0) {\n                    mu = (H * H - rho * rho - d * d) / (2.0 * r * d);\n                }\n                mu = ${V("ClampCosine","f",[g("mu")])};\n                return ${R()}(r, mu);\n\t\t\t}\n\t\t\t\n            ${w("ComputeTransmittanceToTopAtmosphereBoundaryTexture","v3",[y("frag_coord")])}{\n                ${R("r_mu")} = ${V("GetRMuFromTransmittanceTextureUv","v2",[y("frag_coord")])};\n                return ${V("ComputeTransmittanceToTopAtmosphereBoundary","v3",[g("r_mu.x"),g("r_mu.y")])};\n\t\t\t}\n      \n            ${u.getMainFragmentStart(e)}\n                ${R("screenUV")} = ${E("vUv")};\n                \n        \n            flR.width=0.0;\n            flR.exp_term=0.0;\n            flR.exp_scale=0.0;\n            flR.linear_term=0.0;\n            flR.constant_term=0.0;\n            \n            slR.width=0.0;\n            slR.exp_term=1.0;\n            slR.exp_scale=-0.000125;\n            slR.linear_term=0.0;\n            slR.constant_term=0.0;\n            \n            rayleighDensity.layer0 = flR;\n            rayleighDensity.layer1 = slR;\n            \n            \n            flM.width=0.0;\n            flM.exp_term=0.0;\n            flM.exp_scale=0.0;\n            flM.linear_term=0.0;\n            flM.constant_term=0.0;\n            \n            \n            slM.width=0.0;\n            slM.exp_term=1.0;\n            slM.exp_scale=-0.000833333;\n            slM.linear_term=0.0;\n            slM.constant_term=0.0;\n            \n            mieDensity.layer0 = flM;\n            mieDensity.layer1 = slM;\n        \n\n                ${A("res")} = ${V("ComputeTransmittanceToTopAtmosphereBoundaryTexture","v3",[y("screenUV")])};\n\n                ${t} = ${L()}(res, 1.0);           \n            ${u.getMainFragmentEnd(e)}\n        `;return{vertexShader:Q(e),fragmentShader:r}}),"SkyComputeTransmittance"),nn,{}),ComputeScattering:new r(new t((function(n,e){e.customDefines;const t=o.getShaderOutput("out0");let r=`\n            \n            ${B({varyingName:"vUv",varyingType:"v2"})}\n            ${$({uniformName:"angularRadius",uniformType:"f"})}\n            ${$({uniformName:"solarIrradiance",uniformType:"v3"})}\n\n            ${K()}\n            ${Y()}\n\n            ${w("GetRMuMuSNuFromScatteringTextureUvwz","v4",[C("uvwz"),v("ray_r_mu_intersects_ground")])} {\n\n                ${F("r")};\n                ${F("mu")};\n                ${F("mu_s")};\n                ${F("nu")};\n                ${L("invSize")} = ${p("scatterInvSize")};\n                ${F("aTop")} = ${p("atmTop")};\n                ${F("aBottom")} = ${p("atmBottom")};\n                // Distance to top atmosphere boundary for a horizontal ray at ground level.\n                ${F("H")} = sqrt(aTop * aTop - aBottom * aBottom);\n                // Distance to the horizon.\n                ${F("rho")}  = H * ${V("GetUnitRangeFromTextureCoord","f",[g("uvwz.w"),g("invSize.w")])};\n                r = sqrt(rho * rho + aBottom * aBottom);\n\n                if (uvwz.z < 0.5) {\n                    // Distance to the ground for the ray (r,mu), and its minimum and maximum\n                    // values over all mu - obtained for (r,-1) and (r,mu_horizon) - from which\n                    // we can recover mu:\n                    ${F("d_min")}  = r - aBottom;\n                    ${F("d_max")}  = rho;\n                    ${F("d")}  = d_min + (d_max - d_min) * ${V("GetUnitRangeFromTextureCoord","f",[g("1.0 - 2.0 * uvwz.z"),g("invSize.z * 2.0")])};\n                    if ( d == 0.0) {\n                        mu = -1.0;\n                    } else {\n                        mu = ${V("ClampCosine","f",[g("-(rho * rho + d * d) / (2.0 * r * d)")])};\n                    }\n                    ${c("ray_r_mu_intersects_ground")} = true;\n                } else {\n                    // Distance to the top atmosphere boundary for the ray (r,mu), and its\n                    // minimum and maximum values over all mu - obtained for (r,1) and\n                    // (r,mu_horizon) - from which we can recover mu:\n                    ${F("d_min")}  = aTop - r;\n                    ${F("d_max")}  = rho + H;\n                    ${F("d")}  = d_min + (d_max - d_min) * ${V("GetUnitRangeFromTextureCoord","f",[g("2.0 * uvwz.z - 1.0"),g("invSize.z * 2.0")])};\n                    if ( d == 0.0) {\n                        mu = 1.0;\n                    } else {\n                        mu = ${V("ClampCosine","f",[g("(H * H - rho * rho - d * d) / (2.0 * r * d)")])};\n                    }\n                    ${c("ray_r_mu_intersects_ground")} = false;\n                }\n\n                ${F("x_mu_s")} = ${V("GetUnitRangeFromTextureCoord","f",[g("uvwz.y"),g("invSize.y")])};\n                ${F("d_min")}  = aTop - aBottom;\n                ${F("d_max")}  = H;\n                ${F("mu_s_min")} =-0.207912;\n                ${F("A")}  =-2.0 * mu_s_min * aBottom / (d_max - d_min);\n                ${F("a")}  = (A - x_mu_s * A) / (1.0 + x_mu_s * A);\n                ${F("d")}  = d_min + min(a, A) * (d_max - d_min);          \n                if ( d == 0.0) {\n                    mu_s = 1.0;\n                } else {\n                    mu_s = ${V("ClampCosine","f",[g("(H * H - d * d) / (2.0 * aBottom * d)")])};\n                }\n\n                nu = ${V("ClampCosine","f",[g("uvwz.x * 2.0 - 1.0")])};\n                return ${L()}(r, mu, mu_s, nu);\n\t\t\t}\n\n\t\t\t${w("GetRMuMuSNuFromScatteringTextureFragCoord","v4",[y("frag_coord"),v("ray_r_mu_intersects_ground")])} {\n                // const vec4 SCATTERING_TEXTURE_SIZE = vec4(\n                    // SCATTERING_TEXTURE_NU_SIZE - 1,\n                    // SCATTERING_TEXTURE_MU_S_SIZE,\n                    // SCATTERING_TEXTURE_MU_SIZE,\n                    // SCATTERING_TEXTURE_R_SIZE);\n                ${R("coord")} = frag_coord;\n                ${L("invSize")} = ${p("scatterInvSize")};\n                //nu & mu on same coord\n                coord.x /=(invSize.x*invSize.z);\n                // mu_s & r on same coord\n                coord.y /=(invSize.y*invSize.w);\n                //mu size\n                ${F("frag_coord_nu")} = floor(coord.x *invSize.z);\n                //mu size\n                ${F("frag_coord_mu")} = ${G("coord.x","1.0/invSize.z")};\n                //mu_s size\n                ${F("frag_coord_r")} = floor(coord.y *invSize.y);\n                //mu_s size\n                ${F("frag_coord_mu_s")} = ${G("coord.y","1.0/invSize.y")};\n                ${L("uvwz")}  = ${L()}(frag_coord_nu, frag_coord_mu_s, frag_coord_mu, frag_coord_r)*invSize; \n\n                ${L("res")} = ${V("GetRMuMuSNuFromScatteringTextureUvwz","v4",[C("uvwz"),v("ray_r_mu_intersects_ground")])};\n                ${F("r")} = res.x;\n                ${F("mu")} = res.y;\n                ${F("mu_s")} = res.z;\n                ${F("nu")} = res.w;\n                // Clamp nu to its valid range of values, given mu and mu_s.\n                nu = clamp(nu, mu * mu_s - sqrt((1.0 - mu * mu) * (1.0 - mu_s * mu_s)),\n                     mu * mu_s + sqrt((1.0 - mu * mu) * (1.0 - mu_s * mu_s)));\n                return ${L()}(r, mu, mu_s, nu);\n\t\t\t}\n\t\t\t\n            ${w("GetTransmittance","v3",[b("transmittance_texture"),g("r"),g("mu"),g("d"),h("ray_r_mu_intersects_ground")])} {\n                ${R("invSize")} = ${p("transInvSize")};\n                ${F("r_d")} = ${V("ClampRadius","f",[g("sqrt(d * d + 2.0 * r * mu * d + r * r)")])};\n                ${F("mu_d")}  = ${V("ClampCosine","f",[g("(r * mu + d) / r_d")])};\n\n                if (ray_r_mu_intersects_ground) {\n                    return min(\n                        ${V("GetTransmittanceToTopAtmosphereBoundary","v3",[b("transmittance_texture"),g("r_d"),g("-mu_d"),y("invSize")])}\n                        /\n                        ${V("GetTransmittanceToTopAtmosphereBoundary","v3",[b("transmittance_texture"),g("r"),g("-mu"),y("invSize")])},\n                        ${A()}(1.0));\n                } else {\n                    return min(\n                        ${V("GetTransmittanceToTopAtmosphereBoundary","v3",[b("transmittance_texture"),g("r"),g("mu"),y("invSize")])} \n                        /\n                        ${V("GetTransmittanceToTopAtmosphereBoundary","v3",[b("transmittance_texture"),g("r_d"),g("mu_d"),y("invSize")])},\n                        ${A()}(1.0));\n                }\n\t\t\t}\n\t\t\t\n            ${w("GetTransmittanceToSun","v3",[b("transmittance_texture"),g("r"),g("mu_s")])}{\n                ${R("invSize")} = ${p("transInvSize")};\n                ${F("sin_theta_h")}  = ${p("atmBottom")} / r;\n                ${F("cos_theta_h")}  = -sqrt(max(1.0 - sin_theta_h * sin_theta_h, 0.0));\n                ${F("smooth")} = smoothstep(-sin_theta_h * ${p("angularRadius")}, sin_theta_h * ${p("angularRadius")}, mu_s - cos_theta_h);\n                return ${V("GetTransmittanceToTopAtmosphereBoundary","v3",[b("transmittance_texture"),g("r"),g("mu_s"),y("invSize")])} * smooth;\n\t\t\t}\n\t\t\t\n            ${w("ComputeSingleScatteringIntegrand","v4",[b("transmittance_texture"),g("r"),g("mu"),g("mu_s"),g("nu"),g("d"),h("ray_r_mu_intersects_ground")])} {\n                ${F("r_d")} = ${V("ClampRadius","f",[g("sqrt(d * d + 2.0 * r * mu * d + r * r)")])};\n                ${F("mu_s_d")}  = ${V("ClampCosine","f",[g("(r * mu_s + d * nu) / r_d")])};\n                ${F("alt")} = r_d - ${p("atmBottom")};\n                ${A("transmittance")}  =  \n                            ${V("GetTransmittance","v3",[b("transmittance_texture"),g("r"),g("mu"),g("d"),h("ray_r_mu_intersects_ground")])} \n                            * \n                            ${V("GetTransmittanceToSun","v3",[b("transmittance_texture"),g("r_d"),g("mu_s_d")])};\n                ${A("rayleigh")} = transmittance * GetProfileDensity(rayleighDensity, alt);\n                ${F("mie")} = (transmittance * GetProfileDensity(mieDensity, alt)).x;\n                return ${L()}(rayleigh, mie);\n\t\t\t}\n\t\t\t\n            ${w("DistanceToNearestAtmosphereBoundary","f",[g("r"),g("mu"),h("ray_r_mu_intersects_ground")])}{\n                if (ray_r_mu_intersects_ground) {\n                    return ${V("DistanceToBottomAtmosphereBoundary","f",[g("r"),g("mu")])};\n                } else {\n                    return ${V("DistanceToTopAtmosphereBoundary","f",[g("r"),g("mu")])};\n                }\n\t\t\t}\n\t\t\t\n            ${w("ComputeSingleScattering","v4",[b("transmittance_texture"),g("r"),g("mu"),g("mu_s"),g("nu"),h("ray_r_mu_intersects_ground")])}{\n                // Number of intervals for the numerical integration.\n                ${I("SAMPLE_COUNT")}  = 50.0;\n                // The integration step, i.e. the length of each integration interval.\n                float dx = ${V("DistanceToNearestAtmosphereBoundary","f",[g("r"),g("mu"),h("ray_r_mu_intersects_ground")])} / SAMPLE_COUNT;\n                // Integration loop.\n                ${A("rayleigh_sum")}  = ${A()}(0.0);\n                ${F("mie_sum")}  = 0.0;\n                for (${F("i")} = 0.0; i <= SAMPLE_COUNT; i++) {\n                    ${F("d_i")}  = i * dx;\n                    // The Rayleigh and Mie single scattering at the current sample point.\n                    ${L("computed")} =  ${V("ComputeSingleScatteringIntegrand","v4",[b("transmittance_texture"),g("r"),g("mu"),g("mu_s"),g("nu"),g("d_i"),h("ray_r_mu_intersects_ground")])};\n                    ${A("rayleigh_i")} = computed.xyz;\n                    ${F("mie_i")} = computed.w;\n                    // Sample weight (from the trapezoidal rule).\n                    ${F("weight_i")} = 1.0;\n                    if (i == 0.0 || i == SAMPLE_COUNT) {\n                        weight_i = 0.5;\n                    }\n                    rayleigh_sum += rayleigh_i * weight_i;\n                    mie_sum += mie_i * weight_i;\n                }\n                ${A("rayleigh")} = rayleigh_sum * dx * ${p("solarIrradiance")} * ${p("rayleighScattering")};\n                ${F("mie")} = (mie_sum * dx *  ${p("solarIrradiance")} *  ${p("mieScattering")}).x;\n                return ${L()}(rayleigh, mie);\n\t\t\t}\n\t\t\t\n            ${w("ComputeSingleScatteringTexture","v4",[b("transmittance_texture"),y("frag_coord")])}{\n                ${z("ray_r_mu_intersects_ground")} ;\n                ${L("coeffs")} = ${V("GetRMuMuSNuFromScatteringTextureFragCoord","v4",[y("frag_coord"),(a="ray_r_mu_intersects_ground",l.parameterRefB(a))])};\n                ${F("r")} = coeffs.x;\n                ${F("mu")} = coeffs.y;\n                ${F("mu_s")} = coeffs.z;\n                ${F("nu")} = coeffs.w;\n                \n                return ${V("ComputeSingleScattering","v4",[b("transmittance_texture"),g("r"),g("mu"),g("mu_s"),g("nu"),h("ray_r_mu_intersects_ground")])};\n\t\t\t}\n      \n            ${u.getMainFragmentStart(e)}\n                ${R("screenUV")} = ${E("vUv")};\n                \n        \n            flR.width=0.0;\n            flR.exp_term=0.0;\n            flR.exp_scale=0.0;\n            flR.linear_term=0.0;\n            flR.constant_term=0.0;\n            \n            slR.width=0.0;\n            slR.exp_term=1.0;\n            slR.exp_scale=-0.000125;\n            slR.linear_term=0.0;\n            slR.constant_term=0.0;\n            \n            rayleighDensity.layer0 = flR;\n            rayleighDensity.layer1 = slR;\n            \n            \n            flM.width=0.0;\n            flM.exp_term=0.0;\n            flM.exp_scale=0.0;\n            flM.linear_term=0.0;\n            flM.constant_term=0.0;\n            \n            \n            slM.width=0.0;\n            slM.exp_term=1.0;\n            slM.exp_scale=-0.000833333;\n            slM.linear_term=0.0;\n            slM.constant_term=0.0;\n            \n            mieDensity.layer0 = flM;\n            mieDensity.layer1 = slM;\n        \n\n                ${L("res")} = ${V("ComputeSingleScatteringTexture","v4",[b(d("tTrans")),y("screenUV")])};\n\n                ${t} = res;           \n            ${u.getMainFragmentEnd(e)}\n        `;var a;return{vertexShader:Q(e),fragmentShader:r}}),"SkyComputeScattering"),en,{}),RenderSky:new r(new t((function(e,t){t.customDefines;const r=o.getShaderOutput("out0");let a=`\n            \n            ${B({varyingName:"vUv",varyingType:"v2"})}\n\n            ${K()}\n            ${Y()}\n            ${J(t)}\n            ${n._DefaultShaderChunk.ibl_sample_methods(t)}\n      \n            ${u.getMainFragmentStart(t)}\n                ${R("screenUV")} = ${E("vUv")};\n                \n        \n            flR.width=0.0;\n            flR.exp_term=0.0;\n            flR.exp_scale=0.0;\n            flR.linear_term=0.0;\n            flR.constant_term=0.0;\n            \n            slR.width=0.0;\n            slR.exp_term=1.0;\n            slR.exp_scale=-0.000125;\n            slR.linear_term=0.0;\n            slR.constant_term=0.0;\n            \n            rayleighDensity.layer0 = flR;\n            rayleighDensity.layer1 = slR;\n            \n            \n            flM.width=0.0;\n            flM.exp_term=0.0;\n            flM.exp_scale=0.0;\n            flM.linear_term=0.0;\n            flM.constant_term=0.0;\n            \n            \n            slM.width=0.0;\n            slM.exp_term=1.0;\n            slM.exp_scale=-0.000833333;\n            slM.linear_term=0.0;\n            slM.constant_term=0.0;\n            \n            mieDensity.layer0 = flM;\n            mieDensity.layer1 = slM;\n        \n\n                    ${A("camPos")}  = ${A()}(0.0,0.0,${p("atmBottom")}+${p("viewAltitude")});\n\t\t\t\t\t${A("sunDir")}  = normalize(${p("sunDirection")});\n\t\t\t\t\t\n\t\t\t\t\t${A("view_ray")} ;\n\t\t\t\t\t${F("phi")}  = PI * (2.0 * screenUV.x - 1.0);\n\n                    ${F("theta")}  = PI * screenUV.y;\n\n\t\t\t\t\t//pour avoir un view ray cohrent avec l'espace monde _()_/\n\t\t\t\t\tview_ray.x = -sin(theta) * sin(phi);\n                    view_ray.y = sin(theta) * cos(phi);\n                    view_ray.z = -cos(theta); \n\t\t\t\t\t\n\t\t\t\t\tview_ray = normalize(view_ray);\n\t\t\t\t\t${A("nightHaze")} ;\n\t\t\t\t\t${A("scattering")}  = ${V("GetSkyScattering","v3",[b(d("tTrans")),b(d("tScatter")),D("camPos"),_("view_ray"),_("sunDir"),D("nightHaze")])};\n\n\t\t\t\t\t//sun\n\t\t\t\t\t//NRE IMPL\n\t\t\t\t\t${A("sunColor")}    = ${A()}(0.9911, 0.8308, 0.6172);\n\t\t\t\t\t${F("sunFactor")}  = smoothstep(0.999956, 0.999957, dot(view_ray, sunDir));\n\t\t\t\t\t${A("sun")}  = sunFactor * sunColor * 60.0;\n\t\t\t\t\tsun  *= min(sun.x,1.0);\n\t\t\t\t\t\n\t\t\t\t\t${F("r")} = length(camPos);\n\t\t\t\t\t${F("rmu")}  = dot(camPos, view_ray);\n\t\t\t\t\t${F("mu")}  = rmu / r;\n\t\t\t\t\t${z("intersectGround")}  = ${V("RayIntersectsGround","b",[g("r"),g("mu")])};\n\t\t\t\t\tif(intersectGround){\n                        //erase sun when goes behind earth, can be used to add a ground too\n\t\t\t\t\t\tsun  = ${A()}(0.0,0.0,0.0);\n\t\t\t\t\t}\n                ${A("color")} = scattering + nightHaze + sun;\n                ${r} = ${V("RGBtoRGBE","v4",[_("color")])}; \n            ${u.getMainFragmentEnd(t)}\n        `;return{vertexShader:Q(t),fragmentShader:a}}),"SkyRendering"),tn,{}),PostProcessScattering:new r(new t((function(n,e){e.customDefines;const t=o.getShaderOutput("out0");var r;return{vertexShader:`\n            ${B({varyingName:"vUv",varyingType:"v2"})}\n            ${B({varyingName:"vRay",varyingType:"v4"})}\n\n            \n            ${$({uniformName:"near",uniformType:"f"})}\n            ${$({uniformName:"screenToView",uniformType:"v4"})}\n            ${$({uniformName:"invView",uniformType:"m4"})}\n\n            ${u.getMainVertexStart(e)}\n                ${L("pos")} = ${L()}( sign( position_.xy ), 0.0, 1.0 );\n                ${k("vUv")} = pos.xy * 0.5 + 0.5;\n                ${e.WebGPU?`${k("vUv")}=${R()}(${k("vUv")}.x,1.0-${k("vUv")}.y);`:""}\n                ${k("vRay")} = ${p("invView")} * vec4(${p("screenToView")}.xy + ${k("vUv")}*${p("screenToView")}.zw,-${p("near")},0.0);\n                ${r="position",o.getBuiltin(r,o.ShaderStages.out)} = pos;\n            ${u.getMainVertexEnd(e)}\n        `,fragmentShader:`\n            \n            ${B({varyingName:"vUv",varyingType:"v2"})}\n            ${B({varyingName:"vRay",varyingType:"v4"})}\n            \n            ${$({uniformName:"near",uniformType:"f"})}\n            ${$({uniformName:"far",uniformType:"f"})}\n            ${$({uniformName:"texturesLoaded",uniformType:"f"})}\n\n            ${K()}\n            ${Y()}\n            ${J(e)}\n      \n            ${u.getMainFragmentStart(e)}\n                ${R("screenUV")} = ${E("vUv")};\n                ${L("ray")} = ${E("vRay")};\n\n                    ${A("camPos")}  = vec3(0.0,0.0,${p("atmBottom")}+${p("viewAltitude")});\n\t\t\t\t\t${A("sunDir")}  = ${p("sunDirection")};\n\t\t\t\t\tsunDir = normalize(sunDir);\n\t\t\t\t\t\n\t\t\t\t\t${A("viewRay")}  = ray.xyz;\n\t\t\t\t\tviewRay = normalize(viewRay);\n\t\t\t\t\t\n\t\t\t\t\t${L("color")}  = ${O(d("tDiffuse"),"screenUV")};\n\t\t\t\t\t\n\t\t\t\t\tif(${p("texturesLoaded")}==1.0){\n\t\t\t\t\t\n\t\t\t\t\t\t${L("normalDepth")}  = ${O(d("tDepth"),"screenUV")};\n\t\t\t\t\t\t${F("zNDC")}  = 2.0*normalDepth.w - 1.0;\n\t\t\t\t\t\t\n\t\t\t\t\t\t//we don't build point position like NRE, its way too clunky for no reason\n\t\t\t\t\t\t//they rebuild the whole position instead of using cameraPosition and viewRay\n\t\t\t\t\t\t${F("viewZ")}  = zNDC *(2.0*${p("near")}*${p("far")} + ${p("far")} - ${p("near")} )/(${p("near")}+${p("far")});\n\t\t\t\t\t\t\n                        //ratio between actual depth to near\n\t\t\t\t\t\t${F("rayScale")}  = viewZ/${p("near")};\n                        //vRay contains the ray to near plane\n\t\t\t\t\t\t${A("rayToPoint")}  = ray.xyz * rayScale;\n                        //from mm to km\n\t\t\t\t\t\trayToPoint /= 1000000.0;\n\t\t\t\t\t\t${A("scatteringPos")}  = camPos + rayToPoint;\n\t\t\t\t\t\t\n\t\t\t\t\t\t${A("attenuation")}  = ${A()}(1.0);\n\t\t\t\t\t\t${A("nightHaze")}  = ${A()}(0.0);\n\t\t\t\t\t\t${A("scattering")}  = ${A()}(0.0);\n\t\t\t\t\t\t\n\t\t\t\t\t\t${F("r")}  = length(camPos);\n\t\t\t\t\t\t${F("rmu")}  = dot(camPos, viewRay);\n\t\t\t\t\t\t${F("mu")}  = rmu / r;\n\t\t\t\t\t\t${z("intersectGround")}  = ${V("RayIntersectsGround","b",[g("r"),g("mu")])};\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(zNDC>-1.0){\n\t\t\t\t\t\t\tscattering = ${V("GetSkyScatteringWithDepth","v3",[b(d("tScatter")),D("camPos"),_("viewRay"),_("sunDir"),_("scatteringPos"),D("attenuation")])};\n                            ${A("reflColor")} = ${V("GetReflectedLight","v3",[b(d("tIrr")),b(d("tTrans")),_("color.xyz"),_("scatteringPos"),_("camPos"),_("sunDir"),_("attenuation")])};\n\t\t\t\t\t\t\tcolor.x = reflColor.x;\n\t\t\t\t\t\t\tcolor.y = reflColor.y;\n\t\t\t\t\t\t\tcolor.z = reflColor.z;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcolor.x += scattering.x;\n\t\t\t\t\t\tcolor.y += scattering.y;\n\t\t\t\t\t\tcolor.z += scattering.z;\n\t\t\t\t\t\n\t\t\t\t\t}\n\n                ${t} = color;           \n            ${u.getMainFragmentEnd(e)}\n        `}}),"SkyPostProcessScattering"),rn,{})}})),define("DS/ShaderBuilders/PostPro/BlurShaderBuilders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PostPro/PostProUniformHandler","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/PostPro/PostProContext","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a,o,i,s){"use strict";const l="",u=i.ParameterUtils,m=i.FunctionHandler,c=i.BridgeFunctions,$=n=>a.addUniform(n),p=n=>{var e={uniformName:n};return a.getUniform(e)},d=n=>u.parameterV2(n),f=(n,e,t)=>m.declareFunction(n,e,t),h=(n,e,t)=>m.callFunction(n,e,t),v=(n=null,e=0)=>{var t={name:n,size:e};return s.int(t)},g=(n=null,e=0)=>{var t={name:n,size:e};return s.float(t)},x=(n=null,e=0)=>{var t={name:n,size:e};return s.vec2(t)},S=(n=null,e=0)=>{var t={name:n,size:e};return s.vec3(t)},y=(n=null,e=0)=>{var t={name:n,size:e};return s.vec4(t)},_=n=>o.addVarying(n),T=n=>o.getVarying(n,o.ShaderStages.in),D=n=>o.getVarying(n,o.ShaderStages.out),C=(n,e)=>{return c.sample2DTexture((t={uniformName:n},a.getTextureUniform(t)),e);var t},P={LEVEL:1};function N(e){return`\n            \n            ${_({varyingName:"vUv",varyingType:"v2"})}\n            \n\n            ${m.getMainVertexStart(e)}\n\n                ${D("vUv")} = uv.xy;\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(e)}\n            ${m.getMainVertexEnd(e)}\n        `}function b(n){let e=[],t=[],r=l;switch(n){case 1:default:e.push(-1.2),t.push(.3125),e.push(0),t.push(.375),e.push(1.2),t.push(.3125);break;case 2:e.push(-1.285714285714),t.push(.328125),e.push(0),t.push(.3125),e.push(1.285714285714),t.push(.328125);break;case 3:e.push(-3.111111111111),t.push(.03515625),e.push(-1.333333333333),t.push(.328125),e.push(0),t.push(.2734375),e.push(1.333333333333),t.push(.328125),e.push(3.111111111111),t.push(.03515625);break;case 4:e.push(-3.181818181818),t.push(.0537109375),e.push(-1.363636363636),t.push(.322265625),e.push(0),t.push(.24609375),e.push(1.363636363636),t.push(.322265625),e.push(3.181818181818),t.push(.0537109375);break;case 5:e.push(-5.076923076923),t.push(.003173828125),e.push(-3.230769230769),t.push(.06982421875),e.push(-1.384615384615),t.push(.314208984375),e.push(0),t.push(.2255859375),e.push(1.384615384615),t.push(.314208984375),e.push(3.230769230769),t.push(.06982421875),e.push(5.076923076923),t.push(.003173828125)}for(let n=0;n<e.length;n++){let a=0!==e[n]?e[n]:"0.0";r=`\n                ${r}\n                result += ${C("tInput",`screenPos + ${a} * blurSize`)} * ${t[n]};\n            `}return r}class M extends e{constructor(){super(),this.direction=new n.Vector2(1,1),this.blurSize=1,this.ratio=1,this.kernel=[]}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform1f(r.blurSize,this.blurSize),t.uniform1f(r.ratio,this.ratio),t.uniform2f(r.direction,this.direction.x,this.direction.y),t.uniform4fv(r.kernel,this.kernel)}fillUBO(n,e,t){super.fillUBO(n,e,t);const r=n.layout;n.setF(r.blurSize,this.blurSize),n.setF(r.ratio,this.ratio),n.setV2(r.direction,this.direction),n.setFlatV4Array(r.kernel,this.kernel)}clone(){var n=new M;return n.direction=this.direction,n.blurSize=this.blurSize,n.ratio=this.ratio,n.kernel=this.kernel,n}}class U extends e{constructor(e=0){super(e),this.invSize=new n.Vector2(1,1)}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform2f(r.invSize,this.invSize.x,this.invSize.y)}fillUBO(n,e,t){super.fillUBO(n,e,t);const r=n.layout;n.setV2(r.invSize,this.invSize)}clone(){var n=new U;return n.invSize=this.invSize,n}}class w extends U{constructor(){super(),this.radius=1}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform1f(r.radius,this.radius)}fillUBO(n,e,t){super.fillUBO(n,e,t);const r=n.layout;n.setF(r.radius,this.radius)}clone(){var n=new w;return n.invSize=this.invSize,n.radius=this.radius,n}}class V extends U{constructor(){super(1)}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i)}fillUBO(n,e,t){super.fillUBO(n,e,t)}clone(){var n=new V;return n.invSize=this.invSize,n}}const z={NB_SAMPLES:4,STEP:1.5};function F(n){return`\n            ${f("getNormalDepth","v4",[d("uv")])} {\n                ${y("normalDepth")} = ${C("tNormalDepth","uv")};\n                ${n.renderToFloatTexture?`\n                    return ${y()}(normalDepth.xyz * 2.0 - 1.0, normalDepth.w);\n                    `:`\n                    ${S("normal")} = ${h("decodeOct22Normal","v3",[d("normalDepth.xy")])};\n                    ${g("depth")} = ${h("unpackForFloat16","f",[d("normalDepth.zw")])};\n                    return ${y()}(normal, depth);\n                    `}\n            }\n\n        `}function I(n,e){return`\n            ${y("normalDepth")} = ${h("getNormalDepth","v4",[d("screenPos")])};\n            ${S("normal")} = normalDepth.xyz;\n            ${g("depth")} = normalDepth.w;\n            for (${v("i")} = -${n}; i <= ${n}; i++) {\n                for (${v("j")} = -${e}; j <= ${e}; j++) {\n                    // no blur on center\n                    if (i == 0 && j == 0) {\n                        continue;\n                    }\n                    ${x("pos")} = screenPos + offset * ${x()}(${g()}(i), ${g()}(j));            \n                    \n                    ${y("normalDepth2")} = ${h("getNormalDepth","v4",[d("pos")])};\n                    ${S("normal2")} = normalDepth2.xyz;\n                    ${g("depth2")} = normalDepth2.w;\n\n                    ${g("weightDepth")} = 1.0 / (1.0 + 100.0 * abs(depth2 - depth));\n                    ${g("weightNormal")} = clamp(dot(normal, normal2), 0.0, 1.0);\n\n                    result += weightDepth * weightNormal * ${C("tInput","pos")}.xyz;\n                    total += weightDepth * weightNormal;\n                }\n            }\n        `}return{Blur:new r(new t((function(n,e){var t=e.customDefines;const r=o.getShaderOutput("out0");let a=`\n            ${$({uniformName:"blurSize",uniformType:"f"})}\n            ${$({uniformName:"ratio",uniformType:"f"})}\n            ${$({uniformName:"direction",uniformType:"v2"})}\n            ${$({uniformName:"kernel",uniformType:"fv4",size:Math.ceil((2*t.LEVEL+1)/4)})}\n            ${$({uniformName:"tInput",uniformType:"t2",locationName:"tInput"})}\n            \n            ${_({varyingName:"vUv",varyingType:"v2"})}\n\n            ${m.getMainFragmentStart(e)}\n                ${x("screenPos")} = ${T("vUv")};\n\n                ${x("dir")} = ${p("direction")} * ${p("blurSize")} * ${p("ratio")} * 0.5 / ${g()}(${t.LEVEL});\n\n                ${y("color")} = ${y()}(0.0);\n                for (${v("j")} = 0; j < ${Math.ceil((2*t.LEVEL+1)/4)}; j++) {\n                    for (${v("i")} = 0; i < 4; i++) {\n                        ${v("index")} = j * 4 + i - ${t.LEVEL};\n                        if (index > ${t.LEVEL}) {\n                            break;\n                        }\n                        ${x("texCoord")} = dir * ${g()}(index) + screenPos;\n                        ${y("sampleCol")} = ${C("tInput","texCoord")};\n\n                        color += sampleCol * ${p("kernel")}[j][i];\n                    }\n                }\n                ${r} = color;\n            ${m.getMainFragmentEnd(e)}\n        `;return{vertexShader:N(e),fragmentShader:a}}),"BlurBasic"),M,P),BlurH:new r(new t((function(n,e){var t=e.customDefines;const r=o.getShaderOutput("out0");let a=`\n            \n            ${$({uniformName:"invSize",uniformType:"v2"})}\n            ${$({uniformName:"tInput",uniformType:"t2",locationName:"tInput"})}\n            \n            ${_({varyingName:"vUv",varyingType:"v2"})}\n\n            ${m.getMainFragmentStart(e)}\n                ${x("screenPos")} = ${T("vUv")};\n\n                ${y("result")} = ${y()}(0.0);\n                ${x("blurSize")} = ${x()}(${p("invSize")}.x, 0.0);\n\n                ${b(t.LEVEL)}\n\n                ${r} = result;\n            ${m.getMainFragmentEnd(e)}\n        `;return{vertexShader:N(e),fragmentShader:a}}),"BlurH"),U,P),BlurV:new r(new t((function(n,e){var t=e.customDefines;const r=o.getShaderOutput("out0");let a=`\n            \n            ${$({uniformName:"invSize",uniformType:"v2"})}\n            ${$({uniformName:"tInput",uniformType:"t2",locationName:"tInput"})}\n            \n            ${_({varyingName:"vUv",varyingType:"v2"})}\n\n            ${m.getMainFragmentStart(e)}\n                ${x("screenPos")} = ${T("vUv")};\n\n                ${y("result")} = ${y()}(0.0);\n                ${x("blurSize")} = ${x()}(0.0, ${p("invSize")}.y);\n\n                ${b(t.LEVEL)}\n\n                ${r} = result;\n            ${m.getMainFragmentEnd(e)}\n        `;return{vertexShader:N(e),fragmentShader:a}}),"BlurV"),U,P),BlurPoisson:new r(new t((function(n,e){e.customDefines;const t=o.getShaderOutput("out0"),r=[-.326212,-.405805,-.840144,-.07358,-.695914,.457137,-.203345,.620716,.96234,-.194983,.473434,-.480026,.519456,.767022,.185461,-.893124,.507431,.064425,.530992,.412458,-.32194,-.871945,-.791559,.597705],a=2/r.length;let i=`\n            \n            ${$({uniformName:"invSize",uniformType:"v2"})}\n            ${$({uniformName:"radius",uniformType:"f"})}\n            ${$({uniformName:"tInput",uniformType:"t2",locationName:"tInput"})}\n            \n            ${_({varyingName:"vUv",varyingType:"v2"})}\n\n            ${m.getMainFragmentStart(e)}\n                ${x("screenPos")} = ${T("vUv")};\n\n                ${y("result")} = ${y()}(0.0);\n                ${x("blurSize")} = ${p("radius")} * ${p("invSize")};\n\n                ${function(){for(var n=l,e=0;e<r.length;e+=2)n=`\n                    ${n}\n                    result += ${C("tInput",`screenPos + blurSize *${x()}(${r[e]}, ${r[e+1]})`)};\n                `;return n}()}\n\n                ${t} = result * ${a};\n            ${m.getMainFragmentEnd(e)}\n        `;return{vertexShader:N(e),fragmentShader:i}}),"BlurPoisson"),w,{}),BlurAdaptativeHV:new r(new t((function(n,e){var t=e.customDefines;const r=o.getShaderOutput("out0");let a=` \n            ${$({uniformName:"invSize",uniformType:"v2"})}\n            ${$({uniformName:"tInput",uniformType:"t2",locationName:"tInput0"})}\n            ${$({uniformName:"tNormalDepth",uniformType:"t2",locationName:"tInput1"})}\n            ${_({varyingName:"vUv",varyingType:"v2"})}\n\n            ${F(e)}\n\n            ${m.getMainFragmentStart(e)}      \n                ${x("screenPos")} = ${T("vUv")};\n                ${S("result")} = ${C("tInput","screenPos")}.xyz;\n                ${g("total")} = 1.0;\n\n                ${x("offset")} = ${t.STEP} * ${p("invSize")};\n\n                ${I(t.NB_SAMPLES,t.NB_SAMPLES)}\n\n                ${r} = ${y()}(result / total, 1.0);\n            ${m.getMainFragmentEnd(e)}\n        `;return{vertexShader:N(e),fragmentShader:a}}),"BlurAdaptativeHV"),V,z),BlurAdaptativeH:new r(new t((function(n,e){var t=e.customDefines;const r=o.getShaderOutput("out0");let a=` \n            ${$({uniformName:"invSize",uniformType:"v2"})}\n            ${$({uniformName:"tInput",uniformType:"t2",locationName:"tInput0"})}\n            ${$({uniformName:"tNormalDepth",uniformType:"t2",locationName:"tInput1"})}\n            ${_({varyingName:"vUv",varyingType:"v2"})}\n\n            ${F(e)}\n\n            ${m.getMainFragmentStart(e)}       \n                ${x("screenPos")} = ${T("vUv")};\n                ${S("result")} = ${C("tInput","screenPos")}.xyz;\n                ${g("total")} = 1.0;\n\n                ${x("offset")} = ${t.STEP} * ${x()}(${p("invSize")}.x, 0.0);\n\n                ${I(t.NB_SAMPLES,0)}\n\n                ${r} = ${y()}(result / total, 1.0);\n            ${m.getMainFragmentEnd(e)}\n        `;return{vertexShader:N(e),fragmentShader:a}}),"BlurAdaptativeH"),V,z),BlurAdaptativeV:new r(new t((function(n,e){var t=e.customDefines;const r=o.getShaderOutput("out0");let a=` \n            ${$({uniformName:"invSize",uniformType:"v2"})}\n            ${$({uniformName:"tInput",uniformType:"t2",locationName:"tInput0"})}\n            ${$({uniformName:"tNormalDepth",uniformType:"t2",locationName:"tInput1"})}\n            ${_({varyingName:"vUv",varyingType:"v2"})}\n\n            ${F(e)}\n\n            ${m.getMainFragmentStart(e)}         \n                ${x("screenPos")} = ${T("vUv")};\n                ${S("result")} = ${C("tInput","screenPos")}.xyz;\n                ${g("total")} = 1.0;\n\n                ${x("offset")} = ${t.STEP} * ${x()}(0.0, ${p("invSize")}.y);\n\n                ${I(0,t.NB_SAMPLES)}\n\n                ${r} = ${y()}(result / total, 1.0);\n            ${m.getMainFragmentEnd(e)}\n        `;return{vertexShader:N(e),fragmentShader:a}}),"BlurAdaptativeV"),V,z)}})),define("DS/ShaderBuilders/PostPro/OITLinkedListShaderBuilder",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/PostPro/PostProContext","DS/ShaderBuilders/PostPro/PostProUniformHandler","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils"],(function(n,e,t,r,a,o,i){"use strict";const s=i.FunctionHandler,l=n=>o.getShaderInput(n),u=n=>o.getShaderOutput(n),m=n=>a.addUniform(n),c=n=>{var e={uniformName:n};return a.getUniform(e)},$=n=>a.addStorageBuffer(n),p=n=>a.getStorageBuffer(n);class d extends r{constructor(){super()}fillUBO(n,e,t){t.fillOITLinkedListUBO(n)}clone(){return new d}}function f(e){return`\n                ${s.getMainVertexStart(e)}\n                    ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(e)}\n                ${s.getMainVertexEnd(e)}\n            `}function h(n){return n.WebGPU?`\n                ${m({uniformName:"scissorRect",uniformType:"v4"})}\n\n                // [0]    = atomic fragment counter\n                // [1..n] = linked list head indices\n                ${$({bufferName:"oitLinkedListHeads",bufferType:"array<u32>"})}\n\n                // - xy = half-float fragment color\n                // - z  = bit-casted fragment depth\n                // - w  = index of next element\n                ${$({bufferName:"oitLinkedListElements",bufferType:"array<vec4u>",readOnly:!0})}\n\n                // these should be kept as low as result correctness allows\n                const kMaxLayers = 64;       // max number of layers alpha-blended per pixel\n                const kMaxSortedLayers = 6;  // max number of layers depth-sorted per pixel\n\n                // Unpacks a single f16 (stored in lower 16 bits of a u32) to f32\n                fn f16_to_f32(bits: u32) -> f32 {\n                    let sign: u32 = (bits & 0x8000u) << 16;\n                    let exponent: u32 = (bits >> 10) & 0x1Fu;\n                    let mantissa: u32 = (bits & 0x03FFu) << 13;\n\n                    if (exponent == 0) {\n                        // handle subnormal values and zero\n                        return bitcast<f32>(sign | mantissa) * 2.0e-14;\n                    }\n                    if (exponent == 31) {\n                        // handle infinity and NaN\n                        return bitcast<f32>(sign | 0x7F800000u | mantissa);\n                    }\n                    return bitcast<f32>(sign | ((exponent + 112) << 23) | mantissa);\n                }\n\n                // Unpacks 16-bit HDR color (stored in two u32) to 32-bit\n                fn unpackColor(packed: vec2u) -> vec4f {\n                    let r = f16_to_f32(packed.x & 0xFFFFu);\n                    let g = f16_to_f32(packed.x >> 16);\n                    let b = f16_to_f32(packed.y & 0xFFFFu);\n                    let a = f16_to_f32(packed.y >> 16);\n                    return vec4f(r, g, b, a);\n                }\n\n                // Performs alpha blending of srcColor over dstColor\n                fn blendColors(srcColor: vec4f, dstColor: vec4f) -> vec4f {\n                    let rgb = srcColor.rgb * srcColor.a + dstColor.rgb * (1.0f - srcColor.a);\n                    let alpha = srcColor.a + dstColor.a * (1.0f - srcColor.a);\n                    return vec4f(rgb, alpha);\n                }\n\n                ${s.getMainFragmentStart(n)}\n                    let fragCoord = vec2i(${l("fragCoord")}.xy);\n\n                    // retrieve the head of the linked list associated with this pixel\n                    let pixelIdx = 1 + (fragCoord.y - i32(${c("scissorRect")}.y)) * i32(${c("scissorRect")}.z) + fragCoord.x;\n                    var currentIdx = ${p("oitLinkedListHeads")}[pixelIdx];\n\n                    // reset atomic counter and linked list head for next frame\n                    ${p("oitLinkedListHeads")}[0] = 0u;\n                    ${p("oitLinkedListHeads")}[pixelIdx] = 0xFFFFFFFFu;\n\n                    var layers: array<vec3u, kMaxSortedLayers>;\n                    var dstColor = vec4f(0.0);\n                    var numSortedLayers = 0;\n                    var numLayers = 0;\n\n                    // traverse the linked list and sort the layers in depth order\n                    while (currentIdx != 0xFFFFFFFFu && numLayers < kMaxLayers)\n                    {\n                        let toInsert = ${p("oitLinkedListElements")}[currentIdx];\n                        currentIdx = toInsert.w;\n                        numLayers++;\n\n                        if (numSortedLayers < kMaxSortedLayers)\n                        {\n                            // there is still room in the sorted list\n                            // -> insert current layer so that the list stay sorted\n                            var j = numSortedLayers;\n                            while (j > 0 && toInsert.z > layers[j-1].z)\n                            {\n                                layers[j] = layers[j-1];\n                                j--;\n                            }\n                            layers[j] = toInsert.xyz;\n                            numSortedLayers++;\n                        }\n                        else if (toInsert.z < layers[0].z)\n                        {\n                            // current layer is closer than the farthest sorted one\n                            // -> blend farthest layer, then insert current layer (approximation)\n                            let srcColor = unpackColor(layers[0].xy);\n                            dstColor = blendColors(srcColor, dstColor);\n\n                            var j = 0;\n                            while (j < numSortedLayers-1 && toInsert.z < layers[j+1].z)\n                            {\n                                layers[j] = layers[j+1];\n                                j++;\n                            }\n                            layers[j] = toInsert.xyz;\n                        }\n                        else\n                        {\n                            // current layer is farther than any of the sorted ones\n                            // -> blend current layer early (approximation)\n                            let srcColor = unpackColor(toInsert.xy);\n                            dstColor = blendColors(srcColor, dstColor);\n                        }\n                    }\n\n                    // blend sorted layers in back-to-front order\n                    for (var i = 0; i < numSortedLayers; i++)\n                    {\n                        let srcColor = unpackColor(layers[i].xy);\n                        dstColor = blendColors(srcColor, dstColor);\n                    }\n\n                    ${u("out0")} = dstColor;\n                ${s.getMainFragmentEnd(n)}\n            `:`\n                    ${s.getMainFragmentStart(n)}\n                        ${u("out0")} = vec4(0.f);\n                    ${s.getMainFragmentEnd(n)}\n                `}return{Combine:new t(new e((function(n,e){return{vertexShader:f(e),fragmentShader:h(e)}}),"OITCombine"),d,{})}})),define("DS/ShaderBuilders/PostPro/EncodingShaderBuilders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PostPro/PostProUniformHandler","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/PostPro/PostProContext","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a,o,i,s){"use strict";const l=i.ParameterUtils,u=i.FunctionHandler,m=i.BridgeFunctions,c=n=>a.addUniform(n),$=n=>l.parameterV3(n),p=n=>l.parameterV4(n),d=(n,e,t)=>u.callFunction(n,e,t),f=(n=null,e=0)=>{var t={name:n,size:e};return s.vec2(t)},h=(n=null,e=0)=>{var t={name:n,size:e};return s.vec4(t)},v=n=>o.addVarying(n),g=n=>o.getVarying(n,o.ShaderStages.in),x=n=>o.getVarying(n,o.ShaderStages.out),S=(n,e)=>{return m.sample2DTexture((t={uniformName:n},a.getTextureUniform(t)),e);var t};class y extends e{constructor(){super()}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i)}fillUBO(n,e,t){super.fillUBO(n,e,t)}clone(){return new y}}function _(e){return`\n        \n            ${v({varyingName:"vUv",varyingType:"v2"})}\n\n            ${u.getMainVertexStart(e)}\n                ${x("vUv")} = uv.xy;\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(e)}\n            ${u.getMainVertexEnd(e)}\n        `}return{EncodeHDR:new r(new t((function(e,t){var r=t.customDefines;const a=o.getShaderOutput("out0");let i,l;switch(r.OUTPUT_ENCODING){case"RGBE":i=`             \n                    ${a} = ${d("RGBtoRGBE","v4",[$("color")])};\n                `;break;case"RGB":i=`             \n                    ${a} = ${h()}(color, 1.0);\n                `;break;case"LogLUV":i=`             \n                    ${a} = ${d("RGBtoLogLUV","v4",[$("color")])};\n                `;break;case"RGBM":i=`             \n                    ${a} = ${d("RGBtoRGBM","v4",[$("color")])};\n                `}switch(r.INPUT_ENCODING){case"RGBE":l=`             \n                    color = ${d("RGBEtoRGB","v3",[p("fetched")])};\n                `;break;case"RGB":l="           \n                    color = fetched.rgb;  \n                ";break;case"LogLUV":l=`             \n                    color = ${d("LogLUVtoRGB","v3",[p("fetched")])};\n                `;break;case"LogLUV":l=`             \n                    color = ${d("RGBMtoRGB","v3",[p("fetched")])};\n                `}let m=`\n            \n            ${v({varyingName:"vUv",varyingType:"v2"})}\n            \n            ${c({uniformName:"tInput",uniformType:"t2"})}\n\n            ${n._DefaultShaderChunk.ibl_sample_methods(t)}\n\n            ${u.getMainFragmentStart(t)}\n                ${f("screenUV")} = ${g("vUv")};\n                ${h("fetched")}  = ${S("tInput","screenUV")};\n                ${((n=null,e=0)=>{var t={name:n,size:e};return s.vec3(t)})("color")};\n                ${l}\n                ${i}\n            ${u.getMainFragmentEnd(t)}\n        `;return{vertexShader:_(t),fragmentShader:m}}),"EncodeHDR"),y,{INPUT_ENCODING:"RGB",OUTPUT_ENCODING:"RGBE"}),DecodeDepth:new r(new t((function(n,e){e.customDefines;const t=o.getShaderOutput("out0");let r=`\n            \n            ${v({varyingName:"vUv",varyingType:"v2"})}\n            \n            ${c({uniformName:"tInput",uniformType:"t2"})}\n\n\n            ${u.getMainFragmentStart(e)}\n                ${f("screenUV")} = ${g("vUv")};\n                ${h("packedDepth")}  = ${S("tInput","screenUV")};\n                ${t} = ${h()}(0.0);\n                ${2===e.WebGLVersion||e.WebGPU?`${a="fragDepth",o.getShaderOutput(a)} = ${d("unpackRGBA","f",[p("packedDepth")])};`:`gl_FragDepthEXT = ${d("unpackRGBA","f",[p("packedDepth")])};`}\n            ${u.getMainFragmentEnd(e)}\n        `;var a;return{vertexShader:_(e),fragmentShader:r}}),"DecodeDepth"),y,{})}})),define("DS/ShaderBuilders/PostPro/SSLRShaderBuilders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PostPro/PostProUniformHandler","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/PostPro/PostProContext","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a,o,i,s){"use strict";const l=i.ParameterUtils,u=i.FunctionHandler,m=i.BridgeFunctions,c=n=>a.addUniform(n),$=n=>{var e={uniformName:n};return a.getUniform(e)},p=n=>{var e={uniformName:n};return a.getTextureUniform(e)},d=n=>s.dereference(n),f=n=>l.parameterF(n),h=n=>l.parameterInOutF(n),v=n=>l.parameterRefF(n),g=n=>l.parameterV2(n),x=n=>l.parameterV3(n),S=n=>l.parameterV4(n),y=(n,e,t)=>u.declareFunction(n,e,t),_=(n,e,t)=>u.callFunction(n,e,t),T=(n=null,e=0)=>{var t={name:n,size:e};return s.int(t)},D=(n=null,e=0)=>{var t={name:n,size:e,constant:!0};return s.int(t)},C=(n=null,e=0)=>{var t={name:n,size:e};return s.float(t)},P=(n=null,e=0)=>{var t={name:n,size:e,constant:!0};return s.float(t)},N=(n=null,e=0)=>{var t={name:n,size:e};return s.vec2(t)},b=(n=null,e=0)=>{var t={name:n,size:e};return s.vec3(t)},M=(n=null,e=0)=>{var t={name:n,size:e,constant:!0};return s.vec3(t)},U=(n=null,e=0)=>{var t={name:n,size:e};return s.vec4(t)},w=n=>o.addVarying(n),V=n=>o.getVarying(n,o.ShaderStages.in),z=n=>o.getVarying(n,o.ShaderStages.out),F=n=>o.getShaderInput(n),I=(n,e)=>m.sample2DTexture(n,e),R=(n,e)=>m.modulo(n,e);function A(e){return`\n            ${w({varyingName:"vUv",varyingType:"v2"})}\n\n            ${u.getMainVertexStart(e)}\n\n                ${z("vUv")} = uv.xy;\n\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(e)}\n            ${u.getMainVertexEnd(e)}\n\n        `}class L extends e{constructor(){super(2),this.realProjectionMatrix=new n.Matrix4,this.realProjectionMatrixInverse=new n.Matrix4,this.frustumPlanes=[],this.sceneSize=100,this.screenSize=new n.Vector2(512,512),this.renderIteration=0}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform1f(r.sceneSize,this.sceneSize),t.uniform1i(r.renderIteration,this.renderIteration),t.uniform4fv(r.frustumPlanes,this.frustumPlanes),t.uniform2f(r.screenSize,this.screenSize.x,this.screenSize.y),t.uniformMatrix4fv(r.realProjectionMatrixInverse,!1,e.float32Matrix4x4Temp.setDoubles(this.realProjectionMatrixInverse.elements)),t.uniformMatrix4fv(r.realProjectionMatrix,!1,e.float32Matrix4x4Temp.setDoubles(this.realProjectionMatrix.elements))}fillUBO(n,e,t){super.fillUBO(n,e,t);const r=n.layout;n.setF(r.sceneSize,this.sceneSize),n.setI(r.renderIteration,this.renderIteration),n.setFlatV4Array(r.frustumPlanes,this.frustumPlanes),n.setV2(r.screenSize,this.screenSize),n.setM4(r.realProjectionMatrixInverse,this.realProjectionMatrixInverse),n.setM4(r.realProjectionMatrix,this.realProjectionMatrix)}clone(){var n=new L;return n.realProjectionMatrix=this.realProjectionMatrix,n.realProjectionMatrixInverse=this.realProjectionMatrixInverse,n.frustumPlanes=this.frustumPlanes,n.sceneSize=this.sceneSize,n.screenSize=this.screenSize,n.renderIteration=this.renderIteration,n}}function B(n,e){const t=p("tColor"),r=p("tColorNormalDepth");return`\n            \n        ${w({varyingName:"vUv",varyingType:"v2"})}\n\n        ${c({uniformName:"tColor",uniformType:"t2",locationName:"tInput0"})}\n        ${c({uniformName:"tColorNormalDepth",uniformType:"t2",locationName:"tInput1"})}      \n        ${c({uniformName:"tNormalDepthIoRRoughness",uniformType:"t2",locationName:"tInput2"})}\n\n        ${c({uniformName:"realProjectionMatrix",uniformType:"m4"})}\n        ${c({uniformName:"realProjectionMatrixInverse",uniformType:"m4"})}\n        ${c({uniformName:"frustumPlanes",uniformType:"fv4",size:6})}\n        ${c({uniformName:"sceneSize",uniformType:"f"})}\n        ${c({uniformName:"screenSize",uniformType:"v2"})}\n        ${c({uniformName:"renderIteration",uniformType:"i"})}\n\n        ${e?`          \n            ${D("MAX_RAY")} = 8;\n            ${P("MAX_RAY_F")} = 8.0;\n            ${P("I_MAX_RAY_F")} = 1.0 / 8.0;\n            `:`\n            ${D("MAX_RAY")} = 4;\n            ${P("MAX_RAY_F")} = 4.0;\n            ${P("I_MAX_RAY_F")} = 1.0 / 4.0;\n            `}\n        ${P("PI")} = 3.14159265359;\n        ${P("INV_GOLDEN_RATIO")} = 0.6180339887;\n        ${M("CLAMP_VALUE")} = ${b()}(3.0);\n            \n        ${y("toViewPos","v3",[g("uv"),f("depth")])}{\n            ${N("projSpaceXY")} = uv;\n            ${m.uvConvention("projSpaceXY")}\n            ${U("vertexPositionProjected")} = ${U()}(projSpaceXY * 2.0 - 1.0, depth, 1.0);\n            ${U("vertexPositionVS")}  = ${$("realProjectionMatrixInverse")} * vertexPositionProjected;\n            vertexPositionVS.x /= vertexPositionVS.w;\n            vertexPositionVS.y /= vertexPositionVS.w;\n            vertexPositionVS.z /= vertexPositionVS.w;\n            vertexPositionVS.w = 1.0;\n\n            return vertexPositionVS.xyz;\n        }\n\n        ${y("toViewPos","v3",[g("uv")])}{\n            ${U("normalDepth")}  = ${I(r,"uv")};\n            ${C("z")};     \n            // [0.0, 1.0]\n            ${e?`                       \n                ${n.renderToFloatTexture?"\n                    z = normalDepth.w;\n                    ":`\n                    z = ${_("unpackForFloat16","f",[g("normalDepth.zw")])};\n                    `}\n                `:"      \n                // for reflection, tColorNormalDepth is equal to tNormalDepthIoRRoughness     \n                z = normalDepth.w;\n                "}\n            if (z == 0.0) {\n                z = 1.0;\n            }\n\n            ${C("depth")} = ${m.getDepthWithConvention("z")};\n            return ${_("toViewPos","v3",[g("uv"),f("depth")])};\n        }\n\n        ${y("getScreenPos3","v3",[x("pos")])} {\n\n            ${U("offset")}  = ${$("realProjectionMatrix")} * ${U()}(pos, 1.0);\n            offset.x /= offset.w;\n            offset.y /= offset.w;\n            offset.z /= offset.w;\n            offset.x = offset.x * 0.5 + 0.5;\n            offset.y = offset.y * 0.5 + 0.5;\n            \n            ${m.uvConvention("offset")}\n\n            return offset.xyz;\n        }\n\n        ${y("sampleColorScene","v4",[g("uv")])} {\n            ${U("color")}  = ${I(t,"uv")};\n            ${n.noCompositing?`\n                return ${U()}(${_("convertToLinear","v3",[x("color.rgb")])}, color.a);\n                `:"\n                return color;\n                "}\n        }\n\n        ${y("random","f",[x("scale"),f("seed"),S("fragCoord")])} {\n            return fract(sin(dot(fragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n        }\n\n        ${y("Random1D","f",[f("seed"),S("fragCoord")])} {\n            ${b("scale")} = ${b()}(12.9898, 78.233, 151.7182);\n            return ${_("random","f",[x("scale"),f("seed"),S("fragCoord")])};\n        }\n\n        ${y("GetLightVector","v3",[x("N"),x("H")])}{\n            return 2.0 * dot(N, H) * H - N;\n        }\n\n        ${y("ComputeIndex","f",[f("id"),f("N")])}{\n            ${C("mid")} = N * 0.5;\n            ${C("idToUse")} = id;\n            if (${R("id","2.0")} == 0.0) {\n                idToUse = mid + idToUse * 0.5;\n            } else {\n                idToUse = mid - (idToUse - 1.0) * 0.5;\n            }\n            ${C("val")}  = idToUse * N * 24.0;\n            ${C("n")} = val / N;\n            ${C("m")} = ${R("val","N")};\n            return n + m;\n        }\n\n        ${y("LowDiscrepancy2D","v2",[f("i"),f("N")])} {\n            ${C("id")} = ${_("ComputeIndex","f",[f("i"),f("N")])};\n            return ${N()}(fract((id + 0.5) / N* INV_GOLDEN_RATIO), fract(id * INV_GOLDEN_RATIO));\n        }\n\n        ${y("TangentToWorld","v3",[x("Vec"),x("TangentZ")])} {\n\n            ${b("UpVector")}  = ${b()}(1.0,0.0,0.0);\n            if (abs(TangentZ.z) < 0.999) {\n                UpVector = ${b()}(0.0, 0.0, 1.0);\n            }\n            ${b("TangentX")}  = normalize(cross(UpVector, TangentZ));\n            ${b("TangentY")}  = cross(TangentZ, TangentX);\n\n            return TangentX * Vec.x + TangentY * Vec.y + TangentZ * Vec.z;\n        }\n\n        ${y("ImportanceSampleGGX","v3",[g("Xi"),f("roughness")])}{\n\n            ${b("H")};\n            ${C("Phi")}  = 2.0 * PI * Xi.x;\n            ${C("a")}  = roughness * roughness;\n            ${C("a2")}  = a * a;\n\n            ${C("CosTheta")}  = sqrt((1.0 - Xi.y) / (1.0 + (a2 - 1.0) * Xi.y));\n            ${C("SinTheta")}  = sqrt(1.0 - CosTheta * CosTheta);\n\n            H.x = SinTheta * cos(Phi);\n            H.y = SinTheta * sin(Phi);\n            H.z = CosTheta;\n            return H;\n        }\n\n        ${y("ClipByPlane","f",[x("origin"),x("direction"),S("plane"),f("t")])}{\n\n            ${C("clipVal")}  = dot(plane, ${U()}(origin, 1.0));\n            ${C("k")} = -clipVal / dot(plane.xyz, direction);\n            if (k < 0.0) {\n                return t;\n            }\n            return min(t, k);\n        }\n\n        ${y("ClipByFrustum","f",[x("origin"),x("direction")])} {\n\n            ${C("t")} = 1000000000000.0;\n\n            for (${T("k")} = 0; k < 6; k++) {\n                t = ${_("ClipByPlane","f",[x("origin"),x("direction"),S(`${$("frustumPlanes")}[k]`),f("t")])};\n            }\n\n            return t;\n        }\n        `}function E(n,e){const t=o.getShaderOutput("out0");return`\n        \n\t\t\t\t${C("roughness")}  = normalDepthIoRRoughness.z;\n                ${C("z")}  = normalDepthIoRRoughness.w;\n                \n                if ( z == 0.0 ) {\n                    ${u.getEarlyFragmentEnd()}\n                }\n                ${C("depth")} = ${m.getDepthWithConvention("z")};\n                ${b("normal")}  = ${_("decodeOct24Normal","v3",[f("normalDepthIoRRoughness.x")])};\n\n                ${b("origin")}  = ${_("toViewPos","v3",[g("screenPos"),f("depth")])};\n                ${b("V")}  = ${b()}(0.0,0.0,1.0);\n                if (${$("realProjectionMatrix")}[3][3] <= 0.5) {\n                    V = normalize(-origin);\n                }\n\n                ${b("L")} ;\n                ${C("hitDistance")}  = 0.0;\n\n                ${C("iteration")} = ${C()}(${$("renderIteration")});\n                if (iteration > 2.0 ) {\n                    for (${T("i")} = 0; i < MAX_RAY; i++) {\n                        ${C("id")} = ${C()}(i);\n                        ${N("E")} = ${_("LowDiscrepancy2D","v2",[f("id + MAX_RAY_F * (iteration - 3.0)"),f("MAX_RAY_F * 125.0")])};\n\n                        ${b("perturbedZ")}  = ${_("ImportanceSampleGGX","v3",[g("E"),f("roughness")])};\n                        ${b("H")}  = ${_("TangentToWorld","v3",[x("perturbedZ"),x("normal")])};\n\n                        ${e?`\n                            ${b("Vflip")} = reflect(${_("GetLightVector","v3",[x("V"),x("H")])}, normal);\n                            L = refract(Vflip, normal, 1.0/ior);\n                            `:`\n                            L = ${_("GetLightVector","v3",[x("V"),x("H")])};\n                            `}\n                        ${t} += ${_("RayMarchNew","v4",[x("origin"),x("normalize(L)"),v("hitDistance"),S(F("fragCoord"))])};\n                    }\n                    ${t} *= I_MAX_RAY_F;\n                } else {\n                    ${b("H")}  = normal;              \n                    ${e?`\n                        ${b("Vflip")} = reflect(${_("GetLightVector","v3",[x("V"),x("H")])}, normal);\n                        L = refract(Vflip, normal, 1.0/ior);\n                        `:`\n                        L = ${_("GetLightVector","v3",[x("V"),x("H")])};\n                        `}\n                    ${t} = ${_("RayMarchNew","v4",[x("origin"),x("normalize(L)"),v("hitDistance"),S(F("fragCoord"))])};\n                }\n                ${b("clampedColor")} = min(${t}.rgb,CLAMP_VALUE);\n                ${t}.r = clampedColor.r;\n                ${t}.g = clampedColor.g;\n                ${t}.b = clampedColor.b;\n        `}class k extends e{constructor(){super(8),this.realProjectionMatrixInverse=new n.Matrix4,this.sceneSize=100,this.renderIteration=0}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform1f(r.sceneSize,this.sceneSize),t.uniform1i(r.renderIteration,this.renderIteration),t.uniformMatrix4fv(r.realProjectionMatrixInverse,!1,e.float32Matrix4x4Temp.setDoubles(this.realProjectionMatrixInverse.elements))}fillUBO(n,e,t){super.fillUBO(n,e,t);const r=n.layout;n.setF(r.sceneSize,this.sceneSize),n.setI(r.renderIteration,this.renderIteration),n.setM4(r.realProjectionMatrixInverse,this.realProjectionMatrixInverse)}clone(){var n=new k;return n.realProjectionMatrixInverse=this.realProjectionMatrixInverse,n.sceneSize=this.sceneSize,n.renderIteration=this.renderIteration,n}}function O(n){function e(n){const e=p("tMip"+n),t=p("tMip"+(n+1));return`\n                {return mix(${I(e,"uv")}, ${I(t,"uv")}, mipValues.y);}\n            `}return`\n\n        ${w({varyingName:"vUv",varyingType:"v2"})}\n\n        ${c({uniformName:"tMip0",uniformType:"t2",locationName:"tInput0"})}\n        ${c({uniformName:"tMip1",uniformType:"t2",locationName:"tInput1"})}   \n        ${c({uniformName:"tMip2",uniformType:"t2",locationName:"tInput2"})}      \n        ${c({uniformName:"tMip3",uniformType:"t2",locationName:"tInput3"})}     \n        ${c({uniformName:"tMip4",uniformType:"t2",locationName:"tInput4"})}      \n        ${c({uniformName:"tMip5",uniformType:"t2",locationName:"tInput5"})}      \n        ${c({uniformName:"tMip6",uniformType:"t2",locationName:"tInput6"})}      \n        ${c({uniformName:"tMip7",uniformType:"t2",locationName:"tInput7"})}          \n        ${c({uniformName:"tNormalDepthIoRRoughness",uniformType:"t2",locationName:"tInput8"})}\n\n        ${c({uniformName:"realProjectionMatrixInverse",uniformType:"m4"})}\n        ${c({uniformName:"sceneSize",uniformType:"f"})}\n        ${c({uniformName:"renderIteration",uniformType:"i"})}\n\n        ${y("toViewPos","v3",[g("uv"),f("depth")])}{\n            ${N("projSpaceXY")} = uv;\n            ${m.uvConvention("projSpaceXY")}\n            ${U("vertexPositionProjected")} = ${U()}(projSpaceXY * 2.0 - 1.0, depth, 1.0);\n            ${U("vertexPositionVS")}  = ${$("realProjectionMatrixInverse")} * vertexPositionProjected;\n            vertexPositionVS.x /= vertexPositionVS.w;\n            vertexPositionVS.y /= vertexPositionVS.w;\n            vertexPositionVS.z /= vertexPositionVS.w;\n            vertexPositionVS.w = 1.0;\n\n            return vertexPositionVS.xyz;\n        }\n\n        ${y("sampleScene","v4",[g("uv"),g("mipValues")])} {\n            if (mipValues.x == 0.0) ${e(0)}\n            if (mipValues.x == 1.0) ${e(1)}\n            if (mipValues.x == 2.0) ${e(2)}\n            if (mipValues.x == 3.0) ${e(3)}\n            if (mipValues.x == 4.0) ${e(4)}\n            if (mipValues.x == 5.0) ${e(5)}\n            if (mipValues.x == 6.0) ${e(6)}\n            return ${I(p("tMip7"),"uv")};\n        }\n        `}function G(n){const e=o.getShaderOutput("out0");return`\n        \n            ${C("roughness")} = normalDepthIoRRoughness.z;\n            ${C("powerVal")} = 0.8;\n            if (${$("renderIteration")} > 2) {\n                powerVal = 1.8;\n            }\n            ${N("mipValues")};\n            mipValues.x = 7.0 * pow(roughness, powerVal);\n            mipValues.y = fract(mipValues.x);\n            mipValues.x = floor(mipValues.x);\n\n            ${e} = ${_("sampleScene","v4",[g("screenPos"),g("mipValues")])};\n        `}return{SSLRefraction:new r(new t((function(n,e){e.customDefines;const t=o.getShaderOutput("out0");let r=`\n        \n            ${B(e,!0)}\n\n            \n\n            ${y("RayMarchNew","v4",[x("origin"),x("direction"),h("hitDistance"),S("fragCoord")])} {\n                ${U("outColor")}  = ${U()}(0.0);\n                ${d("hitDistance")} = ${$("sceneSize")};\n\n                ${C("maxRayLength")}  = ${$("sceneSize")};\n                ${C("t")} = ${_("ClipByFrustum","f",[x("origin"),x("direction")])};\n                maxRayLength = min(t, maxRayLength);\n\n                ${b("endPos")}  = origin + maxRayLength * direction;\n                ${b("uviz0")}  = ${_("getScreenPos3","v3",[x("origin")])};\n                ${b("uviz1")}  = ${_("getScreenPos3","v3",[x("endPos")])};\n\n                ${N("uvDir")}  = uviz1.xy - uviz0.xy;\n                ${C("nbSteps")}  = length(${$("screenSize")} * uvDir);\n\n                if (nbSteps < 1.0) {\n                    ${b("curOnSegment")}  = ${_("toViewPos","v3",[g("uviz1.xy"),f("uviz1.z")])};\n                    ${b("curPt")}  = ${_("toViewPos","v3",[g("uviz1.xy")])};\n                    if (curPt.z > curOnSegment.z) {\n                        ${d("hitDistance")} = length(curPt - origin);\n                        outColor = ${_("sampleColorScene","v4",[g("uviz1.xy")])};\n                    }\n                    return outColor;\n                }\n                nbSteps = ceil(nbSteps);\n\n                ${C("j")}  = 0.0;\n                ${C("prevDepth")}  = 1.0;\n                ${C("prevSegmentDepth")}  = 1.0;\n                for (${T("i")} = 0; i < 1024; i++) {\n                    ${b("sampleScreenPos")}  = mix(uviz0, uviz1, j / nbSteps);\n                    ${b("curOnSegment")}  = ${_("toViewPos","v3",[g("sampleScreenPos.xy"),f("sampleScreenPos.z")])};\n                    ${b("curPt")}  = ${_("toViewPos","v3",[g("sampleScreenPos.xy")])};\n                    if (abs(1.0 - curPt.z/curOnSegment.z) < 5e-3) {\n                        // ray has intersected \n                        ${d("hitDistance")} = length(curPt - origin);\n                        outColor = ${_("sampleColorScene","v4",[g("sampleScreenPos.xy")])};\n                        break;\n                    }\n                    // ray was in front in previous\n                    // ray is behind on cur\n                    else if (prevSegmentDepth >= prevDepth && curOnSegment.z <= curPt.z) {\n                        ${d("hitDistance")} = length(curPt - origin);                         \n                        ${b("sampleScreenPosToUse")}  = mix(uviz0, uviz1, (j - 1.0) / nbSteps);\n                        outColor = ${_("sampleColorScene","v4",[g("sampleScreenPosToUse.xy")])};\n                        break;\n                    }\n                    prevDepth = curPt.z;\n                    prevSegmentDepth = curOnSegment.z;\n                    if (j >= nbSteps) { break; }\n                    j += 1.0;\n                }\n                return outColor;\n            }\n\n            ${u.getMainFragmentStart(e)}\n                // varying storage\n                ${N("screenPos")} = ${V("vUv")};\n\n                ${t} = ${U()}(0.0, 0.0, 0.0, 0.0);\n                ${U("normalDepthIoRRoughness")}  = ${I("tNormalDepthIoRRoughness","screenPos")};\n                ${C("ior")} = normalDepthIoRRoughness.y;\n                // current pixel is not transparent\n                if (ior < 1.0) {\n                    ${u.getEarlyFragmentEnd()}\n                }\n                ${E(0,!0)}\n            ${u.getMainFragmentEnd(e)}\n        `;return{vertexShader:A(e),fragmentShader:r}}),"RayMarchingRefraction"),L,{}),SSLRefractionMipSolver:new r(new t((function(n,e){e.customDefines;const t=p("tNormalDepthIoRRoughness"),r=o.getShaderOutput("out0");let a=`                \n                ${O()}\n\n                ${u.getMainFragmentStart(e)}\n                    // varying storage\n                    ${N("screenPos")} = ${V("vUv")};\n    \n                    ${r} = ${U()}(0.0, 0.0, 0.0, 0.0);\n\n                    ${U("normalDepthIoRRoughness")} = ${I(t,"screenPos")};\n                    \n                    ${C("ior")}  = normalDepthIoRRoughness.y;\n                    // current pixel is not transparent\n                    if (ior < 1.0) {\n                        ${u.getEarlyFragmentEnd()}\n                    }\n\n                    ${G()}\n                ${u.getMainFragmentEnd(e)}\n            `;return{vertexShader:A(e),fragmentShader:a}}),"RayMarchingRefractionSolver"),k,{}),SSLReflectionMipSolver:new r(new t((function(n,e){e.customDefines;const t=o.getShaderOutput("out0");let r=`            \n                ${O()}\n    \n                ${u.getMainFragmentStart(e)}\n                    // varying storage\n                    ${N("screenPos")} = ${V("vUv")};\n    \n                    ${t} = ${U()}(0.0, 0.0, 0.0, 0.0);\n\n                    ${U("normalDepthIoRRoughness")} = ${I("tNormalDepthIoRRoughness","screenPos")};\n                    ${G()}\n                ${u.getMainFragmentEnd(e)}\n            `;return{vertexShader:A(e),fragmentShader:r}}),"RayMarchingReflectionSolver"),k,{}),SSLReflection:new r(new t((function(n,e){e.customDefines;const t=p("tNormalDepthIoRRoughness"),r=p("tColorNormalDepth"),a=o.getShaderOutput("out0");let i=`\n        \n            ${B(e,!1)}\n\n            \n            ${y("RayMarchNew","v4",[x("origin"),x("direction"),h("hitDistance"),S("fragCoord")])} {\n                ${U("outColor")}  = ${U()}(0.0);\n                ${d("hitDistance")} = ${$("sceneSize")};\n\n                ${C("maxRayLength")}  = ${$("sceneSize")};\n                ${C("t")} = ${_("ClipByFrustum","f",[x("origin"),x("direction")])};\n                if (t <= 0.0) {\n                    return outColor;\n                }\n                maxRayLength = min(t, maxRayLength);\n\n                ${b("endPos")}  = origin + maxRayLength * direction;\n                ${b("uviz0")}  = ${_("getScreenPos3","v3",[x("origin")])};\n                ${b("uviz1")}  = ${_("getScreenPos3","v3",[x("endPos")])};\n\n                ${N("uvDir")}  = uviz1.xy - uviz0.xy;\n                ${C("nbSteps")}  = max(1.0, length(${$("screenSize")} * uvDir));\n\n                ${C("ray_marching_step")}  = 16.0;\n                ${C("j")}  = ray_marching_step;\n\n                for (${T("i")}  = 0; i < 1024; i++) {\n                    // reach the border of the screen\n                    if (j > nbSteps) { break; }\n\n                    ${b("sampleScreenPos")}  = mix(uviz0, uviz1, j / nbSteps);\n                    // for reflection, tColorNormalDepth is equal to tNormalDepthIoRRoughness   \n                    ${U("normalDepth")}  = ${I(r,"sampleScreenPos.xy")};\n                    ${C("depth")} = normalDepth.w;\n                    ${C("z")}  = ${m.getDepthWithConvention("depth")};\n\n                    ${C("diffZ")}  = sampleScreenPos.z - z; \n                    // the ray is behind the object\n                    if (depth > 0.0 && diffZ > 0.0) {\n                        if (ray_marching_step == 1.0) {\n                            ${b("hit")}  = ${_("toViewPos","v3",[g("sampleScreenPos.xy"),f("sampleScreenPos.z")])};\n                            ${C("zOrigin")}  = ${_("toViewPos","v3",[g("sampleScreenPos.xy")])}.z;\n                            if (abs(1.0 - hit.z / zOrigin) < 1e-2) {                  \n                                ${d("hitDistance")} = length(hit - origin);\n                                outColor = ${_("sampleColorScene","v4",[g("sampleScreenPos.xy")])};\n                            }\n                            break;\n                        } else {\n                            ray_marching_step *= 0.5;\n                            j -= ray_marching_step;\n                        }\n                    } else {\n                        ${C("seed")} = ${C()}(${$("renderIteration")}) + j;\n                        j += (0.5 + 0.5 * ${_("Random1D","f",[f("seed"),S("fragCoord")])}) * ray_marching_step;\n                    }\n                }\n                return outColor;\n            }\n\n            ${u.getMainFragmentStart(e)}\n                // varying storage\n                ${N("screenPos")} = ${V("vUv")};\n\n                ${a} = ${U()}(0.0, 0.0, 0.0, 0.0);\n\n                ${U("normalDepthIoRRoughness")}  = ${I(t,"screenPos")};\n\n                ${E(0,!1)}\n            ${u.getMainFragmentEnd(e)}\n        `;return{vertexShader:A(e),fragmentShader:i}}),"RayMarchingReflection"),L,{})}})),define("DS/ShaderBuilders/PostPro/DOFShaderBuilders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PostPro/PostProUniformHandler","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/PostPro/PostProContext","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a,o,i,s){"use strict";const l=i.ParameterUtils,u=i.FunctionHandler,m=i.BridgeFunctions,c=n=>a.addUniform(n),$=n=>{var e={uniformName:n};return a.getUniform(e)},p=n=>l.parameterI(n),d=n=>l.parameterF(n),f=n=>l.parameterV2(n),h=(n,e,t)=>u.declareFunction(n,e,t),v=(n,e,t)=>u.callFunction(n,e,t),g=(n=null,e=0)=>{var t={name:n,size:e};return s.int(t)},x=(n=null,e=0)=>{var t={name:n,size:e,constant:!0};return s.int(t)},S=(n=null,e=0)=>{var t={name:n,size:e};return s.float(t)},y=(n=null,e=0)=>{var t={name:n,size:e,constant:!0};return s.float(t)},_=(n=null,e=0)=>{var t={name:n,size:e};return s.vec2(t)},T=(n=null,e=0)=>{var t={name:n,size:e};return s.vec3(t)},D=(n=null,e=0)=>{var t={name:n,size:e};return s.vec4(t)},C=n=>o.addVarying(n),P=n=>o.getVarying(n,o.ShaderStages.out),N=(n,e)=>{return m.sample2DTexture((t={uniformName:n},a.getTextureUniform(t)),e);var t};class b extends e{constructor(){super(1),this.textureWidth=512,this.textureHeight=512,this.focalDepth=1,this.focalLength=64,this.fstop=.9,this.sensorSize=24,this.sceneScale=1,this.maxCoC=1,this.realProjectionMatrixInverse=new n.Matrix4,this.maxblur=5,this.manualdof=0,this.bias=.5,this.noise=1,this.dithering=1e-4}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform1f(r.textureWidth,this.textureWidth),t.uniform1f(r.textureHeight,this.textureHeight),t.uniform1f(r.focalDepth,this.focalDepth),t.uniform1f(r.focalLength,this.focalLength),t.uniform1f(r.fstop,this.fstop),t.uniform1f(r.sensorSize,this.sensorSize),t.uniform1f(r.sceneScale,this.sceneScale),t.uniform1f(r.maxCoC,this.maxCoC),t.uniformMatrix4fv(r.realProjectionMatrixInverse,!1,e.float32Matrix4x4Temp.setDoubles(this.realProjectionMatrixInverse.elements)),t.uniform1f(r.maxblur,this.maxblur),t.uniform1i(r.manualdof,this.manualdof),t.uniform1f(r.bias,this.bias),t.uniform1i(r.noise,this.noise),t.uniform1f(r.dithering,this.dithering)}fillUBO(n,e,t){super.fillUBO(n,e,t);const r=n.layout;n.setF(r.textureWidth,this.textureWidth),n.setF(r.textureHeight,this.textureHeight),n.setF(r.focalDepth,this.focalDepth),n.setF(r.focalLength,this.focalLength),n.setF(r.fstop,this.fstop),n.setF(r.sensorSize,this.sensorSize),n.setF(r.sceneScale,this.sceneScale),n.setF(r.maxCoC,this.maxCoC),n.setM4(r.realProjectionMatrixInverse,this.realProjectionMatrixInverse),n.setF(r.maxblur,this.maxblur),n.setI(r.manualdof,this.manualdof),n.setF(r.bias,this.bias),n.setI(r.noise,this.noise),n.setF(r.dithering,this.dithering)}clone(){return new b}}function M(e){return`           \n            ${C({varyingName:"vUv",varyingType:"v2"})}\n\n            ${u.getMainVertexStart(e)}\n                ${P("vUv")} = uv.xy;\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(e)}\n            ${u.getMainVertexEnd(e)}\n        `}return{Bokeh:new r(new t((function(n,e){var t=e.customDefines;const r=o.getShaderOutput("out0"),a=t.DOF_BEHAVIOUR,i=t.PHYSIC,l=n=>`th / ${$("sensorSize")} * ${n}`;let P=`\n            \n            ${C({varyingName:"vUv",varyingType:"v2"})}\n            \n            ${c({uniformName:"tScene",uniformType:"t2",locationName:"tInput0"})}\n            ${c({uniformName:"tNormalDepth",uniformType:"t2",locationName:"tInput1"})}\n\n            ${c({uniformName:"textureWidth",uniformType:"f"})}\n            ${c({uniformName:"textureHeight",uniformType:"f"})}\n\n            //focal distance value in mm, but you may use autofocus option below\n            ${c({uniformName:"focalDepth",uniformType:"f"})}\n            //focal length in mm\n            ${c({uniformName:"focalLength",uniformType:"f"})}\n            //f-stop value\n            ${c({uniformName:"fstop",uniformType:"f"})}\n            //physical sensor size 24mm by default\n            ${c({uniformName:"sensorSize",uniformType:"f"})}\n            //1 for mm, 1000 for m\n            ${c({uniformName:"sceneScale",uniformType:"f"})}\n            //ratio of screenHeight a physical blur can have\n            ${c({uniformName:"maxCoC",uniformType:"f"})}\n            ${c({uniformName:"maxblur",uniformType:"f"})}\n            ${c({uniformName:"dithering",uniformType:"f"})}\n            // bokeh edge bias\n            ${c({uniformName:"bias",uniformType:"f"})}\n\n            ${c({uniformName:"realProjectionMatrixInverse",uniformType:"m4"})}\n\n            // manual dof calculation\n            ${c({uniformName:"manualdof",uniformType:"i"})}\n            //use noise instead of pattern for sample dithering\n            ${c({uniformName:"noise",uniformType:"i"})}\n\n            ${y("PI")} = 3.14159265;\n\n            //samples on the first ring\n            ${x("samples")}  = ${t.SAMPLES};\n            //ring count\n            ${x("rings")}  = ${t.RINGS};\n            ${y("rings2")}  = ${S()}(rings);\n\n            ${x("maxringsamples")}  = rings * samples;\n\n            // near dof blur start\n            ${y("ndofstart")}  = 1.0;\n            // near dof blur falloff distance\n            ${y("ndofdist")}  = 2.0;\n            // far dof blur start\n            ${y("fdofstart")}  = 1.0;\n            // far dof blur falloff distance\n            ${y("fdofdist")}  = 3.0;\n            //circle of confusion size in mm (35mm film = 0.03mm)\n            ${y("CoC")}  = 0.03;\n            \n            ${((n=null,e=0)=>{var t={name:n,size:e,addressSpace:"private"};return s.float(t)})("maxPhysicalBlurSize")}; \n\n            ${h("getZ","f",[f("coords")])} {\n                ${D("normalDepth")}  = ${N("tNormalDepth","coords")};\n                \n                // [0.0, 1.0]\n                ${e.renderToFloatTexture?`\n                    ${S("z")} = normalDepth.w; \n                    `:`\n                    ${S("z")}  = ${v("unpackForFloat16","f",[f("normalDepth.zw")])};\n                    `}\n                ${3===e.dofBehavior?"       \n                    //background at distance 0\n                    if ( z == 0.0 ) {\n                        return 0.0;\n                    }\n                    ":"                   \n                    //background at far\n                    if ( z == 0.0 ) {\n                        z=1.0;\n                    }\n                    "}\n                return z;\n            }\n            \n            ${h("getDepth","f",[f("coords"),d("z")])}{\n\n                ${_("xy")}  = coords * 2.0 - 1.0;\n                ${S("depth")} = ${m.getDepthWithConvention("z")};\n                ${D("vertexPositionProjected")}  = ${D()}( xy, depth, 1.0 );\n                ${D("vertexPositionVS")}  = ${$("realProjectionMatrixInverse")} * vertexPositionProjected;\n                vertexPositionVS /= vertexPositionVS.w;\n                vertexPositionVS.w = 1.0;\n\n                return -vertexPositionVS.z*${$("sceneScale")};\n            }\n\n            //paraxial thin lens approxiamtion\n            ${h("getHalfPhysicalBlurSize","f",[d("depth")])}{\n                ${S("fDepth")} = ${$("focalDepth")};\n                ${S("fLength")} = ${$("focalLength")};\n                if(depth>=fDepth){\n                    //case A :beyond focalDepth formula \n                    ${S("maxBlur")}  = maxPhysicalBlurSize;\n                    //depth > focalDepth in case A\n                    ${S("distToFocus")}  = abs(depth-fDepth);\n                    ${S("focusRatio")}  = distToFocus/depth;\n                    return 0.5 * maxBlur*focusRatio;\n                }else if(depth>=fLength){\n                    //case B :in front of focalDepth formula\n                    ${S("currFocal")}  = depth*fLength/(depth-fLength);\n                    ${S("focusFocal")}  = fDepth*fLength/(fDepth-fLength);\n                    //currFocal > focusFocal in case B\n                    ${S("distToFocus")}  = abs(currFocal-focusFocal);\n                    ${S("focusRatio")}  = distToFocus/currFocal;\n                    return 0.5*fLength/${$("fstop")} * focusRatio;\n                \n                }else {\n                    //case C :closer than focalLength\n                    //virtual image, don't know how to deal with that yet, return max blur instead\n                    //aperture size\n                    return 0.5*fLength/${$("fstop")};\n                }\n            }\n\n            ${h("getOffsetedUV","v2",[f("uv"),d("length"),d("j"),d("w"),d("h"),d("steps")])}{\n                ${S("tw")} = ${$("textureWidth")};\n                ${S("th")} = ${$("textureHeight")};\n                ${S("pw")}  = cos(j*steps)*length;\n                ${S("ph")} = sin(j*steps)*length;\n                ${_("res_uv")}  =uv + ${_()}(pw*w, ph*h);\n                res_uv.x = floor(0.5+res_uv.x*tw)/tw;\n                res_uv.y = floor(0.5+res_uv.y*th)/th;\n                return res_uv;\n            }\n\n            ${h("gather","v4",[d("i"),d("j"),f("uv"),p("ringsamples"),d("w"),d("h")])}{\n                ${S("step")}  = PI*2.0 / ${S()}(ringsamples);\n                ${S("pw")}  = cos(j*step)*i;\n                ${S("ph")}  = sin(j*step)*i;\n                ${S("weight")}  = mix(1.0, i/rings2, ${$("bias")});\n                ${_("uvToUse")}  = uv+ ${_()}(pw*w, ph*h);\n                ${T("col")} = ${N("tScene","uvToUse")}.rgb* weight;\n                return ${D()}(col, weight);\n            }\n\n            \n            ${h("rand","v2",[f("coord")])}{\n\n                ${S("tw")} = 0.5*${$("textureWidth")};\n                ${S("th")} = 0.5*${$("textureHeight")};\n\n                ${S("noiseX")}  = (fract(1.0 - coord.x * tw) * 0.25 + fract(coord.y * th) * 0.75) * 2.0 - 1.0;\n                ${S("noiseY")}  = (fract(1.0 - coord.x * tw) * 0.75 + fract(coord.y * th) * 0.25) * 2.0 - 1.0;\n\n                if (${$("noise")} > 0) {\n                    noiseX = clamp(fract(sin(dot(coord ,${_()}(12.9898,78.233))) * 43758.5453),0.0,1.0)*2.0-1.0;\n                    noiseY = clamp(fract(sin(dot(coord ,${_()}(12.9898,78.233)*2.0)) * 43758.5453),0.0,1.0)*2.0-1.0;\n                }\n\n                return ${_()}(noiseX, noiseY);\n            }\n\n            ${u.getMainFragmentStart(e)}\n                ${_("screenUV")} = ${b="vUv",o.getVarying(b,o.ShaderStages.in)};\n\n                ${S("pixelZ")} = ${v("getZ","f",[f("screenUV")])};\n                ${S("depth")} = ${v("getDepth","f",[f("screenUV"),d("pixelZ")])};\n                ${S("fDepth")} = ${$("focalDepth")};\n                ${S("fLength")} = ${$("focalLength")};\n\n                ${D("colAlpha")} = ${N("tScene","screenUV")};\n                ${T("col")} = colAlpha.rgb;\n\n                ${S("tw")} = ${$("textureWidth")};\n                ${S("th")} = ${$("textureHeight")};\n\n                ${S("s")} = 1.0;\n                ${g("ringsamples")};\n                ${_("randNoise")}  = ${v("rand","v2",[f("screenUV")])} * ${$("dithering")};\n                ${3===a?`          \n                    ${S("blur")}  = 0.0;\n\n                    if (${$("manualdof")} > 0) {\n                        ${S("a")} = depth - fDepth;\n                        ${S("b")} = (a - fdofstart) / fdofdist;\n                        ${S("c")} = (- a - ndofstart) / ndofdist;\n                        if (a > 0.0) {\n                            blur = b;\n                        } else {\n                            blur = c;\n                        }\n                    } else {\n                        ${S("f")} = fLength;\n                        ${S("d")} = fDepth;\n                        ${S("o")} = depth;\n\n                        ${S("a")} = (o * f) / (o - f);\n                        ${S("b")} = (d * f) / (d - f);\n                        ${S("c")} = (d - f) / (d * ${$("fstop")} * CoC);\n\n                        blur = abs(a - b) * c;\n                    }\n\n                    blur = clamp(blur, 0.0, 1.0);\n\n                    randNoise *= blur;\n\n                    ${S("w")}  = (1.0 / tw) * blur * ${$("maxblur")} + randNoise.x;\n                    ${S("h")}  = (1.0 / th) * blur * ${$("maxblur")} + randNoise.y;\n\n                    for (${g("i")} = 1; i <= rings; i++) {\n                        ringsamples = i * samples;\n                        ${S("fI")} = ${S()}(i);\n\n                        for (${g("j")} = 0 ; j < maxringsamples ; j++) {\n                            if (j >= ringsamples) {\n                                break;\n                            }\n                            ${S("fJ")} = ${S()}(j);\n                            ${D("colWeight")}= ${v("gather","v4",[d("fI"),d("fJ"),f("screenUV"),p("ringsamples"),d("w"),d("h")])};\n                            col += colWeight.rgb;\n                            s += colWeight.w;\n                        }\n                    }\n                    `:`\n                    //formula hold as long as fDepth>fLength, in real life it is impossible to do a focus closer thant focal length\n                    //so fDepth>fLength is in the realm of we do whatever we want, there is no real life equivalent\n                    //maxPhysicalBlurSize = fLength / ${$("fstop")} * fLength/(fDepth-fLength);\n                    //clamp because extremely wide CoC are not visually pleasing with our sampling approach\n                    //abs because why not\n                    maxPhysicalBlurSize = fLength / ${$("fstop")} * clamp(fLength/abs(fDepth-fLength),0.0,1.0);\n\n                    ${S("sensorBlurRadius")}  = ${v("getHalfPhysicalBlurSize","f",[d("depth")])};\n                    ${S("radiusLower")} = ${$("maxCoC")}*th;\n                    ${S("blurRadius")}  = min(${l("sensorBlurRadius")},radiusLower);\n                    ${S("hBlur")}  = blurRadius/tw+randNoise.x;\n                    ${S("vBlur")}  = blurRadius/th+randNoise.y;\n                    ${S("maxSensorBlurRadius")}  = maxPhysicalBlurSize * 0.5;\n                    ${S("maxBlurRadius")}  =  min(${l("maxSensorBlurRadius")},radiusLower);\n                    ${S("maxHBlur")}  = maxBlurRadius/tw+randNoise.x;\n                    ${S("maxVBlur")}  = maxBlurRadius/th+randNoise.y;\n                    for (${g("i")} = 1; i <= rings; i++) {\n                        ringsamples = i * samples;\n                        ${S("fI")} = ${S()}(i);\n                        ${S("iRatio")}  = fI/rings2;\n\n                        ${S("dist")}  =iRatio*maxBlurRadius;\n\n                        for (${g("j")} = 0; j < maxringsamples ; j++) {\n                            if (j >= ringsamples) {\n                                break;\n                            }\n                            ${S("fJ")} = ${S()}(j);\n                            ${S("weight")}  = mix(1.0, iRatio, ${$("bias")});\n                            \n                            ${S("step")}  = PI*2.0 / ${S()}(ringsamples);\n                            //part1:fetch according to current pixel coc, gross approximation, but give nice blurry blur\n                            ${1===i?`            \n                                ${_("uv")} = ${v("getOffsetedUV","v2",[f("screenUV"),d("iRatio"),d("fJ"),d("hBlur"),d("vBlur"),d("step")])};\n                                ${S("sampleZ")} =${v("getZ","f",[f("uv")])};\n                                ${S("takeSample")} ;\n                                if (sampleZ>=pixelZ) {\n                                    takeSample = 1.0;\n                                } else {\n                                    takeSample = 0.0;\n                                }\n\n                                col += takeSample*${N("tScene","uv")}.rgb * weight;\n                                s+= takeSample*weight;\n                                `:`\n                                //part2:fetch according to max coc, retrieve potential wider cocs affecting this pixel\n                                //lossy because of low number of fetch\n                                ${_("uvMax")}  = ${v("getOffsetedUV","v2",[f("screenUV"),d("iRatio"),d("fJ"),d("maxHBlur"),d("maxVBlur"),d("step")])};\n                                ${S("sampleZMax")} =${v("getZ","f",[f("uvMax")])};\n                                ${S("currentDepth")}  = ${v("getDepth","f",[f("uvMax"),d("sampleZMax")])};\n                                ${S("currentsensorBlurRadius")}  = ${v("getHalfPhysicalBlurSize","f",[d("currentDepth")])};\n                                ${S("currentblurRadius")}  = ${l("currentsensorBlurRadius")};\n                                if(currentblurRadius>=dist){\n                                    col += ${N("tScene","uvMax")}.rgb * weight;\n                                    s+= weight;\n                                }\n                                `}\n                        }\n                    }\n                    `}\n                    \n                col /= s;\n                ${r} = ${D()}(col, colAlpha.a);           \n            ${u.getMainFragmentEnd(e)}\n        `;var b;return{vertexShader:M(e),fragmentShader:P}}),"BokehDOF"),b,{PHYSIC:1,DOF_BEHAVIOUR:0,RINGS:3,SAMPLES:8})}})),define("DS/ShaderBuilders/PostPro/ConvertShaderBuilders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PostPro/PostProUniformHandler","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/PostPro/PostProContext","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a,o,i,s){"use strict";const l=i.ParameterUtils,u=i.FunctionHandler,m=i.BridgeFunctions,c=n=>a.addUniform(n),$=n=>{var e={uniformName:n};return a.getUniform(e)},p=n=>{var e={uniformName:n};return a.getTextureUniform(e)},d=n=>l.parameterF(n),f=n=>l.parameterV2(n),h=n=>l.parameterV4(n),v=n=>l.parameterT2(n),g=(n,e,t)=>u.declareFunction(n,e,t),x=(n,e,t)=>u.callFunction(n,e,t),S=(n=null,e=0)=>{var t={name:n,size:e};return s.float(t)},y=(n=null,e=0)=>{var t={name:n,size:e,constant:!0};return s.float(t)},_=(n=null,e=0)=>{var t={name:n,size:e};return s.vec2(t)},T=(n=null,e=0)=>{var t={name:n,size:e};return s.vec3(t)},D=n=>o.addVarying(n),C=n=>o.getVarying(n,o.ShaderStages.in),P=n=>o.getVarying(n,o.ShaderStages.out),N=(n,e)=>m.sample2DTexture(n,e),b=(n,e)=>m.sampleCubeTexture(n,e);class M extends e{constructor(){super()}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i)}fillUBO(n,e,t){super.fillUBO(n,e,t)}clone(){return new M}}class U extends M{constructor(){super(),this.size=new n.Vector2(1,1)}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform2f(r.size,this.size.x,this.size.y)}fillUBO(n,e,t){super.fillUBO(n,e,t);const r=n.layout;n.setV2(r.size,this.size)}clone(){var n=new U;return n.size=this.size,n}}function w(e){return`      \n            ${D({varyingName:"vUv",varyingType:"v2"})}\n\n            ${u.getMainVertexStart(e)}\n                ${P("vUv")} = uv.xy;\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(e)}\n            ${u.getMainVertexEnd(e)}\n        `}const V={SRGB_INPUT:0,INPUT_ENCODING:"RGB"};return{CubemapToLatlong:new r(new t((function(n,e){var t=e.customDefines;const r=p("tCube"),a=o.getShaderOutput("out0"),i=t.ORIENTATION;let s=`\n            \n            ${D({varyingName:"vUv",varyingType:"v2"})}\n            \n            ${c({uniformName:"tCube",uniformType:"tc",locationName:"tInput"})}\n\n            ${y("PI")} = 3.14159265358979323846264;\n\n            ${u.getMainFragmentStart(e)}\n                ${_("screenUV")} = ${C("vUv")};\n\n                ${T("N")};\n                ${S("phi")} = PI * (2.0 * screenUV.x - 1.0);\n                ${S("theta")};\n\n                ${1===i?"\n                    theta = PI * screenUV.y;\n                    N.x = sin(theta) * sin(phi);\n                    N.y = cos(theta);\n                    N.z = sin(theta) * cos(phi);\n                    ":`\n                    theta = PI * (1.0 - screenUV.y);\n                    N.x = sin(theta) * cos(phi);\n                    ${2===i?"\n                        N.y = -cos(theta);\n                        N.z = sin(theta) * sin(phi);\n                        ":"\n                        N.y = sin(theta) * sin(phi);\n                        N.z = cos(theta);\n                        "}\n                    `}\n                ${a} = ${b(r,"N")};\n            ${u.getMainFragmentEnd(e)}\n        `;return{vertexShader:w(e),fragmentShader:s}}),"CubemapToLatlong"),M,{ORIENTATION:0}),LatlongToDualParaboloid:new r(new t((function(e,t){var r=t.customDefines;const a=p("tMap"),i=o.getShaderOutput("out0"),s=r.SRGB_INPUT>0;let l;switch(r.INPUT_ENCODING){case"RGBE":l=`           \n                    ${_("mapSize")} = ${$("size")};\n                    ${i} = ${x("texture2DBilinearRGBE","v4",[v(a),f("fetchUV"),f("mapSize"),f("1.0 / mapSize")])};\n                `;break;case"RGB":l=`           \n                    ${i} = ${N(a,"fetchUV")};\n                `;break;case"LogLUV":l=`           \n                    ${_("mapSize")} = ${$("size")};\n                    ${i} = ${x("texture2DBilinearLogLUV","v4",[v(a),f("fetchUV"),f("mapSize"),f("1.0 / mapSize")])};\n                `;break;case"RGBM":l=`           \n                    ${_("mapSize")} = ${$("size")};\n                    ${i} = ${x("texture2DBilinearRGBM","v4",[v(a),f("fetchUV"),f("mapSize"),f("1.0 / mapSize")])};\n                `}let m=`\n            \n            ${D({varyingName:"vUv",varyingType:"v2"})}\n            \n            ${c({uniformName:"tMap",uniformType:"t2",locationName:"tInput"})}\n            ${c({uniformName:"size",uniformType:"v2"})}\n\n            ${y("PI")} = 3.14159265358979323846264;\n            ${y("SCALE")} = 1.2;\n\n            ${g("myAtan2","f",[d("y"),d("x")])} {\n                if (x > 0.0) {\n                    return sign(y) * atan(abs(y/x));\n                } else if (x < 0.0) {\n                    return sign(y) * (PI - atan(abs(y/x)));\n                }\n                return 0.5 * PI * sign(y);\n            }\n\n            ${n._DefaultShaderChunk.ibl_sample_methods(t)}\n\n            ${u.getMainFragmentStart(t)}\n                ${_("screenUV")} = ${C("vUv")};\n                ${_("uv")} = ${_()}(fract(2.0 * screenUV.x), screenUV.y);\n\n                ${S("phi")} = ${x("myAtan2","f",[d("2.0 * uv.y - 1.0"),d("2.0 * uv.x - 1.0")])};\n                ${S("theta")};\n                ${S("u")};\n\n                // z < 0\n                if(screenUV.x < 0.5) {\n                    theta = 2.0 * atan(cos(phi) / (SCALE * (2.0 * uv.x - 1.0)));\n                    u = fract(0.5 * phi / PI);\n                } else {\n                    theta = 2.0 * atan(SCALE * (1.0 - 2.0 * uv.x) / cos(phi));\n                    phi += 1.0*PI;\n                    u = fract(0.5*phi / PI);\n                }\n                ${S("v")} = abs(theta / PI);\n                ${_("fetchUV")} = ${_()}(u,v);\n                ${l}\n                ${s?`\n                    ${i}.x *= ${i}.x;\n                    ${i}.y *= ${i}.y;\n                    ${i}.z *= ${i}.z;\n                    `:""}\n                ${i}.a = 1.0;\n            ${u.getMainFragmentEnd(t)}\n        `;return{vertexShader:w(t),fragmentShader:m}}),"LatlongToDualParaboloid"),U,V),CubemapToDualParaboloid:new r(new t((function(e,t){var r=t.customDefines;const a=p("tCubeMap"),i=o.getShaderOutput("out0"),s=r.SRGB_INPUT>0;let l;switch(r.INPUT_ENCODING){case"RGBE":l=`           \n                    ${i} = ${vec4()}(${x("RGBEtoRGB","v3",[h("sampledColor")])}, 1.0);\n                `;break;case"RGB":l=`           \n                    ${i} = sampledColor;\n                `;break;case"LogLUV":l=`           \n                    ${i} = ${vec4()}(${x("LogLUVtoRGB","v3",[h("sampledColor")])}, 1.0);\n                `;break;case"RGBM":l=`           \n                    ${i} = ${vec4()}(${x("RGBMtoRGB","v3",[h("sampledColor")])}, 1.0);\n                `}let m=`\n            \n            ${D({varyingName:"vUv",varyingType:"v2"})}\n            \n            ${c({uniformName:"tCubeMap",uniformType:"tc",locationName:"tInput"})}\n\n            ${y("PI")} = 3.14159265358979323846264;\n            ${y("SCALE")} = 1.2;\n\n            ${g("myAtan2","f",[d("y"),d("x")])} {\n                if (x > 0.0) {\n                    return sign(y) * atan(abs(y/x));\n                } else if (x < 0.0) {\n                    return sign(y) * (PI - atan(abs(y/x)));\n                }\n                return 0.5 * PI * sign(y);\n            }\n\n            ${n._DefaultShaderChunk.ibl_sample_methods(t)}\n\n            ${u.getMainFragmentStart(t)}\n                ${_("screenUV")} = ${C("vUv")};\n                ${_("uv")} = ${_()}(fract(2.0 * screenUV.x), screenUV.y);\n\n                ${S("phi")} = ${x("myAtan2","f",[d("2.0 * uv.y - 1.0"),d("2.0 * uv.x - 1.0")])};\n                ${T("N")};\n                ${S("theta")};\n\n                // z < 0\n                if(screenUV.x < 0.5) {\n                    theta = 2.0 * atan(cos(phi) / (SCALE * (2.0 * uv.x - 1.0)));\n                } else {\n                    theta = 2.0 * atan(SCALE * (1.0 - 2.0 * uv.x) / cos(phi));\n                }\n                ${vec4("sampledColor")} = ${b(a,"N")};\n                ${l}\n                ${s?`\n                    ${i}.x *= ${i}.x;\n                    ${i}.y *= ${i}.y;\n                    ${i}.z *= ${i}.z;\n                    `:""}\n                ${i}.a = 1.0;\n            ${u.getMainFragmentEnd(t)}\n        `;return{vertexShader:w(t),fragmentShader:m}}),"CubemapToDualParaboloid"),U,V),ToRGBLuminance:new r(new t((function(e,t){var r=t.customDefines;const a=p("tMap"),i=o.getShaderOutput("out0");let s;switch(r.INPUT_ENCODING){case"RGBE":s=`           \n                    ${_("mapSize")} = ${$("size")};\n                    ${i} = ${x("texture2DBilinearRGBE","v4",[v(a),f("screenUV"),f("mapSize"),f("1.0 / mapSize")])};\n                `;break;case"RGB":s=`           \n                    ${i} = ${N(a,"screenUV")};\n                `;break;case"LogLUV":s=`           \n                    ${_("mapSize")} = ${$("size")};\n                    ${i} = ${x("texture2DBilinearLogLUV","v4",[v(a),f("screenUV"),f("mapSize"),f("1.0 / mapSize")])};\n                `;break;case"RGBM":s=`           \n                    ${_("mapSize")} = ${$("size")};\n                    ${i} = ${x("texture2DBilinearRGBM","v4",[v(a),f("screenUV"),f("mapSize"),f("1.0 / mapSize")])};\n                `}const l=r.SRGB_INPUT>0;let m=`\n            \n            ${D({varyingName:"vUv",varyingType:"v2"})}\n            \n            ${c({uniformName:"tMap",uniformType:"t2",locationName:"tInput"})}\n            ${c({uniformName:"size",uniformType:"v2"})}\n\n            ${n._DefaultShaderChunk.ibl_sample_methods(t)}\n\n            ${u.getMainFragmentStart(t)}\n                ${_("screenUV")} = ${C("vUv")};\n                ${s}\n                ${l?`\n                    ${i}.x *= ${i}.x;\n                    ${i}.y *= ${i}.y;\n                    ${i}.z *= ${i}.z;\n                    `:""}\n                ${i}.a = dot(${i}.xyz, ${T()}(0.299, 0.587, 0.114));\n            ${u.getMainFragmentEnd(t)}\n        `;return{vertexShader:w(t),fragmentShader:m}}),"ToRGBLuminance"),U,V)}})),define("DS/ShaderBuilders/PostPro/ExposureShaderBuilders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PostPro/PostProUniformHandler","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/PostPro/PostProContext","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a,o,i,s){"use strict";i.ParameterUtils;const l=i.FunctionHandler,u=i.BridgeFunctions,m=n=>a.addUniform(n),c=n=>{var e={uniformName:n};return a.getUniform(e)},$=(n=null,e=0)=>{var t={name:n,size:e};return s.float(t)},p=(n=null,e=0)=>{var t={name:n,size:e};return s.vec3(t)},d=(n=null,e=0)=>{var t={name:n,size:e,constant:!0};return s.vec3(t)},f=(n=null,e=0)=>{var t={name:n,size:e};return s.vec4(t)},h=n=>o.addVarying(n),v=n=>o.getVarying(n,o.ShaderStages.out),g=(n,e)=>{return u.sample2DTexture((t={uniformName:n},a.getTextureUniform(t)),e);var t};class x extends e{constructor(){super(1),this.clampMin=-10,this.clampMax=20}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform1f(r.clampMin,this.clampMin),t.uniform1f(r.clampMax,this.clampMax)}fillUBO(n,e,t){super.fillUBO(n,e,t);const r=n.layout;n.setF(r.clampMin,this.clampMin),n.setF(r.clampMax,this.clampMax)}clone(){return new x}}function S(e){return`           \n            ${h({varyingName:"vUv",varyingType:"v2"})}\n\n            ${l.getMainVertexStart(e)}\n                ${v("vUv")} = uv.xy;\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(e)}\n            ${l.getMainVertexEnd(e)}\n        `}return{WeightedLuminance:new r(new t((function(n,e){var t=e.customDefines;const r=o.getShaderOutput("out0");let a=`\n            \n            ${h({varyingName:"vUv",varyingType:"v2"})}\n\n            ${m({uniformName:"tInput",uniformType:"t2",locationName:"tInput0"})}\n            ${t.USE_WEIGHT_TEXTURE>0?m({uniformName:"tWeight",uniformType:"t2",locationName:"tInput1"}):""}\n            ${m({uniformName:"clampMin",uniformType:"f"})}\n            ${m({uniformName:"clampMax",uniformType:"f"})}\n\n            ${d("luminance_weight")} = ${p()}(0.176204,0.812985,0.0108109);\n            //${d("luminance_weight")} = ${p()}(0.21,0.72,0.07);//native values\n  \n\n            ${l.getMainFragmentStart(e)}\n                ${((n=null,e=0)=>{var t={name:n,size:e};return s.vec2(t)})("screenUV")} = ${i="vUv",o.getVarying(i,o.ShaderStages.in)};\n                ${f("color")} = ${g("tInput","screenUV")};\n                ${$("weight")} = 1.0;\n                ${t.USE_WEIGHT_TEXTURE>0?`\n                    weight = ${g("tWeight","screenUV")}.r;\n                    `:""}\n                //${$("luminance")} = max(dot(color.xyz, luminance_weight),1e-6);\n                ${$("luminance")} = dot(color.xyz, luminance_weight);\n                ${$("value")} = weight * clamp(log(luminance),${c("clampMin")},${c("clampMax")});\n                ${r} = ${f()}(value,weight,0.0, 1.0);       \n            ${l.getMainFragmentEnd(e)}\n        `;var i;return{vertexShader:S(e),fragmentShader:a}}),"WeightedLuminance"),x,{USE_WEIGHT_TEXTURE:0})}})),define("DS/ShaderBuilders/PostPro/GroundShadowShaderBuilders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PostPro/PostProUniformHandler","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/PostPro/PostProContext","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a,o,i,s){"use strict";const l=i.ParameterUtils,u=i.FunctionHandler,m=i.BridgeFunctions,c=n=>a.addUniform(n),$=n=>{var e={uniformName:n};return a.getUniform(e)},p=n=>l.parameterV2(n),d=n=>l.parameterV3(n),f=n=>l.parameterV4(n),h=(n,e,t)=>u.callFunction(n,e,t),v=(n=null,e=0)=>{var t={name:n,size:e};return s.vec4(t)},g=n=>o.addVarying(n),x=(n,e)=>{return m.sample2DTexture((t={uniformName:n},a.getTextureUniform(t)),e);var t};class S extends e{constructor(){super(),this.shadowMatrix=new n.Matrix4,this.intensity=.5}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform1f(r.intensity,this.intensity),t.uniformMatrix4fv(r.shadowMatrix,!1,e.float32Matrix4x4Temp.setDoubles(this.shadowMatrix.elements))}fillUBO(n,e,t){super.fillUBO(n,e,t);const r=n.layout;n.setF(r.intensity,this.intensity),n.setM4(r.shadowMatrix,this.shadowMatrix)}clone(){var n=new S;return n.shadowMatrix=this.shadowMatrix,n.intensity=this.intensity,n}}return{GroundShadow:new r(new t((function(e,t){var r=t.customDefines;const a=o.getShaderOutput("out0");let i=`\n                 \n            ${g({varyingName:"vUv",varyingType:"v2"})}\n                \n\n            ${u.getMainVertexStart(t)}\n\n                ${l="vUv",o.getVarying(l,o.ShaderStages.out)} = uv.xy;\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(t)}\n            ${u.getMainVertexEnd(t)}\n        `;var l;let m=`\n            ${c({uniformName:"intensity",uniformType:"f"})}\n            ${c({uniformName:"shadowMatrix",uniformType:"m4"})}\n            ${c({uniformName:"tShadowMap",uniformType:"t2",locationName:"tInput"})}\n            \n            ${g({varyingName:"vUv",varyingType:"v2"})}\n\n            ${((n,e,t)=>u.declareFunction(n,e,t))("unpackDepth","f",[p("uv")])}{\n                ${v("rgba_depth")}  = ${x("tShadowMap","uv")};\n                ${r.IS_ESM?`\n                    ${((n=null,e=0)=>{var t={name:n,size:e};return s.float(t)})("depth")} = 1.0;\n                    ${t.uintESM?`\n                        depth = ${h("unpackRGB","f",[d("rgba_depth.xyz * pow(10.0,rgba_depth.w*255.0)")])};\n                        `:"\n                        depth = rgba_depth.x;\n                        "}\n                    return log(depth) / 80.0;\n                    `:`\n                    return ${h("unpackRGBA","f",[f("rgba_depth")])};\n                    `}\n            }\n\n            ${u.getMainFragmentStart(t)}\n                ${a} = ${v()}(1.0);\n\n                ${((n=null,e=0)=>{var t={name:n,size:e};return s.vec2(t)})("screenPos")} = ${(n=>o.getVarying(n,o.ShaderStages.in))("vUv")};\n                ${v("shadowCoord")} = ${$("shadowMatrix")} * ${v()}(screenPos.x, screenPos.y, 0.0, 1.0);\n                shadowCoord.x /= shadowCoord.w;\n                shadowCoord.y /= shadowCoord.w;\n                shadowCoord.z /= shadowCoord.w;\n\n                if (${h("unpackDepth","f",[p("shadowCoord.xy")])} < 1.0) {\n                    ${a}.x = ${$("intensity")};\n                }\n            ${u.getMainFragmentEnd(t)}\n        `;return{vertexShader:i,fragmentShader:m}}),"Ground_Shadow"),S,{IS_ESM:0})}})),define("DS/ShaderBuilders/PostPro/ESMBlurShaderBuilders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PostPro/PostProUniformHandler","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/PostPro/PostProContext","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a,o,i,s){"use strict";const l="",u=i.ParameterUtils,m=i.FunctionHandler,c=i.BridgeFunctions,$=n=>a.addUniform(n),p=n=>{var e={uniformName:n};return a.getUniform(e)},d=n=>u.parameterF(n),f=n=>u.parameterV2(n),h=n=>u.parameterV3(n),v=(n,e,t)=>m.declareFunction(n,e,t),g=(n,e,t)=>m.callFunction(n,e,t),x=(n=null,e=0)=>{var t={name:n,size:e};return s.float(t)},S=(n=null,e=0)=>{var t={name:n,size:e};return s.vec2(t)},y=(n=null,e=0)=>{var t={name:n,size:e};return s.vec4(t)},_=n=>o.addVarying(n),T=n=>o.getVarying(n,o.ShaderStages.in),D=n=>o.getVarying(n,o.ShaderStages.out),C=(n,e)=>{return c.sample2DTexture((t={uniformName:n},a.getTextureUniform(t)),e);var t};class P extends e{constructor(){super(),this.invSize=new n.Vector2(512,512)}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform2f(r.invSize,this.invSize.x,this.invSize.y)}fillUBO(n,e,t){super.fillUBO(n,e,t);const r=n.layout;n.setV2(r.invSize,this.invSize)}clone(){var n=new P;return n.invSize=this.invSize,n}}const N={LEVEL:1};function b(e){return`\n            \n            ${_({varyingName:"vUv",varyingType:"v2"})}\n            \n\n            ${m.getMainVertexStart(e)}\n\n                ${D("vUv")} = uv.xy;\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(e)}\n            ${m.getMainVertexEnd(e)}\n        `}function M(n){const e=n=>g("unpackDepth","f",[f(n)]);return`\n        \n            ${$({uniformName:"invSize",uniformType:"v2"})}\n            ${$({uniformName:"tShadowMap",uniformType:"t2",locationName:"tInput"})}\n            \n            ${_({varyingName:"vUv",varyingType:"v2"})}\n\n            ${v("unpackDepth","f",[f("uv")])}{\n                ${y("rgba_depth")}  = ${C("tShadowMap","uv")};\n                ${n.uintESM?`\n                    return ${g("unpackRGB","f",[h("rgba_depth.xyz * pow(10.0,rgba_depth.w*255.0)")])};\n                    `:"\n                    return rgba_depth.x;\n                    "}\n            }\n\n            ${v("unpackLerp","f",[f("coord")])} {\n                ${n.uintESM?`                \n                    ${S("invScreenSize")} = ${p("invSize")} ;  \n                    ${S("fractCoord")}  = fract(coord/invScreenSize + 0.5);\n                    ${S("centroidUV")}  = (coord/invScreenSize - fractCoord) * invScreenSize;\n\n                    ${x("lb")} = ${e("centroidUV")};\n                    ${x("lt")} = ${e(`centroidUV + ${S()}(0.0, invScreenSize.y)`)};\n                    ${x("rb")} = ${e(`centroidUV + ${S()}(invScreenSize.x, 0.0)`)};\n                    ${x("rt")} = ${e("centroidUV + invScreenSize")};\n                    ${x("a")} = mix(lb, lt, fractCoord.y);\n                    ${x("b")} = mix(rb, rt, fractCoord.y);\n                    return mix(a, b, fractCoord.x);\n                    `:`\n                    return ${e("coord")};\n                    `}\n            }\n\n            ${v("packDepth","v4",[d("depth")])} {\n                ${n.uintESM?`\n                    //orders above 1\n                    ${x("exposant")} = ceil(log(depth)/log(10.0));\n                    //[0-1]\n                    ${x("normDepth")} = depth/pow(10.0,exposant);\n                    return ${y()}(${g("packRGB","v3",[d("normDepth")])}, exposant / 255.0);\n                    `:`\n                    return ${y()}(depth,0.0,0.0,1.0);\n                    `}\n            }\n        \n        `}function U(n){let e=[],t=[],r=l;switch(n){case 1:default:e.push(-1.2),t.push(.3125),e.push(0),t.push(.375),e.push(1.2),t.push(.3125);break;case 2:e.push(-1.285714285714),t.push(.328125),e.push(0),t.push(.3125),e.push(1.285714285714),t.push(.328125);break;case 3:e.push(-3.111111111111),t.push(.03515625),e.push(-1.333333333333),t.push(.328125),e.push(0),t.push(.2734375),e.push(1.333333333333),t.push(.328125),e.push(3.111111111111),t.push(.03515625);break;case 4:e.push(-3.181818181818),t.push(.0537109375),e.push(-1.363636363636),t.push(.322265625),e.push(0),t.push(.24609375),e.push(1.363636363636),t.push(.322265625),e.push(3.181818181818),t.push(.0537109375);break;case 5:e.push(-5.076923076923),t.push(.003173828125),e.push(-3.230769230769),t.push(.06982421875),e.push(-1.384615384615),t.push(.314208984375),e.push(0),t.push(.2255859375),e.push(1.384615384615),t.push(.314208984375),e.push(3.230769230769),t.push(.06982421875),e.push(5.076923076923),t.push(.003173828125)}for(let n=0;n<e.length;n++){let a=0!==e[n]?e[n]:"0.0";r=`\n                ${r}\n                res += ${g("unpackLerp","f",[f(`screenPos + ${a} * blurSize`)])} * ${t[n]};\n            `}return r}return{BlurH:new r(new t((function(n,e){var t=e.customDefines;const r=o.getShaderOutput("out0");let a=`\n\n            ${M(e)}\n\n            ${m.getMainFragmentStart(e)}\n\n                ${S("screenPos")} = ${T("vUv")};\n                ${x("res")} = 0.0;\n                ${S("blurSize")} = ${S()}(${p("invSize")}.x, 0.0);\n\n                ${U(t.LEVEL)}\n                \n                ${r} = ${g("packDepth","v4",[d("res")])};\n            ${m.getMainFragmentEnd(e)}\n        `;return{vertexShader:b(e),fragmentShader:a}}),"ESM_Blur_H"),P,N),BlurV:new r(new t((function(n,e){var t=e.customDefines;const r=o.getShaderOutput("out0");let a=`\n\n            ${M(e)}\n\n            ${m.getMainFragmentStart(e)}\n\n                ${S("screenPos")} = ${T("vUv")};\n                ${x("res")} = 0.0;\n                ${S("blurSize")} = ${S()}(0.0, ${p("invSize")}.y);   \n\n                ${U(t.LEVEL)}\n                \n                ${r} = ${g("packDepth","v4",[d("res")])};\n            ${m.getMainFragmentEnd(e)}\n        `;return{vertexShader:b(e),fragmentShader:a}}),"ESM_Blur_V"),P,N)}})),define("DS/ShaderBuilders/PostPro/FXAAShaderBuilders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PostPro/PostProUniformHandler","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/PostPro/PostProContext","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a,o,i,s){"use strict";const l=i.ParameterUtils,u=i.FunctionHandler,m=i.BridgeFunctions,c=n=>a.addUniform(n),$=n=>{var e={uniformName:n};return a.getUniform(e)},p=n=>l.parameterV2(n),d=(n=null,e=0)=>{var t={name:n,size:e};return s.float(t)},f=(n=null,e=0)=>{var t={name:n,size:e,constant:!0};return s.float(t)},h=(n=null,e=0)=>{var t={name:n,size:e};return s.vec2(t)},v=(n=null,e=0)=>{var t={name:n,size:e,constant:!0};return s.vec2(t)},g=(n=null,e=0)=>{var t={name:n,size:e};return s.vec3(t)},x=(n=null,e=0)=>{var t={name:n,size:e,constant:!0};return s.vec3(t)},S=(n=null,e=0)=>{var t={name:n,size:e};return s.vec4(t)},y=n=>o.addVarying(n),_=n=>o.getVarying(n,o.ShaderStages.out),T=n=>o.getShaderInput(n),D=(n,e)=>{return m.sample2DTexture((t={uniformName:n},a.getTextureUniform(t)),e);var t};function C(n){return`\n            ${c({uniformName:"tScene",uniformType:"t2",locationName:"tInput"})}\n            ${c({uniformName:"resolution",uniformType:"v2"})}\n\n            ${y({varyingName:"vUv",varyingType:"v2"})}\n\n            ${f("FXAA_REDUCE_MIN")} =   (1.0/128.0);\n            ${f("FXAA_REDUCE_MUL")}  =   (1.0/8.0);\n            ${f("FXAA_SPAN_MAX")}  =     8.0;\n\n            ${x("luma")} = ${g()}(0.299, 0.587, 0.114);\n\n            ${v("positiveY")} = ${h()}(0.0, 1.0);\n            ${v("positiveX")} = ${h()}(1.0, 0.0);\n            ${v("negativeY")} = ${h()}(0.0, -1.0);\n            ${v("negativeX")} = ${h()}(-1.0, 0.0);\n\n            ${v("winMax")} = ${h()}(FXAA_SPAN_MAX,  FXAA_SPAN_MAX);\n            ${v("winMin")} = ${h()}(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX);\n        `}function P(n){const e="tScene";return`\n        ${h("screenRes")} = ${$("resolution")};\n        ${h("screenUV")} = ${T("fragCoord")}.xy * screenRes;\n        ${g("rgbNW")}  = ${D(e,"screenUV + (negativeX + negativeY) * screenRes")}.xyz;\n        ${g("rgbNE")}   = ${D(e,"screenUV + (positiveX + negativeY) * screenRes")}.xyz;\n        ${g("rgbSW")}   = ${D(e,"screenUV + (negativeX + positiveY) * screenRes")}.xyz;\n        ${g("rgbSE")}   = ${D(e,"screenUV + (positiveX + positiveY) * screenRes")}.xyz;\n        ${S("rgbaM")}    = ${D(e,"screenUV")};\n        ${g("rgbM")}    = rgbaM.xyz;\n        ${d("opacity")}    = rgbaM.w;\n\n        ${d("lumaNW")}  = dot( rgbNW, luma );\n        ${d("lumaNE")}   = dot( rgbNE, luma );\n        ${d("lumaSW")}   = dot( rgbSW, luma );\n        ${d("lumaSE")}   = dot( rgbSE, luma );\n        ${d("lumaM")}    = dot( rgbM,  luma );\n        ${d("lumaMin")}   = min( lumaM, min( min( lumaNW, lumaNE ), min( lumaSW, lumaSE ) ) );\n        ${d("lumaMax")}   = max( lumaM, max( max( lumaNW, lumaNE) , max( lumaSW, lumaSE ) ) );\n\n        ${h("dir")} ;\n        dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n        dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n        ${d("dirReduce")}   = max( ( lumaNW + lumaNE + lumaSW + lumaSE ) * ( 0.25 * FXAA_REDUCE_MUL ), FXAA_REDUCE_MIN );\n\n        ${d("rcpDirMin")}   = 1.0 / ( min( abs( dir.x ), abs( dir.y ) ) + dirReduce );\n        dir = min( winMax, max( winMin, dir * rcpDirMin)) * screenRes;\n        `}function N(e){return`\n            ${y({varyingName:"vUv",varyingType:"v2"})}\n\n            ${u.getMainVertexStart(e)}\n\n                ${_("vUv")} = uv.xy;\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(e)}\n\n            ${u.getMainVertexEnd(e)}\n        `}class b extends e{constructor(){super(),this.resolution=new n.Vector2(1/1024,1/512)}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform2f(r.resolution,this.resolution.x,this.resolution.y)}fillUBO(n,e,t){super.fillUBO(n,e,t);const r=n.layout;n.setV2(r.resolution,this.resolution)}clone(){var n=new b;return n.resolution=this.resolution,n}}return{FXAAShader:new r(new t((function(n,e){e.customDefines;const t="tScene",r=o.getShaderOutput("out0");let a=`\n            ${C()}\n\n            ${u.getMainFragmentStart(e)}\n\n                ${P()}\n\n                ${g("rgbA")}  = 0.5 * (\n                    ${D(t,"screenUV + dir * ( 1.0 / 3.0 - 0.5 )")}.xyz \n                    +\n                    ${D(t,"screenUV + dir * ( 2.0 / 3.0 - 0.5 )")}.xyz \n                );\n\n                ${g("rgbB")}  = rgbA * 0.5 + 0.25 * (\n                    ${D(t,"screenUV + dir * -0.5 ")}.xyz \n                    +\n                    ${D(t,"screenUV + dir * 0.5")}.xyz\n                );\n\n                ${d("lumaB")}  = dot( rgbB, luma );\n\n                if ( ( lumaB < lumaMin ) || ( lumaB > lumaMax ) ) {\n\n                    ${r} = ${S()}( rgbA, opacity );\n\n                } else {\n\n                    ${r} = ${S()}( rgbB, opacity );\n\n                }\n            ${u.getMainFragmentEnd(e)}\n        `;return{vertexShader:N(e),fragmentShader:a}}),"FXAA"),b,{}),OITFXAAShader:new r(new t((function(n,e){e.customDefines;const t=o.getShaderOutput("out0"),r=(n,e)=>{return t="sampleColor",r="v4",a=[p(n),prmV4(e)],u.callFunction(t,r,a);var t,r,a};let a=`\n            ${C()}\n\n            ${i="sampleColor",s="v4",l=[p("uv"),prmV4("color")],u.declareFunction(i,s,l)} {\n                ${S("res")} = ${D("tScene","uv")};\n                if (res.a < 1e-6) {\n                    return ${S()}(color.rgb, 0.2 * color.a);\n                }\n                return res;\n            }\n\n            ${u.getMainFragmentStart(e)}\n\n                ${P()}\n\n                ${S("rgbA")}  = 1.0 / 3.0 * ( rgbaM + \n                        ${r("screenUV + dir * ( 1.0 / 3.0 - 0.5 )","rgbaM")}\n                        +\n                        ${r("screenUV + dir * ( 2.0 / 3.0 - 0.5 )","rgbaM")}\n                );\n\n                ${S("rgbB")}  = rgbA * 0.6 + 0.2 * (\n                        ${r("screenUV + dir * -0.5","rgbaM")} \n                        +\n                        ${r("screenUV + dir * 0.5","rgbaM")} \n                );\n\n                ${d("lumaB")}  = dot( rgbB.rgb, luma );\n\n                if ( ( lumaB < lumaMin ) || ( lumaB > lumaMax ) ) {\n\n                    ${t} = rgbA;\n\n                } else {\n\n                    ${t} = rgbB;\n\n                }\n            ${u.getMainFragmentEnd(e)}\n        `;var i,s,l;return{vertexShader:N(e),fragmentShader:a}}),"FXAAOIT"),b,{})}})),define("DS/ShaderBuilders/PostPro/OITShaderBuilders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PostPro/PostProUniformHandler","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/PostPro/PostProContext","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a,o,i,s){"use strict";i.ParameterUtils;const l=i.FunctionHandler,u=i.BridgeFunctions,m=n=>a.addUniform(n),c=n=>{var e={uniformName:n};return a.getTextureUniform(e)},$=(n=null,e=0)=>{var t={name:n,size:e};return s.float(t)},p=(n=null,e=0)=>{var t={name:n,size:e,constant:!0};return s.float(t)},d=(n=null,e=0)=>{var t={name:n,size:e};return s.vec2(t)},f=(n=null,e=0)=>{var t={name:n,size:e};return s.vec4(t)},h=n=>o.addVarying(n),v=n=>o.getVarying(n,o.ShaderStages.in),g=n=>o.getVarying(n,o.ShaderStages.out),x=(n,e)=>u.sample2DTexture(c(n),e),S=(n,e)=>{return u.sample2DTextureMultisampled(c(n),e,(t="sampleIndex",o.getShaderInput(t)));var t};class y extends e{constructor(){super(2)}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i)}fillUBO(n,e,t){super.fillUBO(n,e,t)}clone(){return new y}}function _(e){return`\n            \n            ${h({varyingName:"vUv",varyingType:"v2"})}\n\n            ${l.getMainVertexStart(e)}\n\n                ${g("vUv")} = uv.xy;\n\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(e)}\n            ${l.getMainVertexEnd(e)}\n        `}class T extends e{constructor(){super()}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i)}fillUBO(n,e,t){super.fillUBO(n,e,t)}clone(){return new T}}return{SolveAndBlendIfPostProShader:new r(new t((function(n,e){var t=e.customDefines;const r=e.antialias?"t2ms":"t2",a=n=>e.antialias?S(n,"screenUV"):x(n,"screenUV"),i=o.getShaderOutput("out0");let u=`\n            \n            ${h({varyingName:"vUv",varyingType:"v2"})}\n\n            ${t.POSTPRO?m({uniformName:"tScene",uniformType:r,locationName:"tInput0"}):""}\n            ${m({uniformName:"tAccum",uniformType:r,locationName:"tInput1"})}\n            ${m({uniformName:"tReveal",uniformType:r,locationName:"tInput2"})}\n\n            ${p("threshold")} = 1e-6;\n\n            ${l.getMainFragmentStart(e)}\n                ${d("screenUV")} = ${v("vUv")};\n                ${t.POSTPRO?`\n                    ${f("opaque")} = ${a("tScene")};\n                    `:`\n                    ${f("opaque")} = ${f()}(0.0);\n                    `}\n                ${$("reveal")}  = ${a("tReveal")}.r;\n                if (reveal > 1.0 - threshold) {\n                    ${i} = opaque;\n                    ${l.getEarlyFragmentEnd()}\n                }\n                ${f("accum")}  = ${a("tAccum")};\n                ${$("divider")} = max(accum.a,threshold);\n                if (${g="abs(accum)",c=`max(${g}.r,max(${g}.g,max(${g}.b,${g}.a)))`,`abs(${c}) == 1e6`}){\n                    accum.r = divider;\n                    accum.g = divider;\n                    accum.b = divider;\n                }\n                ${((n=null,e=0)=>{var t={name:n,size:e};return s.vec3(t)})("avgCol")}  = accum.rgb / divider;\n                ${t.POSTPRO?`\n                    ${i} = vec4(avgCol * (1.0 - reveal) + reveal * opaque.rgb, 1.0 - reveal + opaque.a * reveal);\n                    `:`\n                    ${i} = vec4(avgCol, 1.0 - reveal);\n                    `}\n            ${l.getMainFragmentEnd(e)}\n        `;var c,g;return{vertexShader:_(e),fragmentShader:u}}),"OIT_Solve_Blend"),y,{POSTPRO:1}),BlendShader:new r(new t((function(n,e){e.customDefines;const t=o.getShaderOutput("out0");let r=`\n            \n            ${h({varyingName:"vUv",varyingType:"v2"})}\n\n            ${m({uniformName:"tTransparent",uniformType:"t2",locationName:"tInput"})}\n\n            ${p("threshold")} = 1e-6;\n\n            ${l.getMainFragmentStart(e)}\n                ${d("screenUV")} = ${v("vUv")};\n                ${t} = ${x("tTransparent","screenUV")};\n            ${l.getMainFragmentEnd(e)}\n        `;return{vertexShader:_(e),fragmentShader:r}}),"OIT_Blend"),T,{})}})),define("DS/ShaderBuilders/PostPro/FakeOutlinesShaderBuilders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PostPro/PostProUniformHandler","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/PostPro/PostProContext","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a,o,i,s){"use strict";const l=i.ParameterUtils,u=i.FunctionHandler,m=i.BridgeFunctions,c=n=>a.addUniform(n),$=n=>l.parameterV2(n),p=(n,e,t)=>u.callFunction(n,e,t),d=(n=null,e=0)=>{var t={name:n,size:e};return s.float(t)},f=(n=null,e=0)=>{var t={name:n,size:e};return s.vec3(t)},h=(n=null,e=0)=>{var t={name:n,size:e};return s.vec4(t)},v=n=>o.addVarying(n),g=n=>o.getVarying(n,o.ShaderStages.out),x=(n,e)=>{return m.sample2DTexture((t={uniformName:n},a.getTextureUniform(t)),e);var t};class S extends e{constructor(){super(1),this.near=0,this.far=0,this.edlStrength=.4,this.edlRadius=.5,this.edlRadiusDepth=1,this.edlRadiusNormal=1,this.edlRadiusMesh=1,this.grazingAngleDepth=1,this.depthStrength=1,this.tRandomTexture=null,this.invSize=new n.Vector2(1/800,1/600),this.samplingPoints=null}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform1f(r.near,this.near),t.uniform1f(r.far,this.far),t.uniform1f(r.edlStrength,this.edlStrength),t.uniform1f(r.edlRadius,this.edlRadius),t.uniform1f(r.edlRadiusDepth,this.edlRadiusDepth),t.uniform1f(r.edlRadiusNormal,this.edlRadiusNormal),t.uniform1f(r.edlRadiusMesh,this.edlRadiusMesh),t.uniform1f(r.grazingAngleDepth,this.grazingAngleDepth),t.uniform1f(r.depthStrength,this.depthStrength),e.loadTexture(t,r.tRandomTexture,this.tRandomTexture),t.uniform2f(r.invSize,this.invSize.x,this.invSize.y),t.uniform4fv(r.samplingPoints,this.samplingPoints)}fillUBO(n,e,t){super.fillUBO(n,e,t);const r=n.layout;n.setF(r.near,this.near),n.setF(r.far,this.far),n.setF(r.edlStrength,this.edlStrength),n.setF(r.edlRadius,this.edlRadius),n.setF(r.edlRadiusDepth,this.edlRadiusDepth),n.setF(r.edlRadiusNormal,this.edlRadiusNormal),n.setF(r.edlRadiusMesh,this.edlRadiusMesh),n.setF(r.grazingAngleDepth,this.grazingAngleDepth),n.setF(r.depthStrength,this.depthStrength),n.setTexture(r.tRandomTexture,this.tRandomTexture),n.setV2(r.invSize,this.invSize),n.setFlatV4Array(r.samplingPoints,this.samplingPoints)}clone(){var n=new S;return n.near=this.near,n.far=this.far,n.edlStrength=this.edlStrength,n.edlRadius=this.edlRadius,n.edlRadiusDepth=this.edlRadiusDepth,n.edlRadiusNormal=this.edlRadiusNormal,n.edlRadiusMesh=this.edlRadiusMesh,n.grazingAngleDepth=this.grazingAngleDepth,n.depthStrength=this.depthStrength,n.tRandomTexture=this.tRandomTexture,n.invSize=this.invSize,n.samplingPoints=this.samplingPoints,n}}function y(e){return`\n            ${v({varyingName:"vUv",varyingType:"v2"})}\n            \n            ${u.getMainVertexStart(e)}\n\n                ${g("vUv")} = uv.xy;\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(e)}\n            ${u.getMainVertexEnd(e)}\n        `}return new r(new t((function(n,e){var t=e.customDefines;const r=o.getShaderOutput("out0");var a,i=`\n        ${c({uniformName:"samplingPoints",uniformType:"fv4",size:8})}\n\n        ${function(n){var e=n.customDefines;const t="tNormalDepth";return`\n        ${c({uniformName:"edlRadius",uniformType:"f"})}\n        ${c({uniformName:"edlRadiusDepth",uniformType:"f"})}\n        ${c({uniformName:"edlRadiusNormal",uniformType:"f"})}\n        ${c({uniformName:"edlRadiusMesh",uniformType:"f"})}\n        ${c({uniformName:"grazingAngleDepth",uniformType:"f"})}\n        ${c({uniformName:"depthStrength",uniformType:"f"})}\n        ${c({uniformName:"edlStrength",uniformType:"f"})}\n        ${c({uniformName:"near",uniformType:"f"})}\n        ${c({uniformName:"far",uniformType:"f"})}\n        ${c({uniformName:"tNormalDepth",uniformType:"t2",locationName:"tInput0"})}\n        ${c({uniformName:"tPickingColors",uniformType:"t2",locationName:"tInput1"})}\n        \n        ${c({uniformName:"invSize",uniformType:"v2"})}\n\n        ${v({varyingName:"vUv",varyingType:"v2"})}\n\n        vec3 getNormal(const in vec2 iUV) {\n            ${h("normalDepth")}  = ${x(t,"iUV")};\n            ${f("normal")};\n            ${n.renderToFloatTexture?"\n                normal = normalDepth.xyz * 2.0 - 1.0;\n                ":`\n                normal = ${p("decodeOct22Normal","v3",[$("normalDepth.xy")])};\n                `}\n            return normal;\n        }\n\n        float getDepth(const in vec2 iUV) {\n            ${h("normalDepth")}  = ${x(t,"iUV")};\n            ${d("z")};\n            ${n.renderToFloatTexture?"\n                z = normalDepth.w;\n                ":`\n                z = ${p("unpackForFloat16","f",[$("normalDepth.zw")])};\n                `}\n            return z;\n        }\n\n        float getLinearDepth(const in vec2 iUV) {\n            float depth = getDepth(iUV);\n            if (depth == 0.0) {\n                depth = 1.0;\n            }\n            return near * far / (far - depth * (far - near));\n        }\n\n        float getLinearAndNormalizedDepth(const in vec2 iUV) {\n            float depth = getDepth(iUV);\n            return depth * near / (far - depth * (far - near));\n        }\n\n        vec3 getPickingColor(const in vec2 iUV) {\n            ${h("color")} = ${x("tPickingColors","iUV")};\n            return color.rgb;\n        }\n\n        float computeEDLFromDepth(const in vec2 uv, const in float depth) {\n\n            vec2 uvRadius = 1.5 * edlRadius * edlRadiusDepth * invSize;\n            float sum = 0.0;\n\n            for (int i = 0; i < 8; i++) {\n\n                vec2 neighbour = samplingPoints[i].xy;\n                vec2 uvNeighbor = uv + uvRadius * neighbour;\n                float neighbourDepth = getLinearAndNormalizedDepth(uvNeighbor);\n                sum += max(0.0, (depth - neighbourDepth));\n            }\n\n            return smoothstep(0.0, 1.0 - depthStrength, 0.125 * sum);\n        }\n\n        float computeEDLFromNormal(const in vec2 uv) {\n\n            vec3 centerNormal = getNormal(uv);\n            vec2 uvRadius = edlRadius * edlRadiusNormal * invSize;\n            float maxDiff = 0.0;\n            \n            for (int i = 0; i < 8; i++) {\n                vec2 neighbour = samplingPoints[i].xy;\n                vec2 uvNeighbor = uv + uvRadius * neighbour;\n                vec3 neighbourNormal = getNormal(uvNeighbor);\n                \n                // Angle entre les normales\n                float normalDiff = 1.0 - max(0.0, abs(dot(centerNormal, neighbourNormal)));\n                //float normalDiff = length(centerNormal - neighbourNormal);\n                //maxDiff = max(maxDiff, normalDiff);\n                maxDiff += 0.125 * normalDiff;\n            }\n            \n            return maxDiff;\n        }\n\n        float computeEDLFromMesh(const in vec2 uv){\n\n            // Sobel sur la picking color map\n            vec2 texelSize = invSize;\n            vec3 n_tl = getPickingColor(uv + vec2(-texelSize.x, -texelSize.y));\n            vec3 n_tc = getPickingColor(uv + vec2(0.0, -texelSize.y));\n            vec3 n_tr = getPickingColor(uv + vec2(texelSize.x, -texelSize.y));\n            vec3 n_ml = getPickingColor(uv + vec2(-texelSize.x, 0.0));\n            vec3 n_mr = getPickingColor(uv + vec2(texelSize.x, 0.0));\n            vec3 n_bl = getPickingColor(uv + vec2(-texelSize.x, texelSize.y));\n            vec3 n_bc = getPickingColor(uv + vec2(0.0, texelSize.y));\n            vec3 n_br = getPickingColor(uv + vec2(texelSize.x, texelSize.y));\n            \n            // Gradient horizontal et vertical\n            vec3 sobelX = -n_tl + n_tr - 2.0*n_ml + 2.0*n_mr - n_bl + n_br;\n            vec3 sobelY = -n_tl - 2.0*n_tc - n_tr + n_bl + 2.0*n_bc + n_br;\n            float sobel = length(sobelX) + length(sobelY);\n            \n            return max(0.0,1.0-step(0.02, sobel) * 20.0);\n        }\n\n        float computeEDLFromMeshRing(const in vec2 uv) {\n\n            vec2 uvRadius = edlRadius * edlRadiusMesh * invSize;\n            float sum = 0.0;\n            vec3 centerColor = getPickingColor(uv);\n\n            for (int i = 0; i < 8; i++) {\n\n                vec2 neighbour = samplingPoints[i].xy;\n                vec2 uvNeighbor = uv + uvRadius * neighbour;\n                vec3 neighbourColor = getPickingColor(uvNeighbor);\n                vec3 diff = centerColor - neighbourColor;\n                sum += max(0.0, 100.0*dot(diff, diff));\n            }\n\n            return max(0.0, 1.0 - sum / 8.0);\n        }\n\n        float computeEDL(const in vec2 uv, const in float depth, const in float viewAngle) {\n\n            float res = 0.0;\n\n            // EDL classique avec attnuation sur surfaces rasantes\n            ${e.DEPTH_CONTRIB?"\n                float depthFactor = computeEDLFromDepth(uv, depth) * mix(1.0 - grazingAngleDepth, 1.0, viewAngle);\n                res = max(res, depthFactor);\n                ":""}\n\n            // Dtection de contours par normales\n            ${e.NORMAL_CONTRIB?"\n                float normalFactor = smoothstep(0.02, 0.5, computeEDLFromNormal(uv));\n                res = max(res, normalFactor);\n                ":""}\n\n            ${e.MESH_CONTRIB?"\n                float meshFactor = computeEDLFromMeshRing(uv);\n                res = max(res, 1.0 - meshFactor);\n                ":""}\n\n            //float depthWeight = 1.0 - depth; // Privilgier les objets proches\n            //return mix(normalFactor, depthFactor, depthWeight);\n\n            return res;\n        }\n\n        vec3 computeEDL_debugcolor(const in vec2 uv, const in float depth, const in float viewAngle) {\n\n            vec3 res = vec3(1.0);\n\n            // EDL classique avec attnuation sur surfaces rasantes\n            ${e.DEPTH_CONTRIB?"\n                float depthFactor = computeEDLFromDepth(uv, depth) * mix(1.0 - grazingAngleDepth, 1.0, viewAngle);\n                res *= vec3(1.0-100.0*depthFactor, 1.0, 1.0-100.0*depthFactor);\n                ":""}\n\n            // Dtection de contours par normales\n            ${e.NORMAL_CONTRIB?"\n                float normalFactor = smoothstep(0.02, 0.5, computeEDLFromNormal(uv));\n                res *= vec3(1.0-pow(normalFactor, 0.1), 1.0-pow(normalFactor, 0.1), 1.0);\n                ":""}\n\n            ${e.MESH_CONTRIB?"\n                float meshFactor = computeEDLFromMeshRing(uv);\n                res *= vec3(1.0, pow(meshFactor, 100.0), pow(meshFactor, 100.0));\n                ":""}\n\n            //float depthWeight = 1.0 - depth; // Privilgier les objets proches\n            //return mix(normalFactor, depthFactor, depthWeight);\n\n            //float isBlack = step(0.0, 0.001 - dot(res, res)); // 1.0 si res est (presque) noir\n            //return mix(res, vec3(1.0), isBlack);\n            //return vec3(1.0) - res;\n            return res;\n        }\n        `}(e)}\n        \n            ${u.getMainFragmentStart(e)}\n\n            ${((n=null,e=0)=>{var t={name:n,size:e};return s.vec2(t)})("screenUV")} = ${a="vUv",o.getVarying(a,o.ShaderStages.in)};\n            ${r} = ${h()}(1.0);\n\n            vec3 centerNormal = getNormal(screenUV);\n            ${d("depth")} = ${p("getLinearAndNormalizedDepth","f",[$("screenUV")])};\n            float viewAngle = abs(centerNormal.z); // z = composante vers la camra\n\n            ${t.DEBUG_COLORS?`\n                vec3 edl = computeEDL_debugcolor(screenUV, depth, viewAngle);\n                //vec3 shade = exp(-edl * 300.0 * edlStrength);\n                ${r} = ${h()}(edl, 1.0);\n                `:`\n                float edl = computeEDL(screenUV, depth, viewAngle);\n                float shade = exp(-edl * 300.0 * edlStrength);\n                ${r} = ${h()}(vec3(shade), 1.0);\n                `}\n\n            ${t.DEBUG_DEPTH?`\n                ${r} = ${h()}(vec3(depth), 1.0);\n                `:""}\n\n            ${t.DEBUG_NORMAL?`\n                ${r} = ${h()}(0.5 * centerNormal + 0.5, 1.0);\n                `:""}\n\n            ${t.DEBUG_MESH?`\n                vec3 centerColor = getPickingColor(vUv);\n                ${r} = ${h()}(centerColor, 1.0);\n                `:""}\n        ${u.getMainFragmentEnd(e)}\n        `;return{vertexShader:y(e),fragmentShader:i}}),"FakeOutlines_Direct"),S,{DEPTH_CONTRIB:!0,NORMAL_CONTRIB:!0,MESH_CONTRIB:!0,DEBUG_DEPTH:!1,DEBUG_NORMAL:!1,DEBUG_MESH:!1,DEBUG_COLORS:!1})})),define("DS/ShaderBuilders/PostPro/HighlightShaderBuilders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PostPro/PostProUniformHandler","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/PostPro/PostProContext","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a,o,i,s){"use strict";const l="true"===localStorage.getItem("__1x3HL__"),u=i.ParameterUtils,m=i.FunctionHandler,c=i.BridgeFunctions,$=n=>s.dereference(n),p=n=>a.addUniform(n),d=n=>{var e={uniformName:n};return a.getUniform(e)},f=(n,e)=>u.parameterStruct(n,e),h=n=>u.parameterF(n),v=n=>u.parameterI(n),g=n=>u.parameter("b",n),x=n=>u.parameterInOut("b",n),S=n=>u.parameterRef("b",n),y=n=>u.parameterV2(n),_=n=>u.parameterV4(n),T=n=>u.parameterInOutV4(n),D=n=>u.parameterRefV4(n),C=(n,e,t)=>m.declareFunction(n,e,t),P=(n,e,t)=>m.callFunction(n,e,t),N=(n=null,e=0)=>{var t={name:n,size:e};return s.bool(t)},b=(n=null,e=0)=>{var t={name:n,size:e};return s.int(t)},M=(n=null,e=0)=>{var t={name:n,size:e,constant:!0};return s.int(t)},U=(n=null,e=0)=>{var t={name:n,size:e};return s.float(t)},w=(n=null,e=0)=>{var t={name:n,size:e,constant:!0};return s.float(t)},V=(n=null,e=0)=>{var t={name:n,size:e};return s.vec2(t)},z=(n=null,e=0)=>{var t={name:n,size:e};return s.vec3(t)},F=(n=null,e=0)=>{var t={name:n,size:e};return s.vec4(t)},I=n=>o.addVarying(n),R=(n,e)=>{return c.sample2DTexture((t={uniformName:n},a.getTextureUniform(t)),e);var t},A=(n,e)=>c.greaterThan(n,e);class L extends e{constructor(){super(1),this.h=1/1024,this.v=1/1024,this.empty=0,this.poisson=[],this.iHaloColors=[],this.iLineicHaloColors=[],this.iColors=[],this.iOutlineColors=[],this.iLineicOutlineColors=[]}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform1f(r.h,this.h),t.uniform1f(r.v,this.v),t.uniform1i(r.empty,this.empty),t.uniform4fv(r.poisson,this.poisson),t.uniform4fv(r.iHaloColors,this.iHaloColors),t.uniform4fv(r.iLineicHaloColors,this.iLineicHaloColors),t.uniform4fv(r.iColors,this.iColors),t.uniform4fv(r.iOutlineColors,this.iOutlineColors),t.uniform4fv(r.iLineicOutlineColors,this.iLineicOutlineColors)}fillUBO(n,e,t){super.fillUBO(n,e,t);const r=n.layout;n.setF(r.h,this.h),n.setF(r.v,this.v),n.setI(r.empty,this.empty),n.setFlatV4Array(r.poisson,this.poisson),n.setFlatV4Array(r.iHaloColors,this.iHaloColors),n.setFlatV4Array(r.iLineicHaloColors,this.iLineicHaloColors),n.setFlatV4Array(r.iColors,this.iColors),n.setFlatV4Array(r.iOutlineColors,this.iOutlineColors),n.setFlatV4Array(r.iLineicOutlineColors,this.iLineicOutlineColors)}clone(){var n=new L;return n.h=this.h,n.v=this.v,n.empty=this.empty,n.poisson=this.poisson,n.iHaloColors=this.iHaloColors,n.iLineicHaloColors=this.iLineicHaloColors,n.iColors=this.iColors,n.iOutlineColors=this.iOutlineColors,n.iLineicOutlineColors=this.iLineicOutlineColors,n}}const B={POSTPRO:1,NB_CONFIG:0,HALO_THICKNESS:2,HAS_POLITE:0,QA_AUTOMATION:0};let E={UNROLLED:1};Object.assign(E,B);let k={UNROLLED:0};Object.assign(k,B);const O=new t((function(e,t){var r=t.customDefines;let a=`\n            ${I({varyingName:"vUv",varyingType:"v2"})}\n\n            ${m.getMainVertexStart(t)}\n                ${i="vUv",o.getVarying(i,o.ShaderStages.out)} = uv.xy;\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(t)}\n            ${m.getMainVertexEnd(t)}\n\n        `;var i;const u=r.NB_CONFIG,L=1===u,B=!!r.POSTPRO,E=!!r.UNROLLED,k=!E&&!!r.HAS_POLITE,O=!!r.QA_AUTOMATION,G="tSceneHighlight",H=r.HALO_THICKNESS,X=o.getShaderOutput("out0"),W=n=>P("GetID","i",[h(n)]),j=n=>P("GetID","i",[_(n)]);function q(n){for(var e="",t=0;t<u;t++)e=`\n                    ${e}\n                    if (${t} + 1 == index) {\n                        ${M("i")} = ${t};\n                        ${n};\n                    }\n                `;return e}let Z=`\n            \n            ${I({varyingName:"vUv",varyingType:"v2"})}\n        \n            ${B?p({uniformName:"tScene",uniformType:"t2",locationName:"tInput0"}):""}\n            ${p({uniformName:"tSceneHighlight",uniformType:"t2",locationName:"tInput1"})}\n            ${p({uniformName:"h",uniformType:"f"})}\n            ${p({uniformName:"v",uniformType:"f"})}\n            ${p({uniformName:"empty",uniformType:"i"})}\n            ${p({uniformName:"poisson",uniformType:"fv4",size:6})}\n            //\n            ${p({uniformName:"iHaloColors",uniformType:"fv4",size:u})}\n            ${p({uniformName:"iLineicHaloColors",uniformType:"fv4",size:u})}\n            //\n            ${p({uniformName:"iOutlineColors",uniformType:"fv4",size:u})}\n            ${p({uniformName:"iLineicOutlineColors",uniformType:"fv4",size:u})}\n            //\n            ${p({uniformName:"iColors",uniformType:"fv4",size:u})}\n\n            ${w("fHaloThickness")} = ${U()}(${H});\n            ${M("haloThickness")} = ${H};\n\n            \n            ${s.createStruct({structName:"highlightConfig",attributes:[{type:"b",name:"colorEnabled"},{type:"v3",name:"color"},{type:"v2",name:"colorIntensity"},{type:"b",name:"outlineEnabled"},{type:"v3",name:"outlineColor"},{type:"v3",name:"lineicOutlineColor"},{type:"f",name:"outlineAlpha"},{type:"f",name:"outlineThickness"}]})}\n\n            \n            ${s.struct({name:"emptyConfig",structName:"highlightConfig",addressSpace:"private"})};\n\n            ${w("outlineCheck")} = 8.0;\n\n            ${C("GetID","i",[h("texR")])} {\n                return ${b()}(floor(255.0 * texR + 0.5));\n            }\n\n            ${C("GetID","i",[_("tex")])} {\n                return ${b()}(floor(255.0 * tex.r + 0.5));\n            }\n\n            ${C("GetHaloData","v4",[v("index"),h("glType")])}{\n                ${F("res")} = ${F()}(0.0);\n                ${k?`\n                    if (${W("glType")} == 2 || ${W("glType")} == 4) {\n                        return res;\n                    }\n                    `:""}\n                ${U("factor")} = 0.0;\n                if (${W("glType")} <= 2) {\n                    factor = ceil(glType);\n                }\n                if (index > 0) {\n                    ${L?`\n                        res.a = (1.0 + factor) * ${d("iHaloColors")}[0].a;\t\t\t\t\t\n                        res.r = ${d("iHaloColors")}[0].r;\t\t\n                        res.g = ${d("iHaloColors")}[0].g;\t\t\n                        res.b = ${d("iHaloColors")}[0].b;\n                        `:function(){const n=`       \n                res.a = (1.0 + factor) * ${d("iHaloColors")}[i].a;\n                ${z("color")} = ${d("iHaloColors")}[i].rgb;\n                res.r = color.r;\n                res.g = color.g;\n                res.b = color.b;\n            `;return E?q(n):`\n            for (${b("i")} = 0; i < ${u}; i++) {\n                if (i + 1 == index) {\n                    ${n}\n                    break;\n                }\n            }\n            `}()}\n                }\n                return res;\n            }\n\n            ${C("GetLineicHaloData","v4",[v("index")])}{\n                ${F("res")} = ${F()}(0.0);\n                if (index > 0) {\n                    ${L?`\t\t\t\n                        res.r = ${d("iLineicHaloColors")}[0].x;\t\t\n                        res.g = ${d("iLineicHaloColors")}[0].y;\t\t\n                        res.b = ${d("iLineicHaloColors")}[0].z;\n                        `:function(){const n=`          \n                ${z("color")} = ${d("iLineicHaloColors")}[i].rgb;\n                res.r = color.x;\n                res.g = color.y;\n                res.b = color.z;\n            `;return E?q(n):`\n            for (${b("i")} = 0; i < ${u}; i++) {\n                if (i + 1 == index) {\n                    ${n}\n                    break;\n                }\n            }\n            `}()}\n                }\n                ${l?"\n                    res.a = 0.45;\n                    ":"\n                    res.a = 0.8;\n                    "}\n                return res;\n            }\n\n            ${C("GetHighlightConfig","highlightConfig",[v("index")])} {               \n                if (index > 0) {                  \n                    ${s.struct({name:"res",structName:"highlightConfig"})};\n                    ${L?`\t\t\t\n                        res.color = ${d("iColors")}[0].rgb;\n                        res.colorIntensity = ${V()}(${d("iColors")}[0].a, ${d("iLineicHaloColors")}[0].a);\n                        res.outlineColor = ${d("iOutlineColors")}[0].rgb;\n                        res.lineicOutlineColor = ${d("iLineicOutlineColors")}[0].rgb;\n                        res.outlineAlpha = ${d("iOutlineColors")}[0].a;\n                        //res.lineicOutlineAlpha = ${d("iLineicOutlineAlphas")}[0];\n                        res.outlineThickness = ${d("iLineicOutlineColors")}[0].a;\n                        `:function(){const n=`\n            \n                res.color = ${d("iColors")}[i].rgb;\n                res.colorIntensity = ${V()}(${d("iColors")}[i].a, ${d("iLineicHaloColors")}[i].a);\n                res.outlineColor = ${d("iOutlineColors")}[i].rgb;\n                res.lineicOutlineColor = ${d("iLineicOutlineColors")}[i].rgb;\n                res.outlineAlpha = ${d("iOutlineColors")}[i].a;\n                //res.lineicOutlineAlpha = ${d("iLineicOutlineAlphas")}[i];\n                res.outlineThickness = ${d("iLineicOutlineColors")}[i].a;\n            `;return E?q(n):`\n            for (${b("i")} = 0; i < ${u}; i++) {\n                if (i + 1 == index) {\n                    ${n}\n                    break;\n                }\n            }\n            `}()}\n                    return res;\n                }\n                return emptyConfig;\n            }\n\n            ${C("GetHighlightConfig","highlightConfig",[h("texR")])} {\n                ${b("id")} = ${W("texR")};\n                return ${P("GetHighlightConfig","highlightConfig",[v("id")])};\n            }\n\n            ${k?`             \n                ${C("DoPoliteLineic","b",[T("center"),x("forceOutlineOn"),x("forceHaloOn"),x("isLineic"),v("id"),y("iUv")])}{\n                    ${N("forceBasePostProOff")}  = false;\n                    ${F("oldCenter")}  = ${$("center")};\n                    ${b("curID")}  = 0;\n                    ${U("curDistance")}  = 1e6;\n                    ${N("curBack")}  = false;\t\n                    ${N("outer")}  = false;\n                    ${N("outerOutline")}  = false;\t\t\t\t\n                    ${N("inner")}  = false;\t\t\t\t\t\n                    ${N("innerOuter")}  = false;\t\t\t\n                    ${N("innerOutline")}  = false;\t\n                    ${V("oneAndHalf")} = ${V()}(1.5, 1.5);\n                    ${V("halfVec")} = ${V()}(0.5, 0.5);\n                    for (${b("i")} = -2; i <= 2 ; i++) {\n                        for (${b("j")} = -2; j <= 2 ; j++) {\n                            ${V("offsetFactor")} = ${V()}(${U()}(i), ${U()}(j));\n                            ${U("dist")} = length(offsetFactor);\n                            ${V("uv")} = iUv + offsetFactor * ${V()}(${d("h")},${d("v")});\n                            ${F("auxCenter")}  = ${R(G,"uv")};\n                            if (${W("auxCenter.w")} == id && auxCenter.b > 0.0) {\t\t\t\t\t\t\n                                ${b("auxID")}  = ${W("auxCenter.r")};\n                                if (dist < curDistance || (abs(dist - curDistance) < 1e-6)) {\n                                    // Front Priority\n                                    if (curID > 0 && auxCenter.b > 0.5 && !curBack) {\n                                        continue;\n                                    }\n                                    ${$("center")} = auxCenter;\n                                    ${V("absOffsetFactor")} = abs(offsetFactor);\n                                    curID = auxID;\n                                    curDistance = dist;\n                                    curBack = auxCenter.b > 0.5;\n                                    outer = any(${A("absOffsetFactor","oneAndHalf")});\n                                    outerOutline = outer;\n                                    //outerOutline = any(greaterThan(abs(offsetFactor), oneAndHalf)) && !outer;\n                                    inner = all(${Y="absOffsetFactor",J="oneAndHalf",c.lessThan(Y,J)});\n                                    innerOuter = inner;\n                                    //inner && any(greaterThan(abs(offsetFactor), oneAndHalf));\n                                    innerOutline = any(${A("absOffsetFactor","halfVec")});\t\n                                    forceBasePostProOff = true;\t\t\t\t\t\t\t\t\t\t\n                                }\n                            }\n                        }\n                    }\n                    if (curBack && !inner){\n                        ${$("center")} = oldCenter;\n                    } else {\n                        ${$("forceOutlineOn")} = (curBack && !innerOutline) || (!curBack && !outerOutline && innerOutline);\n                        ${$("forceHaloOn")} = (curBack && innerOutline) || (!curBack && outerOutline);\n                        ${$("isLineic")} = ${W(`${$("center")}.w`)} == id;\n                    }\n                    return forceBasePostProOff;\n                }\n                `:""}\n\n            ${C("CheckIfOutlines","f",[_("center"),y("uv"),f("highlightConfig","config")])} {\n                ${b("curID")} = ${P("GetID","i",[h("center.r")])};\n                ${U("tx")} = config.outlineThickness * ${d("h")};\n                ${U("ty")} = config.outlineThickness * ${d("v")};\n\n                ${U("result")} = 0.0;\n\n\t\t\t\t${b("cardinalSampling")}  = ${j(R(G,`${V()}( uv.x - tx, uv.y + ty)`))};\n                if (curID == cardinalSampling) {\n                    result += 1.0;\n                }\n\t\t\t\tcardinalSampling      = ${j(R(G,`${V()}( uv.x     , uv.y + ty)`))};\n                if (curID == cardinalSampling) {\n                    result += 1.0;\n                }\n\t\t\t\tcardinalSampling  = ${j(R(G,`${V()}( uv.x + tx, uv.y + ty)`))};\n                if (curID == cardinalSampling) {\n                    result += 1.0;\n                }\n\n\t\t\t\tcardinalSampling      = ${j(R(G,`${V()}( uv.x - tx, uv.y)`))};\n                if (curID == cardinalSampling) {\n                    result += 1.0;\n                }\n\t\t\t\tcardinalSampling       = ${j(R(G,`${V()}( uv.x + tx, uv.y)`))};\n                if (curID == cardinalSampling) {\n                    result += 1.0;\n                }\n\n\t\t\t\tcardinalSampling  = ${j(R(G,`${V()}( uv.x - tx, uv.y - ty)`))};\n                if (curID == cardinalSampling) {\n                    result += 1.0;\n                }\n\t\t\t\tcardinalSampling      = ${j(R(G,`${V()}( uv.x     , uv.y - ty)`))};\n                if (curID == cardinalSampling) {\n                    result += 1.0;\n                }\n\t\t\t\tcardinalSampling  = ${j(R(G,`${V()}( uv.x + tx, uv.y - ty)`))};\n                if (curID == cardinalSampling) {\n                    result += 1.0;\n                }\n\n                return result;\n            }\n\n            ${C("ComputeHaloColor","v4",[y("uv")])} {\n\n\t\t\t\t${F("haloColor")}  = ${F()}(0.0);\n\t\t\t\t${U("count")}  = 0.0;\n\t\t\t\t${U("tx")}  = fHaloThickness * ${d("h")};\n\t\t\t\t${U("ty")}  = fHaloThickness * ${d("v")};\n\n\t\t\t\t{\n\t\t\t\t\t${U("stx")}  = 1.5 * ${d("h")};\n\t\t\t\t\t${U("sty")}  = 1.5 * ${d("v")};\n\t\t\t\t\n\t\t\t\t\tcount+= ${R(G,`${V()}( uv.x - stx, uv.y + sty)`)}.r;\n\t\t\t\t\tcount+= ${R(G,`${V()}( uv.x    , uv.y + sty)`)}.r;\n\t\t\t\t\tcount+= ${R(G,`${V()}( uv.x + stx, uv.y + sty)`)}.r;\n\n\t\t\t\t\tcount+= ${R(G,`${V()}( uv.x - stx, uv.y)`)}.r;\n\t\t\t\t\tcount+= ${R(G,`${V()}( uv.x + stx, uv.y)`)}.r;\n\n\t\t\t\t\tcount+= ${R(G,`${V()}( uv.x - stx, uv.y - sty)`)}.r;\n\t\t\t\t\tcount+= ${R(G,`${V()}( uv.x    , uv.y - sty)`)}.r;\n\t\t\t\t\tcount+= ${R(G,`${V()}( uv.x + stx, uv.y - sty)`)}.r;\n\t\t\t\t\tfor (${b("p")} = 0; p < 6; p ++) {\t\t\t\t\n\t\t\t\t\t\tcount += ${R(G,`${V()}(uv.x + tx * ${d("poisson")}[p].x, uv.y + ty * ${d("poisson")}[p].y)`)}.r;\n\t\t\t\t\t\tcount += ${R(G,`${V()}(uv.x + tx * ${d("poisson")}[p].z, uv.y + ty * ${d("poisson")}[p].w)`)}.r;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (count > 0.0) {\n\t\t\t\t\t${F("aux")} ;\n\t\t\t\t\t${U("hit")}  = 0.0;\n\t\t\t\t\tfor (${b("halo")}  = 1; halo <= haloThickness ; halo++) {\t\t\n\t\t\t\t\t\ttx = ${U()}(halo) * ${d("h")};\n\t\t\t\t\t\tty = ${U()}(halo) * ${d("v")};\t\t\t\t\n\t\t\t\t\t\tfor (${b("p")} = 0; p < 6; p++) {\t\n\t\t\t\t\t\t\t${F("tex")}  = ${R(G,`${V()}(uv.x + tx * ${d("poisson")}[p].x, uv.y + ty * ${d("poisson")}[p].y)`)};\n\t\t\t\t\t\t\taux = ${P("GetHaloData","v4",[v(`${W("tex.r")}`),h("tex.w")])};\n\t\t\t\t\t\t\thaloColor += aux;\n                            if (aux.a > 0.0) {\n                                hit += 1.0;\n                            }\n\t\t\t\t\t\t\t${F("tex2")}  = ${R(G,`${V()}(uv.x + tx * ${d("poisson")}[p].z, uv.y + ty * ${d("poisson")}[p].w)`)};\n\t\t\t\t\t\t\taux = ${P("GetHaloData","v4",[v(`${W("tex2.r")}`),h("tex2.w")])};\n\t\t\t\t\t\t\thaloColor += aux;\n                            if (aux.a > 0.0) {\n                                hit += 1.0;\n                            }\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\thaloColor.a *= 0.08333333333 / fHaloThickness;\n\t\t\t\t\thaloColor.r /= max(hit, 1.0);\n\t\t\t\t\thaloColor.g /= max(hit, 1.0);\n\t\t\t\t\thaloColor.b /= max(hit, 1.0);\n\t\t\t\t}\t\t\t\n\t\t\t\treturn haloColor;\n            }\n\n            ${C("GetLineicAlpha","f",[g("isEdge")])}{\n                ${l?"\n                    return 0.8;\n                    ":"\n                    if (isEdge) {\n                        return 0.6;\n                    }\n                    return 0.8;\n                    "}\n            }\n\n            ${C("ComputePoliteColorAlpha","f",[f("highlightConfig","config"),g("isMarker"),g("isEdge"),g("back")])}{\n                if (isMarker || isEdge) {\n                    return ${P("GetLineicAlpha","f",[g("isEdge")])};\n                }\n                if (back) {\n                    return config.colorIntensity.y;\n                }\n                return config.colorIntensity.x;\n            }\n\n            ${C("ComputeHaloColorAlpha","f",[f("highlightConfig","config"),h("factor")])}{\n                return (0.6 * factor + 0.2) * config.colorIntensity.x;\n            }\n\n            ${m.getMainFragmentStart(t)}\n                // varying storage\n                ${V("screenUV")} = ${(n=>o.getVarying(n,o.ShaderStages.in))("vUv")};\n                ${F("fetched")} = ${F()}(0.0);\n                ${B?`\n                    fetched = ${R("tScene","screenUV")};\n                    `:""}\n                if (${d("empty")} == 0) {\n                    ${X} = fetched;\n                    ${m.getEarlyFragmentEnd()}\n                }\n\n                \n\t\t\t\t// init empty config\n\t\t\t\temptyConfig.color = ${z()}(0.0);\n\t\t\t\temptyConfig.colorIntensity = ${V()}(0.0, -1.0);\n\t\t\t\temptyConfig.outlineColor = ${z()}(0.0);\n\t\t\t\temptyConfig.lineicOutlineColor = ${z()}(0.0);\n\t\t\t\t//emptyConfig.lineicOutlineAlpha = 0.0;\n\t\t\t\temptyConfig.outlineAlpha = 0.0;\n\t\t\t\temptyConfig.outlineThickness = 0.0;\n\t\t\t\t//\n\t\t\t\t${F("center")} = ${R(G,"screenUV")};\n\t\t\t\t${z("finalColor")}  = ${z()}(0.0);\n                ${U("finalAlpha")}  = 0.0;\n                ${O?`        \n                ${b("qaAutomationID")}  = ${W("center.r")};\n                if (qaAutomationID > 0) {\n                    ${b("qaAutomationGeomID")} = ${W("center.w")};\n                    finalAlpha = 1.0;\n                    if (qaAutomationGeomID == 0) {\n                        finalColor = ${z()}(0.0,0.61,0.61);\n                    } else if (qaAutomationGeomID < 3) {\n                        if (qaAutomationGeomID == 2) {\n                            finalColor = ${z()}(1.0, 0.0, 0.0);\n                        } else {\n                            finalColor = ${z()}(0.0, 0.78, 0.78);\n                        }\n                    } else {\n                        finalColor = ${z()}(0.0,0.78,0.78);\n                    }\n                }\n            `:`\n                \n\t\t\t\t${N("forceHaloOn")}  = false;\n\t\t\t\t${N("forceOutlineOn")}  = false;\n\t\t\t\t${N("forceBasePostProOff")}  = false;\n\t\t\t\t${N("isMarker")}  = false;\n\t\t\t\t${N("isEdge")}  = false;\n                ${k?`\n\t\t\t\t\tforceBasePostProOff = ${W("center.w")} == 4 || ${W("center.w")} == 2;\n\t\t\t\t\tforceOutlineOn = forceBasePostProOff && center.b > 0.5;\n\t\t\t\t\t// Find point\n\t\t\t\t\tif (!forceBasePostProOff) {\n\t\t\t\t\t\tforceBasePostProOff = ${P("DoPoliteLineic","b",[D("center"),S("forceOutlineOn"),S("forceHaloOn"),S("isMarker"),v("4"),y("screenUV")])};\n\t\t\t\t\t}\n\t\t\t\t\t// Find edge\n\t\t\t\t\tif (!forceBasePostProOff) {\n\t\t\t\t\t\tforceBasePostProOff = ${P("DoPoliteLineic","b",[D("center"),S("forceOutlineOn"),S("forceHaloOn"),S("isEdge"),v("2"),y("screenUV")])};\t\t\t\t\t\t\n\t\t\t\t\t}\n                    `:""}\n                \n                ${s.struct({name:"config",structName:"highlightConfig"})} = ${P("GetHighlightConfig","highlightConfig",[h("center.r")])};\t\t\t\t\t\t\t\n\t\t\t\t// Outline detection\n\t\t\t\t${U("isOutline")}  = 8.0;\n\t\t\t\tif (config.outlineAlpha > -0.5 && !forceBasePostProOff) {\t\t\t\t\t\t\n\t\t\t\t\tisOutline = ${P("CheckIfOutlines","f",[_("center"),y("screenUV"),f("highlightConfig","config")])};\t\n\t\t\t\t}\n\t\t\t\tif (forceOutlineOn && config.outlineAlpha > -0.5) {\n                    finalColor = config.lineicOutlineColor.rgb;\n                    finalAlpha = ${P("GetLineicAlpha","f",[g("isEdge")])};\n\t\t\t\t} else if (isOutline < outlineCheck) {\n\t\t\t\t\t// outline\n                    finalColor = config.outlineColor.rgb;\n                    finalAlpha = config.outlineAlpha;\n\t\t\t\t} else {\n\t\t\t\t\t//  halo\n\t\t\t\t\tif (center.r == 0.0 && !forceBasePostProOff) {\t\t\t\n                        ${F("haloData")}  = ${P("ComputeHaloColor","v4",[y("screenUV")])};\n\t\t\t\t\t\tfinalColor = haloData.rgb;\n\t\t\t\t\t\tfinalAlpha = haloData.a;\n\t\t\t\t\t} else if (forceHaloOn) {\n                        ${b("index")} = ${W("center.r")};\n\t\t\t\t\t\t${F("lineicHaloData")}  = ${P("GetLineicHaloData","v4",[v("index")])};\n\t\t\t\t\t\tfinalColor = lineicHaloData.rgb;\n\t\t\t\t\t\tfinalAlpha = lineicHaloData.a;\n\t\t\t\t\t} else if (config.colorIntensity.x > 1e-6 || config.colorIntensity.y > 1e-6) {\n\t\t\t\t\t\tif (config.colorIntensity.y > -0.5) {\n                            // polite\n\t\t\t\t\t\t\tfinalAlpha = ${P("ComputePoliteColorAlpha","f",[f("highlightConfig","config"),g("isMarker"),g("isEdge"),g("center.b > 0.5")])};\n\t\t\t\t\t\t\tfinalColor = center.g * config.color.rgb;\n\t\t\t\t\t\t} else { \n                            // halo\t\t\n\t\t\t\t\t\t\tfinalAlpha = ${P("ComputeHaloColorAlpha","f",[f("highlightConfig","config"),h("center.g")])};\n\t\t\t\t\t\t\tfinalColor = config.color.rgb;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n            `}\n                \n\t\t\t\t// alpha blend\n\t\t\t\tfinalAlpha = min(finalAlpha, 1.0);            \n                ${U("fetchedFactor")} = (1.0 - finalAlpha) * fetched.a;\n\t\t\t\t${U("alpha")}  = finalAlpha + fetchedFactor;\n\t\t\t\t${X} = ${F()}((finalAlpha * finalColor + fetchedFactor * fetched.rgb)/max(alpha,1e-12), alpha);\n            ${m.getMainFragmentEnd(t)}\n        `;var Y,J;return{vertexShader:a,fragmentShader:Z}}),"Highlight");return{FinalBlending:new r(O,L,k),FinalMobileBlending:new r(O,L,E)}})),define("DS/ShaderBuilders/PostPro/GraphicsOptimizerShaderBuilders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PostPro/PostProUniformHandler","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/PostPro/PostProContext","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a,o,i,s){"use strict";const l=i.ParameterUtils,u=i.FunctionHandler,m=i.BridgeFunctions,c=n=>a.addUniform(n),$=n=>{var e={uniformName:n};return a.getUniform(e)},p=n=>l.parameterV3(n),d=n=>l.parameterV4(n),f=(n,e,t)=>u.declareFunction(n,e,t),h=(n,e,t)=>u.callFunction(n,e,t),v=(n=null,e=0)=>{var t={name:n,size:e};return s.int(t)},g=(n=null,e=0)=>{var t={name:n,size:e};return s.float(t)},x=(n=null,e=0)=>{var t={name:n,size:e};return s.vec2(t)},S=(n=null,e=0)=>{var t={name:n,size:e};return s.vec3(t)},y=(n=null,e=0)=>{var t={name:n,size:e};return s.vec4(t)},_=n=>o.addVarying(n),T=n=>o.getVarying(n,o.ShaderStages.in),D=n=>o.getVarying(n,o.ShaderStages.out),C=(n,e)=>{return m.sample2DTexture((t={uniformName:n},a.getTextureUniform(t)),e);var t};class P extends e{constructor(e=0){super(e),this.empty=0,this.texelSize=new n.Vector2}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform1f(r.empty,this.empty),t.uniform2f(r.texelSize,this.texelSize.x,this.texelSize.y)}fillUBO(n,e,t){super.fillUBO(n,e,t);const r=n.layout;n.setF(r.empty,this.empty),n.setV2(r.texelSize,this.texelSize)}clone(){var n=new P;return n.empty=this.empty,n}}function N(e){return`           \n            ${_({varyingName:"vUv",varyingType:"v2"})}\n\n            ${u.getMainVertexStart(e)}\n                ${D("vUv")} = uv.xy;\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(e)}\n            ${u.getMainVertexEnd(e)}\n        `}return{Pixels:[new r(new t((function(n,e){var t=e.customDefines;const r=o.getShaderOutput("out0");let a=`\n            \n            ${_({varyingName:"vUv",varyingType:"v2"})}\n            ${c({uniformName:"empty",uniformType:"f"})}\n\n            ${f("mod289","v4",[d("x")])}{\n                return x - floor(x * (1.0 / 289.0)) * 289.0;\n              }\n  \n              ${f("mod289","v3",[p("x")])}{\n                return x - floor(x * (1.0 / 289.0)) * 289.0;\n              }\n  \n              ${f("mod289","v2",[(i="x",l.parameterV2(i))])} {\n                return x - floor(x * (1.0 / 289.0)) * 289.0;\n              }\n  \n              ${f("permute","v3",[p("x")])}{\n                  ${S("value")}  = ((x*34.0)+1.0)*x;\n                  return ${h("mod289","v3",[p("value")])};\n              }\n  \n              ${f("permute","v4",[d("x")])}{\n                  ${y("value")}  = ((x*34.0)+1.0)*x;\n                  return ${h("mod289","v4",[d("value")])};\n              }\n  \n              ${f("taylorInvSqrt","v4",[d("r")])}{\n                  return 1.79284291400159 - 0.85373472095314 * r;\n              }\n  \n              ${f("snoise","f",[p("v")])}{\n  \n                  ${((n=null,e=0)=>{var t={name:n,size:e,constant:!0};return s.vec2(t)})("C")} = ${x()}(1.0/6.0, 1.0/3.0);\n                  ${((n=null,e=0)=>{var t={name:n,size:e};return s.vec4(t)})("D")} = ${y()}(0.0, 0.5, 1.0, 2.0);\n  \n                  ${S("i")}   = floor(v + dot(v, C.yyy) );\n                  ${S("x0")}  =   v - i + dot(i, C.xxx) ;\n  \n                  ${S("g")}  = step(x0.yzx, x0.xyz);\n                  ${S("l")}  = 1.0 - g;\n                  ${S("i1")}  = min( g.xyz, l.zxy );\n                  ${S("i2")}  = max( g.xyz, l.zxy );\n  \n                  ${S("x1")}  = x0 - i1 + C.xxx;\n                  // 2.0*C.x = 1/3 = C.y\n                  ${S("x2")}  = x0 - i2 + C.yyy; \n                  // -1.0+3.0*C.x = -0.5 = -D.y\n                  ${S("x3")}  = x0 - D.yyy;      \n  \n                  i = ${h("mod289","v3",[p("i")])};\n                  ${y("permutationAux")}  = i.z + ${y()}(0.0, i1.z, i2.z, 1.0 );\n                  permutationAux = ${h("permute","v4",[d("permutationAux")])} + i.y + ${y()}(0.0, i1.y, i2.y, 1.0 );\n                  permutationAux = ${h("permute","v4",[d("permutationAux")])} + i.x + ${y()}(0.0, i1.x, i2.x, 1.0 );\n                  ${y("permutation")}  = ${h("permute","v4",[d("permutationAux")])};\n  \n                  // 1.0/7.0\n                  ${g("n_")}  = 0.142857142857;\n                  ${S("ns")} = n_ * D.wyz - D.xzx;\n                  //  mod(permutation,7*7)\n                  ${y("j")} = permutation - 49.0 * floor(permutation * ns.z * ns.z);  \n  \n                  ${y("x_")}  = floor(j * ns.z);\n                  // mod(j,N)\n                  ${y("y_")}  = floor(j - 7.0 * x_ );    \n  \n                  ${y("x")}  = x_ *ns.x + ns.yyyy;\n                  ${y("y")}  = y_ *ns.x + ns.yyyy;\n                  ${y("h")}  = 1.0 - abs(x) - abs(y);\n  \n                  ${y("b0")}  = vec4( x.xy, y.xy );\n                  ${y("b1")}  = vec4( x.zw, y.zw );\n  \n                  ${y("s0")}  = floor(b0)*2.0 + 1.0;\n                  ${y("s1")}  = floor(b1)*2.0 + 1.0;\n                  ${y("sh")}  = -step(h, vec4(0.0));\n  \n                  ${y("a0")}  = b0.xzyw + s0.xzyw*sh.xxyy;\n                  ${y("a1")}  = b1.xzyw + s1.xzyw*sh.zzww;\n  \n                  ${S("p0")}  = ${S()}(a0.xy,h.x);\n                  ${S("p1")}  = ${S()}(a0.zw,h.y);\n                  ${S("p2")}  = ${S()}(a1.xy,h.z);\n                  ${S("p3")}  = ${S()}(a1.zw,h.w);\n  \n                  ${y("r")} = ${y()}(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3));\n                  ${y("norm")}  = ${h("taylorInvSqrt","v4",[d("r")])};\n                  p0 *= norm.x;\n                  p1 *= norm.y;\n                  p2 *= norm.z;\n                  p3 *= norm.w;\n  \n                  ${y("m")}  = max(0.6 - ${y()}(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), ${y()}(0.0));\n                  m = m * m;\n                  return 42.0 * dot( m*m, ${y()}( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );\n              }\n  \n\n            ${u.getMainFragmentStart(e)}\n                ${x("screenUV")} = ${T("vUv")};\n\n                if (${$("empty")} == 1.0) {\n                    ${u.getEarlyFragmentEnd()}\n                }\n                ${S("pos")}  = ${(n=>o.getShaderInput(n))("fragCoord")}.xyz;\n                ${S("seed")} = sin(pos);\n                ${g("a")} = 0.0;\n                for (${v("i")} = 0; i < ${t.LOOP_COUNT}; i++) {\n                    ${S("noiseIn")} = pos + ${g()}(i) * seed;\n                    a += ${h("snoise","f",[p("noiseIn")])};\n                }\n                ${r} = ${y()}(${S()}(a) / ${g()}(${t.LOOP_COUNT}), 1.0);           \n            ${u.getMainFragmentEnd(e)}\n        `;var i;return{vertexShader:N(e),fragmentShader:a}}),"PixelGO"),P,{LOOP_COUNT:128})],Textures:[new r(new t((function(n,e){var t=e.customDefines;const r=o.getShaderOutput("out0");let a=`\n            \n            ${_({varyingName:"vUv",varyingType:"v2"})}\n            ${function(){for(var n=`\n            \n            ${c({uniformName:"empty",uniformType:"f"})}\n            ${c({uniformName:"texelSize",uniformType:"v2"})}\n            `,e=0;e<8;e++)n=`\n                    ${n}\n                    ${c({uniformName:"tInput"+e,uniformType:"t2"})}\n                `;return n}()}\n\n\n            ${u.getMainFragmentStart(e)}\n                ${x("screenUV")} = ${T("vUv")};\n                ${x("size")} = ${$("texelSize")};\n\n                if (${$("empty")} == 1.0) {\n                    ${u.getEarlyFragmentEnd()}\n                }\n                ${function(){for(var n="",e=0;e<8;e++)n=`\n                    ${n}\n                    for (${v("i")} = 0; i < ${t.FETCH_COUNT}; i++) {\n                        screenUV = ${C(`tInput${e}`,`screenUV + 1e-2 * ${g()}(i) / size`)}.rg;\n                    }\n                `;return n}()}\n                ${r} = ${y()}(screenUV.xy, 0.0, 1.0);\n            ${u.getMainFragmentEnd(e)}\n        `;return{vertexShader:N(e),fragmentShader:a}}),"TextureGO"),P,{FETCH_COUNT:128},7)]}})),define("DS/ShaderBuilders/PostPro/SDFFontIterativeShaderBuilders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PostPro/PostProUniformHandler","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/PostPro/PostProContext","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a,o,i,s){"use strict";const l=i.ParameterUtils,u=i.FunctionHandler,m=i.BridgeFunctions,c=n=>a.addUniform(n),$=n=>{var e={uniformName:n};return a.getUniform(e)},p=n=>l.parameterV2(n),d=n=>l.parameterV4(n),f=(n=null,e=0)=>{var t={name:n,size:e};return s.float(t)},h=(n=null,e=0)=>{var t={name:n,size:e,constant:!0};return s.float(t)},v=(n=null,e=0)=>{var t={name:n,size:e};return s.vec2(t)},g=(n=null,e=0)=>{var t={name:n,size:e};return s.vec3(t)},x=(n=null,e=0)=>{var t={name:n,size:e};return s.vec4(t)},S=n=>o.addVarying(n),y=n=>o.getVarying(n,o.ShaderStages.in),_=n=>o.getVarying(n,o.ShaderStages.out),T=(n,e)=>{return m.sample2DTexture((t={uniformName:n},a.getTextureUniform(t)),e);var t};class D extends e{constructor(){super()}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i)}fillUBO(n,e,t){super.fillUBO(n,e,t)}clone(){return new D}}class C extends D{constructor(){super(),this.size=new n.Vector2(256,256),this.invSize=new n.Vector2(1/256,1/256)}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform2f(r.size,this.size.x,this.size.y),t.uniform2f(r.invSize,this.invSize.x,this.invSize.y)}fillUBO(n,e,t){super.fillUBO(n,e,t);const r=n.layout;n.setV2(r.size,this.size),n.setV2(r.invSize,this.invSize)}clone(){return new C}}class P extends e{constructor(){super(),this.tileMin=new n.Vector2(0,0),this.tileMax=new n.Vector2(64,64),this.realTileMax=new n.Vector2(64,646)}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform2f(r.tileMin,this.tileMin.x,this.tileMin.y),t.uniform2f(r.tileMax,this.tileMax.x,this.tileMax.y),t.uniform2f(r.realTileMax,this.realTileMax.x,this.realTileMax.y)}fillUBO(n,e,t){super.fillUBO(n,e,t);const r=n.layout;n.setV2(r.tileMax,this.tileMax),n.setV2(r.tileMin,this.tileMin),n.setV2(r.realTileMax,this.realTileMax)}clone(){return new P}}function N(e){return`           \n            ${S({varyingName:"vUv",varyingType:"v2"})}\n\n            ${u.getMainVertexStart(e)}\n                ${_("vUv")} = uv.xy;\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(e)}\n            ${u.getMainVertexEnd(e)}\n        `}return{SDFFontDisplay:new r(new t((function(n,e){e.customDefines;const t=o.getShaderOutput("out0");let r=`\n            \n            ${S({varyingName:"vUv",varyingType:"v2"})}\n            ${c({uniformName:"tInput",uniformType:"t2"})}\n\n            ${u.getMainFragmentStart(e)}\n                ${v("screenUV")} = ${y("vUv")};\n                ${f("dist")} = ${T("tInput","screenUV")}.r;\n                ${t} = ${x()}(${g()}(${a="10.0*dist",i="1.0",m.modulo(a,i)}), 1.0);           \n            ${u.getMainFragmentEnd(e)}\n        `;var a,i;return{vertexShader:N(e),fragmentShader:r}}),"SDFFontDisplay"),D,{}),SDFFontMerge:new r(new t((function(n,e){e.customDefines;const t=o.getShaderOutput("out0");let r=`\n            \n            ${S({varyingName:"vUv",varyingType:"v2"})}\n            ${c({uniformName:"tInput",uniformType:"t2"})}\n\n            ${u.getMainFragmentStart(e)}\n                ${v("screenUV")} = ${y("vUv")};\n\n                ${x("texel")} = ${T("tInput","screenUV")};\n                ${f("diff")} = length(texel.rg) - length(texel.ba);\n                diff = clamp(20.0 * diff, -1.0, 1.0);\n                diff = clamp(0.5 * diff + 0.5, 0.0, 1.0);\n                ${t} = ${x()}(${g()}(diff), 1.0);           \n            ${u.getMainFragmentEnd(e)}\n        `;return{vertexShader:N(e),fragmentShader:r}}),"SDFFontMerge"),D,{}),SDFFontSeed:new r(new t((function(n,e){e.customDefines;const t=o.getShaderOutput("out0");let r=`\n            \n            ${S({varyingName:"vUv",varyingType:"v2"})}\n            ${c({uniformName:"tInput",uniformType:"t2"})}\n\n            ${u.getMainFragmentStart(e)}\n                ${v("screenUV")} = ${y("vUv")};\n\n                ${x("texel")} = ${T("tInput","screenUV")};\n                if (texel.r > 0.99999) {\n                    ${t} = ${x()}(9999.0, 9999.0, 0.0, 0.0);   \n                } else {\n                    ${t} = ${x()}(0.0, 0.0, 9999.0, 9999.0);   \n                }        \n            ${u.getMainFragmentEnd(e)}\n        `;return{vertexShader:N(e),fragmentShader:r}}),"SDFFontSeed"),D,{}),SDFFontFlood:new r(new t((function(n,e){e.customDefines;const t=(n,e,t,r)=>{return a="ComputeDistance",o="v4",i=[p(n),p(`${v()}(${e}, ${t})`),d(r)],u.callFunction(a,o,i);var a,o,i},r=o.getShaderOutput("out0");let a=`\n            \n            ${S({varyingName:"vUv",varyingType:"v2"})}\n            ${c({uniformName:"tInput",uniformType:"t2"})}\n            ${c({uniformName:"invSize",uniformType:"v2"})}\n            ${c({uniformName:"size",uniformType:"v2"})}\n\n            ${i="ComputeDistance",s="v4",l=[p("uv"),p("offset"),d("bestSeed")],u.declareFunction(i,s,l)}{\n\n                ${v("newVec")}  = uv + offset;\n                ${x("newSeed")}  = ${T("tInput","newVec")};\n                ${x("returnSeed")} = bestSeed;\n                // if the new seed is not indeterminate distance\n                if (newVec.x >= 0.0 && newVec.x <= 1.0 && newVec.y >= 0.0 && newVec.y <= 1.0) { \n\n                    newSeed.r += offset.x;\n                    newSeed.g += offset.y;\n                    newSeed.b += offset.x;\n                    newSeed.a += offset.y;\n\n                    if (length(newSeed.rg) < length(returnSeed.rg)) {\n\n                        returnSeed.r = newSeed.r;\n                        returnSeed.g = newSeed.g;\n                    }\n\n                    if (length(newSeed.ba) < length(returnSeed.ba)) {\n\n                        returnSeed.b = newSeed.b;\n                        returnSeed.a = newSeed.a;\n                    }\n                }\n                return returnSeed;\n            }\n\n\n            ${u.getMainFragmentStart(e)}\n                ${v("screenUV")} = ${y("vUv")};\n\n                ${x("bestSeed")} = ${T("tInput","screenUV")};\n\n                ${v("delta")} = ${$("invSize")};\n\n                bestSeed = ${t("screenUV","-delta.x","-delta.y","bestSeed")};\n                bestSeed = ${t("screenUV","-delta.x","0.0","bestSeed")};\n                bestSeed = ${t("screenUV","-delta.x","delta.y","bestSeed")};\n\n                bestSeed = ${t("screenUV","0.0","-delta.y","bestSeed")};\n                bestSeed = ${t("screenUV","0.0","delta.y","bestSeed")};\n\n                bestSeed = ${t("screenUV","delta.x","-delta.y","bestSeed")};\n                bestSeed = ${t("screenUV","delta.x","0.0","bestSeed")};\n                bestSeed = ${t("screenUV","delta.x","delta.y","bestSeed")};\n\n                ${r} = bestSeed;\n            ${u.getMainFragmentEnd(e)}\n        `;var i,s,l;return{vertexShader:N(e),fragmentShader:a}}),"SDFFontFlood"),C,{}),SDFFontCompute:new r(new t((function(n,e){const t=!!e.customDefines.OUTSIDE,r=o.getShaderOutput("out0");let a=`\n            \n            ${S({varyingName:"vUv",varyingType:"v2"})}\n            ${c({uniformName:"tInput",uniformType:"t2"})}\n            ${c({uniformName:"invSize",uniformType:"v2"})}\n            ${c({uniformName:"size",uniformType:"v2"})}\n\n            ${h("SQRT2")} = 1.41421356;\n\n            ${u.getMainFragmentStart(e)}\n                ${v("screenUV")} = ${y("vUv")};\n\n                ${f("value")} = ${T("tInput","screenUV")}.r;\n\n                ${v("iSize")} = ${$("invSize")};\n                ${f("qv")} = iSize.x;\n                ${f("qd")} = SQRT2 * iSize.y;\n\n                ${f("lValue")}   = ${T("tInput",`${v()}(screenUV.x - iSize.x, screenUV.y)`)}.r + qv;\n                ${f("rValue")}   = ${T("tInput",`${v()}(screenUV.x + iSize.x, screenUV.y)`)}.r + qv;\n                ${f("bValue")}   = ${T("tInput",`${v()}(screenUV.x, screenUV.y - iSize.y)`)}.r + qv;\n                ${f("tValue")}   = ${T("tInput",`${v()}(screenUV.x, screenUV.y + iSize.y)`)}.r + qv;\n\n                ${f("tlValue")}  = ${T("tInput",`${v()}(screenUV.x - iSize.x, screenUV.y + iSize.y)`)}.r + qd;\n                ${f("trValue")}  = ${T("tInput",`${v()}(screenUV.x + iSize.x, screenUV.y + iSize.y)`)}.r + qd;\n                ${f("blValue")}  = ${T("tInput",`${v()}(screenUV.x - iSize.x, screenUV.y - iSize.y)`)}.r + qd;\n                ${f("brValue")}  = ${T("tInput",`${v()}(screenUV.x + iSize.x, screenUV.y - iSize.y)`)}.r + qd;\n\n                ${t?"\n                    if (screenUV.x - iSize.x > 0.0) { value = min(lValue, value); }\n                    if (screenUV.x + iSize.x < 1.0) { value = min(rValue, value); }\n                    if (screenUV.y - iSize.y > 0.0) { value = min(bValue, value); }\n                    if (screenUV.y + iSize.y < 1.0) { value = min(tValue, value); }\n    \n                    if (screenUV.x - iSize.x > 0.0 && screenUV.y + iSize.y < 1.0) { value = min(tlValue, value); }\n                    if (screenUV.x + iSize.x < 1.0 && screenUV.y + iSize.y < 1.0) { value = min(trValue, value); }\n                    if (screenUV.x - iSize.x > 0.0 && screenUV.y - iSize.y > 0.0) { value = min(blValue, value); }\n                    if (screenUV.x + iSize.x < 1.0 && screenUV.y - iSize.y > 0.0) { value = min(brValue, value); }\n    \n                    ":'\n                    // JBN10: what is inScreen4?? This code does not compile nor touch "value"\n                    lValue  = mix(1.0, lValue, inScreen4.x);\n                    rValue   = mix(1.0, rValue, inScreen4.y);\n                    bValue   = mix(1.0, bValue, inScreen4.z);\n                    tValue   = mix(1.0, tValue, inScreen4.w);\n    \n                    tlValue  = mix(1.0, tlValue, inScreen4.x * inScreen4.w);\n                    trValue  = mix(1.0, trValue, inScreen4.y * inScreen4.w);\n                    blValue  = mix(1.0, blValue, inScreen4.x * inScreen4.z);\n                    brValue  = mix(1.0, brValue, inScreen4.y * inScreen4.z);\n                    '}\n\n                ${r} = ${x()}(${g()}(value), 1.0);     \n            ${u.getMainFragmentEnd(e)}\n        `;return{vertexShader:N(e),fragmentShader:a}}),"SDFFontCompute"),C,{OUTSIDE:!1}),SDFFontDisplayResult:new r(new t((function(n,e){e.customDefines;const t=o.getShaderOutput("out0");let r=`\n            \n            ${S({varyingName:"vUv",varyingType:"v2"})}\n            ${c({uniformName:"tInput",uniformType:"t2"})}\n            ${c({uniformName:"invSize",uniformType:"v2"})}\n            ${c({uniformName:"size",uniformType:"v2"})}\n\n            ${h("SQRT2")} = 1.41421356;\n\n            ${((n=null,e=0)=>{var t={name:n,size:e,constant:!0};return s.vec2(t)})("halfVec2")} = ${v()}(0.5);\n\n            ${u.getMainFragmentStart(e)}\n                // Scale texcoords to range ([0,texw], [0,texh])\n                ${v("uv")} = ${y("vUv")} * ${$("size")};\n                ${v("iSize")} = ${$("invSize")};\n\n                // Compute texel-local (u,v) coordinates for the four closest texels\n                // Lower left corner of lower left texel\n                ${v("uv00")}  = floor(uv - halfVec2); \n                // Texel-local lerp blends [0,1]\n                ${v("uvlerp")}  = uv - uv00 - halfVec2;\n\n                // Perform explicit texture interpolation of distance value.\n                // This is required for the split RG encoding of the 8.8 fixed-point value,\n                // and as a bonus it works around the bad texture interpolation precision\n                // in at least some ATI hardware.\n\n                // Center st00 on lower left texel and rescale to [0,1] for texture lookup\n                ${v("st00")}  = (uv00 + halfVec2) * iSize;\n\n                // Compute distance value from four closest 8-bit RGBA texels\n                ${x("D00")}  = ${T("tInput","st00")};\n                ${x("D10")}  = ${T("tInput",`st00 + ${v()}(iSize.x, 0.0)`)};\n                ${x("D01")}  = ${T("tInput",`st00 + ${v()}(0.0, iSize.y)`)};\n                ${x("D11")}  = ${T("tInput",`st00 + ${v()}(iSize.x, iSize.y)`)};\n\n                // Restore the values for D from their 8.8 fixed point encoding in RG channels\n                ${v("D00_10")}  = ${v()}(D00.r, D10.r)*255.0-128.0 + ${v()}(D00.g, D10.g)*(255.0/256.0);\n                ${v("D01_11")}  = ${v()}(D01.r, D11.r)*255.0-128.0 + ${v()}(D01.g, D11.g)*(255.0/256.0);\n\n                // Interpolate along v\n                ${v("D0_1")}  = mix(D00_10, D01_11, uvlerp.y);\n                // Interpolate along u\n                ${f("D")}  = mix(D0_1.x, D0_1.y, uvlerp.x);\n\n                // Replacement for RSL's 'filterstep()', with fwidth() done right.\n                // 'threshold ' is constant , 'D ' is smoothly varying\n                ${f("threshold")} = 0.0;\n                ${f("afwidth")}  = 0.7 * length ( ${v()}(${m.dpdx("D")}, ${m.dpdy("D")}));\n                ${f("g")} = smoothstep (threshold - afwidth, threshold + afwidth, D);\n\n                ${t} = ${x()}(${g()}(g), 1.0);     \n            ${u.getMainFragmentEnd(e)}\n        `;return{vertexShader:N(e),fragmentShader:r}}),"SDFFontDisplayResult"),C,{}),SDFFontMergeTiles:new r(new t((function(n,e){e.customDefines;const t=o.getShaderOutput("out0");let r=`\n            \n            ${S({varyingName:"vUv",varyingType:"v2"})}\n            ${c({uniformName:"tInput",uniformType:"t2"})}\n            // offset\n            ${c({uniformName:"tileMin",uniformType:"v2"})}\n            // offset + tile size\n            ${c({uniformName:"tileMax",uniformType:"v2"})}\n            // offset + real size\n            ${c({uniformName:"realTileMax",uniformType:"v2"})}\n\n            ${u.getMainFragmentStart(e)}\n                ${v("screenUV")} = ${y("vUv")};\n                if (screenUV.x < ${$("tileMin")}.x) { \n                    discard; \n                }\n                ${v("tiledUV")}  = (screenUV - ${$("tileMin")}) / (${$("tileMax")} - ${$("tileMin")});\n                tiledUV.y = 1.0 - tiledUV.y;\n\n                ${t} = ${T("tInput","tiledUV")};           \n            ${u.getMainFragmentEnd(e)}\n        `;return{vertexShader:N(e),fragmentShader:r}}),"SDFFontMergeTiles"),P,{})}})),define("DS/ShaderBuilders/ShaderUtils/AttributeUtils",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/GPUFormats/VertexAttribute"],(function(n,e,t){"use strict";return{_context:null,_addAttribute:function({attributeName:e,attributeType:t,size:r=0,attributeCategory:a,locationName:o=null,checkName:i=!0,pdsfx:s=!1}){const l=(this._context.isWebGPU?n.ToWGSLTypes:n.ToGLSLTypes)[t];if(i&&"a"!==e[0]&&console.warn('Bad Practice: start the name of your attributes with "a"'),!l)return console.warn(`Invalid Operation: ${t} for ${e} is not a proper type`),"";if(0===r&&l.isArray)return console.warn(`Invalid Operation: ${t} for ${e} is not a proper array`),"";if(r>0&&!l.isArray)return console.warn(`Invalid Operation: ${t} for ${e} is can not be an array`),"";let u={type:t,locationName:o||null,size:r,dynamic:!0,pdsfx:s};if(u[a+"Attribute"]=!0,this._context.__attributes__[e]=u,this._context.isWebGPU)return"";const m=1===this._context.__features__.WebGLVersion?"attribute":"in";return r>0?`\n                        ${m} ${l.t} ${e}[${r}];\n                    `:`\n                    ${m} ${l.t} ${e};\n                `},addAttribute:function({attributeName:n,attributeType:e,size:t=0,locationName:r=null}){return this._addAttribute({attributeName:n,attributeType:e,locationName:r,size:t,attributeCategory:"core"})},addPDSFXAttribute:function({attributeName:n,attributeType:e,size:t=0}){return this._addAttribute({attributeName:"_IPCA"+n,attributeType:e,locationName:n,size:t,attributeCategory:"core",checkName:!1,pdsfx:!0})},addInstancingAttribute:function({attributeName:n,attributeType:e,size:t=0,locationName:r=null}){return this._addAttribute({attributeName:n,attributeType:e,locationName:r,size:t,attributeCategory:"instancing"})},addPDSFXInstancingAttribute:function({attributeName:n,attributeType:e,size:t=0}){return this._addAttribute({attributeName:"_IPCA"+n,attributeType:e,locationName:n,size:t,attributeCategory:"instancing",checkName:!1,pdsfx:!0})},getAttribute:function(n){return this._context.isWebGPU?"input."+n:n},addPDSFXCustomAttribute:function({attributeName:n,attributeType:e,geomLayoutGPU:t}){let r="_IPCA"+n,a=this._addAttribute({attributeName:r,attributeType:e,locationName:n,size:0,attributeCategory:"core",checkName:!1,pdsfx:!0});return this.setCustomAttribute({attributeName:r,geomLayoutGPU:t}),a},setCustomAttribute:function({attributeName:n,geomLayoutGPU:e}){if(!this._context.isWebGPU)return void console.error("setCustomAttribute can only be used in WebGPU");let t=!1;(e._attributes.get(n)||this._context.__attributes__[n])&&(this._context.__customAttributes__[n]={customBuffer:!1},t=!0);let r=this._context.__uniforms__;t?(this._context.__customAttributes__._geomLayoutGPU||null===e||(this._context.__customAttributes__._geomLayoutGPU=e),r[n]&&"ssbo"===r[n].type&&(this._context.__customAttributes__[n].customBuffer=!0)):console.error(`${n} is not an existing Vertex Attribute. Use addAttribute to create an attribute beforehand`)},getCustomAttribute:function(n,r){if(!this._context.isWebGPU)return console.error("Custom attributes are only supported on webgpu"),"SHADER_GENERATION_ERROR";function a(n,t){return`${r=`AttributeBuffer${n}`,e.getObjectStorageBuffer(r)}[index * ${(n=>{var t={uniformName:n};return e.getObjectUniform(t)})(`_Stride${n}`)} + ${t}]`;var r}let o=this._context.__customAttributes__[r],i=this._context.__customAttributes__._geomLayoutGPU;if(!i)return console.error("Geometry Layout is needed to generate custom attributes getter. Provide it to setCustomAttribute"),"SHADER_GENERATION_ERROR";if(o){r.startsWith("_IPCA")&&(r=r.slice(5));let e=i._attributes.get(r),o=!1;if(void 0===e)switch(o=!0,e={type:void 0,offset:0,bufferId:0},this._context.__attributes__[`_IPCA${r}`].type){case"v":e.type="float32x1";break;case"v2":e.type="float32x2";break;case"v3":e.type="float32x3";break;case"v4":e.type="float32x4"}let s=t[e.type],l=s.size;s.base!==e.type&&(l=t[s.base].size);let u="",m=["0.0","0.0","0.0","1.0"],c=s.components;switch("uv"===r&&(c=4),c){case 1:u="f32";break;case 2:u="vec2f";break;case 3:u="vec3f";break;case 4:u="vec4f"}let $="",p="",d=Math.floor(e.offset/Float32Array.BYTES_PER_ELEMENT);if(l<4){let t=e.offset%Float32Array.BYTES_PER_ELEMENT,r=s.normalized?" / 255.0":"",i=[],u=0;$=`var tmp_${n}: u32 = ${o?"0":`bitcast<u32>(${a(e.bufferId,d)})`};\n`,1===l?(t<=0&&u<s.components&&(i.push(`f32((tmp_${n} >> 0) & 0xFF)${r}`),u+=1),t<=1&&u<s.components&&(i.push(`f32((tmp_${n} >> 8) & 0xFF)${r}`),u+=1),t<=2&&u<s.components&&(i.push(`f32((tmp_${n} >> 16) & 0xFF)${r}`),u+=1),t<=3&&u<s.components&&(i.push(`f32((tmp_${n} >> 24) & 0xFF)${r}`),u+=1)):2===l?(t<=0&&u<s.components&&(i.push(`f32((tmp_${n} >> 0) & 0xFFFF)${r}`),u+=1),t<=2&&u<s.components&&(i.push(`f32((tmp_${n} >> 16) & 0xFFFF)${r}`),u+=1)):console.error("getCustomAttribute sizeof 3 bytes === 24bits is not yet supported"),p=i.join(",")}else{if(4!==l)return console.error(`TDU1: TODO: ${l} > 4 is not yet managed by customAttribute`),"SHADER_GENERATION_ERROR";p+=o?m[0]:`${a(e.bufferId,d)}`;for(let n=1;n<s.components;n++)p+=`, ${o?m[n]:a(e.bufferId,d+n)}`;for(let n=s.components;n<c;n++)p+=`, ${m[n]}`}return`${$}${n} = ${u}(${p})`}return console.error(`Calling getCustomAttribute on ${r} but is not a custom Attribute. Use setCustomAttribute before calling getCustomAttribute !`),"SHADER_GENERATION_ERROR"},_useUv2:function(n){return!!(n.specgloss||n.dspbr||n.pdsfxUseUv2||n.custom)&&n.useUV},_useUv3:function(n){return!!(n.specgloss||n.dspbr||n.pdsfxUseUv3||n.custom)&&n.useUV}}})),define("DS/ShaderBuilders/Commons/CoreShaders",["DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/AttributeUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a){"use strict";const o="",i=r.ParameterUtils,s=r.FunctionHandler,l=r.BridgeFunctions,u=(n,e)=>i.parameter(n,e),m=n=>i.parameterF(n),c=n=>i.parameterV2(n),$=n=>i.parameterV3(n),p=n=>i.parameterRefV3(n),d=n=>i.parameterM3(n),f=n=>i.parameterRefM3(n),h=n=>i.parameterV4(n),v=n=>i.parameterT2(n),g=(n,e,t)=>s.declareFunction(n,e,t),x=(n,e,t)=>s.callFunction(n,e,t),S=e=>n.addUniform(e),y=e=>{var t={uniformName:e};return n.getUniform(t)},_=e=>{var t={uniformName:e};return n.getTextureUniform(t)},T=e=>n.addGlobalUniform(e),D=e=>{var t={uniformName:e};return n.getGlobalUniform(t)},C=e=>n.addObjectUniform(e),P=e=>{var t={uniformName:e};return n.getObjectUniform(t)},N=(n=null)=>((n=null,e="")=>{var t={name:n,addressSpace:e};return a.bool(t)})(n,"private"),b=(n=null,e=0,t="")=>{var r={name:n,size:e,addressSpace:t};return a.float(r)},M=(n=null)=>b(n,0,"private"),U=(n=null,e=0,t="")=>{var r={name:n,size:e,addressSpace:t};return a.vec2(r)},w=(n=null)=>U(n,0,"private"),V=(n=null,e=0,t="")=>{var r={name:n,size:e,addressSpace:t};return a.vec3(r)},z=(n=null)=>V(n,0,"private"),F=(n=null,e=0,t="")=>{var r={name:n,size:e,addressSpace:t};return a.vec4(r)},I=(n=null)=>F(n,0,"private"),R=(n=null,e="")=>{var t={name:n,addressSpace:e};return a.mat3(t)},A=(n=null,e="")=>{var t={name:n,addressSpace:e};return a.mat4(t)},L=(n=null)=>A(n,"private"),B=n=>{var e={name:n,constant:!0};return a.vec2(e)},E=n=>{var e={name:n,constant:!0};return a.vec3(e)},k=n=>{var e={name:n,constant:!0};return a.vec4(e)},O=n=>t.addVarying(n),G=n=>t.getVarying(n,t.ShaderStages.in),H=n=>t.getVarying(n,t.ShaderStages.out),X=(n,e)=>l.sample2DTexture(n,e),W=n=>e.addAttribute(n),j=n=>e.addInstancingAttribute(n),q=n=>e.getAttribute(n),Z=(n,t)=>e.getCustomAttribute(n,t);return{Default_uniforms_declaration:function(n){return`\n            ${2===n.WebGLVersion?"uniform FrameUBO {\n                    mat4 viewMatrix;\n                    mat4 projectionMatrix;\n                    vec3 cameraPosition;\n                };\n                ":`\n                ${T({uniformName:"viewMatrix",uniformType:"m4"})} \n                ${T({uniformName:"projectionMatrix",uniformType:"m4"})} \n                ${T({uniformName:"cameraPosition",uniformType:"v3"})} \n                `}\n            ${C({uniformName:"_modelMatrixForDoubleGPU",uniformType:"m4",locationName:"modelMatrix"})} \n\t\t\t${L("modelMatrix")} ;\n\t\t\t${z("vertexLocalPosition")} ; \n            ${n.defaultInstancing?`\n                ${C({uniformName:"belowInstancingModelMatrix",uniformType:"m4"})} \n                ${L("multipliedDefaultInstancingMatrix")} ;               \n                ${O({varyingName:"multipliedDefaultInstancingMatrixX",varyingType:"v4"})}\n                ${O({varyingName:"multipliedDefaultInstancingMatrixY",varyingType:"v4"})}\n                ${O({varyingName:"multipliedDefaultInstancingMatrixZ",varyingType:"v4"})}\n                `:o}\n\t\t\t${I("dummyFragColor")} ;\n\t\t\t${z("lowPartModelTranslation")} ;\n            ${n.largeScale?`\n                ${L("modelViewMatrix")};\n                ${N("_modelViewMatrixSet")} = false;\n                ${g("getModelViewMatrix","m4",[])} {\n                    if (!_modelViewMatrixSet) {\n                        modelViewMatrix = ${D("viewMatrix")} * modelMatrix;\n                        _modelViewMatrixSet = true;\n                    }\n                    return modelViewMatrix;\n                }\n                `:`\n                ${C({uniformName:"modelViewMatrix",uniformType:"m4"})}\n                \n                ${g("getModelViewMatrix","m4",[])} {\n                    return ${P("modelViewMatrix")};\n                }\n                `}\n            `},normalMatrix_uniforms_declaration:function(n){return`\n                ${n.useNormalMatrix?`\n                    ${N("use_normal_matrix")}  = true;\n                    ${C({uniformName:"normalMatrix",uniformType:"m3"})}\n                    `:`\n                    ${N("use_normal_matrix")} = false;\n                    ${((n=null)=>R(n,"private"))("normalMatrix")} ;\n                    `}\n            `},double_emulation_utilities:function(n){return`\n            // http://andrewthall.org/papers/df64_qf128.pdf\n            ${g("quickTwoSum","v2",[m("a"),m("b")])}{\n                ${b("s")} = a + b;\n                ${b("e")} = b - (s-a);\n                return ${U()}(s,e);\n            }\n            \n            ${g("twoSumComp","v4",[c("a"),c("b")])}{\n                ${U("s")}  = a + b;\n                ${U("v")}  = s - a;\n                ${U("e")}  = (a - (s-v)) + (b-v);\n                return ${F()}(s.x,e.x,s.y,e.y);\n            }\n            \n            ${g("df64_add","v2",[c("a"),c("b")])}{\n                ${F("st")}  = ${x("twoSumComp","v4",[c("a"),c("b")])};\n                st.y += st.z;\n                ${U("auxQTS")} = ${x("quickTwoSum","v2",[m("st.x"),m("st.y")])};\n                st.x = auxQTS.x;\n                st.y = auxQTS.y;\n                st.y += st.w;\n                return  ${x("quickTwoSum","v2",[m("st.x"),m("st.y")])};\n            }\n\n        \n            ${g("_computeModelPosition","v3",[$("pos"),$("cameraPos"),$("lowPartCameraPos"),u("m4","matrix"),$("lowPartTranslation")])}{\n                // Model double translation\n               ${U("Tmx")}  = ${U()}(matrix[3][0],lowPartTranslation.x);\n               ${U("Tmy")}  = ${U()}(matrix[3][1],lowPartTranslation.y);\n               ${U("Tmz")}  = ${U()}(matrix[3][2],lowPartTranslation.z);\n                // View camera translation\n                ${U("Tcx")}  = -${U()}(cameraPos.x,lowPartCameraPos.x);\n                ${U("Tcy")}  = -${U()}(cameraPos.y,lowPartCameraPos.y);\n                ${U("Tcz")}  = -${U()}(cameraPos.z,lowPartCameraPos.z);\n                // Translation\n                ${U("Tx")}  = ${x("df64_add","v2",[c("Tmx"),c("Tcx")])};\n                ${U("Ty")}  = ${x("df64_add","v2",[c("Tmy"),c("Tcy")])};\n                ${U("Tz")}  = ${x("df64_add","v2",[c("Tmz"),c("Tcz")])};\n                // \n                ${F("worldPos")}  = matrix * ${F()}(pos.xyz,0.0);\n                return worldPos.xyz + ${V()}(Tx.x, Ty.x, Tz.x);\n            }\n        \n            ${g("_computeModelViewPosition","v3",[$("pos"),$("cameraPos"),$("lowPartCameraPos"),u("m4","matrix"),$("lowPartTranslation"),u("m4","viewMatrix")])}{\n               return (viewMatrix * ${F()}(${x("_computeModelPosition","v3",[$("pos"),$("cameraPos"),$("lowPartCameraPos"),u("m4","matrix"),$("lowPartTranslation")])}, 0.0)).xyz;\n            }\n            `},double_emulation:function(n){const e=x("getModelViewMatrix","m4",[]);return`\n                ${T({uniformName:"lowPartCameraPosition",uniformType:"v3"})} \n        \n                ${g("computeModelViewPosition","v4",[h("pos")])}{        \n                    ${F("posToUse")} = pos;                    \n                    ${n.defaultInstancing?`posToUse = (multipliedDefaultInstancingMatrix * ${F()}(posToUse.xyz, 1.0));`:o}   \n                    ${n.largeScale?`\n                        return  ${F()}(${x("_computeModelViewPosition","v3",[$("posToUse.xyz"),$(`${D("cameraPosition")}`),$(`${D("lowPartCameraPosition")}`),u("m4","modelMatrix"),$("lowPartModelTranslation"),u("m4",`${D("viewMatrix")}`)])},1.0);\n                        `:`return ${e} * posToUse;`}\n                }\n        \n                \n                ${g("computeModelViewPosition","v4",[$("pos")])}{ \n                    ${F("posV4")} =  ${F()}(pos, 1.0);\n                    return ${x("computeModelViewPosition","v4",[h("posV4")])};\n                }\n        \n                ${g("computeModelViewDirection","v4",[$("direction")])}{          \n                    ${V("directionToUse")} = direction;                    \n                    ${n.defaultInstancing?`directionToUse = (multipliedDefaultInstancingMatrix * ${F()}(directionToUse.xyz, 0.0)).xyz;`:o}   \n                    return ${e} *  ${F()}(directionToUse, 0.0);\n                }\n\n                ${g("computeModelPosition","v4",[h("iVec4")])}{\n                    ${F("res")}  = iVec4;                     \n                    ${n.defaultInstancing?`res = (multipliedDefaultInstancingMatrix * ${F()}(res.xyz, 1.0));`:o}      \n                    return modelMatrix * res;\n\t\t\t\t}\n                ${g("computeModelPosition","v4",[$("iVec3")])}{       \n                    return ${x("computeModelPosition","v4",[h("vec4(iVec3, 1.0)")])};\n\t\t\t\t}\n\n                ${g("computeModelDirection","v4",[$("direction")])}{          \n                    ${V("directionToUse")} = direction;                    \n                    ${n.defaultInstancing?`directionToUse = (multipliedDefaultInstancingMatrix * ${F()}(directionToUse.xyz, 0.0)).xyz;`:o}   \n                    return modelMatrix * ${F()}(directionToUse, 0.0);\n                }\n        \n                ${g("computeModelViewPositionCustom","v4",[h("pos"),u("m4","matrix"),$("lowPartTranslation")])}{     \n                   return  ${F()}(${x("_computeModelViewPosition","v3",[$("pos.xyz"),$(`${D("cameraPosition")}`),$(`${D("lowPartCameraPosition")}`),u("m4","matrix"),$("lowPartTranslation"),u("m4",`${D("viewMatrix")}`)])},1.0);\n                }\n        \n                ${g("computeModelViewPositionCustom","v4",[$("pos"),u("m4","matrix"),$("lowPartTranslation")])}{     \n                   return  ${F()}(${x("_computeModelViewPosition","v3",[$("pos.xyz"),$(`${D("cameraPosition")}`),$(`${D("lowPartCameraPosition")}`),u("m4","matrix"),$("lowPartTranslation"),u("m4",`${D("viewMatrix")}`)])},1.0);\n                }\n\n                ${g("computeModelViewDirectionCustom","v4",[$("direction"),u("m4","matrix")])}{         \n                    return ${D("viewMatrix")} * (matrix *  ${F()}(direction, 0.0));\n                }\n        \n                ${n.shadowMapEnabled?`\n                    ${g("computeShadowCoord","v4",[$("pos"),u("m4","shadowMat"),$("shadowCameraPos"),$("lowPartShadowCameraPos")])}{                      \n                        ${V("posToUse")} = pos;                    \n                        ${n.defaultInstancing?`posToUse = (multipliedDefaultInstancingMatrix * ${F()}(posToUse, 1.0)).xyz;`:o}   \n                        ${F("worldPos")} =  ${F()}(${x("_computeModelPosition","v3",[$("posToUse"),$("shadowCameraPos"),$("lowPartShadowCameraPos"),u("m4","modelMatrix"),$("lowPartModelTranslation")])},1.0);\n                       return shadowMat * worldPos;\n                    }\n                    `:o}\n            `},bumpmap_pars_fragment:function(n){if(!n.bumpMap)return o;const e=_("bumpMap");return`\n                ${S({uniformName:"bumpMap",uniformType:"t2"})} \n                ${S({uniformName:"bumpScale",uniformType:"f"})} \n\n                // Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\n                //\thttp://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\n\n                // Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n                ${g("dHdxy_fwd","v2",[c("uv")])}{\n                    ${U("dSTdx")}  = ${l.dpdx("uv")};\n                    ${U("dSTdy")}  = ${l.dpdy("uv")};\n\n                    ${b("Hll")}  = ${y("bumpScale")} * ${X(e,"uv")}.x;\n                    ${b("dBx")}  = ${y("bumpScale")} * ${X(e,"uv + dSTdx")}.x - Hll;\n                    ${b("dBy")}  = ${y("bumpScale")} * ${X(e,"uv + dSTdy")}.x - Hll;\n\n                    return ${U()}( dBx, dBy );\n\n                }\n\n                ${g("perturbNormalArb","v3",[$("surf_pos"),$("surf_norm"),c("dHdxy")])}{\n\n                    ${V("vSigmaX")}  = ${l.dpdx("surf_pos")};\n                    ${V("vSigmaY")}  = ${l.dpdy("surf_pos")};\n                    ${V("vN")}  = surf_norm;\t\t// normalized\n\n                    ${V("R1")}  = cross( vSigmaY, vN );\n                    ${V("R2")}  = cross( vN, vSigmaX );\n\n                    ${b("fDet")}  = dot( vSigmaX, R1 );\n\n                    ${V("vGrad")}  = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n                    return normalize( abs( fDet ) * surf_norm - vGrad );\n\n                }\n            `},normalmap_pars_fragment:function(n){return n.normalMap?`\n                ${S({uniformName:"normalMap",uniformType:"t2"})} \n                ${S({uniformName:"normalScale",uniformType:"v2"})} \n                \n                // Per-Pixel Tangent Space Normal Mapping\n                // http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n                ${g("perturbNormal2Arb","v3",[$("eye_pos"),$("surf_norm")])}{\n\n                    ${V("q0")}  = ${l.dpdx("eye_pos.xyz")};\n                    ${V("q1")}  = ${l.dpdy("eye_pos.xyz")};\n                    ${U("st0")}  = ${l.dpdx("uvToUse.xy")};\n                    ${U("st1")}  = ${l.dpdy("uvToUse.xy")};\n\n                    //Fallback for degenerate UV mappings.\n                    //== 0.0 if no direction for tangent\n                    ${b("alphaT")}  = step(0.00001, abs(st0.y) + abs(st1.y)); \n                    //== 0.0 if no direction for binorm\n                    ${b("alphaB")}   = step(0.00001, abs(st0.x) + abs(st1.x)); \n                    //== 0.0 if no direction for both\n                    ${b("alphaBT")}   = 1.0 - max(alphaB, alphaT);                 \n\n                    //If both vectors are null, set them to canonical basis;\n                    //If only one is null, set it to be perpendicular to the other one.\n                    //Do not change anything otherwise.\n\n                    st0.y = alphaT * st0.y - (1.0 - alphaT)*(alphaB * st1.x);\n                    st1.y = alphaT * st1.y + (1.0 - alphaT)*(alphaB * st0.x) + alphaBT;\n\n                    st0.x = alphaB * st0.x - (1.0 - alphaB)*(alphaT * st1.y) + alphaBT;\n                    st1.x = alphaB * st1.x + (1.0 - alphaB)*(alphaT * st0.y);\n\n                    ${V("S")}  = normalize(  q0 * st1.y - q1 * st0.y );\n                    ${V("T")}  = normalize( -q0 * st1.x + q1 * st0.x );\n                    ${V("N")}  = normalize( surf_norm );\n\n                    ${V("mapN")}  = ${X(_("normalMap"),"uvToUse")}.xyz * 2.0 - 1.0;\n                    mapN.x = ${y("normalScale")}.x * mapN.x;\n                    mapN.y = ${y("normalScale")}.y * mapN.y;\n                    ${n.normalMapFlipY?"mapN.y = - mapN.y;":o}\n\n                    ${R("tsn")}  = ${R()}( S, T, N );\n                    return normalize( tsn * mapN );\n\n                }\n            `:o},specularmap_pars_fragment:function(n){return n.specularMap?S({uniformName:"specularMap",uniformType:"t2"}):o},specularmap_fragment:function(n){return n.specularMap?`\n            ${U("specularUV")} =uvToUse;\n            ${F("texelSpecular")}  = ${X(_("specularMap"),"specularUV")};\n            ${b("specularStrength")}  = texelSpecular.r;\n            ${n.phong?`\n                if (${y("shininessInSpecMap")} > 0) {\n                    shininessValue = texelSpecular.a;\n                }\n                `:o}\n            `:`${b("specularStrength")}  = 1.0;`},large_scale_VS:function(n){return`\n            \n            modelMatrix = ${A()}(${P("_modelMatrixForDoubleGPU")});\n            lowPartModelTranslation = ${V()}(modelMatrix[0][3],modelMatrix[1][3],modelMatrix[2][3]);\n            modelMatrix[0][3] = 0.0;\n            modelMatrix[1][3] = 0.0;\n            modelMatrix[2][3] = 0.0;\n            ${n.defaultInstancing?`\n                multipliedDefaultInstancingMatrix = defaultInstancingMatrix * ${P("belowInstancingModelMatrix")};\n                ${H("multipliedDefaultInstancingMatrixX")} = ${F()}(multipliedDefaultInstancingMatrix[0].xyz, multipliedDefaultInstancingMatrix[3].x);\n                ${H("multipliedDefaultInstancingMatrixY")} = ${F()}(multipliedDefaultInstancingMatrix[1].xyz, multipliedDefaultInstancingMatrix[3].y);\n                ${H("multipliedDefaultInstancingMatrixZ")} = ${F()}(multipliedDefaultInstancingMatrix[2].xyz, multipliedDefaultInstancingMatrix[3].z);\n                `:o}\n            ${x("getModelViewMatrix","m4",[])};\n\n            `},large_scale_FS:function(n){return`\n            modelMatrix = ${A()}(${P("_modelMatrixForDoubleGPU")});\n            lowPartModelTranslation = ${V()}(modelMatrix[0][3],modelMatrix[1][3],modelMatrix[2][3]);\n            modelMatrix[0][3] = 0.0;\n            modelMatrix[1][3] = 0.0;\n            modelMatrix[2][3] = 0.0;\n            ${n.defaultInstancing?`\n                multipliedDefaultInstancingMatrix[0] = ${F()}(${G("multipliedDefaultInstancingMatrixX")}.xyz, 0.0);\n                multipliedDefaultInstancingMatrix[1] = ${F()}(${G("multipliedDefaultInstancingMatrixY")}.xyz, 0.0);\n                multipliedDefaultInstancingMatrix[2] = ${F()}(${G("multipliedDefaultInstancingMatrixZ")}.xyz, 0.0);\n                multipliedDefaultInstancingMatrix[3] = ${F()}(${G("multipliedDefaultInstancingMatrixX")}.w, ${G("multipliedDefaultInstancingMatrixY")}.w, ${G("multipliedDefaultInstancingMatrixZ")}.w, 1.0);\n                `:o}\n            `},rgba_packing_pars:function(n){return`\n\n            \n            ${g("packRGBA","v4",[m("value")])}{\n                ${b("clamped_value")} = min(value,0.9999999);//packing doesn't work on 1.0\n                ${k("bit_shift")}  = ${F()}( 255.0 * 255.0 * 255.0, 255.0 * 255.0, 255.0, 1.0 );\n                ${k("bit_mask")}   = ${F()}( 0.0, 1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0 );\n                ${F("res")}  = clamped_value * bit_shift;\n                res -= floor(res);\n                res -= res.xxyz * bit_mask;\n                return res;\n            }\n\n            ${g("unpackRGBA","f",[h("rgba")])}{\n\n\t\t\t\t${k("bit_shift")} = ${F()}( 1.0 / ( 255.0 * 255.0 * 255.0 ), 1.0 / ( 255.0 * 255.0 ), 1.0 / 255.0, 1.0 );\n\t\t\t\t${n.mobileDevice?`${b("unpack")}  = dot( floor(255.0 * rgba + 0.5) / 255.0, bit_shift );`:`${b("unpack")} = dot( rgba, bit_shift );`}\n\t\t\t\treturn unpack;\n\t\t\t}\n\n            ${g("packRGB","v3",[m("value")])}{\n                ${E("bit_shift")} = ${V()}(255.0 * 255.0, 255.0, 1.0 );\n                ${E("bit_mask")}  = ${V()}( 0.0, 1.0 / 255.0, 1.0 / 255.0 );\n                ${V("res")}  = value * bit_shift;\n                res -= floor(res);\n                res -= res.xxy * bit_mask;\n                return res;\n            }\n\n            ${g("unpackRGB","f",[$("rgb")])}{\n\n\t\t\t\t${E("bit_shift")} = ${V()}(1.0 / ( 255.0 * 255.0 ), 1.0 / 255.0, 1.0 );\n                ${n.mobileDevice?`${b("unpack")} = dot( floor(255.0 * rgb + 0.5) / 255.0, bit_shift );`:`${b("unpack")} = dot( rgb, bit_shift );`}\n\t\t\t\treturn unpack;\n\t\t\t}\n\n            ${g("packRG","v2",[m("value")])}{\n                ${B("bit_shift")} = ${U()}(255.0, 1.0 );\n                ${B("bit_mask")}  = ${U()}( 0.0, 1.0 / 255.0 );\n                ${U("res")}  = value * bit_shift;\n                res -= floor(res);\n                res -= res.xx * bit_mask;\n                return res;\n            }\n\n            ${g("unpackRG","f",[c("rg")])}{\n\n\t\t\t\t${B("bit_shift")} = ${U()}(1.0 / 255.0, 1.0 );\n                ${n.mobileDevice?`${b("unpack")} = dot( floor(255.0 * rg + 0.5) / 255.0, bit_shift );`:`${b("unpack")} = dot( rg, bit_shift );`}\n\t\t\t\treturn unpack;\n\t\t\t}\n\n            ${g("packForFloat16","v2",[m("toPackF16")])}{\n                ${b("converted")} = 2047.0 * toPackF16;\n                ${b("up")} = floor(converted);\n                ${b("down")} = floor((converted - up) * 2047.0);\n                return ${U()}(up, down);\n            }\n\n            ${g("unpackForFloat16","f",[c("packedF16")])}{\n                return (packedF16.x + packedF16.y / 2047.0) / 2047.0;\n            }\n\n            ${g("packForFloat8","v2",[m("toPackF8")])}{\n                ${b("converted")} = 255.0 * toPackF8;\n                ${b("up")} = floor(converted);\n                ${b("down")} = floor((converted - up) * 255.0);\n                return ${U()}(up, down);\n            }\n\n            ${g("unpackForFloat8","f",[c("packedF8")])}{\n                return (packedF8.x + packedF8.y / 255.0) / 255.0;\n            }\n            \n            `},math_utils_pars:function(n){return`\n\n                ${g("pow0","f",[m("iValue")])}{\n                    return 1.0;\n                }\n\n                ${g("pow1","f",[m("iValue")])}{\n                    return iValue;\n                }\n            \n                ${g("pow2","f",[m("iValue")])}{\n                    return iValue*iValue;\n                }\n\n                ${g("pow3","f",[m("iValue")])}{\n                    return  ${x("pow2","f",[m("iValue")])} * iValue;\n                }\n\n                ${g("pow4","f",[m("iValue")])}{\n                    ${b("tmp")}  = ${x("pow2","f",[m("iValue")])};\n                    return ${x("pow2","f",[m("tmp")])};\n                }\n\n                ${g("pow5","f",[m("iValue")])}{\n                    ${b("tmp")}  = ${x("pow4","f",[m("iValue")])};\n                    return tmp * iValue;\n                }\n\n                ${g("pow6","f",[m("iValue")])}{\n                    ${b("tmp")}  = ${x("pow2","f",[m("iValue")])};\n                    ${b("tmp2")}  = ${x("pow3","f",[m("tmp")])};\n                    return tmp2;\n                }\n\n                ${g("pow7","f",[m("iValue")])}{\n                    ${b("tmp")}  = iValue;\n                    ${b("tmp2")}  = ${x("pow6","f",[m("tmp")])};\n                    return tmp * tmp2;\n                }\n\n                ${g("pow8","f",[m("iValue")])}{\n                    ${b("tmp")}  = ${x("pow2","f",[m("iValue")])};\n                    ${b("tmp2")}  = ${x("pow4","f",[m("tmp")])};\n                    return tmp2;\n                }\n\n                ${g("pow9","f",[m("iValue")])}{\n                    ${b("tmp")}  = iValue;\n                    ${b("tmp2")}  = ${x("pow8","f",[m("tmp")])};\n                    return  tmp * tmp2;\n                }\n\n                ${g("pow10","f",[m("iValue")])}{\n                    ${b("tmp")}  = ${x("pow2","f",[m("iValue")])};\n                    ${b("tmp2")}  = ${x("pow5","f",[m("tmp")])};\n                    return tmp2;\n                }\n\n                ${g("pow11","f",[m("iValue")])}{\n                    ${b("tmp")}  = iValue;\n                    ${b("tmp2")}  = ${x("pow10","f",[m("tmp")])};\n                    return tmp * tmp2;\n                }\n\n                ${g("pow12","f",[m("iValue")])}{\n                    ${b("tmp")}  = ${x("pow2","f",[m("iValue")])};\n                    ${b("tmp2")}  = ${x("pow6","f",[m("tmp")])};\n                    return tmp2;\n                }\n\n                ${g("vNormalize","v2",[c("val")])}{\n                    ${b("len")}  = length(val);\n                    if ( len < 1e-6) {\n                        return ${U()}(0.0);\n                    }\n                    return val/len;\n                }\n\n                ${g("vNormalize","v3",[$("val")])}{\n                    ${b("len")}  = length(val);\n                    if ( len < 1e-6) {\n                        return ${V()}(0.0);\n                    }\n                    return val/len;\n                }\n\n                ${g("vNormalize","v4",[h("val")])}{\n                    ${b("len")}  = length(val);\n                    if ( len < 1e-6) {\n                        return ${F()}(0.0);\n                    }\n                    return val/len;\n                }\n            `},attribute_pars_vertex:function(n){if(n.WebGPU)throw"attribute_pars_vertex must not get called in webgpu";let t=n.useUV||n.usePointUV,r=e._useUv2(n),a=e._useUv3(n),o=n.needTangentBinormalVertex||n.needTangentBinormal&&!n.gpuTangentBinormal||n.pdsfxUseTangentBinormal,i=` \n\n                ${W({attributeName:"aPosition",attributeType:n.compressedVertices?n.useCompressionContext?"v4":"v2":"v3",locationName:"position"})}\n                ${W({attributeName:"aNormal",attributeType:n.compressedNormals?"f":"v3",locationName:"normal"})}\n\n            `;return o&&(i=`\n                    ${i}\n                    ${W({attributeName:"aTangent",attributeType:"v3",locationName:"tangent"})}\n                    ${W({attributeName:"aBinormal",attributeType:"v3",locationName:"binormal"})}\n                `),t&&(i=`\n                    ${i}\n                    ${W({attributeName:"aUv",attributeType:"v4",locationName:"uv"})}\n                `),r&&(i=`\n                    ${i}\n                    ${W({attributeName:"aUv2",attributeType:"v4",locationName:"uv2"})}\n                `),a&&(i=`\n                    ${i}\n                    //${W({attributeName:"aUv3",attributeType:"v4",locationName:"uv3"})}\n                `),n.dashedLine&&(i=n.cpuPattern?`\n                        ${i}\n                        ${W({attributeName:"aLinePixelDistance",attributeType:"v2",locationName:"linePixelDistance"})}\n                    `:`\n                        ${i}\n                        ${W({attributeName:"aLineDistance",attributeType:"v2",locationName:"lineDistance"})}\n                    `,n.worldSizePattern2&&(i=`\n                        ${i}\n                        ${W({attributeName:"aPatternStartEnd",attributeType:"v2",locationName:"patternStartEnd"})}\n                    `)),n.wideLine&&(i=`\n                    ${i}\n                    ${W({attributeName:"aSideExtrusion",attributeType:"f",locationName:"sideExtrusion"})}\n                    ${W({attributeName:"aPreviousPos",attributeType:"v3",locationName:"previousPos"})}\n\n                    ${W({attributeName:"aFollowingPos",attributeType:"v3",locationName:"followingPos"})}\n                `),(n.vertexColors||n.pdsfxUseVertexColors)&&(i=`\n                    ${i}\n                    ${W({attributeName:"aColor",attributeType:n.compressedColors?"v2":"v4",locationName:"color"})}\n                `),n.isMultiInstanced&&(i=`\n                    ${i}\n                    ${j({attributeName:"aInstanceId",attributeType:"f",locationName:"instanceId"})}\n                `),n.defaultInstancing&&(i=`\n                    ${i}\n                    ${j({attributeName:"aDefaultInstancingMatrix",attributeType:"m4",locationName:"defaultInstancingMatrix"})}\n                `),n.morphTargets&&(i=`\n                    ${i}\n                    ${W({attributeName:"aMorphTarget0",attributeType:"v3",locationName:"morphTarget0"})}\n\n                    ${W({attributeName:"aMorphTarget1",attributeType:"v3",locationName:"morphTarget1"})}\n\n                    ${W({attributeName:"aMorphTarget2",attributeType:"v3",locationName:"morphTarget2"})}\n\n                    ${W({attributeName:"aMorphTarget3",attributeType:"v3",locationName:"morphTarget3"})}\n                `,i=n.morphNormals?`\n                        ${i}\n                        ${W({attributeName:"aMorphNormal0",attributeType:"v3",locationName:"morphNormal0"})}\n\n                        ${W({attributeName:"aMorphNormal1",attributeType:"v3",locationName:"morphNormal1"})}\n\n                        ${W({attributeName:"aMorphNormal2",attributeType:"v3",locationName:"morphNormal2"})}\n                        ${W({attributeName:"aMorphNormal3",attributeType:"v3",locationName:"morphNormal3"})}\n                    `:`\n                        ${i}\n                        ${W({attributeName:"aMorphTarget4",attributeType:"v3",locationName:"morphTarget4"})}\n\n                        ${W({attributeName:"aMorphTarget5",attributeType:"v3",locationName:"morphTarget5"})}\n\n                        ${W({attributeName:"aMorphTarget6",attributeType:"v3",locationName:"morphTarget6"})}\n\n                        ${W({attributeName:"aMorphTarget7",attributeType:"v3",locationName:"morphTarget7"})}\n                    `),n.skinning&&(i=`\n                    ${i}\n                    ${W({attributeName:"aSkinIndex",attributeType:"v4",locationName:"skinIndex"})}\n                    ${W({attributeName:"aSkinWeight",attributeType:"v4",locationName:"skinWeight"})}\n                `),i},attribute_uniforms_pars_vertex:function(e){let t=`\n                \n                ${e.WebGPU?o:`${z("position")};`}\n                ${z("position_")};\n                // TBN\n                ${z("normal")};\n                ${z("tangent")};\n                ${z("binormal")};\n                // UV\n                ${I("uv")};\n                ${I("uv2")};\n                ${I("uv3")};\n                // Color\n                ${I("color")};\n            `;return e.dashedLine&&(t=`\n                    ${t}\n                    ${w("lineDistance")} ;\n                `,e.worldSizePattern2&&(t=`\n                        ${t}\n                        ${w("patternStartEnd")} ;\n                    `)),e.wideLine&&(t=`\n                    ${t}\n                    ${M("sideExtrusion")};\n\n                    ${z("previousPos")} ;\n\n                    ${z("followingPos")} ;\n                `),e.compressedVertices&&(t=e.useCompressionContext?`\n                        ${t}\n                        ${n.addObjectUniform({uniformName:"compressionContext",uniformType:"t2"})}\n                        ${n.addObjectUniform({uniformName:"ccSize",uniformType:"f"})}\n                    `:`\n                        ${t}\n                        ${n.addObjectUniform({uniformName:"offsetVector",uniformType:"v3"})}\n                        ${n.addObjectUniform({uniformName:"quantizedVector",uniformType:"v3"})}\n                    `),e.isMultiInstanced&&(t=`\n                    ${t}\n                    ${M("instanceId")};\n                `),e.defaultInstancing&&(t=`\n                    ${t}\n                    ${L("defaultInstancingMatrix")};\n                `),e.morphTargets&&(t=`\n                    ${t}\n                    ${z("morphTarget0")};\n\n                    ${z("morphTarget1")};\n\n                    ${z("morphTarget2")};\n\n                    ${z("morphTarget3")};\n                `,t=e.morphNormals?`\n                        ${t}\n                        ${z("morphNormal0")};\n\n                        ${z("morphNormal1")};\n\n                        ${z("morphNormal2")};\n\n                        ${z("morphNormal3")};\n                    `:`\n                        ${t}\n                        ${z("morphTarget4")};\n\n                        ${z("morphTarget5")};\n\n                        ${z("morphTarget6")};\n\n                        ${z("morphTarget7")};\n                    `),e.skinning&&(t=`\n                    ${t}\n                    ${I("skinIndex")};\n                    ${I("skinWeight")};\n                `),t},attribute_vertex:function(t){var r="\n            ";let a=!0,i=!0,s=t.useUV||t.usePointUV,l=e._useUv2(t),u=e._useUv3(t),g=!0,S=!0,y=!0,_=!0,T=!0,D=!0,C=!0,N={};if(t.WebGPU){const n=t.shaderIO.attribute;N=t.shaderContext.__customAttributes__||{},a=!!n.aPosition||!!N.position,i=!!n.aNormal||!!N.aNormal,y=!!n.aTangent,_=!!n.aBinormal,g=!!n.aMorphTarget0||!!N.aMorphTarget0,S=!!n.aMorphNormal0||!!N.aMorphNormal0,T=!!n.aLinePixelDistance||!!N.aLinePixelDistance,D=!!n.aLineDistance||!!N.aLinePixelDistance,C=!!n.aColor,s=s&&(!!n.aUv||!!N.uv),l=l&&(!!n.aUv2||!!N.aUv2),u=u&&(!!n.aUv3||!!N.aUv3)}var b,M;return t.useCompressionContext?(r=`\n                ${r}\n                ${V("quantized")};\n                ${V("offset")};\n                ${R("localMatrix")};\n                ${x("fetchContext","",[m(`${q("aPosition")}.w`),v(`${b="compressionContext",M={uniformName:b},n.getObjectTextureUniform(M)}`),m(`${P("ccSize")}`),p("quantized"),p("offset"),f("localMatrix")])};\n                position_ = ${x("decodePosition","v3",[h(`${q("aPosition")}`),$("quantized"),$("offset")])};\n                `,t.WebGPU||(r=`${r}\n                        position = position_;\n                    `),i&&(r=`\n                        ${r=t.oct16Normals?`\n                            ${r}\n                            normal = ${x("decodeOct16Normal","v3",[m(`${q("aNormal")}`)])};\n                        `:`\n                            ${r}\n                            normal = ${x("decodeOct24Normal","v3",[m(`${q("aNormal")}`)])};\n                        `}\n                        normal = ${x("rotateNormal","v3",[$("normal"),d("localMatrix")])};\n                    `)):(t.compressedVertices?r=`\n                            ${r}\n                            position_ = ${x("decodePosition","v3",[c(`${q("aPosition")}`),$(`${P("quantizedVector")}`),$(`${P("offsetVector")}`)])};\n                        `:a&&(r=`\n                                ${r}\n                                ${N.position?Z("position_","position"):"position_ = "+q("aPosition")};\n                            `),t.WebGPU||(r=`\n                        ${r}\n                        position = position_;\n                    `),i&&(r=t.compressedNormals?t.oct16Normals?`\n                            ${r}\n                            normal = ${x("decodeOct16Normal","v3",[m(`${q("aNormal")}`)])};\n                            `:`\n                            ${r}\n                            normal = ${x("decodeOct24Normal","v3",[m(`${q("aNormal")}`)])};\n                            `:`\n                            ${r}\n                            normal = ${N.aNormal?Z(i):q("aNormal")};\n                        `)),s&&(r=t.compressedUVs?`\n                        ${r}             \n                        uv = ${F()}(${x("decodeUV","v3",[c(`${q("aUv")}.xy`)])}, 0.0);\n                        ${l?`\n                            uv2 = ${F()}(${x("decodeUV","v3",[c(`${q("aUv2")}.xy`)])}, 0.0);\n                            `:o}                  \n                        ${u?`\n                            uv3 = ${F()}(${x("decodeUV","v3",[c(`${q("aUv3")}.xy`)])}, 0.0);\n                            `:o}\n                        `:`\n                        ${r}\n                        ${N.uv?Z("uv","uv"):"uv = "+q("aUv")};\n                        ${l?`\n                            uv2 = ${N.aUv2?Z(l):q("aUv2")};\n                            `:o}\n                        ${u?`\n                            uv3 = ${N.aUv3?Z(u):q("aUv3")};\n                            `:o}\n                        `),C&&(t.vertexColors||t.pdsfxUseVertexColors)&&(r=t.compressedColors?`\n                        ${r}  \n                        color = ${x("decodeColor","v4",[c(q("aColor"))])};               \n                    `:`\n                        ${r}                 \n                        color = ${q("aColor")};\n                    `),(t.needTangentBinormalVertex||t.needTangentBinormal&&!t.gpuTangentBinormal||t.pdsfxUseTangentBinormal)&&(r=`\n                    ${r}    \n                    ${y?`tangent = ${q("aTangent")};`:o}\n                    ${_?`binormal = ${q("aBinormal")};`:o}           \n                `),t.dashedLine&&(t.cpuPattern?T&&(r=`   \n                            ${r}   \n                            lineDistance = ${N.aLinePixelDistance?Z(T):q("aLinePixelDistance")};\n                        `):D&&(r=`    \n                        ${r}      \n                        lineDistance = ${N.aLineDistance?Z(D):q("aLineDistance")};\n                    `),t.worldSizePattern2&&(r=`\n                        ${r}\n                        patternStartEnd = ${q("aPatternStartEnd")};\n                    `)),t.wideLine&&(r=`\n                    ${r}\n                    sideExtrusion = ${q("aSideExtrusion")};\n                    previousPos = ${q("aPreviousPos")};\n                    followingPos = ${q("aFollowingPos")};\n                `),t.isMultiInstanced&&(r=`\n                    ${r}\n                    instanceId = ${q("aInstanceId")};\n                `),t.defaultInstancing&&(r=t.WebGPU?`\n                        ${r}\n                        defaultInstancingMatrix = mat4x4f(\n                            ${q("aDefaultInstancingMatrix_c0")},\n                            ${q("aDefaultInstancingMatrix_c1")},\n                            ${q("aDefaultInstancingMatrix_c2")},\n                            ${q("aDefaultInstancingMatrix_c3")},\n                        );\n                    `:`\n                        ${r}\n                        defaultInstancingMatrix = ${q("aDefaultInstancingMatrix")};\n                    `),t.morphTargets&&g&&(r=`\n                    ${r}\n                    morphTarget0 = ${N.aMorphTarget0?Z(g):q("aMorphTarget0")};\n                    morphTarget1 = ${N.aMorphTarget1?Z(g):q("aMorphTarget1")};\n                    morphTarget2 = ${N.aMorphTarget2?Z(g):q("aMorphTarget2")};\n                    morphTarget3 = ${N.aMorphTarget3?Z(g):q("aMorphTarget3")};\n                `,r=t.morphNormals&&S?`\n                        ${r}\n                        morphNormal0 = ${N.aMorphNormal0?Z(S):q("aMorphNormal0")};\n                        morphNormal1 = ${N.aMorphNormal1?Z(S):q("aMorphNormal1")};\n                        morphNormal2 = ${N.aMorphNormal2?Z(S):q("aMorphNormal2")};\n                        morphNormal3 = ${N.aMorphNormal3?Z(S):q("aMorphNormal3")};\n                    `:`\n                        ${r}\n                        morphTarget4 = ${q("aMorphTarget4")};\n                        morphTarget5 = ${q("aMorphTarget5")};\n                        morphTarget6 = ${q("aMorphTarget6")};\n                        morphTarget7 = ${q("aMorphTarget7")};\n                    `),t.skinning&&(r=`\n                    ${r}\n                    skinIndex = ${q("aSkinIndex")};\n                    skinWeight = ${q("aSkinWeight")};\n                `),r}}})),define("DS/ShaderBuilders/GaussianSplatShaderBuilder",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/AttributeUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils"],(function(n,e,t,r,a){"use strict";const o=n=>a.addVarying(n),i=n=>a.getShaderOutput(n);let s=function(e,a){return e.WebGPU?`\n            ${s={bufferName:"splatIndex2",bufferType:"array<u32>",readOnly:!0},t.addStorageBuffer(s)}\n            ${t.addUniform({uniformName:"centersTextureSize",uniformType:"v2"})}\n            ${t.addUniform({uniformName:"centersRGTexture",uniformType:"tu2"})}\n            ${t.addUniform({uniformName:"covariancesTextureSize",uniformType:"v2"})}\n            ${t.addUniform({uniformName:"covariancesBATexture",uniformType:"t2"})}\n            ${t.addUniform({uniformName:"focal",uniformType:"v2"})}\n            ${t.addUniform({uniformName:"basisViewport",uniformType:"v2"})}\n            ${o({varyingName:"myvColor",varyingType:"v4"})}\n            ${o({varyingName:"myvPosition",varyingType:"v2"})}\n\n            const encodeNorm4 = vec4f(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0);\n            const mask4: vec4u = vec4u(u32(0x000000FF), u32(0x0000FF00), u32(0x00FF0000), u32(0xFF000000));\n            const shift4: vec4u = vec4u(0, 8, 16, 24);\n            fn uintToRGBAVec (u: u32) -> vec4f {\n               var urgba: vec4u = mask4 & vec4u(u);\n               urgba = urgba >> shift4;\n               var rgba: vec4f = vec4f(urgba) * encodeNorm4;\n               return rgba;\n            }\n\n            var<private> g_instanceIndex: u32;\n            fn getDataUV(input: VertexInput, stride: u32, offset: u32, dimensions: vec2u) -> vec2u {\n                var d: u32 = (${(n=>t.getStorageBuffer(n))("splatIndex2")}[g_instanceIndex] * stride + offset);\n                var samplerUV: vec2u = vec2u(d % dimensions.x, d / dimensions.x);\n\n                return samplerUV;\n            }\n\n            @vertex\n            fn vertex_main(input: VertexInput, @builtin(instance_index) instanceIndex: u32) -> VertexOutput {\n                var out: VertexOutput;\n                g_instanceIndex = instanceIndex;\n\n                var vPosition: vec2f = input.aPosition.xy;\n\n                var centersRG: vec4u = textureLoad(centersRGTexture, getDataUV(input, 1, 0, vec2u(material_uniforms.centersTextureSize)), 0);\n                var splatCenter: vec3f = vec3f(0) + bitcast<vec3f>(centersRG.xyz);\n\n                var vColor: vec4f = uintToRGBAVec(centersRG.a);\n\n                var viewCenter: vec4f = getModelViewMatrix() * vec4f(splatCenter, 1.0);\n                var clipCenter: vec4f = global_uniforms.projectionMatrix * viewCenter;\n                var clip: f32 = 1.2 * clipCenter.w;\n                if (clipCenter.z < -clip || clipCenter.x < -clip || clipCenter.x > clip || clipCenter.y < -clip || clipCenter.y > clip) {\n                    ${i("position")} = vec4f(0.0, 0.0, 2.0, 1.0); \n                    return out;\n                }\n\n                var ndcCenter: vec3f = clipCenter.xyz / clipCenter.w;\n\n                var cov_0: vec2f = textureLoad(covariancesBATexture, getDataUV(input, 3, 0, vec2u(material_uniforms.covariancesTextureSize)), 0).rg;\n                var cov_1: vec2f = textureLoad(covariancesBATexture, getDataUV(input, 3, 1, vec2u(material_uniforms.covariancesTextureSize)), 0).rg;\n                var cov_2: vec2f = textureLoad(covariancesBATexture, getDataUV(input, 3, 2, vec2u(material_uniforms.covariancesTextureSize)), 0).rg;\n\n                var cov1: vec4f = vec4f(cov_0, cov_1);\n                var cov2BA: vec4f = vec4f(cov_2, 0.0, 0.0);\n                // vec4 cov1 = vec4(1e-5,-1e-5,6e-6,2e-5);\n                // vec4 cov2BA = vec4(-2e-5,8e-5,0.0,0.0);\n\n                var Vrk: mat3x3f  = mat3x3f(\n                    cov1.x, cov1.y, cov1.z,\n                    cov1.y, cov1.w, cov2BA.x,\n                    cov1.z, cov2BA.x, cov2BA.y\n                );\n                var s: f32 = 1.0 / (viewCenter.z * viewCenter.z);\n                var J: mat3x3f = mat3x3f(\n                    material_uniforms.focal.x / viewCenter.z, 0., -(material_uniforms.focal.x * viewCenter.x) * s,\n                    0., material_uniforms.focal.y / viewCenter.z, -(material_uniforms.focal.y * viewCenter.y) * s,\n                    0., 0., 0.\n                );\n                var mV4: mat4x4f = getModelViewMatrix();\n                // 4x4 -> (3x3 and transpose) in one easy step\n                var W: mat3x3f = mat3x3f(\n                    vec3f(mV4[ 0 ].x, mV4[ 1 ].x, mV4[ 2 ].x),\n                    vec3f(mV4[ 0 ].y, mV4[ 1 ].y, mV4[ 2 ].y),\n                    vec3f(mV4[ 0 ].z, mV4[ 1 ].z, mV4[ 2 ].z)\n                );\n                var T: mat3x3f = W * J;\n                var cov2Dm: mat3x3f = transpose(T) * Vrk * T;\n                cov2Dm[0][0] += 0.3;\n                cov2Dm[1][1] += 0.3;\n                var cov2Dv: vec3f = vec3f(cov2Dm[0][0], cov2Dm[0][1], cov2Dm[1][1]);\n                var a: f32 = cov2Dv.x;\n                var d: f32 = cov2Dv.z;\n                var b: f32 = cov2Dv.y;\n                var D: f32 = a * d - b * b;\n                var trace: f32 = a + d;\n                var traceOver2: f32 = 0.5 * trace;\n                var term2: f32 = sqrt(max(0.1, traceOver2 * traceOver2 - D));\n                var eigenValue1: f32 = traceOver2 + term2;\n                var eigenValue2: f32 = traceOver2 - term2;\n                var transparentAdjust: f32 = step(1.0 / 255.0, vColor.a);\n                eigenValue2 = eigenValue2 * transparentAdjust;\n                var eigenVector1: vec2f = normalize(vec2f(b, eigenValue1 - a));\n                var eigenVector2: vec2f = vec2f(eigenVector1.y, -eigenVector1.x);\n                var basisVector1: vec2f = eigenVector1 * sqrt(8.0) * sqrt(eigenValue1);\n                var basisVector2: vec2f = eigenVector2 * sqrt(8.0) * sqrt(eigenValue2);\n\n                var ndcOffset: vec2f = vec2f(vPosition.x * basisVector1 + vPosition.y * basisVector2) * material_uniforms.basisViewport * 2.0;\n                vPosition *= sqrt(8.0);\n                ${i("position")} = vec4(ndcCenter.xy + ndcOffset, ndcCenter.z, 1.0);\n                out.myvColor = vColor;\n                out.myvPosition = vPosition;\n\n                return out;\n            }`:2===n.WebGLVersion?""+r.addInstancingAttribute({attributeName:"aSplatIndex",attributeType:"f"})+t.addUniform({uniformName:"centersTextureSize",uniformType:"v2"})+t.addUniform({uniformName:"covariancesTextureSize",uniformType:"v2"})+t.addUniform({uniformName:"covariancesBATexture",uniformType:"t2"})+t.addUniform({uniformName:"centersRGTexture",uniformType:"tu2"})+t.addUniform({uniformName:"focal",uniformType:"v2"})+t.addUniform({uniformName:"basisViewport",uniformType:"v2"})+"\n\n            varying vec4 myvColor;\n            varying vec2 myvPosition;\n\n            vec4 vColor;\n            vec2 vPosition;\n\n            vec2 getDataUV(in int stride, in int offset, in vec2 dimensions) {\n                vec2 samplerUV = vec2(0.0, 0.0);\n                float d = float(int(aSplatIndex) * stride + offset) / dimensions.x;\n                samplerUV.y = float(floor(d)) / dimensions.y;\n                samplerUV.x = fract(d);\n                return samplerUV;\n            }\n\n            mat3 transposeMat3( const in mat3 m ) {\n                mat3 tmp;\n                tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n                tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n                tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n                return tmp;\n            }\n\n            const vec4 encodeNorm4 = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0);\n            const uvec4 mask4 = uvec4(uint(0x000000FF), uint(0x0000FF00), uint(0x00FF0000), uint(0xFF000000));\n            const uvec4 shift4 = uvec4(0, 8, 16, 24);\n            vec4 uintToRGBAVec (uint u) {\n               uvec4 urgba = mask4 & u;\n               urgba = urgba >> shift4;\n               vec4 rgba = vec4(urgba) * encodeNorm4;\n               return rgba;\n            }\n\n            void main() {\n                vPosition = aPosition.xy;\n\n                uvec4 centersRG = texture2D(centersRGTexture, getDataUV(1, 0, centersTextureSize));\n                vec3 splatCenter = uintBitsToFloat(uvec3(centersRG.rgb));\n                vColor = uintToRGBAVec(centersRG.a);\n\n                vec4 viewCenter = getModelViewMatrix() * vec4(splatCenter, 1.0);\n                vec4 clipCenter = projectionMatrix * viewCenter;\n\n                float clip = 1.2 * clipCenter.w;\n                if (clipCenter.z < -clip || clipCenter.x < -clip || clipCenter.x > clip || clipCenter.y < -clip || clipCenter.y > clip) {\n                    gl_Position = vec4(0.0, 0.0, 2.0, 1.0);\n                    return;\n                }\n\n                vec3 ndcCenter = clipCenter.xyz / clipCenter.w;\n\n                // Compute ndcOffset from covariance\n                vec2 cov_0 = texture2D(covariancesBATexture, getDataUV(3, 0, covariancesTextureSize)).rg;\n                vec2 cov_1 = texture2D(covariancesBATexture, getDataUV(3, 1, covariancesTextureSize)).rg;\n                vec2 cov_2 = texture2D(covariancesBATexture, getDataUV(3, 2, covariancesTextureSize)).rg;\n\n                vec4 cov1 = vec4(cov_0, cov_1);\n                vec4 cov2BA = vec4(cov_2, 0.0, 0.0);\n                // vec4 cov1 = vec4(1e-5,-1e-5,6e-6,2e-5);\n                // vec4 cov2BA = vec4(-2e-5,8e-5,0.0,0.0);\n\n                mat3 Vrk = mat3(\n                    cov1.x, cov1.y, cov1.z,\n                    cov1.y, cov1.w, cov2BA.x,\n                    cov1.z, cov2BA.x, cov2BA.y\n                );\n                float s = 1.0 / (viewCenter.z * viewCenter.z);\n                mat3 J = mat3(\n                    focal.x / viewCenter.z, 0., -(focal.x * viewCenter.x) * s, 0., focal.y / viewCenter.z, -(focal.y * viewCenter.y) * s, 0., 0., 0.\n                );\n                mat3 W = transposeMat3(mat3(getModelViewMatrix()));\n                mat3 T = W * J;\n                mat3 cov2Dm = transposeMat3(T) * Vrk * T;\n                cov2Dm[0][0] += 0.3;\n                cov2Dm[1][1] += 0.3;\n                vec3 cov2Dv = vec3(cov2Dm[0][0], cov2Dm[0][1], cov2Dm[1][1]);\n                float a = cov2Dv.x;\n                float d = cov2Dv.z;\n                float b = cov2Dv.y;\n                float D = a * d - b * b;\n                float trace = a + d;\n                float traceOver2 = 0.5 * trace;\n                float term2 = sqrt(max(0.1, traceOver2 * traceOver2 - D));\n                float eigenValue1 = traceOver2 + term2;\n                float eigenValue2 = traceOver2 - term2;\n                float transparentAdjust = step(1.0 / 255.0, vColor.a);\n                eigenValue2 = eigenValue2 * transparentAdjust;\n                vec2 eigenVector1 = normalize(vec2(b, eigenValue1 - a));\n                vec2 eigenVector2 = vec2(eigenVector1.y, -eigenVector1.x);\n                vec2 basisVector1 = eigenVector1 * sqrt(8.0) * sqrt(eigenValue1);\n                vec2 basisVector2 = eigenVector2 * sqrt(8.0) * sqrt(eigenValue2);\n                vec2 ndcOffset = vec2(vPosition.x * basisVector1 + vPosition.y * basisVector2) * basisViewport * 2.0;\n\n                vPosition *= sqrt(8.0);\n\n                gl_Position = vec4(ndcCenter.xy + ndcOffset, ndcCenter.z, 1.0);\n\n                myvColor = vColor;\n                myvPosition = vPosition;\n            }\n        ":"\n            "+r.addInstancingAttribute({attributeName:"aSplatIndex",attributeType:"f"})+t.addUniform({uniformName:"centersTextureSize",uniformType:"v2"})+t.addUniform({uniformName:"covariancesTextureSize",uniformType:"v2"})+t.addUniform({uniformName:"centersRGTexture",uniformType:"t2"})+t.addUniform({uniformName:"covariancesBATexture",uniformType:"t2"})+t.addUniform({uniformName:"focal",uniformType:"v2"})+t.addUniform({uniformName:"basisViewport",uniformType:"v2"})+"\n\n            varying vec4 myvColor;\n            varying vec2 myvPosition;\n\n            vec4 vColor;\n            vec2 vPosition;\n\n            vec2 getDataUV(in int stride, in int offset, in vec2 dimensions) {\n                vec2 samplerUV = vec2(0.0, 0.0);\n                float d = float(int(aSplatIndex) * stride + offset) / dimensions.x;\n                samplerUV.y = float(floor(d)) / dimensions.y;\n                samplerUV.x = fract(d);\n                return samplerUV;\n            }\n\n            mat3 transposeMat3( const in mat3 m ) {\n                mat3 tmp;\n                tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n                tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n                tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n                return tmp;\n            }\n\n            void main() {\n                vPosition = aPosition.xy;\n\n                vec4 centersRG = texture2D(centersRGTexture, getDataUV(1, 0, centersTextureSize));\n                vec3 splatCenter = centersRG.rgb;\n\n                vec4 viewCenter = getModelViewMatrix() * vec4(splatCenter, 1.0);\n                vec4 clipCenter = projectionMatrix * viewCenter;\n\n                float clip = 1.2 * clipCenter.w;\n                if (clipCenter.z < -clip || clipCenter.x < -clip || clipCenter.x > clip || clipCenter.y < -clip || clipCenter.y > clip) {\n                    gl_Position = vec4(0.0, 0.0, 2.0, 1.0);\n                    return;\n                }\n\n                vec3 ndcCenter = clipCenter.xyz / clipCenter.w;\n\n                // Compute ndcOffset from covariance\n                vec4 cov1 = texture2D(covariancesBATexture, getDataUV(2, 0, covariancesTextureSize));\n                vec4 cov2BA = texture2D(covariancesBATexture, getDataUV(2, 1, covariancesTextureSize));\n                // vec4 cov1 = vec4(1e-5,-1e-5,6e-6,2e-5);\n                // vec4 cov2 = vec4(-2e-5,8e-5,0.0,0.0);\n\n                float rg = centersRG.a;\n                vec2 rg_unpacked = vec2(1.0, 255.0)* rg;\n                rg_unpacked = fract(rg_unpacked);\n                rg_unpacked -= rg_unpacked.xy * (1.0/255.0);\n                vColor = vec4(rg_unpacked.x, rg_unpacked.y, cov2BA.b, cov2BA.a);\n\n                mat3 Vrk = mat3(\n                    cov1.x, cov1.y, cov1.z,\n                    cov1.y, cov1.w, cov2BA.x,\n                    cov1.z, cov2BA.x, cov2BA.y\n                );\n                float s = 1.0 / (viewCenter.z * viewCenter.z);\n                mat3 J = mat3(\n                    focal.x / viewCenter.z, 0., -(focal.x * viewCenter.x) * s, 0., focal.y / viewCenter.z, -(focal.y * viewCenter.y) * s, 0., 0., 0.\n                );\n                mat3 W = transposeMat3(mat3(getModelViewMatrix()));\n                mat3 T = W * J;\n                mat3 cov2Dm = transposeMat3(T) * Vrk * T;\n                cov2Dm[0][0] += 0.3;\n                cov2Dm[1][1] += 0.3;\n                vec3 cov2Dv = vec3(cov2Dm[0][0], cov2Dm[0][1], cov2Dm[1][1]);\n                float a = cov2Dv.x;\n                float d = cov2Dv.z;\n                float b = cov2Dv.y;\n                float D = a * d - b * b;\n                float trace = a + d;\n                float traceOver2 = 0.5 * trace;\n                float term2 = sqrt(max(0.1, traceOver2 * traceOver2 - D));\n                float eigenValue1 = traceOver2 + term2;\n                float eigenValue2 = traceOver2 - term2;\n                float transparentAdjust = step(1.0 / 255.0, vColor.a);\n                eigenValue2 = eigenValue2 * transparentAdjust;\n                vec2 eigenVector1 = normalize(vec2(b, eigenValue1 - a));\n                vec2 eigenVector2 = vec2(eigenVector1.y, -eigenVector1.x);\n                vec2 basisVector1 = eigenVector1 * sqrt(8.0) * sqrt(eigenValue1);\n                vec2 basisVector2 = eigenVector2 * sqrt(8.0) * sqrt(eigenValue2);\n                vec2 ndcOffset = vec2(vPosition.x * basisVector1 + vPosition.y * basisVector2) * basisViewport * 2.0;\n\n                vPosition *= sqrt(8.0);\n\n                gl_Position = vec4(ndcCenter.xy + ndcOffset, ndcCenter.z, 1.0);\n\n                myvColor = vColor;\n                myvPosition = vPosition;\n            }\n        ";var s};return new e((function(n,e){e.isDeferredMaterial;let t=s(e),r=function(n,e){return n.WebGPU?`\n            ${o({varyingName:"myvColor",varyingType:"v4"})}\n            ${o({varyingName:"myvPosition",varyingType:"v2"})}\n            @fragment\n            fn fragment_main(input: FragmentInput) -> FragmentOutput {\n                var out: FragmentOutput;\n\n                var A: f32 = -dot(input.myvPosition, input.myvPosition) * 0.5;\n                if (A < -4.0) {\n                    discard;\n                }\n                var opacity: f32 = exp(A) * (input.myvColor.a);\n\n                var vColor: vec3f = pow(input.myvColor.rgb, vec3f(2.2));\n                ${i("out0")} = vec4f(vColor, opacity);\n\n                return out;\n            }`:`\n            precision highp float;\n\n            varying vec4 myvColor;\n            varying vec2 myvPosition;\n\n            void main() {\n                float A = -dot(myvPosition, myvPosition) * 0.5;\n                if (A < -4.0) {\n                    discard;\n                }\n                float opacity = exp(A) * (myvColor.a);\n                vec3 vColor = pow(myvColor.rgb, vec3(2.2));\n                ${i("out0")} = vec4(vColor, opacity);\n            }\n        `}(e);return{vertexShader:t,fragmentShader:r}}))})),define("DS/ShaderBuilders/ParticleBasicShaderBuilder",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils","DS/ShaderBuilders/ShaderUtils/AttributeUtils"],(function(n,e,t,r,a,o,i){"use strict";const s="",l=a.ParameterUtils,u=a.FunctionHandler,m=a.BridgeFunctions,c=n=>l.parameterV3(n),$=(n,e,t)=>u.callFunction(n,e,t),p=n=>t.addUniform(n),d=n=>{var e={uniformName:n};return t.getUniform(e)},f=n=>t.addObjectUniform(n),h=n=>{var e={uniformName:n};return t.getObjectUniform(e)},v=n=>t.addObjectStorageBuffer(n),g=n=>t.getObjectStorageBuffer(n),x=n=>{var e={uniformName:n};return t.getHighFrequencyUniform(e)},S=(n,e)=>e.highFrequencyColors?x(n):d(n),y=(n=null,e=0)=>{var t={name:n,size:e};return o.vec2(t)},_=(n=null,e=0)=>{var t={name:n,size:e};return o.vec3(t)},T=(n=null,e=0)=>{var t={name:n,size:e};return o.vec4(t)},D=n=>r.addVarying(n),C=n=>r.getVarying(n,r.ShaderStages.out),P=n=>r.getShaderInput(n),N=n=>r.getBuiltin(n,r.ShaderStages.out);let b=function(e,a){let i=n._ShaderChunk,l=n._DeferredShaderChunk,f=`                      \n            ${l._debug_common_pars_fragment(e)}\n            ${i.PDSFX_Color_pars_fragment(e)}\n            ${p({uniformName:"size",uniformType:"f"})}\n            ${e.WebGPU?`\n                ${p({uniformName:"scale",uniformType:"f"})}\n                ${p({uniformName:"hasSymbol",uniformType:"f"})}\n                ${p({uniformName:"myViewportSize",uniformType:"v2"})}\n                ${D({varyingName:"screenSpacePos",varyingType:"v2"})}\n                `:s}\n            ${i.clip_pars_fragment(e)}\n\t\t\t${i.color_pars_fragment(e)}\n            ${n._DefaultShaderChunk.viewposition_lineic_pars_fragment(e)}\n            ${i.map_pars_fragment(e)}\n            ${i.fog_pars_fragment(e)}\n\t\t\t${l.oit_pars_fragment(e)}\n\t\t\t${i.postprocess_pars_fragment(e)}\n\t\t\t${a?`\n                ${l.depth_pars_fragment(e)}\n                ${l.picking_pars_fragment(e)}\n                ${l.picking_instancing_pars_fragment(e)}\n                ${l.highlight_pars_fragment(e)}\n                ${l.gpupos_pars_fragment(e)}\n                `:s}\n        `,h=`   \n                ${_("diffuseToUse")}  = ${S("diffuse",e)}.rgb;\n                ${((n=null)=>{var e={name:n};return o.float(e)})("opacityToUse")}  = ${S("opacity",e)};\n                ${e.selectionMaterial?"opacityToUse = 1.0;":s}\n\t\t\t\t${i.color_fragment(e)}\n                if(${S("diffuse",e)}.w > 0.5) {\n                    diffuseToUse = ${S("diffuse",e)}.rgb;\n                }\n                ${e.PDSFX?`\n                    ${i.PDSFX_start_fragment(e)}\n                    INTERNAL_backup_size = ${d("size")};\n                    ${i.PDSFX_uv_fragment(e)}\n                    ${i.PDSFX_Color_backup_fragment(e)}\n\t\t\t\t    ${$("ComputeCommonValues",null,[])}; \n                    ${i.PDSFX_discard_fragment(e)}\n                    ${i.PDSFX_Color_fragment(e)}\n                    ${i.PDSFX_viewPosition_fragment(e)}\n                    `:s}\n                ${e.map?`\n                    ${y("pointTexCoord")} = ${e.usePointUV?`\n                        ${v="vUv",r.getVarying(v,r.ShaderStages.in)}.xy;\n                        `:`\n                        ${y()}(gl_PointCoord.x, 1.0 - gl_PointCoord.y);\n                        `}\n                    ${T("texelColor")} = ${m.sample2DTexture((n=>{var e={uniformName:n};return t.getTextureUniform(e)})("map"),"pointTexCoord")};\n\n                    ${e.gammaInput&&!e.mapHDR?`\n                        ${_("convertedColor")} = ${$("convertToLinear","v3",[c("texelColor.rgb")])};\n                        texelColor.r = convertedColor.r;\n                        texelColor.g = convertedColor.g;\n                        texelColor.b = convertedColor.b;\n                        `:s}\n                    if(${S("diffuse",e)}.w < 0.5) {\n                        diffuseToUse *= texelColor.rgb;\n                    }\n                    ${e.selectionMaterial&&!e.alphaTest?"\n                        if (texelColor.a < 1e-2) {\n                            discard;\n                        }\n                        ":s}\n                    opacityToUse *= texelColor.a;\n                    `:s}\n                ${(n=>r.getShaderOutput(n))("out0")} = ${T()}( diffuseToUse, opacityToUse );\n\n                ${n._DefaultShaderChunk.viewposition_lineic_fragment(e)}\n                ${i.clip_fragment(e)}\n\t\t\t\t${i.alphatest_fragment(e)}\n\n                ${i.postprocess_fragment(e)}\n                ${i.linear_to_gamma_fragment(e)}\n\n\t\t\t\t${i.PDSFX_end_fragment(e)}\n\t\t\t\t${i.fog_fragment(e)}\n\t\t\t\t${i.backgroundviewmode_lowlight_fragment(e)}\n                ${l._debug_common_lineic_fragment(e)}\n                ${l.oit_fragment_point(e)}\n\t\t\t\t${a?`\n                    ${l.depth_fragment(e)}\n                    ${l.picking_fragment(e)}\n                    ${l.picking_instancing_fragment(e)}\n                    ${l.highlight_fragment_point(e)}\n                    ${l.lineic_normal_fragment(e)}\n                    ${l.lineic_normal_depth_fragment(e)}\n                    ${l.gpupos_fragment(e)}\n                    `:s}\n                \n        `;var v;return`\n            ${f}\n            ${u.getMainFragmentStart(e)}\n                ${h}\n            ${u.getMainFragmentEnd(e)}\n        `},M=function(e,r,a){let o=n._ShaderChunk,m=n._DeferredShaderChunk;e.WebGPU&&(a._attributes.get("position")&&i.setCustomAttribute({attributeName:"position",geomLayoutGPU:a}),a._attributes.get("uv")&&i.setCustomAttribute({attributeName:"uv",geomLayoutGPU:a}));let S=`\n\n            ${p({uniformName:"size",uniformType:"f"})}\n            ${p({uniformName:"scale",uniformType:"f"})}\n            ${e.WebGPU?`\n                // offset in index buffer \n                ${y={uniformName:"startIndex",uniformType:"i"},t.addHighFrequencyUniform(y)}\n                ${f({uniformName:"haveIndexBuffer",uniformType:"i"})}\n                // Is the index buffer in 32 bits ?\n                ${f({uniformName:"isIndexBuffer32Bits",uniformType:"i"})}\n                // Vertex Pulling buffers\n                ${v({bufferName:"IndexBuffer",bufferType:"array<u32>",readOnly:!0})}\n                ${p({uniformName:"myViewportSize",uniformType:"v2"})}\n                \n                // Vertex Attributes aNormal and aUv use the same GPU Buffer\n                // We generate only the default vertex buffer binding in this case\n                ${f({uniformName:"_Stride0",uniformType:"i"})}\n                ${v({bufferName:"AttributeBuffer0",bufferType:"array<f32>",readOnly:!0})}\n\n                ${(n=>t.addGlobalUniform(n))({uniformName:"pixelSize",uniformType:"v2"})}\n\n                ${D({varyingName:"screenSpacePos",varyingType:"v2"})}\n                `:s}\n\n\n            ${o.clip_pars_vertex(e)}\n            ${o.color_pars_vertex(e)}\n            ${n._DefaultShaderChunk.viewposition_lineic_pars_vertex(e)}\n            ${o.fog_pars_vertex(e)}\n\n            ${o.map_pars_vertex(e)}\n\n            ${m.oit_pars_vertex(e)}\n            ${r?`\n                ${m.depth_pars_vertex(e)}\n                ${m.picking_pars_vertex(e)}\n                ${m.picking_instancing_pars_vertex(e)}\n                ${m.highlight_pars_vertex(e)}\n                ${m.gpupos_pars_vertex(e)}\n                `:s}\n        `;var y;let _="";var b;e.WebGPU?e.vertexColors&&(_+=`\n                var tmp: u32 = bitcast<u32>(${g("AttributeBuffer0")}[index * ${h("_Stride0")} + 3]);\n                color = vec4f(f32((tmp >> 0) & 0xFF) / 255.0, f32((tmp >> 8) & 0xFF) / 255.0, f32((tmp >> 16) & 0xFF) / 255.0, f32((tmp >> 24) & 0xFF) / 255.0);\n                ${C("vVertexColor")} = ${T()}(\n                    ${$("GetVertexColorMult","v3",[c("color.rgb")])}, \n                    ${$("GetVertexAlphaMult","f",[(b="color.a",l.parameterF(b))])}\n                );\n                `,e.gammaInput&&(_+=`${C("vVertexColor")} *= ${C("vVertexColor")};`)):_=o.color_vertex(e);let M=e.WebGPU?`let cstPoints = array(\n                vec2f(-1, -1),\n                vec2f( 1, -1),\n                vec2f(-1,  1),\n                vec2f(-1,  1),\n                vec2f( 1, -1),\n                vec2f( 1,  1),\n              );\n\n              let pos = cstPoints[${P("vertexIndex")}];\n              let pointPos = vec4f(pos * wgpuPointSize * 0.5 * ${(n=>{var e={uniformName:n};return t.getGlobalUniform(e)})("pixelSize")}, 0, 0);\n              ${C("screenSpacePos")} = (((${N("position")}.xy / ${N("position")}.w) + 1) / 2) * ${d("myViewportSize")};\n              ${C("screenSpacePos")}.y = ${d("myViewportSize")}.y - ${C("screenSpacePos")}.y;\n              ${N("position")} = ${N("position")} + pointPos;\n\n              ${C("vUv")} = vec4f(pos * 0.5 + 0.5, 1.0, 1.0);\n            `:s,U=`\n            ${o.PDSFX_start_particle_vertex(e)}\n            ${o.PDSFX_start_vertex(e)}\n            ${o.map_varying_set_vertex(e)}\n            ${o.position_vertex(e)}\n            ${_}\n            ${o.default_vertex(e)}\n            ${o.PDSFX_point_size_vertex(e)}\n            ${n._DefaultShaderChunk.viewposition_lineic_vertex(e)}\n            ${o.clip_vertex(e)}\n            ${o.fog_vertex(e)}\n\n            ${m.oit_vertex_point(e)}\n            ${r?`\n                ${m.depth_vertex(e)}\n                ${m.picking_vertex(e)}\n                ${m.picking_instancing_vertex(e)}\n                ${m.highlight_vertex(e)}\n                ${m.gpupos_vertex(e)}\n                `:s}\n\n            ${e.PDSFX?o.PDSFX_end_vertex(e,M):M}\n        `,w="";return e.WebGPU&&(w=`\n                // Pull data\n                var index: i32 = 0;\n                if (${h("isIndexBuffer32Bits")} == 1) {\n                    index = select(i32(${P("instanceIndex")}), i32(${g("IndexBuffer")}[${P("instanceIndex")} + u32(${x("startIndex")})]), ${h("haveIndexBuffer")} == 1);\n                } else {\n                    if (${h("haveIndexBuffer")} == 1) {\n                        // Fetch the lower or higher endian of the Uint32 value, to get the two indices packed as Uint16 inside it\n                        let oldIndex: u32 = ${P("instanceIndex")} + u32(${x("startIndex")});\n                        let uint16Index: u32 = oldIndex >> 1; // divide by 2 to get the correct index\n                        index = select(i32(${g("IndexBuffer")}[uint16Index] & 0x0000FFFF), i32((${g("IndexBuffer")}[uint16Index] & 0xFFFF0000) >> 16), (oldIndex & 1) == 1); // Check if even or odd to get the correct word\n                    } else {\n                        index = i32(${P("instanceIndex")});\n                    }\n                }`),`\n            ${S}\n            ${u.getMainVertexStart(e,w)}\n                ${U}\n            ${u.getMainVertexEnd(e)}\n        `};return new e((function(n,e,t,r){let a=e.isDeferredMaterial,o=b(e,a);return{vertexShader:M(e,a,r),fragmentShader:o}}))})),define("DS/ShaderBuilders/Commons/DefaultShaders",["DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r){"use strict";const a="",o=n.ParameterUtils,i=n.FunctionHandler,s=n.BridgeFunctions,l=n=>r.dereference(n),u=(n,e)=>o.parameter(n,e),m=n=>o.parameterB(n),c=n=>o.parameterI(n),$=n=>o.parameterV2(n),p=n=>o.parameterV3(n),d=n=>o.parameterInOutV3(n),f=n=>o.parameterRefV3(n),h=n=>o.parameterV4(n),v=n=>o.parameterT2(n),g=(n,e,t)=>i.declareFunction(n,e,t),x=(n,e,t)=>i.callFunction(n,e,t),S=n=>{var t={uniformName:n};return e.getGlobalUniform(t)},y=n=>{var t={uniformName:n};return e.getObjectUniform(t)},_=(n,t)=>t.mappingFromMatApp?(n=>e.addHighFrequencyUniform(n))(n):(n=>e.addUniform(n))(n),T=(n,t)=>t.mappingFromMatApp?(n=>{var t={uniformName:n};return e.getHighFrequencyUniform(t)})(n):(n=>{var t={uniformName:n};return e.getUniform(t)})(n),D=n=>t.addVarying(n),C=n=>t.getVarying(n,t.ShaderStages.in),P=n=>t.getVarying(n,t.ShaderStages.out),N=n=>t.getShaderInput(n),b=(n=null)=>{var e={name:n};return r.float(e)},M=(n=null)=>{var e={name:n};return r.vec2(e)},U=(n=null)=>{var e={name:n};return r.vec3(e)},w=(n=null)=>{var e={name:n};return r.vec4(e)},V=(n=null)=>{var e={name:n};return r.mat2(e)},z=(n=null)=>{var e={name:n};return r.mat3(e)},F=(n=null)=>{var e={name:n,constant:!0};return r.mat3(e)},I=(n=null)=>{var e={name:n};return r.mat4(e)},R=(n,e)=>s.atan2(n,e);function A(n,e){const t=(n,e,t)=>x("texture2D"+t,"v4",[v(n),$(e)]),o=(n,e,t,r)=>x("get2DBoxedBilinearUV","v2",[$(n),$(e),$(t),$(r)]);function i(n,r){return`\n\n            ${g("texture2D"+n,"v4",[v("textureSampler"),$("uv")])}{\n\n                ${w("texel")} = ${s.sample2DTexture("textureSampler","uv")};\n                return ${w()}(${x(n+"toRGB","v3",[h("texel")])}, 1.0);\n                \n            }\n\n            ${g("texture2DBilinear"+n,"v4",[v("textureSampler"),$("uv"),$("textureSize"),$("texelSize")])} {\n                ${r?`\n                    ${M("fetchUVToUse")} = clamp(uv, ${M()}(0.5) * texelSize, (textureSize - ${M()}(0.5)) * texelSize);\n                    ${w("tl")} = ${t("textureSampler","fetchUVToUse",n)};        \n                    return tl;\n                    `:`\n                    ${M("st")} = uv * textureSize - 0.5;\n                    ${M("iuv")} = (floor(st) + ${M()}(0.5)) * texelSize;\n                    ${M("fuv")} = fract(st);\n    \n                    ${w("tl")} = ${t("textureSampler","iuv",n)};          \n                    ${w("tr")} = ${t("textureSampler",`iuv + ${M()}(texelSize.x, 0.0)`,n)};\n                    ${w("bl")} = ${t("textureSampler",`iuv + ${M()}(0.0, texelSize.y)`,n)};\n                    ${w("br")} = ${t("textureSampler",`iuv + ${M()}(texelSize.x, texelSize.y)`,n)};\n    \n                    ${w("tA")} = mix(tl, tr, fuv.x);\n                    ${w("tB")} = mix(bl, br, fuv.x);\n    \n                    return mix(tA, tB, fuv.y);\n                    `}\n            }\n\n            ${g("texture2DBilinear"+n+"wBox","v4",[v("textureSampler"),h("uvBox"),$("uv"),$("textureSize"),$("texelSize")])} {\n            \n                ${e?`${M("start")} = uvBox.xy;\n                    ${M("factor")} = uvBox.zw;\n                    ${M("fetchUVToUse")} = factor* uv + start;\n\n\n                    ${r?`\n                        fetchUVToUse = clamp(fetchUVToUse, ${M()}(0.5) * texelSize, (textureSize - ${M()}(0.5)) * texelSize);\n                        ${w("tl")} = ${t("textureSampler",`${o("fetchUVToUse",`${M()}(0.0, 0.0)`,"factor","start")}`,n)};\n                        return tl;\n                        `:`\n                        ${M("st")} = fetchUVToUse * textureSize - 0.5;\n                        ${M("iuv")} = (floor(st) + ${M()}(0.5)) * texelSize;\n                        ${M("fuv")} = fract(st);\n    \n                        ${w("tl")} = ${t("textureSampler",`${o("iuv",`${M()}(0.0, 0.0)`,"factor","start")}`,n)};\n                        ${w("tr")} = ${t("textureSampler",`${o("iuv",`${M()}(texelSize.x, 0.0)`,"factor","start")}`,n)};\n                        ${w("bl")} = ${t("textureSampler",`${o("iuv",`${M()}(0.0, texelSize.y)`,"factor","start")}`,n)};\n                        ${w("br")} = ${t("textureSampler",`${o("iuv",`${M()}(texelSize.x, texelSize.y)`,"factor","start")}`,n)};\n\n                        ${w("tA")} = mix(tl, tr, fuv.x);\n                        ${w("tB")} = mix(bl, br, fuv.x);\n    \n                        return mix(tA, tB, fuv.y);\n                        `}\n                    `:`\n                    return ${x("texture2DBilinear"+n,"v4",[v("textureSampler"),$("uvBox.xy"),$("textureSize"),$("texelSize")])};\n                    `}\n                \n            }\n            `}return`\n\n            ${g("get2DBoxedBilinearUV","v2",[$("iuv"),$("offset"),$("factor"),$("start")])} {\n\n                //float x = mod(iuv.x + offset.x, factor.x) + start.x;\n                ${b("modulo")} = iuv.x + offset.x - factor.x * floor((iuv.x + offset.x)/factor.x);\n                ${b("x")} = modulo + start.x;\n                ${b("y")} = iuv.y + offset.y;\n                return ${M()}(x,y);\n            }\n            // https://mynameismjp.wordpress.com/2008/12/12/logluv-encoding-for-hdr/\n            ${F("LogLUVEncodeMatrix")} = ${z()}(\n                0.2209, 0.3390, 0.4184,\n                0.1138, 0.6780, 0.7319,\n                0.0102, 0.1130, 0.2969\n            );      \n            ${g("RGBtoLogLUV","v4",[p("color")])} {\n                ${w("encoded")} ;\n                ${U("Xp_Y_XYZp")}  =  LogLUVEncodeMatrix * min(color, vec3(1000.0));\n                Xp_Y_XYZp = max(Xp_Y_XYZp, ${U()}(1e-6, 1e-6, 1e-6));\n                ${b("Le")} = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n                encoded.z = fract(Le);\n                encoded.w = (Le - encoded.z) / 255.0;\n                encoded.x = Xp_Y_XYZp.x / Xp_Y_XYZp.z;\n                encoded.y = Xp_Y_XYZp.y / Xp_Y_XYZp.z;\n                return min(encoded, ${w()}(1.0));\n            }\n\n            ${F("LogLUVDecodeMatrix")} = ${z()}(\n                6.0013,    -2.700,    -1.7995,\n                -1.332,    3.1029,    -5.7720,\n                .3007,    -1.088,    5.6268\n            );\n            ${g("LogLUVtoRGB","v3",[h("encoded")])} {     \n                ${U("Xp_Y_XYZp")} ;    \n                ${b("Le")} = encoded.w * 255.0 + encoded.z;\n                Xp_Y_XYZp.y = exp2((Le - 127.0) * 0.5);\n                Xp_Y_XYZp.z = Xp_Y_XYZp.y / encoded.y;\n                Xp_Y_XYZp.x = encoded.x * Xp_Y_XYZp.z;\n                ${U("color")}  = LogLUVDecodeMatrix * Xp_Y_XYZp;\n                return max(color, ${U()}(0.0));\n            }\n            ${i("LogLUV",n.useLinearSampling)}\n\n            ${g("RGBEtoRGB","v3",[h("encoded")])} {         \n                ${b("exponent")} = pow(2.0, 255.0 * encoded.w - 128.0);\n                return encoded.xyz * exponent;\n            }\n            \n            ${g("RGBtoRGBE","v4",[p("color")])} {\n                ${b("value")} = max(color.r, max(color.g, color.b));\n                if (value < 1e-6) {\n                    return ${w()}(0.0, 0.0, 0.0, 1.0);\n                }\n                // in [-128..127]\n                ${b("exponent")}  = clamp(ceil(log2(value)), -128.0, 127.0);\n\n                return ${w()}(color * pow(2.0, -exponent), (exponent + 128.0) / 255.0);\n            }\n            ${i("RGBE",n.useLinearSampling)}\n\n            ${((n=null)=>{var e={name:n,constant:!0};return r.float(e)})("RGBMMaxRange")} = 14.0;\n            ${g("RGBMtoRGB","v3",[h("encoded")])} {         \n                return encoded.rgb * (encoded.a * RGBMMaxRange);\n            }\n            \n            ${g("RGBtoRGBM","v4",[p("color")])} {\n                ${U("clampedColor")} = min(color, ${U()}(RGBMMaxRange));\n                ${b("maxRGB")}  = max(clampedColor.x,max(clampedColor.g,clampedColor.b));\n                ${b("M")} = maxRGB / RGBMMaxRange;\n                M = ceil(M * 255.0) / 255.0;\n                return ${w()}(color / (M * RGBMMaxRange), M);\n            }\n            ${i("RGBM",n.useLinearSampling)}\n       \n            ${n.envMap?`\n                ${g("IBLtoRGB","v3",[h("encoded")])} {         \n                    ${"LOGLUV"===n.envMapEncoding?`\n                        return ${x("LogLUVtoRGB","v3",[h("encoded")])};\n                        `:`\n                        \n                        ${"RGBE"===n.envMapEncoding?`\n                            return ${x("RGBEtoRGB","v3",[h("encoded")])};\n                            `:`\n                            ${"RGBM"===n.envMapEncoding?`\n                                return ${x("RGBMtoRGB","v3",[h("encoded")])};\n                                `:"\n                                return encoded.rgb;\n                                "}\n                            `}\n                        `}\n                }\n                ${i("IBL",n.useLinearSampling)}\n                \n                `:a}\n        `}return{model_view_projection_transformation_vertex:function(n){return`${e="position",t.getShaderOutput(e)} = ${S("projectionMatrix")} * ${x("computeModelViewPosition","v4",[p("position_")])};`;var e},model_view_transformation_pars:function(n){var e=function(n){let e=a;return(n.billboard||n.fixedSize)&&(e=`\n                            ${e}\n                            ${x("setSimpleNodeData",null,[])};\n                        `),n.billboard&&(e=`\n                            ${e}\n                            res = simpleNodeData.billboardMatrix * res;\n                        `),n.fixedSize&&(e=`\n                            ${e}\n                            res.x *= simpleNodeData.fixedSizeScale;\n                            res.y *= simpleNodeData.fixedSizeScale;\n                            res.z *= simpleNodeData.fixedSizeScale;\n                            ${U("fixedSizeCenterOffset")}  = simpleNodeData.fixedSizeScaleCenter * res.w * ${y("fixedSizeCenterRatio")}.xyz;\n                            res.x += fixedSizeCenterOffset.x;\n                            res.y += fixedSizeCenterOffset.y;\n                            res.z += fixedSizeCenterOffset.z;\n                        `),e};return`\n                ${g("getLocalPositionTransformation","v4",[h("iVec4")])} {\n\t\t\t\t\t${w("res")} = iVec4;\n\t\t\t\t\t${e(n)}\n\t\t\t\t\treturn res;\n\t\t\t\t}\n                ${g("getLocalPositionTransformation","v4",[p("iVec3")])}{\n\t\t\t\t\t${w("res")}  = vec4(iVec3, 1.0);\n\t\t\t\t\t${e(n)}\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\n                ${g("getModelTransformation","v4",[h("iVec4")])}{\n                    ${w("res")}  = ${x("getLocalPositionTransformation","v4",[h("iVec4")])};                     \n                    ${n.defaultInstancing?`res = (multipliedDefaultInstancingMatrix * ${w()}(res.xyz, 1.0));`:a}      \n                    return modelMatrix * res;\n\t\t\t\t}\n                ${g("getModelTransformation","v4",[p("iVec3")])}{       \n                    return ${x("getModelTransformation","v4",[h(`${w()}(iVec3, 1.0)`)])};\n\t\t\t\t}\n\n                ${g("getModelViewTransformation","v4",[h("iVec4")])}{\n                    ${w("res")} = ${x("getLocalPositionTransformation","v4",[h("iVec4")])};            \n                    return ${x("computeModelViewPosition","v4",[p("res.xyz")])};\n                }\n                ${g("getModelViewTransformation","v4",[p("iVec3")])}{        \n                    return ${x("getModelViewTransformation","v4",[h("vec4(iVec3, 1.0)")])};\n                }\n            `},getModelViewTransformationChunk:function(n,e,t){return`${n} = ${x("getModelViewTransformation","v4",[h(e)])};`},model_view_unit_transformation_pars:function(n){let e=a;return(n.billboard||n.fixedSize)&&(e=`\n                    ${e}\n                    ${x("setSimpleNodeData",null,[])};\n                `),n.billboard&&(e=`\n                    ${e}\n                    res = (simpleNodeData.billboardMatrix * ${w()}(res, 0.0)).xyz;\n                `),`\n                ${g("getModelViewUnitTransformation","v3",[p("iVec3")])} {\n                    ${U("res")} = iVec3;\n                    ${e}\n                    return ${x("computeModelViewDirection","v4",[p("res")])}.xyz;\n                }\n            `},getModelViewUnitVectorTransformationChunk:function(n,e,t){return`${n} = ${x("getModelViewUnitTransformation","v3",[p(e)])};`},getNormalMatrixUnitVectorTransformationChunk:function(n,e,t){return`${n} = ${(n=>{var e=a;return e=n.useNormalMatrix?y("normalMatrix"):"normalMatrix",n.defaultInstancing&&(e=`${e} * ${z()}(multipliedDefaultInstancingMatrix[0].xyz, multipliedDefaultInstancingMatrix[1].xyz, multipliedDefaultInstancingMatrix[2].xyz)`),e})(t)} * ${e};`},map_pars_vertex_fragment:function(n){if(n.mappingType>-1||n.lightMapMappingType>-1){var e=`${function(n){const e=`\n\n        ${g("mappingTranspose","m4",[u("m4","m")])} {\n            ${w("i0")} = m[0];\n            ${w("i1")} = m[1];\n            ${w("i2")} = m[2];\n            ${w("i3")} = m[3];\n            ${I("outMatrix")} = ${I()}(\n                ${w()}(i0.x, i1.x, i2.x, i3.x),\n                ${w()}(i0.y, i1.y, i2.y, i3.y),\n                ${w()}(i0.z, i1.z, i2.z, i3.z),\n                ${w()}(i0.w, i1.w, i2.w, i3.w)\n            );\n            return outMatrix;\n        }\n\n        ${g("applyMappingOperator","v2",[$("inUV"),p("pos"),p("norm"),c("mappType"),d("outTangent"),d("outBinormal")])} {\n        \n            ${M("outUV")} = inUV;\n            ${I("invMappingObjTransformation")} = ${x("mappingTranspose","m4",[u("m4",`${T("mappingObjTransformation",n)}`)])};\n            ${U("x")} = ${U()}(invMappingObjTransformation[0].xyz);\n            ${U("y")} =  ${U()}(invMappingObjTransformation[1].xyz);\n            ${U("z")} =  ${U()}(invMappingObjTransformation[2].xyz);\n            ${U("localpos")} = (${T("mappingObjTransformation",n)} * ${w()}(pos, 1.0)).xyz; \n            ${U("localnorm")} = (${T("mappingObjTransformation",n)} * ${w()}(norm, 0.0)).xyz;; \n\n            if (mappType == 1) {\n\n                outUV = localpos.xy;\n\n                ${l("outTangent")} = x;\n                ${l("outBinormal")} = y;\n\n            } else if (mappType == 2) {\n\n                ${b("radius3d")} = max(0.000001,length(localpos.xyz));\n                ${b("z_by_radius3d")} = localpos.z / radius3d;\n\n                ${b("thetaMapping")} =0.0;\n                if (localpos.y!=0.0 || localpos.x!=0.0) {\n                    thetaMapping = ${R("localpos.y","localpos.x")};\n                }\n\n                ${b("phiMapping")} = asin(z_by_radius3d );\n                ${b("u")} =thetaMapping*radius3d;\n                ${b("v")} =phiMapping*radius3d;\n                outUV = ${M()}(u, v);\n\n                ${b("cos_theta")} = cos(thetaMapping);\n                ${b("sin_theta")} = sin(thetaMapping);\n                ${b("cos_phi")} = cos(phiMapping);\n                ${b("sin_phi")} = z_by_radius3d;\n\n                ${l("outTangent")} = -sin_theta*x + cos_theta*y;\n                ${l("outBinormal")} = -cos_theta*sin_phi*x - sin_theta*sin_phi*y + cos_phi*z;\n\n\n            } else if (mappType == 6) {\n\n                ${b("radius3d")}  = max(0.000001,length(localpos.xyz));\n                ${b("z_by_radius3d")}  = localpos.z / radius3d;\n\n                ${b("thetaMapping")} =0.0;\n                if (localpos.y!=0.0 || localpos.x!=0.0) {\n                    thetaMapping = ${R("localpos.y","localpos.x")};\n                }\n\n                ${b("phiMapping")}    = asin(z_by_radius3d );\n                ${b("u")} =thetaMapping/3.14159;\n                ${b("v")} =phiMapping/3.14159;\n                outUV = ${M()}(u, v);\n                \n                ${b("cos_theta")}  = cos(thetaMapping);\n                ${b("sin_theta")}  = sin(thetaMapping);\n                ${b("cos_phi")}  = cos(phiMapping);\n                ${b("sin_phi")}  = z_by_radius3d;\n\n                ${l("outTangent")} = -sin_theta*x + cos_theta*y;\n                ${l("outBinormal")} = -cos_theta*sin_phi*x - sin_theta*sin_phi*y + cos_phi*z;\n\n            } else if (mappType == 3) {\n\n                ${U("absolute_normal")}  = abs(localnorm);\n                ${b("maxima_normal")}  = max(absolute_normal.x, max(absolute_normal.y, absolute_normal.z));\n\t\t\t\t\n\t\t\t\t${n.dspbr?`\n\t\t\t\t\t${U("n")}  = normalize(localnorm);\n\t\t\t\t\tif (dot(localpos, localnorm) < 0.0) {\n\t\t\t\t\t\tn = -n;\n\t\t\t\t\t}\n\t\t\t\t\t`:`${U("n")} = normalize(localpos);`}\n\n                ${U("s")};\n                s.x = -1.0;\n                if (n.x >= -0.0000001) { s.x = 1.0; }\n                s.y = 1.0;\n                if (n.y >= -0.0000001) { s.y = -1.0; }\n                s.z = -1.0;\n                if (n.z >= -0.0000001) { s.z = 1.0; }\n\n                if(maxima_normal == absolute_normal.x){\n                    outUV = ${M()}(s.x * localpos.y, localpos.z );\n                    ${l("outTangent")} = s.x * y;\n                    ${l("outBinormal")} = z;\n                }\n\n                else if(maxima_normal == absolute_normal.y){\n                    outUV = ${M()}(s.y * localpos.x, localpos.z );\n                    ${l("outTangent")} = s.y * x;\n                    ${l("outBinormal")} = z;\n                }\n                else{\n                    outUV = ${M()}(s.z * localpos.x, localpos.y );\n                    ${l("outTangent")} = s.z * x;\n                    ${l("outBinormal")} = y;\n                }\n\n            } else if (mappType == 4) {\n\t\t\t\t${U("n")}  = localnorm;\n\t\t\t\t${n.dspbr?"\n\t\t\t\t\tif (dot(localpos, localnorm) < 0.0) {\n\t\t\t\t\t\tn = -n;\n\t\t\t\t\t}\n\t\t\t\t\t":a}\n                ${b("radius2d")}  = length(localpos.xy);\n                ${U("absolute_normal")}  = abs(n);\n                ${b("maxima_normal")}  = max(absolute_normal.x, max(absolute_normal.y, absolute_normal.z));\n\n                if(maxima_normal == absolute_normal.z){\n                    ${b("s")}  = -1.0;\n                    if (localpos.z >= 0.0) {\n                        s = 1.0;\n                    }\n                    outUV.x = s * localpos.x;\n                    outUV.y = localpos.y;\n                \n                    ${l("outTangent")} = s * x;\n                    ${l("outBinormal")} = y;\n                }else{\n                    ${b("thetaMapping")} =0.0;\n                    if (localpos.y!=0.0 || localpos.x!=0.0){\n                        thetaMapping = ${R("localpos.y","localpos.x")};\n                    }\n\n                    ${b("u")} =thetaMapping*radius2d;\n                    outUV = ${M()}(u , localpos.z);\n\n                    ${b("cos_theta")}  = cos(thetaMapping);\n                    ${b("sin_theta")}  = sin(thetaMapping);\n                \n                    ${l("outTangent")} = -sin_theta*x + cos_theta*y;\n                    ${l("outBinormal")} = z;\n                }\n\n            } else if (mappType == 5) {\n\n                ${b("radius2d")}  = length(localpos.xy);\n                ${b("thetaMapping")} =0.0;\n                if (localpos.y!=0.0 || localpos.x!=0.0) {\n                    thetaMapping = ${R("localpos.y","localpos.x")};\n                }\n\n                ${b("u")} =thetaMapping*radius2d;\n                outUV = ${M()}(u, localpos.z);\n                \n                ${b("cos_theta")}  = cos(thetaMapping);\n                ${b("sin_theta")}  = sin(thetaMapping);\n            \n                ${l("outTangent")} = -sin_theta*x + cos_theta*y;\n                ${l("outBinormal")} = z;\n            } else if (mappType == 7) {\n\n                ${b("radius2d")}  = length(localpos.xy);\n                ${b("thetaMapping")} =0.0;\n                if (localpos.y!=0.0 || localpos.x!=0.0) {\n                    thetaMapping = ${R("localpos.y","localpos.x")};\n                }\n\n                ${b("u")} =thetaMapping/3.14159;\n                outUV = ${M()}(u, localpos.z/(radius2d*3.14159));\n                \n                ${b("cos_theta")}  = cos(thetaMapping);\n                ${b("sin_theta")}  = sin(thetaMapping);\n            \n                ${l("outTangent")} = -sin_theta*x + cos_theta*y;\n                ${l("outBinormal")} = z;\n\n            } else if (mappType == 8) {\n\n                ${b("thetaMapping")} =0.0;\n                if (localpos.y!=0.0 || localpos.x!=0.0) {\n                    thetaMapping = ${R("localpos.y","localpos.x")};\n                }\n                ${b("u")} =thetaMapping/3.14159;\n                outUV = ${M()}(u, localpos.z);\n\n                ${b("cos_theta")}  = cos(thetaMapping);\n                ${b("sin_theta")}  = sin(thetaMapping);\n                ${l("outTangent")} = -sin_theta*x + cos_theta*y;\n                ${l("outBinormal")} = z;\n\n            }\n\n            if(mappType >0){\n                ${l("outTangent")}= normalize(cross(${l("outBinormal")},norm));\n                ${l("outBinormal")}= normalize(cross(norm,${l("outTangent")}));\n            }\n\n            if (${T("mappingTransformSemantic",n)}==1){\n               return (${T("mappingUVTransformation",n)} * ${U()}(outUV, 1.0)).xy;\n            }else{\n               return outUV;\n            }\n    }\n\n        ${g("applyMappingOperator","v2",[$("inUV"),p("pos"),p("norm"),d("outTangent"),d("outBinormal")])} {\n            return ${x("applyMappingOperator","v2",[$("inUV"),p("pos"),p("norm"),c(`${T("mappingType",n)}`),d("outTangent"),d("outBinormal")])};\n        }\n\n        ${g("applyMappingOperator","v2",[$("inUV"),p("pos"),p("norm"),c("mappType")])} {\n            ${U("bogusTangent")};\n            ${U("bogusBinormal")};\n            return ${x("applyMappingOperator","v2",[$("inUV"),p("pos"),p("norm"),c("mappType"),f("bogusTangent"),f("bogusBinormal")])};\n        }\n\n        ${g("applyMappingOperator","v2",[$("inUV"),p("pos"),p("norm")])} {\n            ${U("bogusTangent")};\n            ${U("bogusBinormal")};\n            return ${x("applyMappingOperator","v2",[$("inUV"),p("pos"),p("norm"),f("bogusTangent"),f("bogusBinormal")])};\n        }\n\n        ${g("applyMappingOperator","v4",[h("inUV"),p("pos"),p("norm"),c("mappType"),d("outTangent"),d("outBinormal")])} {\n            ${M("outUV")} = inUV.xy;\n            outUV = ${x("applyMappingOperator","v2",[$("outUV"),p("pos"),p("norm"),c("mappType"),d("outTangent"),d("outBinormal")])};\n            return ${w()}(outUV,inUV.z,inUV.w);\n        }\n\n        ${g("applyMappingOperator","v4",[h("inUV"),p("pos"),p("norm"),d("outTangent"),d("outBinormal")])} {\n            ${M("outUV")} = inUV.xy;\n            outUV = ${x("applyMappingOperator","v2",[$("outUV"),p("pos"),p("norm"),c(`${T("mappingType",n)}`),d("outTangent"),d("outBinormal")])};\n            return ${w()}(outUV,inUV.z,inUV.w);\n        }\n\n        ${g("applyMappingOperator","v4",[h("inUV"),p("pos"),p("norm"),c("mappType")])} {\n            ${U("bogusTangent")};\n            ${U("bogusBinormal")};\n            ${M("outUV")} = inUV.xy;\n            outUV =  ${x("applyMappingOperator","v2",[$("outUV"),p("pos"),p("norm"),c("mappType"),f("bogusTangent"),f("bogusBinormal")])};\n            return ${w()}(outUV,inUV.z,inUV.w);\n        }\n\n        ${g("applyMappingOperator","v4",[h("inUV"),p("pos"),p("norm")])} {\n            ${U("bogusTangent")};\n            ${U("bogusBinormal")};\n            ${M("outUV")} = inUV.xy;\n            outUV =  ${x("applyMappingOperator","v2",[$("outUV"),p("pos"),p("norm"),f("bogusTangent"),f("bogusBinormal")])};\n            return ${w()}(outUV,inUV.z,inUV.w);\n        }\n        `,t=`          \n                        if(${T("mappingTransformSemantic",n)}==2){\n                            ${M("T0")}  = ${T("mappingUVTransformation",n)}[2].xy; // M0 translation only\n                            ${M("Ti")}  = uvtransform[2].xy; // Mi translation only\n                    \n                            ${V("Ri")}  = ${V()}(uvtransform[0].xy, uvtransform[1].xy);//rotation\n                            ${V("R0")}  = ${V()}(${T("mappingUVTransformation",n)}[0].xy, ${T("mappingUVTransformation",n)}[1].xy);//rotation\n                            ${M("uv_shifted")}  = uv.xy + T0 +Ti;\n                            return Ri * R0 * uv_shifted;\n                        } else if(${T("mappingTransformSemantic",n)}==3) {\n                            ${M("T0")}  = ${T("mappingUVTransformation",n)}[2].xy; // M0 translation only\n                            ${M("Ti")}  = uvtransform[2].xy; // Mi translation only\n                    \n                            ${V("Ri")}  = ${V()}(uvtransform[0].xy, uvtransform[1].xy);//rotation\n                            ${V("R0")}  = ${V()}(${T("mappingUVTransformation",n)}[0].xy, ${T("mappingUVTransformation",n)}[1].xy);//rotation\n                            ${M("uv_shifted")}  = uv.xy + T0 +Ti-${M()}(0.5,0.5);\n                            return (Ri * R0 * uv_shifted)+${M()}(0.5,0.5);\n                        }\n        `,r=`\n        \n            ${g("applyUVCombination","v2",[$("uv"),u("m3","uvtransform")])}{         \n                    ${n.mappingType>-1?`\n                        ${t}\n                        `:a}\n                    return (uvtransform * ${U()}(uv,1.0)).xy;\n            }\n            ${n.lightMap?`\n                ${g("applyLightMapUVCombination","v2",[$("uv"),u("m3","uvtransform")])}{             \n                        ${n.lightMapMappingType>-1?`\n                            ${t}\n                            `:a}\n                        return (uvtransform * ${U()}(uv,1.0)).xy;\n                }\n                `:a}\n        `;return`          \n        ${_({uniformName:"mappingType",uniformType:"i"},n)}\n        ${_({uniformName:"mappingNormTransformation",uniformType:"m3"},n)}\n        ${_({uniformName:"mappingObjTransformation",uniformType:"m4"},n)}\n        ${_({uniformName:"mappingUVTransformation",uniformType:"m3"},n)}\n        ${_({uniformName:"mappingTransformSemantic",uniformType:"i"},n)}\n\n        ${e}\n        ${r}\n        `}(n)}`;return!0===n.mappingUseFragment&&(e=`\n                        ${e}\n                        ${D({varyingName:"localPosition",varyingType:"v3"})}\n                        ${D({varyingName:"localNormal",varyingType:"v3"})}\n                    `),e}return n.dspbr||n.specgloss||n.PDSFX?`    \n                    ${g("applyUVCombination","v2",[$("uv"),u("m3","uvtransform")])}{                   \n                            return (uvtransform * ${U()}(uv,1.0)).xy;\n                    }\n                        \n                    ${n.lightMap?`\n                        ${g("applyLightMapUVCombination","v2",[$("uv"),u("m3","uvtransform")])}{\n                            return (uvtransform * ${U()}(uv,1.0)).xy;\n                        }\n                        `:a}\n                `:a},ibl_sample_methods:function(n){return A(n,!1)},ibl_sample_methods_repeat:function(n){return A(n,!0)},normal_viewposition_pars_vertex:function(n){return n.PDSFX?a:`\n                ${D({varyingName:"vViewPosition",varyingType:"v3"})}\n                ${D({varyingName:"vNormal",varyingType:"v3"})}\n            `},normal_viewposition_vertex:function(n){return n.PDSFX?"transformedNormal = _viewTangentSpace.Normal;":`\n                    ${P("vNormal")} = normalize( transformedNormal );\n                    ${P("vViewPosition")} = -mvPosition.xyz;\n            `},viewposition_lineic_pars_vertex:function(n){return n.PDSFX?a:`\n                ${D({varyingName:"vViewPosition",varyingType:"v3"})}\n            `},viewposition_lineic_vertex:function(n){return n.PDSFX?a:`\n                    ${P("vViewPosition")} = -mvPosition.xyz;\n            `},viewposition_lineic_pars_fragment:function(n){var e=a;return n.PDSFX||(e=`\n                ${D({varyingName:"vViewPosition",varyingType:"v3"})}\n                `),e},viewposition_lineic_fragment:function(n){var e=a;const t=n.PDSFX?"INTERNAL_computed_viewPosition":C("vViewPosition");return e=`\n                ${e}\n                ${U("view")}  = normalize( ${t} );\n                ${U("vPos")}  = ${t};\n            `},planar_normal_pars_fragment:function(n){return`\n                ${g("diffNormalFromPosition","v3",[h("view_position"),m("frontFacing")])} {\n                    ${U("p")} = view_position.xyz / view_position.w;\n                    ${U("x")} = ${s.dpdx("p")};\n                    ${U("y")} = ${s.dpdy("p")};\n                    ${U("normal")} = normalize(cross(x,y));\n                    // counter the flipping that occur later in the code\n                    ${b("front_facing")} = 2.0 * ${b()}(frontFacing) - 1.0;\n                    return normal * front_facing;\n                }\n            `},planar_normal_fragment:function(n,e){if(!n.enablePlanarNormals)return a;const t=n.PDSFX?"INTERNAL_computed_viewPosition":C("vViewPosition");let o=!n.forcePlanarNormals,i=`\n                //outside of if to prevent adreno bug messing with subsequent frontfacing calls\n\t\t\t\t${((n=null)=>{var e={name:n};return r.bool(e)})("isFrontFacing")} = ${N("frontFacing")};\n\t\t\t`,s=`         \n                ${w("v4ForPlanarViewPosition")}=${w()}(${t}, 1.0);\n                ${e} = ${x("diffNormalFromPosition","v3",[h("v4ForPlanarViewPosition"),m("isFrontFacing")])};      \n            `;return o?`\n\t\t\t\t\t${i}\n                    if(${x("get_draw_id","i",[])} == 1){\n                        ${s}\n                    }\n                `:`\n\t\t\t\t${i}\n\t\t\t\t${s}\n\t\t\t`},normal_viewposition_pars_fragment:function(n){var e=a;return n.PDSFX||(e=`\n                ${D({varyingName:"vViewPosition",varyingType:"v3"})}\n                ${D({varyingName:"vNormal",varyingType:"v3"})}\n                `),e},normal_viewposition_fragment:function(n){const e=n.PDSFX?"INTERNAL_computed_viewPosition":C("vViewPosition");return`\n                ${n.PDSFX?`${U("normal")}  = INTERNAL_computed_viewNormal;`:`${U("normal")}  = normalize( ${C("vNormal")} );`}\n                ${this.planar_normal_fragment(n,"normal")}\n                normal = normal * ( -1.0 + 2.0 * ${b()}( ${N("frontFacing")} ) );\n                ${U("view")}  = normalize( ${e} );\n                ${U("vPos")}  = ${e};\n            `},getScreenUVs:function(n){const e=`${M()}(1.0)`,t=`${N("fragCoord")}.xy * ${S("invScreenSize")}`;return`${r=t,a=e,s.modulo(r,a)}`;var r,a}}})),define("DS/ShaderBuilders/Commons/ScenegraphShaders",["DS/ShaderBuilders/Commons/DefaultShaders","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a){"use strict";const o="",i=e.ParameterUtils,s=(e.FunctionHandler,e.BridgeFunctions),l=n=>a.dereference(n),u=(n,e)=>i.parameter(n,e),m=n=>i.parameterF(n),c=n=>i.parameterV2(n),$=n=>i.parameterV3(n),p=n=>i.parameterInOutV3(n),d=n=>i.parameterInOutM3(n),f=n=>i.parameterV4(n),h=(n,t,r)=>e.FunctionHandler.declareFunction(n,t,r),v=(n,t,r)=>e.FunctionHandler.callFunction(n,t,r),g=n=>t.addObjectUniform(n),x=n=>{var e={uniformName:n};return t.getObjectUniform(e)},S=n=>t.addGlobalUniform(n),y=n=>{var e={uniformName:n};return t.getGlobalUniform(e)},_=(n=null)=>((n=null,e="")=>{var t={name:n,addressSpace:e};return a.bool(t)})(n,"private"),T=(n=null)=>{var e={name:n};return a.float(e)},D=(n=null)=>{var e={name:n};return a.vec2(e)},C=(n=null)=>{var e={name:n};return a.vec3(e)},P=(n=null)=>{var e={name:n};return a.vec4(e)},N=(n=null)=>{var e={name:n};return a.mat4(e)},b=(n,e)=>s.sample2DTextureGrad(n,e),M=(n,e)=>s.modulo(n,e);return{gpu_scenegraph_nodes:function(n){return`\n\t\t\t${n.billboard?`\n                ${g({uniformName:"modelInvRotMatrix",uniformType:"m4"})}\n                ${g({uniformName:"billboardType",uniformType:"i"})}\n                ${g({uniformName:"billboardRotationEnabled",uniformType:"i"})}\n                ${g({uniformName:"billboardRotation",uniformType:"m4"})}\n                ${S({uniformName:"billCameraPos",uniformType:"v3"})}\n                ${S({uniformName:"billCameraLookAt",uniformType:"v3"})}\n                ${S({uniformName:"billCameraUp",uniformType:"v3"})}\n                    ${h("lookAt","m4",[$("eye"),$("lookTarget"),$("up")])} {\n\t\t\t\t\t\t${C("z")} = eye - lookTarget;\n\t\t\t\t\t\tif (length(z) < 1e-6) {\n\t\t\t\t\t\t\tz.z = 1.0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tz = normalize(z);\n\t\t\t\t\t\t${C("x")} = cross(up, z);\n\t\t\t\t\t\tif (length(x) < 1e-6) {\n\t\t\t\t\t\t\tz.x += 0.001;\n\t\t\t\t\t\t\tx = cross(up, z);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tx = normalize(x);\n\t\t\t\t\t\t${C("y")} = cross(z,x);\n\t\t\t\t\t\treturn ${N()}(${P()}(x, 0.0), ${P()}(y, 0.0), ${P()}(z, 0.0), ${P()}(0.0,0.0,0.0,1.0));\n\t\t\t\t\t}\n                ${g({uniformName:"billboardAxis",uniformType:"v3"})}\n                ${S({uniformName:"invViewMatrix",uniformType:"m4"})}\n                ${S({uniformName:"invProjectionMatrix",uniformType:"m4"})}\n\n                ${h("applyProjection","v3",[$("vector"),u("m4","proj")])} {\n\t\t\t\t\t${P("res")} = proj * ${P()}(vector, 1.0);\n\t\t\t\t\treturn res.xyz / max(abs(res.w),1e-6);\n\t\t\t\t}\n\n                ${h("getBillboardMatrix","m4",[])} {\n                    ${C("cameraPos")}  = ${y("billCameraPos")};\n\t\t\t\t\t${C("cameraTarget")}  = ${y("billCameraLookAt")} + cameraPos;\n\t\t\t\t\t${N("billMat")} ;\n\t\t\t\t\tif (${x("billboardType")} == 1) {\n\t\t\t\t\t\tbillMat = ${v("lookAt","m4",[$("cameraPos"),$("cameraTarget"),$(`${y("billCameraUp")}`)])};\n\t\t\t\t\t} else {\n\t\t\t\t\t\t${C("axis")}  = normalize(${v("computeModelDirection","v4",[$(`${x("billboardAxis")}`)])}.xyz);\n\t\t\t\t\t\t${C("objToCam")}  = vec3(0.0);\n\t\t\t\t\t\tif (${x("billboardType")} == 3) {\n\t\t\t\t\t\t\t${C("worldPosOrigin")}  = ${v("computeModelPosition","v4",[$(`${C()}(0.0)`)])}.xyz;\n\t\t\t\t\t\t\tobjToCam = worldPosOrigin - cameraPos;\n\t\t\t\t\t\t\t${C("tmp")}  = worldPosOrigin + axis;\n\t\t\t\t\t\t\t${N("proj")}  = ${y("projectionMatrix")} * ${y("viewMatrix")};\n\t\t\t\t\t\t\t${C("projOrig")}  = ${v("applyProjection","v3",[$("worldPosOrigin"),u("m4","proj")])};\n\t\t\t\t\t\t\ttmp = ${v("applyProjection","v3",[$("tmp"),u("m4","proj")])};\n\t\t\t\t\t\t\ttmp.z = projOrig.z;\n                            ${N("projectionToApply")}  = ${y("invViewMatrix")} * ${y("invProjectionMatrix")};\n\t\t\t\t\t\t\ttmp = ${v("applyProjection","v3",[$("tmp"),u("m4","projectionToApply")])};\n\t\t\t\t\t\t\ttmp -= worldPosOrigin;\n\t\t\t\t\t\t\taxis = normalize(tmp);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tobjToCam = ${y("billCameraLookAt")};\n\t\t\t\t\t\t}\n\t\t\t\t\t\tobjToCam = normalize(objToCam);\n\t\t\t\t\t\t${C("crossX")}  = cross(objToCam, axis);\n\t\t\t\t\t\tif (length(crossX) < 1e-6) {\n                            if (abs(objToCam.z) < 0.999) {\n                                crossX = cross(${C()}(0.0,0.0,1.0), objToCam);\n                            } else {\n                                crossX = cross(${C()}(1.0,0.0,0.0), objToCam);\n                            }\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcrossX = normalize(crossX);\n\t\t\t\t\t\t${C("crossY")}  = normalize(cross(axis, crossX));\n\t\t\t\t\t\tbillMat = ${N()}(${P()}(crossX, 0.0), ${P()}(crossY, 0.0), ${P()}(axis, 0.0), ${P()}(0.0,0.0,0.0,1.0));\n\t\t\t\t\t}\n\t\t\t\t\tif (${x("billboardRotationEnabled")} == 1) {\n\t\t\t\t\t\treturn ${x("modelInvRotMatrix")} * billMat * ${x("billboardRotation")};\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn ${x("modelInvRotMatrix")} * billMat;\n\t\t\t\t\t}\n\t\t\t\t}\n                `:o}\n\n\t\t\t${n.fixedSize?`\n                ${g({uniformName:"fixedSizeCenterRatio",uniformType:"v4"})}\n                ${S({uniformName:"pixelToWorldSizeCst",uniformType:"f"})}\n                ${h("getScale","v2",[])} {\n\t\t\t\t\t${C("xAxis")}  = modelMatrix[0].xyz;\n\t\t\t\t\t${C("yAxis")}  = modelMatrix[1].xyz;\n\t\t\t\t\t${C("zAxis")}  = modelMatrix[2].xyz;\n\t\t\t\t\t${T("radius")}  = max(length(xAxis),max(length(yAxis),length(zAxis)));\n                    ${n.defaultInstancing?"\n                        xAxis  = multipliedDefaultInstancingMatrix[0].xyz;\n                        yAxis  = multipliedDefaultInstancingMatrix[1].xyz;\n                        zAxis  = multipliedDefaultInstancingMatrix[2].xyz;\n                        radius *= max(length(xAxis),max(length(yAxis),length(zAxis)));\n                        ":o}\n\t\t\t\t\t${T("screenRadius")}  = 1.0;\n\t\t\t\t\tif (${y("projectionMatrix")}[3][3] > 0.5) {\n\t\t\t\t\t\tscreenRadius = radius;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t${P("aux")}  = ${v("computeModelViewPosition","v4",[$(`${C()}(0.0)`)])};\n\t\t\t\t\t\t${T("constant")}  = abs(aux.z);\n\t\t\t\t\t\tscreenRadius = radius / constant;\n\t\t\t\t\t}\n                    ${T("scaleFactorCenter")}  = 0.0;\n                    if (length(${x("fixedSizeCenterRatio")}.xyz) > 0.0) {\n                        scaleFactorCenter = 1.0 / screenRadius * ${y("pixelToWorldSizeCst")};\n                        if (${y("projectionMatrix")}[3][3] > 0.5) {\n                            screenRadius = radius;\n                        } else {\n                            ${C("scaleCenter")}  = ${x("fixedSizeCenterRatio")}.xyz * scaleFactorCenter;\n                            ${P("aux2")}  = ${v("computeModelViewPosition","v4",[$("scaleCenter")])};\n                            ${T("constant2")}  = abs(aux2.z);\n                            screenRadius = radius / constant2;\n                        }\n                    }\n                    ${T("scaleFactor")}  = ${x("fixedSizeCenterRatio")}.w / screenRadius * ${y("pixelToWorldSizeCst")};\n\t\t\t\t\treturn ${D()}(scaleFactor, scaleFactorCenter);\n\t\t\t\t}\n                `:o}\n\n\t\t\t${n.billboard||n.fixedSize?`\n                ${a.createStruct({structName:"SimpleNodeData",attributes:[{type:"m4",name:"billboardMatrix"},{type:"f",name:"fixedSizeScale"},{type:"f",name:"fixedSizeScaleCenter"}]})}\n                ${a.struct({name:"simpleNodeData",structName:"SimpleNodeData",addressSpace:"private"})};\n\t\t\t\t${_("simpleSizeDataSet")}  = false;\n                ${h("setSimpleNodeData",null,[])}{\n\t\t\t\t\tif (simpleSizeDataSet) {\n                        return;\n                    }\n\t\t\t\t\t${n.billboard?`simpleNodeData.billboardMatrix = ${v("getBillboardMatrix","m4",[])};`:o}\n\t\t\t\t\t${n.fixedSize?`\n\t\t\t\t\t\t${D("fixedSizeData")}  = ${v("getScale","v2",[])};\n\t\t\t\t\t\tsimpleNodeData.fixedSizeScale = fixedSizeData.x;\n\t\t\t\t\t\tsimpleNodeData.fixedSizeScaleCenter = fixedSizeData.y;\n                        `:o}\n\t\t\t\t\tsimpleSizeDataSet = true;\n\t\t\t\t}\n                `:o}\n            `},decompress_normals_pars:function(n){const e=[12,16,22,24];function t(n){let e=Math.pow(2,n/2),t=e-1;return`            \n                    ${h("unpack_2unorm"+n/2+"_in_2floats","v2",[m("iEncodedNormal")])} {\n                        ${D("res")};\n                        res.x = floor(iEncodedNormal/${e}.0);\n                        res.y = (iEncodedNormal - ${e}.0 * floor(iEncodedNormal/${e}.0));\n                        return res;\n                    }\n                    ${h("normalToV2Oct"+n,"v2",[$("normal")])}{\n                        ${T("manNorm")}  = abs(normal.x) + abs(normal.y) + abs(normal.z);\n                        ${T("oNx")}  = normal.x / manNorm;\n                        ${T("oNy")}  = normal.y / manNorm;\n                        if (normal.z < 0.0) {              \n                            ${T("tmpx")}  = (1.0 - abs(oNy)) * ${v("signNotZero","f",[m("oNx")])};\n                            ${T("tmpy")}  = (1.0 - abs(oNx)) * ${v("signNotZero","f",[m("oNy")])};\n                            oNx = tmpx;\n                            oNy = tmpy;\n                        }\n                        return floor((${t}.0 * (0.5 * ${D()}(oNx, oNy) + 0.5))+0.5);\n                    }\n                \n                    ${h("normalToFOct"+n,"f",[$("normal")])}{\n                        ${D("compNormal")}  = ${v("normalToV2Oct"+n,"v2",[$("normal")])};\n                        return compNormal.x * ${e}.0 + compNormal.y;\n                    }               \n                           \n                    ${h("decodeOct"+n+"Normal","v3",[c("iEncodedNormal")])} {\n                        //put in [-1,1]\n                        ${T("x")} = iEncodedNormal.x / ${t}.0 *2.0 - 1.0;\n                        ${T("y")} = iEncodedNormal.y / ${t}.0 *2.0 - 1.0;\n                        ${C("v")} = ${C()}(x, y, 1.0 - abs(x) - abs(y));\n                        if (v.z <= 0.0) {\n                            ${D("sgn")} = ${v("signNotZero","v2",[c("v.xy")])};\n                            ${D("tmp")} = -abs(v.yx)*sgn + sgn;\n                            v.x = tmp.x;\n                            v.y = tmp.y;\n                        }\n                        return normalize(v);\n                    }\n\n                    ${h("decodeOct"+n+"Normal","v3",[m("iEncodedNormal")])}{\n                        return ${v("decodeOct"+n+"Normal","v3",[c(`${v("unpack_2unorm"+n/2+"_in_2floats","v2",[m("iEncodedNormal")])}`)])};\n                    }\n                `}let r=o;for(let n=0;n<e.length;n++)r=`\n                    ${r}\n                    ${t(e[n])}\n                `;return`\n\n                ${h("signNotZero","f",[m("k")])} {\n                    if (k >= 0.0) { return 1.0; }\n                    return -1.0;\n                }\n\n                ${h("signNotZero","v2",[c("v")])} {\n                    return ${D()}( ${v("signNotZero","f",[m("v.x")])}, ${v("signNotZero","f",[m("v.y")])} );\n                }\n\n                ${h("rotateNormal","v3",[$("iNormal"),(a="iLocalMatrix",i.parameterM3(a))])} {\n                    ${C("rNorm")} = iLocalMatrix*iNormal;                    \n                    return normalize(rNorm);\n                }\n\n                ${r}\n            `;var a},decompress_vertices_pars:function(n){return`\n            ${h("unpack_3unorm16_in_3floats","v3",[c("iEncodedPosition")])} {\n                ${C("res")};\n                res.x = floor(iEncodedPosition.x/256.0);\n                res.y  = (iEncodedPosition.x - 256.0 * floor(iEncodedPosition.x / 256.0)) * 256.0;\n                res.y += (iEncodedPosition.y - 256.0 * floor(iEncodedPosition.y / 256.0));\n                res.z = floor(iEncodedPosition.y/256.0);\n                return res;\n            }\n\n            ${h("decodePosition","v3",[c("iEncodedPosition"),$("quantized"),$("offset")])} {\n                ${C("res")} = ${v("unpack_3unorm16_in_3floats","v3",[c("iEncodedPosition")])};\n                return quantized * (res + offset);\n            }\n\n            ${h("fetchContext","",[m("iCtxIdx"),(e="iCompressionContext",i.parameterT2(e)),m("iCcSize"),p("oQuantized"),p("oOffset"),d("oLocalMatrix")])} {\n\n                ${T("invCcSize")} = 1.0/iCcSize;\n                ${T("baseOffset")} = iCtxIdx*5.0;\n                ${D("coord")} = ${D()}(${M("baseOffset","iCcSize")},floor(baseOffset*invCcSize));\n                coord *= invCcSize;\n               \n                ${l("oQuantized")} = ${b("iCompressionContext","coord")}.xyz;\n\n                baseOffset += 1.0;\n\n                coord = ${D()}(${M("baseOffset","iCcSize")},floor(baseOffset*invCcSize));\n                coord *= invCcSize;\n\n                ${l("oOffset")} = ${b("iCompressionContext","coord")}.xyz;\n\n                baseOffset += 1.0;\n\n                coord = ${D()}(${M("baseOffset","iCcSize")},floor(baseOffset*invCcSize));\n                coord *= invCcSize;\n\n                ${C("col0")} = ${b("iCompressionContext","coord")}.xyz;\n\n                baseOffset += 1.0;\n\n                coord = ${D()}(${M("baseOffset","iCcSize")},floor(baseOffset*invCcSize));\n                coord *= invCcSize;\n\n                ${C("col1")} = ${b("iCompressionContext","coord")}.xyz;\n\n                baseOffset += 1.0;\n\n                coord = ${D()}(${M("baseOffset","iCcSize")},floor(baseOffset*invCcSize));\n                coord *= invCcSize;\n\n                ${C("col2")} = ${b("iCompressionContext","coord")}.xyz;\n\n                ${l("oLocalMatrix")} = ${((n=null)=>{var e={name:n};return a.mat3(e)})()}(col0,col1,col2);\n            }\n\n            ${h("decodePosition","v3",[f("iEncodedPosition"),$("iQuantized"),$("iOffset")])} {\n\n                ${C("uncompressedPos")} = iQuantized * (iEncodedPosition.xyz + iOffset);\n\n                return uncompressedPos;\n            }\n            `;var e},decompress_colors_pars:function(n){return`\n            ${h("unpack_4unorm8_in_4floats","v4",[c("iEncodedColor")])} {\n\n                ${P("res")};\n                res.x = floor(iEncodedColor.x/65536.0);\n                res.y = floor(iEncodedColor.x/256.0) - 256.0 * floor(floor(iEncodedColor.x/256.0)/256.0);\n                res.z = iEncodedColor.x - 256.0 * floor(iEncodedColor.x/256.0);\n                res.w = iEncodedColor.y;\n                return res;\n            }\n\n            ${h("decodeColor","v4",[c("iEncodedColor")])} {\n\n                ${P("res")} = ${v("unpack_4unorm8_in_4floats","v4",[c("iEncodedColor")])};\n                return res / 255.0;\n            }\n            `},decompress_uvs_pars:function(n){return`\n                ${h("unpack_2unorm16_in_3floats","v3",[c("iEncodedUV")])} {\n                    ${C("res")};\n                    res.x = floor(iEncodedUV.x/256.0);\n                    res.y  = (iEncodedUV.x - 256.0 * floor(iEncodedUV.x / 256.0)) * 256.0;\n                    res.y += (iEncodedUV.y - 256.0 * floor(iEncodedUV.y / 256.0));\n                    res.z = floor(iEncodedUV.y/256.0);\n                    return res;\n                }\n\n                ${h("decodeUV","v3",[c("iEncodedUV")])} {\n                    ${C("res")} = ${v("unpack_2unorm16_in_3floats","v3",[c("iEncodedUV")])};\n                    return res / 65535.0;\n                }\n            `}}})),define("DS/ShaderBuilders/Commons/ColorShaders",["DS/ShaderBuilders/Commons/DefaultShaders","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a){"use strict";const o="",i=r.ParameterUtils,s=r.FunctionHandler,l=r.BridgeFunctions,u=n=>i.parameterF(n),m=n=>i.parameterV3(n),c=(n,e,t)=>s.declareFunction(n,e,t),$=(n,e,t)=>s.callFunction(n,e,t),p=n=>e.addGlobalUniform(n),d=n=>{var t={uniformName:n};return e.getUniform(t)},f=n=>{var t={uniformName:n};return e.getGlobalUniform(t)},h=n=>{var t={uniformName:n};return e.getObjectUniform(t)},v=n=>e.addPostProUniform(n),g=n=>{var t={uniformName:n};return e.getPostProUniform(t)},x=n=>t.addVarying(n),S=n=>t.getVarying(n,t.ShaderStages.in),y=n=>t.getVarying(n,t.ShaderStages.out),_=(n=null)=>{var e={name:n};return a.float(e)},T=(n=null)=>{var e={name:n};return a.vec3(e)},D=(n=null)=>{var e={name:n};return a.vec4(e)},C=n=>{var e={name:n,constant:!0};return a.float(e)},P=n=>t.getShaderOutput(n),N=(n,e)=>l.modulo(n,e);return{postprocess_pars_fragment:function(n){if(n.gammaOutput&&n.inlinedPostProActivated){let e=v({uniformName:"brightness",uniformType:"f"});return 4===n.inlinedPostProTonemapping?e=`\n                        ${e}\n                        ${v({uniformName:"filmic_1",uniformType:"v4"})} \n                        ${v({uniformName:"filmic_2",uniformType:"v3"})} \n                    `:6===n.inlinedPostProTonemapping&&(e=`\n                        ${e}\n                        ${v({uniformName:"crushblacks",uniformType:"f"})} \n                        ${v({uniformName:"burnhighlights",uniformType:"f"})} \n                        ${c("luminance_RGB","f",[m("iColor")])} {\n                            ${T("luminance_weight")} =${T()}(0.176204,0.812985,0.0108109);\n                            return dot(iColor,luminance_weight);\n                        }\n                    `),e}return o},postprocess_fragment:function(n){if(n.gammaOutput&&n.inlinedPostProActivated){let e=`\n                    ${_("powBrightness")} = pow(2.0,${g("brightness")});\n                    ${P("out0")}.x *= powBrightness;\n                    ${P("out0")}.y *= powBrightness;\n                    ${P("out0")}.z *= powBrightness;\n                `;return 4===n.inlinedPostProTonemapping?e=`\n                    ${e}\n                    ${_("A")} = ${g("filmic_1")}.x;\n                    ${_("B")} = ${g("filmic_1")}.y;\n                    ${_("C")} = ${g("filmic_1")}.z;\n                    ${_("D")} = ${g("filmic_1")}.w;\n                    ${_("E")} = ${g("filmic_2")}.x;\n                    ${_("F")} = ${g("filmic_2")}.y;\n                    ${_("W")} = ${g("filmic_2")}.z;\n                    ${D("tmpCol")}  = ${D()}(${P("out0")}.xyz, W);\n                    tmpCol = ((tmpCol*(A*tmpCol+C*B)+D*E)\n                            /(tmpCol*(A*tmpCol+B)+D*F))\n                            -E/F;\n                    tmpCol = tmpCol.xyzw/tmpCol.w;\n                    ${P("out0")}.x = tmpCol.x;\n                    ${P("out0")}.y = tmpCol.y;\n                    ${P("out0")}.z = tmpCol.z;\n                    `:6===n.inlinedPostProTonemapping&&(e=`\n                    ${e}\n                    ${_("saturation")} = 1.0;\n                    ${T("colorCorrection")} = ${T()}(1.0);\n                    ${T("c")} = ${P("out0")}.xyz * colorCorrection;\n                    c *= (c*${g("burnhighlights")}+1.0)/(c+1.0);\n                    c = mix(${T()}(${$("luminance_RGB","f",[m("c")])}),c,saturation);\n                    ${_("intens")} = ${$("luminance_RGB","f",[m("c")])};\n                    if(intens<1.0){\n                        ${_("_crushblacks")} = 2.0* ${g("crushblacks")} +1.0;\n                        intens = sqrt(intens);\n                        ${_("oms2")} = 1.0 - intens;\n                        c.x = c.x*intens + pow(c.x,_crushblacks)*oms2;\n                        c.y = c.y*intens + pow(c.y,_crushblacks)*oms2;\n                        c.z = c.z*intens + pow(c.z,_crushblacks)*oms2;\n                    }\n                    ${P("out0")}.x = c.x;\n                    ${P("out0")}.y = c.y;\n                    ${P("out0")}.z = c.z;\n                    `),e}return o},linear_to_gamma_fragment:function(n){if(n.gammaOutput){var e=P("out0");return n.simpleGamma?`${e} = ${D()}(sqrt(${e}.xyz), ${e}.a);`:`                     \n                    if (${e}.r < 0.0031308) {\n                        ${e}.r = ${e}.r*12.92;  \n                    } else { \n                        ${e}.r = 1.055*pow(${e}.r,1.0/2.4)-0.055; \n                    }\n                    if (${e}.g < 0.0031308) {\n                        ${e}.g = ${e}.g*12.92;  \n                    } else { \n                        ${e}.g = 1.055*pow(${e}.g,1.0/2.4)-0.055; \n                    }\n                    if (${e}.b < 0.0031308) {\n                        ${e}.b = ${e}.b*12.92;  \n                    } else { \n                        ${e}.b = 1.055*pow(${e}.b,1.0/2.4)-0.055; \n                    }\n                    `}return o},color_pars_fragment:function(n){return n.vertexColors?x({varyingName:"vVertexColor",varyingType:"v4"}):o},color_fragment:function(n){return n.objectVertexColors?`         \n                    diffuseToUse = ${S("vVertexColor")}.rgb;\n                    opacityToUse *= ${S("vVertexColor")}.a;\n                `:n.vertexColors?`\n                diffuseToUse *= ${S("vVertexColor")}.rgb;\n                opacityToUse *= ${S("vVertexColor")}.a;\n                `:o},color_pars_vertex:function(n){return n.vertexColors?`\n                    ${n.objectVertexColors?(t={uniformName:"objectColorBufferType",uniformType:"f"},e.addObjectUniform(t)):(n=>e.addUniform(n))({uniformName:"colorBufferType",uniformType:"f"})}\n                    ${x({varyingName:"vVertexColor",varyingType:"v4"})}\n\n                    ${C("VertexColorsFace")} = 1.0;\n                    ${C("VertexColorsRGBA")} = 2.0;\n                    ${C("VertexColorsRGB")} = 3.0;\n                    ${C("VertexColorsA")} = 4.0;\n                    ${C("VertexColorsR")} = 8.0;\n                    ${C("VertexColorsG")} = 16.0;\n                    ${C("VertexColorsB")} = 32.0;\n\n                    ${c("GetVertexColorMult","v3",[m("colorValue")])} {\n                        ${_("colorTypeToUse")};\n                        ${n.objectVertexColors?`colorTypeToUse = ${h("objectColorBufferType")};`:`colorTypeToUse = ${d("colorBufferType")};`}\n                        if (colorTypeToUse <= VertexColorsRGB) {\n                            return colorValue.rgb;\n                        }\n                        ${T("res")} = ${T()}(1.0);\n                        ${_("maskR")} = floor(colorTypeToUse / VertexColorsR);\n                        if (${N("maskR","2.0")} > 0.5) {\n                            res.r = colorValue.r;\n                        }\n                        ${_("maskG")} = floor(colorTypeToUse / VertexColorsG);\n                        if (${N("maskG","2.0")} > 0.5) {\n                            res.g = colorValue.g;\n                        }\n                        ${_("maskB")} = floor(colorTypeToUse / VertexColorsB);\n                        if (${N("maskB","2.0")} > 0.5) {\n                            res.b = colorValue.b;\n                        }\n                        return res;\n                    }\n\n                    ${c("GetVertexAlphaMult","f",[u("alphaValue")])} {\n                        ${_("colorTypeToUse")};\n                        ${n.objectVertexColors?`colorTypeToUse = ${h("objectColorBufferType")};`:`colorTypeToUse = ${d("colorBufferType")};`}\n                        if (colorTypeToUse < VertexColorsRGB) {\n                            return alphaValue;\n                        }\n                        ${_("maskA")}  = floor(colorTypeToUse / VertexColorsA);\n                        if (${N("maskA","2.0")} > 0.5) {\n                            return alphaValue;\n                        }\n                        return 1.0;\n                    }\n\n                `:o;var t},color_vertex:function(n){if(n.vertexColors){var e=`\n                    ${y("vVertexColor")} = ${D()}(\n                        ${$("GetVertexColorMult","v3",[m("color.rgb")])}, \n                        ${$("GetVertexAlphaMult","f",[u("color.a")])}\n                    );\n                `;return n.gammaInput&&(e=`\n                        ${e}\n                        ${y("vVertexColor")} *= ${y("vVertexColor")};\n                    `),e}return o},sRGB_conversion:function(n){return`\n                ${c("convertToLinear","v3",[m("color")])} {\n\n                    ${T("res")};\n\n                    ${n.simpleGamma?"res = color*color;":"\n                        if (color.r < 0.04045) {\n                            res.r = color.r/12.92;  \n                        } else { \n                            res.r = pow((color.r + 0.055)/1.055, 2.4); \n                        };\n                        if (color.g < 0.04045) {\n                            res.g = color.g/12.92;  \n                        } else { \n                            res.g = pow((color.g + 0.055)/1.055, 2.4); \n                        };\n                        if (color.b < 0.04045) {\n                            res.b = color.b/12.92;  \n                        } else { \n                            res.b = pow((color.b + 0.055)/1.055, 2.4); \n                        };\n                        "}\n                    \n                    return res;\n                }\n            \n            `},ao_pars_fragment:function(n){return n.useSSAO?`\n            ${p({uniformName:"invScreenSize",uniformType:"v2"})} \n            ${p({uniformName:"aoTexture",uniformType:"t2"})} \n            ${p({uniformName:"aoParams",uniformType:"v2"})} \n            `:o},__ao_fragment:function(t){return`\n            ${_("aoValue")} = ${l.sample2DTextureLevel((r="aoTexture",a={uniformName:r},e.getGlobalTextureUniform(a)),`${n.getScreenUVs(t)}`,"0.0")}.x;\n            ${_("occ")} = 1.0 - ${f("aoParams")}.x *(1.0 - aoValue);\n            occ = pow(clamp(occ, 0.0, 1.0), ${f("aoParams")}.y);\n            ${t.invisiblePlaneMaterial?`if (${d("smallPlaneSSAO")} < 0.5){occ = 1.0;}`:o}\n            `;var r,a},_ao_fragment:function(n){return`\n            ${this.__ao_fragment(n)}\n            ${P("out0")}.x *= occ;\n            ${P("out0")}.y *= occ;\n            ${P("out0")}.z *= occ;\n            `},ao_fragment:function(n){return n.useSSAO?`\n            if (${P("out0")}.a > 1.0 - 1e-3) {\n                ${this._ao_fragment(n)}\n            }\n            `:o}}})),define("DS/ShaderBuilders/Commons/AlphaShaders",["DS/ShaderBuilders/Commons/DefaultShaders","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils"],(function(n,e){"use strict";let t;const r=n=>e.getShaderOutput(n,t);return{alphatest_fragment:function(n){t=n;var e="";return n.alphaTest&&(e=`\n                ${e}\n                if ( ${r("out0")}.a < ${n.alphaTest.toFixed(5)} ) { discard; }\n                ${n.discardOrOpaque?`${r("out0")}.a = 1.0;`:""}\n            `),n.skipTranspar&&(e=`\n                ${e}\n                if ( ${r("out0")}.a < 1.0 - 1e-3) {discard; }\n            `),e}}})),define("DS/ShaderBuilders/Commons/EnvMapShaders",["DS/ShaderBuilders/Commons/DefaultShaders","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a){"use strict";const o="",i=r.ParameterUtils,s=r.FunctionHandler,l=r.BridgeFunctions,u=n=>i.parameterV2(n),m=n=>i.parameterT2(n),c=(n,e,t)=>s.callFunction(n,e,t),$=n=>e.addUniform(n),p=n=>{var t={uniformName:n};return e.getUniform(t)},d=n=>{var t={uniformName:n};return e.getTextureUniform(t)},f=n=>{var t={uniformName:n};return e.getGlobalUniform(t)},h=n=>t.addVarying(n),v=n=>t.getVarying(n,t.ShaderStages.in),g=n=>t.getVarying(n,t.ShaderStages.out),x=n=>t.getShaderOutput(n),S=(n=null)=>{var e={name:n};return a.float(e)},y=(n=null)=>{var e={name:n};return a.vec2(e)},_=(n=null)=>{var e={name:n};return a.vec3(e)},T=(n=null)=>{var e={name:n};return a.vec4(e)},D=n=>{var e={name:n,constant:!0};return a.float(e)};return{envmap_pars_fragment:function(e){let t=o;return(e.mapHDR||e.envMapHDR)&&(t=`\n                ${t}\n                ${$({uniformName:"mapHDRSize",uniformType:"v2"})} \n                ${$({uniformName:"envMapHDRSize",uniformType:"v2"})} \n                ${$({uniformName:"envMapHDRToMipsRatio",uniformType:"f"})} \n                ${n.ibl_sample_methods(e)}\n            `),e.envMap&&(t=`\n                ${t}\n                ${D("PI")} = 3.1415926535898;\n                ${D("INV_PI")} = 0.31830988618;\n                ${$({uniformName:"reflectivity",uniformType:"f"})} \n                ${$({uniformName:"combine",uniformType:"i"})} \n            `,t=1===e.envMapping||2===e.envMapping?`\n                    ${t}\n                    ${$({uniformName:"envMap",uniformType:"t2"})} \n                    ${$({uniformName:"ambienceMatrix",uniformType:"m4"})} \n                    ${$({uniformName:"envMapExposureSpecular",uniformType:"f"})} \n                    ${$({uniformName:"envMapExposureDiffuse",uniformType:"f"})} \n                `:`\n                    ${t}\n                    ${$({uniformName:"envMap",uniformType:"tc"})} \n                `,t=e.bumpMap||e.normalMap?`\n                    ${t}\n                    ${$({uniformName:"useRefract",uniformType:"i"})} \n                    ${$({uniformName:"refractionRatio",uniformType:"f"})} \n                    ${e.refractionRatioMap?$({uniformName:"refractionRatioMap",uniformType:"t2"}):o}\n                `:`\n                    ${t}\n                    ${h({varyingName:"vReflect",varyingType:"v3"})}\n                `),t},envmap_fragment:function(n){if(!n.envMap)return o;let e=`${_("reflectVec")};`;e=n.bumpMap||n.normalMap?`\n                ${e}\n                ${_("cameraToVertex")}  = normalize( ${v("vWorldPosition")} - ${f("cameraPosition")} );\n                ${_("worldNormal")}  = normalize( ( ${T()}( normal, 0.0 ) * ${f("viewMatrix")} ).xyz );\n                if ( ${p("useRefract")} > 0 ) {\n                    reflectVec = refract( cameraToVertex, worldNormal, ${n.refractionRatioMap?`${l.sample2DTexture(d("refractionRatioMap"),"uvToUse")}.r`:`${p("refractionRatio")}`} );\n                } else {\n                    reflectVec = reflect( cameraToVertex, worldNormal );\n                }\n            `:`\n                ${e}\n                reflectVec = ${v("vReflect")};\n            `,e=`\n            ${e}\n            ${_("flipReflectVec")} ;\n            ${S("flipNormal")}  = 1.0;\n            flipReflectVec = flipNormal * reflectVec;\n        `;const t=d("envMap");var r,a;return 1===n.envMapping||2===n.envMapping?1===n.envMapping?(e=`\n                    ${e}\n                    flipReflectVec = ${_()}(flipReflectVec.y, flipReflectVec.z, flipReflectVec.x);\n                    flipReflectVec = (${p("ambienceMatrix")}*vec4(flipReflectVec,0.0)).xyz;\n                    ${S("probeR")}  = INV_PI * acos( flipReflectVec.z ) / length(flipReflectVec.xy);\n                `,e=n.envMapHDR?`\n                        ${e}\n                        ${y("texelSizeEnvMap")} = ${y()}(1.0 / ${p("envMapHDRSize")});\n                        ${T("cubeColor")}  = ${c("texture2DBilinearIBL","v4",[m(t),u(" 0.5 * (probeR * flipReflectVec.xy + 1.0)"),u(`${p("envMapHDRSize")}`),u("texelSizeEnvMap")])};\n                    `:`\n                        ${e}\n                        ${T("cubeColor")} = ${l.sample2DTexture(t,"0.5 * (probeR * flipReflectVec.xy + 1.0)")};\n                    `):(e=`\n                    ${e}\n                    flipReflectVec = (${p("ambienceMatrix")}*${T()}(flipReflectVec,0.0)).xyz;\n                    ${S("phi")} = ${r="flipReflectVec.y",a="flipReflectVec.x",l.atan2(r,a)};\n                    ${S("theta")} = acos(flipReflectVec.z);\n                `,e=n.envMapHDR?`\n                        ${e}\n                        ${y("texelSizeEnvMap")}  = ${y()}(1.0 / ${p("envMapHDRSize")});\n                        ${T("cubeColor")} = ${p("envMapExposureSpecular")} * ${c("texture2DBilinearIBL","v4",[m(t),u(`${y()}(0.5 + 0.5 * INV_PI * phi, 1.0 - INV_PI * theta)`),u(`${p("envMapHDRSize")}`),u("texelSizeEnvMap")])};\n                    `:`\n                        ${e}\n                        ${T("cubeColor")} = ${p("envMapExposureSpecular")} * ${l.sample2DTexture(t,`${y()}(0.5 + 0.5 * INV_PI * phi, 1.0 - INV_PI * theta)`)};\n                    `):e=`\n                ${e}\n                ${T("cubeColor")} = ${l.sampleCubeTexture(t,"flipReflectVec")};\n            `,e=`\n            ${e}\n            ${_("finalColor")}  = ${x("out0")}.xyz;\n            if ( ${p("combine")} == 1 ) {\n                finalColor = mix( ${x("out0")}.xyz, cubeColor.xyz, specularStrength * ${p("reflectivity")} );\n            } else if ( ${p("combine")} == 2 ) {\n                finalColor += cubeColor.xyz * specularStrength * ${p("reflectivity")};\n            } else {\n                finalColor= mix( ${x("out0")}.xyz, ${x("out0")}.xyz * cubeColor.xyz, specularStrength * ${p("reflectivity")} );\n            }\n            ${x("out0")}.x = finalColor.x;\n            ${x("out0")}.y = finalColor.y;\n            ${x("out0")}.z = finalColor.z;\n        `,e},envmap_pars_vertex:function(n){let e=o;return!n.envMap||n.bumpMap||n.normalMap||(e=`\n                ${e}\n                ${h({varyingName:"vReflect",varyingType:"v3"})}\n                ${$({uniformName:"refractionRatio",uniformType:"f"})}\n                ${$({uniformName:"useRefract",uniformType:"i"})}\n                ${n.refractionRatioMap?$({uniformName:"refractionRatioMap",uniformType:"t2"}):o}\n            `),e},envmap_vertex:function(n){let e=o;var t;return!n.envMap||n.bumpMap||n.normalMap||(e=`\n                ${e}\n                ${_("worldNormal")}  = ${c("getModelTransformation","v4",[(t=`${T()}(objectNormal, 0.0)`,i.parameterV4(t))])}.xyz;\n                worldNormal = normalize( worldNormal );\n                ${_("cameraToVertex")}  = normalize( worldPosition.xyz - ${f("cameraPosition")} );\n                if ( ${p("useRefract")} > 0) {\n                    ${g("vReflect")} = refract( cameraToVertex, worldNormal, ${n.refractionRatioMap?`${l.sample2DTexture(d("refractionRatioMap"),"uvToUse")}.r`:`${p("refractionRatio")}`});\n                } else {\n                    ${g("vReflect")} = reflect( cameraToVertex, worldNormal );\n                }\n            `),e}}})),define("DS/ShaderBuilders/Commons/DeferrableShaders",["DS/ShaderBuilders/Commons/DefaultShaders","DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/ShaderUtils/AttributeUtils","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a,o,i){"use strict";const s="",l=o.ParameterUtils,u=o.FunctionHandler,m=o.BridgeFunctions,c=n=>l.parameterF(n),$=n=>l.parameterV2(n),p=n=>l.parameterV3(n),d=n=>l.parameterV4(n),f=(n,e,t)=>u.declareFunction(n,e,t),h=(n,e,t)=>u.callFunction(n,e,t),v=n=>r.addGlobalUniform(n),g=n=>{var e={uniformName:n};return r.getGlobalUniform(e)},x=n=>{var e={uniformName:n};return r.getGlobalTextureUniform(e)},S=n=>r.addObjectUniform(n),y=n=>{var e={uniformName:n};return r.getObjectUniform(e)},_=n=>r.addGlobalStorageBuffer(n),T=n=>r.getGlobalStorageBuffer(n),D=n=>a.addVarying(n),C=n=>a.getVarying(n,a.ShaderStages.in),P=n=>a.getVarying(n,a.ShaderStages.out),N=n=>a.getShaderInput(n),b=n=>a.getShaderOutput(n),M=(n=null)=>{var e={name:n};return i.float(e)},U=(n=null)=>{var e={name:n};return i.vec2(e)},w=(n=null)=>{var e={name:n};return i.vec3(e)},V=(n=null)=>{var e={name:n};return i.vec4(e)},z=n=>{var e={name:n,constant:!0};return i.int(e)},F=n=>{var e={name:n,constant:!0};return i.float(e)},I=(n,e)=>m.modulo(n,e);function R(n){return`\n        \n        ${f("shift_right","f",[c("v"),c("amt")])}{\n            ${M("fv")} = floor(v) + 0.5;\n            return floor(fv / exp2(amt));\n          }\n\n          ${f("shift_left","f",[c("v"),c("amt")])} {\n            return floor(v * exp2(amt) + 0.5);\n          }\n\n          ${f("mask_last","f",[c("v"),c("bits")])} {\n            ${M("shifted")} = ${h("shift_left","f",[c("1.0"),c("bits")])};\n            return ${I("v","shifted")};\n          }\n\n          ${f("extract_bits","f",[c("num"),c("aFrom"),c("to")])} {\n            ${M("fFrom")} = floor(aFrom + 0.5);\n            ${M("fTo")} = floor(to + 0.5);\n            ${M("shifted")}  = ${h("shift_right","f",[c("num"),c("fFrom")])};\n            return ${h("mask_last","f",[c("shifted"),c("fTo - fFrom")])};\n          }\n  \n          ${f("encode_float","v4",[c("val")])} {\n            if (val == 0.0) {\n              return ${V()}(0, 0, 0, 0);\n            }\n            ${M("sign")} = 1.0;\n            if (val > 0.0) {\n                sign = 0.0;\n            }\n            ${M("aVal")} = abs(val);\n            ${M("exponent")}  = floor(log2(aVal));\n            ${M("biased_exponent")}  = exponent + 127.0;\n            ${M("fraction")}  = ((aVal / exp2(exponent)) - 1.0) * 8388608.0;\n            ${M("t")}  = biased_exponent / 2.0;\n            ${M("last_bit_of_biased_exponent")}  = fract(t) * 2.0;\n            ${M("remaining_bits_of_biased_exponent")}  = floor(t);\n            ${M("byte4")}  = ${h("extract_bits","f",[c("fraction"),c("0.0"),c("8.0")])} / 255.0;\n            ${M("byte3")}  = ${h("extract_bits","f",[c("fraction"),c("8.0"),c("16.0")])} / 255.0;\n            ${M("byte2")}  = (last_bit_of_biased_exponent * 128.0 + ${h("extract_bits","f",[c("fraction"),c("16.0"),c("23.0")])}) / 255.0;\n            ${M("byte1")}  = (sign * 128.0 + remaining_bits_of_biased_exponent) / 255.0;\n            return  ${V()}(byte4, byte3, byte2, byte1);\n          }\n        `}return{picking_pars_vertex:function(n){return n.materialToUse===e.MaterialToUse.pickingMaterial&&n.specialPickingInstancing?D({varyingName:"pickingColor",varyingType:"v3"}):s},picking_vertex:function(n){return n.materialToUse===e.MaterialToUse.pickingMaterial&&n.specialPickingInstancing?`${P("pickingColor")} = specialMeshPicking;`:s},picking_pars_fragment:function(n){return n.materialToUse===e.MaterialToUse.pickingMaterial?n.specialPickingInstancing?D({varyingName:"pickingColor",varyingType:"v3"}):S({uniformName:"pickingColor",uniformType:"v3"}):s},picking_fragment:function(n){return n.materialToUse===e.MaterialToUse.pickingMaterial?n.specialPickingInstancing?`${b("out0")} = ${V()}( ${C("pickingColor")}, 1.0 );`:`${b("out0")} = ${V()}( ${y("pickingColor")}, 1.0 );`:s},picking_instancing_pars_vertex:function(n){return n.materialToUse===e.MaterialToUse.pickingMaterialInstancing?D({varyingName:"vInstancePickingColor",varyingType:"v3"}):s},picking_instancing_vertex:function(n){return n.materialToUse===e.MaterialToUse.pickingMaterialInstancing?`\n            if (instanceId > 16777215.0) {\n                ${P("vInstancePickingColor")} = ${w()}(0.0);\n            } else {\n                ${P("vInstancePickingColor")} .r = floor(instanceId / 65536.0);\n                ${P("vInstancePickingColor")} .g = floor((instanceId - ${P("vInstancePickingColor")} .r * 65536.0) / 256.0);\n                ${P("vInstancePickingColor")} .b = floor(instanceId - ${P("vInstancePickingColor")} .r * 65536.0 - ${P("vInstancePickingColor")} .g * 256.0);\n                ${P("vInstancePickingColor")}  /= 255.0;\n            }\n            `:s},picking_instancing_pars_fragment:function(n){return n.materialToUse===e.MaterialToUse.pickingMaterialInstancing?D({varyingName:"vInstancePickingColor",varyingType:"v3"}):s},picking_instancing_fragment:function(n){return n.materialToUse===e.MaterialToUse.pickingMaterialInstancing?`${b("out0")} = ${V()}(${C("vInstancePickingColor")} , 1.0);`:s},depth_pars_vertex:function(n){switch(n.materialToUse){case e.MaterialToUse.depthMaterial:case e.MaterialToUse.depthRGBAMaterial:case e.MaterialToUse.normalDepthMaterial:case e.MaterialToUse.normalDepthIoRRoughnessMaterial:case e.MaterialToUse.decalNormalStencilDepthMaterial:return n.isDecal?s:D({varyingName:"clipPos_Deferred",varyingType:"v4"});default:return s}},depth_vertex:function(n){switch(n.materialToUse){case e.MaterialToUse.depthMaterial:case e.MaterialToUse.depthRGBAMaterial:case e.MaterialToUse.normalDepthMaterial:case e.MaterialToUse.normalDepthIoRRoughnessMaterial:case e.MaterialToUse.decalNormalStencilDepthMaterial:return n.isDecal?s:`${P("clipPos_Deferred")} = ${b("position")};`;default:return s}},depth_pars_fragment:function(n){switch(n.materialToUse){case e.MaterialToUse.depthMaterial:case e.MaterialToUse.depthRGBAMaterial:case e.MaterialToUse.normalDepthMaterial:case e.MaterialToUse.normalDepthIoRRoughnessMaterial:case e.MaterialToUse.decalNormalStencilDepthMaterial:var t="";return n.isDecal||(t=`\n                        ${t}\n                        ${D({varyingName:"clipPos_Deferred",varyingType:"v4"})}\n                    `),n.materialToUse!==e.MaterialToUse.depthMaterial&&n.materialToUse!==e.MaterialToUse.depthRGBAMaterial||(t=`\n                            ${t}\n\n                            ${R()}\n      \n                            ${f("packRGBAFace","v4",[c("depth")])} {\n                                ${M("depthToUse")} = depth;\n                                ${n.extDerivatives?`\n                                ${M("dx")} = ${r="depth",m.dpdx(r)};\n                                ${M("dy")} = ${(n=>m.dpdy(n))("depth")};\n\n                                depthToUse += sqrt(dx*dx + dy*dy) + DEPTH_PRECISION;\n                                `:"depthToUse += 2.0 *DEPTH_PRECISION;"}\n                                return ${h("packRGBA","v4",[c("depthToUse")])};\n                            }\n                        `),t;default:return s}var r},depth_fragment_face:function(n){switch(n.materialToUse){case e.MaterialToUse.depthMaterial:case e.MaterialToUse.depthRGBAMaterial:var t=n.materialToUse===e.MaterialToUse.depthRGBAMaterial;return`\n                        ${n.isDecal?`\n                            ${t?`${V("encode")} = ${h("packRGBAFace","v4",[c("_decalDepth")])};`:`${V("encode")} = ${h("encode_float","v4",[c("_decalDepth")])};`}\n                            `:`\n                            ${M("depthValue")} = ${m.setDepthWithConvention(`${C("clipPos_Deferred")}.z / ${C("clipPos_Deferred")}.w`)};\n                            ${t?`${V("encode")}  = ${h("packRGBAFace","v4",[c("depthValue")])};`:`${V("encode")}  = ${h("encode_float","v4",[c("depthValue")])};`}\n                            `}\n                    ${b("out0")} = encode;\n                    `;default:return s}},depth_fragment:function(n){switch(n.materialToUse){case e.MaterialToUse.depthMaterial:case e.MaterialToUse.depthRGBAMaterial:var t=n.materialToUse===e.MaterialToUse.depthRGBAMaterial;return`       \n                    ${M("depthValue")} = ${m.setDepthWithConvention(`${C("clipPos_Deferred")}.z / ${C("clipPos_Deferred")}.w`)};\n                    ${t?`${V("encode")}  = ${h("packRGBA","v4",[c("depthValue")])};`:`${V("encode")}  = ${h("encode_float","v4",[c("depthValue")])};`}\n                    ${b("out0")} = encode;\n                    `;default:return s}},normal_fragment:function(n){return n.materialToUse===e.MaterialToUse.normalMaterial?`\n                ${b("out0")}.x = normal.x * 0.5 + 0.5;\n                ${b("out0")}.y = normal.y * 0.5 + 0.5;\n                ${b("out0")}.z = normal.z * 0.5 + 0.5;\n            `:s},lineic_normal_fragment:function(n){return n.materialToUse===e.MaterialToUse.normalMaterial?`\n                ${b("out0")}.x = 0.5;\n                ${b("out0")}.y = 0.5;\n                ${b("out0")}.z = 0.5;\n            `:s},decal_normal_depth_pars_fragment:function(n){let t=s;return t=`\n                ${t}\n                ${n.materialToUse===e.MaterialToUse.decalNormalStencilDepthMaterial?S({uniformName:"decalStencilValue",uniformType:"f"}):s}\n            `,t},normal_depth_fragment:function(n){switch(n.materialToUse){case e.MaterialToUse.normalDepthMaterial:case e.MaterialToUse.normalDepthIoRRoughnessMaterial:case e.MaterialToUse.decalNormalStencilDepthMaterial:var t=n.materialToUse===e.MaterialToUse.decalNormalStencilDepthMaterial,r=n.materialToUse===e.MaterialToUse.normalDepthMaterial,a=`            \n                ${n.isDecal?`${b("out0")}.w = _decalDepth;`:`\n                        ${M("depthValue")} = ${m.setDepthWithConvention(`${C("clipPos_Deferred")}.z / ${C("clipPos_Deferred")}.w`)};\n                        ${b("out0")}.w = depthValue;\n                        `}\n                    `;return t?a=`\n                            ${a}\n                            ${U("compNormal")} =  ${h("normalToV2Oct22","v2",[p("normal")])};\n                            ${b("out0")}.x = compNormal.x;\n                            ${b("out0")}.y = compNormal.y;\n                            ${b("out0")}.z = ${y("decalStencilValue")};\n                        `:r?(a=`\n                            ${a}         \n                            ${b("out0")}.x = normal.x * 0.5 + 0.5;\n                            ${b("out0")}.y = normal.y * 0.5 + 0.5;\n                            ${b("out0")}.z = normal.z * 0.5 + 0.5;\n                        `,n.renderToFloatTexture||(a=`\n                                ${a}\n                                ${U("compNormal")} =  ${h("normalToV2Oct22","v2",[p("normal")])};\n                                ${b("out0")}.x = compNormal.x;\n                                ${b("out0")}.y = compNormal.y;\n                                ${U("packedForFloat16")} = ${h("packForFloat16","v2",[c(`${b("out0")}.w`)])};\n                                ${b("out0")}.z = packedForFloat16.x;\n                                ${b("out0")}.w = packedForFloat16.y;\n                            `)):a=`\n                            ${a}         \n                            //${U("compNormal")} =  ${h("normalToV2Oct22","v2",[p("normal")])};\n                            //${b("out0")}.x = compNormal.x;\n                            //${b("out0")}.y = compNormal.y;\n                            ${b("out0")}.x = ${h("normalToFOct24","f",[p("normal")])};\n                            ${n.dspbr||n.specgloss?`\n                                ${M("iorToUse")} = 0.0;\n                                ${M("roughnessToUse")} = materialData.roughness;\n                                ${n.useTransparency?`\n                                    ${n.dspbr?`\n                                        ${n.thinWalled?"\n                                            if (materialData.transparency > 0.0 && materialData.metalness < 1.0) {\n                                                iorToUse = 1.0;\n                                            }\n                                            ":"\n                                            if (materialData.transparency > 0.0 && materialData.metalness < 1.0) {\n                                                iorToUse = materialData.adjustedIoR;\n                                            }\n                                            "}\n                                        `:"\n                                        if (materialData.transparency > 0.0 && materialData.metalness < 1.0) {\n                                            iorToUse = 1.0;\n                                        }\n                                        "}\n                                    `:s}\n                                ${b("out0")}.y = iorToUse;\n                                ${b("out0")}.z = roughnessToUse;\n                                //${b("out0")}.z = roughnessToUse + 10.0 * floor(min(iorToUse * 1e3, 1e6));\n                                `:`                \n                                ${b("out0")}.y = 0.0;\n                                ${b("out0")}.z = 0.0;\n                                `}\n                        `,a;default:return s}},lineic_normal_depth_fragment:function(n){return n.materialToUse===e.MaterialToUse.decalNormalStencilDepthMaterial?`   \n                    // no normals             \n                    ${b("out0")}.x = 0.0;\n                    ${b("out0")}.y = 0.0;\n                    // stencil id 0\n                    ${b("out0")}.z = 0.0;    \n                         \n                    ${b("out0")}.w = ${m.setDepthWithConvention(`${C("clipPos_Deferred")}.z / ${C("clipPos_Deferred")}.w`)};\n                  `:s},shadowmap_pars_fragment:function(n){return n.materialToUse===e.MaterialToUse.shadowMapDepthMaterial?`\n                ${f("pack_depth_esm","v4",[c("depth")])}{\n                    ${n.uintESM?`\n                        ${M("esmDepth")}= exp(80.0*depth);\n                        ${M("exposant")} = ceil(log(esmDepth)/log(10.0));\n                        ${M("normDepth")} = esmDepth/pow(10.0,exposant);\n                        return ${V()}(${h("packRGB","v3",[c("normDepth")])},exposant/255.0);\n                        `:`return ${V()}(exp(80.0*depth),0.0,0.0,1.0);`}\n                }\n\n                ${f("pack_depth","v4",[c("depth")])}{\n                    return ${h("packRGBA","v4",[c("depth")])};\n                }\n            `:s},shadowmap_fragment:function(n){return n.materialToUse===e.MaterialToUse.shadowMapDepthMaterial?`\n                ${n.subsurface?s:`\n                        if (${b("out0")}.a < 1.0 - 1e-3) {\n                            discard;\n                        }\n                        `}\n                    ${V("finalData")} ;\n                    ${n.isDecal?`${M("depth")} = _decalDepth;`:`${M("depth")} = ${N("fragCoord")}.z;`}\n                    ${n.shadowMapType===e.ESMImprovedShadowMap||n.shadowMapType===e.ESMShadowMap?`finalData = ${h("pack_depth_esm","v4",[c("depth")])};`:`finalData = ${h("pack_depth","v4",[c("depth")])};`}\n            \n                    ${b("out0")} = finalData;\n            `:n.materialToUse===e.MaterialToUse.transparentShadowMaterial&&n.subsurface?"discard;":s},highlight_pars_vertex:function(n){return n.materialToUse===e.MaterialToUse.highlightMaterial&&n.politeHighlight?`\n                ${D({varyingName:"clipPos_Deferred",varyingType:"v4"})}\n            `:s},highlight_vertex:function(n){return n.materialToUse===e.MaterialToUse.highlightMaterial&&n.politeHighlight?`\n                ${P("clipPos_Deferred")} = ${b("position")};\n            `:s},highlight_pars_fragment:function(n){if(n.materialToUse!==e.MaterialToUse.highlightMaterial)return s;var t="";return t=n.mobileHL?`\n                ${t}\n                ${v({uniformName:"iHighlightLineicColor",uniformType:"v4"})} \n                ${v({uniformName:"iHighlightColor",uniformType:"v4"})} \n                ${v({uniformName:"iHighlightIntensity",uniformType:"v2"})} \n            `:`\n                ${t}\n                ${v({uniformName:"highlightID",uniformType:"f"})} \n            `,n.politeHighlight&&(t=`\n                ${t}\n                ${D({varyingName:"clipPos_Deferred",varyingType:"v4"})}\n                ${n.noZObject||!n.useDepthForPoliteHighlight?`\n                        ${n.noZObject?`${z("noZ")} = 2;`:`${z("noZ")} = 1;`}\n                        `:`${z("noZ")} = 0;`}\n                    ${v({uniformName:"rgbaDepth",uniformType:"t2"})} \n\n                    ${F("highlightBack")} = 0.66;\n                    ${F("highlightFront")} = 0.33;\n\n                    ${f("depthSampleTest","f",[$("coord"),c("depth")])}{\n                        ${V("sampledTexture")}  = ${m.sample2DTexture(x("rgbaDepth"),"coord")};\n                        ${M("fDepth")}  = ${h("unpackRGBA","f",[d("sampledTexture")])};\n                        if ( fDepth  < depth) { return highlightBack; }\n                        return highlightFront;\n                    }\n\n                    ${f("getDepthTestResult","f",[c("depth"),d("clipPos")])}{\n                        ${U("coord")} = 0.5 + 0.5*clipPos.xy/clipPos.w;\n                        ${m.uvConvention("coord")}\n                        return ${h("depthSampleTest","f",[$("coord"),c("depth - 2.38418579e-7")])};\n                    }\n\n                    ${f("getFaceDepthValue","f",[d("clipPos")])}{\n                        if (noZ > 0) {\n                            return highlightFront;\n                        }\n                        ${n.isDecal?`${M("depth")} = _decalDepth;`:`\n                            ${M("depth")} = ${m.setDepthWithConvention("clipPos.z / clipPos.w")};\n                            `}\n                        ${M("faceDepth")}  = depth;\n                        ${n.mobileDevice?s:`\n                            ${n.extDerivatives?`\n                                ${M("dx")}  = ${m.dpdx("depth")};\n                                ${M("dy")}  = ${m.dpdy("depth")};\n                                ${n.mobileHL?"faceDepth += 0.5 * (sqrt(dx*dx + dy*dy) + DEPTH_PRECISION);":"faceDepth += 0.9 * (sqrt(dx*dx + dy*dy) + DEPTH_PRECISION);"}\n                                `:"faceDepth += 1.5 *DEPTH_PRECISION;"}\n                            `}\n                        return ${h("getDepthTestResult","f",[c("faceDepth"),d("clipPos")])};\n                    }\n\n                    ${f("getDepthValue","f",[d("clipPos")])}{\n                        if (noZ > 0) {\n                            return highlightFront;\n                        }\n                        ${M("depth")} = ${m.setDepthWithConvention("clipPos.z / clipPos.w")};\n                        return ${h("getDepthTestResult","f",[c("depth"),d("clipPos")])};\n                    }\n            `),t},highlight_fragment_face:function(n){return n.materialToUse!==e.MaterialToUse.highlightMaterial?s:`\n                ${w("I")} = ${w()}(0.0, 0.0, 1.0);\n                if (!(${g("projectionMatrix")}[3][3] > 0.0)) {\n                    I = normalize( vPos.xyz );\n                }\n                ${M("reflectionFactor")}  = abs( dot( I, normal ) );\n                ${n.politeHighlight?`          \n                    ${M("depthValue")}  = ${h("getFaceDepthValue","f",[d(C("clipPos_Deferred"))])};\n                    if (noZ == 2) {\n                        reflectionFactor = 0.8;\n                    } else if (depthValue < 0.5) {\n                        reflectionFactor = (1.0 - 1.0 / 3.141) * reflectionFactor + 1.0/3.141;\n                    }\n                    ${n.mobileHL?`\n                        ${M("colorA")};\n                        if (depthValue > 0.5) {\n                            colorA = ${g("iHighlightIntensity")}.y;\n                        } else {\n                            colorA = ${g("iHighlightIntensity")}.x;\n                        }\n                        ${b("out0")} = ${V()}( ${g("iHighlightColor")}.xyz * reflectionFactor, colorA);\n                        ${b("out0")}.a = min(${b("out0")}.a, 1.0);\n                        `:`${b("out0")} = ${V()}( ${g("highlightID")} / 255.0, reflectionFactor, depthValue , 0.0 );`}\n                    `:`\n                    reflectionFactor = 1.0 - reflectionFactor;\n                    ${n.mobileHL?`\n                        ${b("out0")} = ${V()}( ${g("iHighlightColor")}.xyz, (0.6 * reflectionFactor*reflectionFactor + 0.2)* ${g("iHighlightIntensity")}.x );\n                        ${b("out0")}.a = min(${b("out0")}.a, 1.0);\n                        `:`${b("out0")} = ${V()}( ${g("highlightID")} / 255.0, reflectionFactor * reflectionFactor , 0.0, 0.0 );`}\n                    `}\n            `},highlight_fragment_edge:function(n){return n.materialToUse!==e.MaterialToUse.highlightMaterial?s:`\n            ${n.politeHighlight?`\n                ${n.mobileHL?`\n                        ${n.wideLine?`\n                            ${M("colorA")};\n                            if (${h("getHalfWidth","f",[])} > 0.5) {\n                                colorA = 0.8;\n                            } else {\n                                colorA = 1.0;\n                            }\n                            ${b("out0")} = ${V()}( ${g("iHighlightLineicColor")}.xyz, colorA);\n                            `:`${b("out0")} = ${V()}(  ${g("iHighlightLineicColor")}.xyz, 1.0);`}   \n                        ${b("out0")}.a = min(${b("out0")}.a, 1.0);\n                    `:`\n                        ${M("wValue")}  = 1.0 / 255.0;\n                        ${n.primitiveHighlight?"wValue = 2.0 / 255.0;":s}\n                        ${n.adjacenceHighlight?`${b("out0")} = ${V()}( ${g("highlightID")} / 255.0, 1.0, highlightFront , wValue );`:`${b("out0")} = ${V()}( ${g("highlightID")} / 255.0, 1.0, ${h("getDepthValue","f",[d(C("clipPos_Deferred"))])} , wValue );`}\n                        `}\n                    `:`\n                        ${n.mobileHL?`\n                                ${b("out0")} = ${V()}(  ${g("iHighlightLineicColor")}.xyz, 0.8 * ${g("iHighlightIntensity")}.x );\n                                ${b("out0")}.a = min(${b("out0")}.a, 1.0);\n                            `:`              \n                                ${M("wValue")} = 1.0 / 255.0;\n                                ${b("out0")} = ${V()}( ${g("highlightID")} / 255.0, 1.0 , 0.0, wValue );\n                            `}\n                    `}\n          `},highlight_fragment_point:function(n){return n.materialToUse!==e.MaterialToUse.highlightMaterial?s:`\n            ${n.mobileHL?`\t\t\n                ${n.politeHighlight?`       \n                    ${b("out0")} = ${V()}(  ${g("iHighlightLineicColor")}.xyz, 0.8);\n                    `:`\n                    ${b("out0")} = ${V()}(  ${g("iHighlightLineicColor")}.xyz, 0.8 * ${g("iHighlightIntensity")}.x );\n                    `}\n                ${b("out0")}.a = min(${b("out0")}.a, 1.0);\n                `:`\n                ${M("wValue")}= 3.0 / 255.0;\n                ${n.politeHighlight?`\n                    ${n.primitiveHighlight?`\t\n                        wValue = 4.0 / 255.0;\n                        ${b("out0")} = ${V()}( ${g("highlightID")} / 255.0, 1.0 , ${h("getDepthValue","f",[d(C("clipPos_Deferred"))])}, wValue );\n                        `:`${b("out0")} = ${V()}( ${g("highlightID")} / 255.0, 1.0 , 0.0, wValue);`}\n                    `:`\n                    ${b("out0")} = ${V()}( ${g("highlightID")} / 255.0, 1.0 , 0.0, wValue );\n                    `}\n                `}\n          `},texcoord_pars_vertex:function(n){return n.materialToUse===e.MaterialToUse.texCoordMaterial?`\n                    ${D({varyingName:"vUv_deferred",varyingType:"v2"})}\n                    ${D({varyingName:"vUv2_deferred",varyingType:"v2"})}\n                `:s},texcoord_vertex:function(n){return n.materialToUse===e.MaterialToUse.texCoordMaterial?`\n                    ${P("vUv_deferred")} = uv.xy;\n                    ${P("vUv2_deferred")} = uv2.xy;\n                `:s},texcoord_pars_fragment:function(n){return n.materialToUse===e.MaterialToUse.texCoordMaterial?`\n                    ${D({varyingName:"vUv_deferred",varyingType:"v2"})}\n                    ${D({varyingName:"vUv2_deferred",varyingType:"v2"})}\n                `:s},texcoord_fragment:function(n){return n.materialToUse===e.MaterialToUse.texCoordMaterial?`\n                    ${b("out0")} = ${V()}(  ${C("vUv_deferred")}.x,  ${C("vUv_deferred")}.y , ${C("vUv2_deferred")}.x,  ${C("vUv2_deferred")}.y);\n                `:s},_debug_common_pars_fragment:function(n){let e=s;return e=`\n                    ${e}\n                    ${((n=null)=>{var e={name:n,addressSpace:"private"};return i.vec4(e)})("debug_color")} = ${V()}(0.0, 0.0, 0.0, 1.0);\n                    ${((n=null)=>{var e={name:n,addressSpace:"private"};return i.bool(e)})("debug_color_set")} = false;\n                `,e},_debug_common_face_fragment:function(n){var r=s;return n.depthDebugMaterial&&(r=`\n                    ${r}\n                    ${b("out0")}.a = 1.0;\n                    ${b("out0")}.r = ${N("fragCoord")}.z;\n                    ${b("out0")}.g = ${N("fragCoord")}.z;\n                    ${b("out0")}.b = ${N("fragCoord")}.z;\n                `),n.normalDebugMaterial&&(r=`\n                    ${r}\n                    ${b("out0")}.a = 1.0;\n                    ${w("transfoNormal")} = 0.5 * normalize((${V()}(normal.xyz, 0.0) * ${g("viewMatrix")}).xyz) + 0.5;\n                    ${b("out0")}.r = transfoNormal.x;\n                    ${b("out0")}.g = transfoNormal.y;\n                    ${b("out0")}.b = transfoNormal.z;\n                `),n.shadowMapDebugMaterial&&(r=`\n                    ${r}\n                    ${b("out0")}.a = 1.0;\n                    ${n.dspbr||n.specgloss?s:"discard;"}\n                `),n.geomUVDebug&&(r=`\n                    ${r}                   \n                    ${b("out0")}.a = 1.0;\n                    ${n.useUV?`\n                        ${U("origUV")} = ${C("vUv")}.xy;\n                        ${w("uvResult")} = ${w()}(${I("origUV.x","1.0")}, ${I("origUV.y","1.0")}, 0.0);\n                        ${b("out0")}.r = uvResult.x;\n                        ${b("out0")}.g = uvResult.y;\n                        ${b("out0")}.b = uvResult.z;\n                        `:`\n                        ${b("out0")}.r = 0.0;\n                        ${b("out0")}.g = 0.0;\n                        ${b("out0")}.b = 0.0;\n                        `}\n                `),n.mappingUVDebug&&(r=`\n                    ${r}\n                    ${b("out0")}.a = 1.0;\n                    ${n.useUV?`\n                        ${w("uvResult")} = ${w()}(${I("uvToUse.x","1.0")}, ${I("uvToUse.y","1.0")}, 0.0);\n                        ${b("out0")}.r = uvResult.x;\n                        ${b("out0")}.g = uvResult.y;\n                        ${b("out0")}.b = uvResult.z;\n                        `:`\n                        ${b("out0")}.r = 0.0;\n                        ${b("out0")}.g = 0.0;\n                        ${b("out0")}.b = 0.0;\n                        `}\n                `),n.geomUV2Debug&&(r=`\n                    ${r}\n                    ${b("out0")}.a = 1.0;\n                    ${n.useUV&&t._useUv2(n)?`\n                        ${U("origUV2")} = ${C("vUv2")}.xy;\n                        ${w("uvResult")} = ${w()}(${I("origUV2.x","1.0")}, ${I("origUV2.y","1.0")}, 0.0);\n                        ${b("out0")}.r = uvResult.x;\n                        ${b("out0")}.g = uvResult.y;\n                        ${b("out0")}.b = uvResult.z;\n                        `:`\n                        ${b("out0")}.r = 0.0;\n                        ${b("out0")}.g = 0.0;\n                        ${b("out0")}.b = 0.0;\n                        `}\n                `),n.geomUV3Debug&&(r=`\n                    ${r}\n                    ${b("out0")}.a = 1.0;\n                    ${n.useUV&&t._useUv3(n)?`\n                        ${U("origUV3")} = ${C("vUv3")}.xy;\n                        ${w("uvResult")} = ${w()}(${I("origUV3.x","1.0")}, ${I("origUV3.y","1.0")}, 0.0);\n                        ${b("out0")}.r = uvResult.x;\n                        ${b("out0")}.g = uvResult.y;\n                        ${b("out0")}.b = uvResult.z;\n                        `:`\n                        ${b("out0")}.r = 0.0;\n                        ${b("out0")}.g = 0.0;\n                        ${b("out0")}.b = 0.0;\n                        `}\n                `),n.mappingUV2Debug&&(r=`\n                    ${r}\n                    ${b("out0")}.a = 1.0;\n                    ${n.useUV&&t._useUv2(n)?`\n                        ${w("uvResult")} = ${w()}(${I("uv2ToUse.x","1.0")}, ${I("uv2ToUse.y","1.0")}, 0.0);\n                        ${b("out0")}.r = uvResult.x;\n                        ${b("out0")}.g = uvResult.y;\n                        ${b("out0")}.b = uvResult.z;\n                        `:`\n                        ${b("out0")}.r = 0.0;\n                        ${b("out0")}.g = 0.0;\n                        ${b("out0")}.b = 0.0;\n                        `}\n                `),n.mappingUV3Debug&&(r=`\n                    ${r}\n                    ${b("out0")}.a = 1.0;\n                    ${n.useUV&&t._useUv3(n)?`\n                        ${w("uvResult")} = ${w()}(${I("uv3ToUse.x","1.0")}, ${I("uv3ToUse.y","1.0")}, 0.0);\n                        ${b("out0")}.r = uvResult.x;\n                        ${b("out0")}.g = uvResult.y;\n                        ${b("out0")}.b = uvResult.z;\n                        `:`\n                        ${b("out0")}.r = 0.0;\n                        ${b("out0")}.g = 0.0;\n                        ${b("out0")}.b = 0.0;\n                        `}\n                `),n.colorDebugMaterial&&(r=`\n                    ${r}\n                    if (debug_color_set) {\n                        ${b("out0")} = debug_color;\n                    }\n                `),n.aoDebugMaterial&&(r=n.useSSAO?`\n                        ${r}        \n                        if (${b("out0")}.a > 1.0 - 1e-3) {\n                            ${e._ShaderChunk.__ao_fragment(n)}\n                            ${b("out0")}.x = occ;\n                            ${b("out0")}.y = occ;\n                            ${b("out0")}.z = occ;\n                            ${b("out0")}.a = 1.0;\n                        } else {\n                            discard;\n                        }              \n                    `:`\n                        ${r}\n                        if (${b("out0")}.a > 1.0 - 1e-3) {\n                            ${b("out0")}.x = 1.0;\n                            ${b("out0")}.y = 1.0;\n                            ${b("out0")}.z = 1.0;\n                            ${b("out0")}.a = 1.0;\n                        } else {\n                            discard;\n                        } \n                    `),n.oct22NormalDebugMaterial&&(r=`\n                    ${r}      \n                    ${w("transfoNormal")} = 0.5 * normalize((${V()}(normal.xyz, 0.0) * ${g("viewMatrix")}).xyz) + 0.5;\n                    ${U("compNormal")} =  ${h("normalToV2Oct22","v2",[p("transfoNormal")])};\n                    ${b("out0")}.x = compNormal.x / 2047.0;\n                    ${b("out0")}.y = compNormal.y / 2047.0;\n                    ${b("out0")}.z = 1.0;\n                    ${b("out0")}.w = 1.0;\n                `),n.float16DepthDebugMaterial&&(r=`\n                    ${r}                    \n                    ${U("packedForFloat16")} = ${h("packForFloat16","v2",[c(`${N("fragCoord")}.z`)])};\n                    ${b("out0")}.x = packedForFloat16.x / 2047.0;\n                    ${b("out0")}.y = packedForFloat16.y / 2047.0;\n                    ${b("out0")}.z = 1.0;\n                    ${b("out0")}.w = 1.0;\n                `),r},_debug_common_lineic_fragment:function(n){var e=s;return n.depthDebugMaterial&&(e=`\n                    ${e}\n                    ${b("out0")}.a = 1.0;               \n                    ${b("out0")}.r = ${N("fragCoord")}.z;\n                    ${b("out0")}.g = ${N("fragCoord")}.z;\n                    ${b("out0")}.b = ${N("fragCoord")}.z;\n                `),n.normalDebugMaterial&&(e=`\n                    ${e}\n                    ${b("out0")}.a = 1.0;             \n                    ${b("out0")}.r = 0.5;\n                    ${b("out0")}.g = 0.5;\n                    ${b("out0")}.b = 0.5;\n                `),n.colorDebugMaterial&&(e=`\n                    ${e}\n                    if (debug_color_set) {\n                        ${b("out0")} = debug_color;\n                    }\n                `),(n.float16DepthDebugMaterial||n.oct22NormalDebugMaterial||n.shadowMapDebugMaterial||n.geomUVDebug||n.mappingUVDebug||n.geomUV2Debug||n.mappingUV2Debug||n.geomUV3Debug||n.mappingUV3Debug)&&(e=`\n                    ${e}\n                    discard;\n                `),e},oit_pars_vertex:function(n){return n.useOIT?n.materialToUse!==e.MaterialToUse.oitAccumMaterial?s:D({varyingName:"depthOITValue",varyingType:"f"}):s},oit_vertex:function(t){return t.useOIT?t.materialToUse!==e.MaterialToUse.oitAccumMaterial?s:`\n                ${n.getModelViewTransformationChunk(`${V("aux")}`,`${V()}(position_.xyz, 1.0)`,t)}\n                ${P("depthOITValue")} = aux.z;\n                ${M("m22")}  = ${g("projectionMatrix")}[2][2];\n                ${M("m32")}  = ${g("projectionMatrix")}[3][2];\n                ${M("near")}  = m32 / (m22 - 1.0);\n                ${M("far")}  = ((m22 - 1.0)*near)/(m22 + 1.0);\n                ${M("normalizeValue")}  = far + near;\n                ${P("depthOITValue")} /= 0.5*normalizeValue;\n            `:s},oit_vertex_point:function(n){return s},_oit_weighted_accum_pars_fragment:function(n){return`\n                ${D({varyingName:"depthOITValue",varyingType:"f"})}\n                ${f("getOITWeight","f",[c("depthValue"),c("iAlpha")])} {\n                    ${M("distanceTerm")} = 0.3/ (1e-3 + pow(abs(depthValue), 4.0));\n                    distanceTerm = clamp(distanceTerm, 1e-3, 3e3);\n                    return iAlpha * iAlpha * distanceTerm;\n                }\n            `},_oit_weighted_accum_fragment:function(n){return`\n                ${b("out0")} = ${V()}(${b("out0")}.rgb, 1.0)* ${h("getOITWeight","f",[c(C("depthOITValue")),c(`${b("out0")}.a`)])};\n            `},_oit_weighted_reveal_pars_fragment:function(n){return s},_oit_weighted_reveal_fragment:function(n){return`\n                ${b("out0")}.r = ${b("out0")}.a;\n            `},_oit_linked_list_pars_fragment:function(n){return n.WebGPU?`\n                ${v({uniformName:"scissorRect",uniformType:"v4"})}\n                ${v({uniformName:"oitMaxFragments",uniformType:"i"})}\n                ${v({uniformName:"oitOpaqueDepth",uniformType:n.oitOpaqueUseMSAA?"td2ms":"td2"})}\n\n                // [0]    = atomic fragment counter\n                // [1..n] = linked list head indices\n                ${_({bufferName:"oitLinkedListHeads",bufferType:"array<atomic<u32>>"})}\n\n                // - xy = half-float fragment color\n                // - z  = bit-casted fragment depth\n                // - w  = index of next element\n                ${_({bufferName:"oitLinkedListElements",bufferType:"array<vec4u>"})}\n\n                // Packs a single f32 into f16 (stored in lower 16 bits of a u32)\n                fn f32_to_f16(value: f32) -> u32 {\n                    let bits: u32 = bitcast<u32>(value);\n                    let sign: u32 = (bits >> 16) & 0x8000u;\n                    let exponent: i32 = i32((bits >> 23) & 0xFFu) - 112;\n                    let mantissa: u32 = (bits >> 13) & 0x03FFu;\n\n                    if (exponent <= 0) {\n                        // handle subnormal values and zero\n                        return sign | (mantissa >> u32(-exponent + 1));\n                    }\n                    if (exponent >= 31) {\n                        // handle infinity and NaN\n                        return sign | 0x7C00u | select(0x01u, 0u, mantissa == 0);\n                    }\n                    return sign | (u32(exponent) << 10) | mantissa;\n                }\n\n                // Unpacks 32-bit HDR color to 16-bit (stored in two u32)\n                fn packColor(color: vec4f) -> vec2u {\n                    let r = f32_to_f16(color.r);\n                    let g = f32_to_f16(color.g);\n                    let b = f32_to_f16(color.b);\n                    let a = f32_to_f16(color.a);\n                    return vec2u(r | (g << 16), b | (a << 16));\n                }\n            `:s},_oit_linked_list_fragment:function(n){return n.WebGPU?`\n                let fragCoord = vec2i(${N("fragCoord")}.xy);\n                let fragDepth = ${N("fragCoord")}.z;\n                let fragColor = ${b("out0")};\n\n                // In WebGPU, writing to a storage resource from the fragment shader disables early depth test optimizations. This \n                // forces the depth test to occur after the fragment stage, as opposed to before it. To prevent storing transparent\n                // fragments that are fully occluded by opaque objects, the depth test must be manually performed.\n                let opaqueDepth = textureLoad(${x("oitOpaqueDepth")}, fragCoord, 0);\n                if (opaqueDepth < fragDepth)\n                {\n                    discard;\n                }\n\n                // increment atomic counter and get a free slot where to store fragment data\n                let fragIdx = atomicAdd(&${T("oitLinkedListHeads")}[0], 1u);\n\n                // discard fragment if we run out of space to store it\n                if (fragIdx >= u32(${g("oitMaxFragments")}))\n                {\n                    discard;\n                }\n\n                // chain fragment into the linked list associated with this pixel\n                let pixelIdx = 1 + (fragCoord.y - i32(${g("scissorRect")}.y)) * i32(${g("scissorRect")}.z) + fragCoord.x;\n                let nextElement = atomicExchange(&${T("oitLinkedListHeads")}[pixelIdx], fragIdx);\n\n                // store fragment data in the linked list elements buffer\n                ${T("oitLinkedListElements")}[fragIdx] = vec4u(packColor(fragColor), bitcast<u32>(fragDepth), nextElement);\n          `:s},oit_pars_fragment:function(n){return n.useOIT?n.materialToUse===e.MaterialToUse.oitAccumMaterial?this._oit_weighted_accum_pars_fragment(n):n.materialToUse===e.MaterialToUse.oitRevealMaterial?this._oit_weighted_reveal_pars_fragment(n):n.materialToUse===e.MaterialToUse.oitLinkedListMaterial?this._oit_linked_list_pars_fragment(n):s:s},oit_fragment:function(n){if(!n.useOIT)return s;let t=n.materialToUse===e.MaterialToUse.oitAccumMaterial,r=n.materialToUse===e.MaterialToUse.oitRevealMaterial,a=n.materialToUse===e.MaterialToUse.oitLinkedListMaterial,o=n.materialToUse===e.MaterialToUse.originalMaterial||n.materialToUse===e.MaterialToUse._fakeOriginalMaterial;return`\n                ${t||r||a?`\n                    if (${b("out0")}.a > 1.0 - 1e-2) {\n                        discard;\n                    }\n                    `:`\n                    ${o?`\n                        if (${b("out0")}.a < 1.0 - 1e-2) {\n                            discard;\n                        }\n                        ${b("out0")}.a = 1.0;\n                        `:s}\n                    `}\n                ${t?this._oit_weighted_accum_fragment(n):r?this._oit_weighted_reveal_fragment(n):a?this._oit_linked_list_fragment(n):s}\n            `},oit_fragment_point:function(n){if(!n.useOIT)return s;let t=n.materialToUse===e.MaterialToUse.oitAccumMaterial,r=n.materialToUse===e.MaterialToUse.oitRevealMaterial,a=n.materialToUse===e.MaterialToUse.oitLinkedListMaterial;return t||r||a?"discard;":s},gpupos_pars_vertex:function(n){return n.materialToUse!==e.MaterialToUse.gpuPositionMaterial?s:D({varyingName:"vPos_deferred",varyingType:"v3"})},gpupos_vertex:function(n){return n.materialToUse!==e.MaterialToUse.gpuPositionMaterial?s:`${P("vPos_deferred")} = ${h("getModelTransformation","v4",[p("position_.xyz")])}.xyz;`},gpupos_pars_fragment:function(n){return n.materialToUse!==e.MaterialToUse.gpuPositionMaterial?s:`\n            ${D({varyingName:"vPos_deferred",varyingType:"v3"})}\n            ${n.useMRT?s:v({uniformName:"positionComponent",uniformType:"v3"})}\n\n            ${R()}\n            `},gpupos_fragment:function(n){return n.materialToUse!==e.MaterialToUse.gpuPositionMaterial?s:n.useMRT?`\n              ${w("deferredPos")} = ${C("vPos_deferred")};\n              ${b("out0")} = ${h("encode_float","v4",[c("deferredPos.x")])};\n              ${b("out1")} = ${h("encode_float","v4",[c("deferredPos.y")])};\n              ${b("out2")} = ${h("encode_float","v4",[c("deferredPos.z")])};\n              `:`\n            ${M("component")} = dot(${C("vPos_deferred")}.xyz,${g("positionComponent")});\n            ${b("out0")} = ${h("encode_float","v4",[c("component")])};\n            `}}})),define("DS/ShaderBuilders/Commons/MappingShaders",["DS/ShaderBuilders/Commons/DefaultShaders","DS/ShaderBuilders/ShaderUtils/AttributeUtils","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a,o){"use strict";const i="",s=a.ParameterUtils,l=a.FunctionHandler,u=a.BridgeFunctions,m=n=>s.parameterV2(n),c=n=>s.parameterV3(n),$=n=>s.parameterT2(n),p=(n,e,t)=>l.callFunction(n,e,t),d=n=>t.addUniform(n),f=n=>{var e={uniformName:n};return t.getUniform(e)},h=n=>r.addVarying(n),v=n=>r.getVarying(n,r.ShaderStages.in),g=n=>r.getVarying(n,r.ShaderStages.out),x=(n=null,e="")=>{var t={name:n,addressSpace:e};return o.vec2(t)},S=(n=null)=>x(n,"private"),y=(n=null)=>{var e={name:n};return o.vec4(e)};return{map_pars_varying_declare_vertex_fragment:function(n){return n.useUV||n.usePointUV?`\n                ${h({varyingName:"vUv",varyingType:"v4"})}\n                ${S("uvToUse")};\n                ${e._useUv2(n)?h({varyingName:"vUv2",varyingType:"v4"}):i}\n                ${S("uv2ToUse")};\n                ${e._useUv3(n)?h({varyingName:"vUv3",varyingType:"v4"}):i}\n                ${S("uv3ToUse")};\n                `:i},map_varying_set_vertex:function(n){return n.useUV?`\n                ${g("vUv")} = uv;\n                ${e._useUv2(n)?`${g("vUv2")} = uv2;`:i}\n                ${e._useUv3(n)?`${g("vUv3")} = uv3;`:i}\n                `:i},map_pars_vertex:function(e){return e.useUV||e.usePointUV?`\n                ${this.map_pars_varying_declare_vertex_fragment(e)}\n                ${d({uniformName:"offsetBumpMap",uniformType:"v2"})}\n                ${d({uniformName:"repeatBumpMap",uniformType:"v2"})}\n                ${n.map_pars_vertex_fragment(e)}\n                `:i},map_pars_fragment:function(e){var t=i;return(e.useUV||e.usePointUV)&&(t=`\n                ${t}\n                ${this.map_pars_varying_declare_vertex_fragment(e)}\n                ${n.map_pars_vertex_fragment(e)}\n                `),e.map&&(t=`\n                ${t}\n                ${d({uniformName:"map",uniformType:"t2"})}\n                `),t},map_vertex:function(n){var t=n.mappingType>-1&&!n.mappingUseFragment,r=n.mappingType>-1&&n.mappingUseFragment;if(n.useUV){function a(e,r){return`      \n                        ${e} = ${e} * ${y()}(${f("repeatBumpMap")},1.0,1.0) + ${y()}(${f("offsetBumpMap")},0.0,0.0);\n                        ${n.mappingType>-1?`\n                            ${t?`\n                                ${g("vUv")} = ${p("applyMappingOperator","v4",[(a=r,s.parameterV4(a)),c("position_"),c("normal")])};\n                                `:i}\n                            `:i}\n                    `;var a}return`\n                ${this.map_varying_set_vertex(n)}\n                ${a(g("vUv"),"uv")}\n                ${e._useUv2(n)?a(g("vUv2"),"uv2"):i}\n                ${e._useUv3(n)?a(g("vUv3"),"uv3"):i}\n                ${r?`\n                    ${g("localPosition")}=position_;\n                    ${g("localNormal")}=normal;\n                    `:i}\n                `}return i},uvmapping_fragment:function(n){return n.useUV?`\n                uvToUse = ${v("vUv")}.xy;\n                ${n.mappingType>-1&&!0===n.mappingUseFragment?`uvToUse = ${p("applyMappingOperator","v2",[m("uvToUse"),c(`${v("localPosition")}`),c(`${v("localNormal")}`)])};`:i}\n                `:i},map_fragment:function(n){if(n.map||n.pdsfxUseMap){const a=(e={uniformName:"map"},t.getTextureUniform(e));return`\n                ${y("texelColor")}  = ${y()}(1.0, 1.0, 1.0, 1.0);\n                ${n.map?`\n                    ${n.mapHDR?`\n                        ${x("texelSizeMap")} = ${x()}(1.0 / ${f("mapHDRSize")});\n                        texelColor = ${p("texture2DBilinearRGBE","v4",[$(a),m("uvToUse"),m(`${f("mapHDRSize")}`),m("texelSizeMap")])};\n                        `:`\n                        texelColor = ${u.sample2DTexture(a,"uvToUse")};\n                        ${n.gammaInput?`\n                            ${((n=null)=>{var e={name:n};return o.vec3(e)})("convertedTexelColor")} = ${p("convertToLinear","v3",[c("texelColor.xyz")])};\n                            texelColor.x = convertedTexelColor.x;\n                            texelColor.y = convertedTexelColor.y;\n                            texelColor.z = convertedTexelColor.z;\n                            `:i}\n                        `}\n                    `:i}\n                ${n.phong?`                   \n                    ${(n=>r.getShaderOutput(n))("out0")} *= texelColor;\n                    `:"        \n                    diffuseToUse *= texelColor.rgb;\n                    opacityToUse *= texelColor.a;\n                    "}\n                `}var e;return i}}})),define("DS/ShaderBuilders/Commons/VerticeShaders",["DS/ShaderBuilders/Commons/DefaultShaders","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a){"use strict";const o="",i=e.ParameterUtils,s=e.FunctionHandler,l=e.BridgeFunctions,u=n=>a.dereference(n),m=n=>i.parameterF(n),c=n=>i.parameterV3(n),$=n=>i.parameterInOutV3(n),p=n=>i.parameterRefV3(n),d=(n,e,t)=>s.declareFunction(n,e,t),f=(n,e,t)=>s.callFunction(n,e,t),h=n=>{var e={uniformName:n};return t.getUniform(e)},v=n=>t.addObjectUniform(n),g=(n,e)=>{var r={uniformName:n,uniformIndex:e};return t.getObjectTextureUniform(r)},x=n=>{var e={uniformName:n};return t.getGlobalUniform(e)},S=(n,e)=>e.mappingFromMatApp?(n=>{var e={uniformName:n};return t.getHighFrequencyUniform(e)})(n):h(n),y=(n=null)=>{var e={name:n};return a.int(e)},_=(n=null)=>{var e={name:n};return a.float(e)},T=(n=null)=>{var e={name:n};return a.vec2(e)},D=(n=null,e=0)=>{var t={name:n,size:e};return a.vec3(t)},C=(n=null,e=0)=>{var t={name:n,size:e};return a.vec4(t)},P=(n=null)=>{var e={name:n};return a.mat4(e)},N=n=>{var e={name:n,constant:!0};return a.float(e)},b=n=>r.addVarying(n),M=n=>r.getVarying(n,r.ShaderStages.in),U=n=>r.getVarying(n,r.ShaderStages.out),w=n=>r.getBuiltin(n,r.ShaderStages.out),V=(n,e)=>l.sample2DTextureGrad(n,e);var z=function(n){return n.needTangentBinormal?`\n            ${b({varyingName:"vTangent",varyingType:"v3"})}\n            ${b({varyingName:"vBinormal",varyingType:"v3"})}\n        `:o},F=function(e){return`\n            ${C("mvPosition")} ;\n            ${n.getModelViewTransformationChunk("mvPosition",`${C()}( vertexLocalPosition, 1.0 )`,e)}\n            mvPosition.w = 1.0;\n        `},I=function(n){return`\n        ${f("ProcessViewTangentSpace",null,[(e="TangentSpace",t="_viewTangentSpace",i.parameterRefStruct(e,t))])};\n        mvPosition.x = _viewTangentSpace.Position.x;\n        mvPosition.y = _viewTangentSpace.Position.y;\n        mvPosition.z = _viewTangentSpace.Position.z;\n        ${n.sizeAttenuation?"INTERNAL_backup_sizeForGLPointSize *= INTERNAL_backup_scale / length( mvPosition.xyz );":o}\n        ${n.needTangentBinormal?`\n            ${U("vTangent")} = _viewTangentSpace.Tangent;\n            ${U("vBinormal")} = _viewTangentSpace.Binormal;\n            `:o}\n        `;var e,t};return{tangent_Binormal_pars:z,tangent_Binormal_vertex:function(e){return e.needTangentBinormal?e.gpuTangentBinormal&&!e.displacementMap?o:`\n        ${e.skinning?`\n            ${D("objectTangent")}  = ${D()}(skinMatrix * ${C()}( tangent, 0.0 ));\n            ${D("objectBinormal")}  = ${D()}(skinMatrix * ${C()}( binormal, 0.0 ));\n            `:`\n            ${D("objectTangent")}  = tangent;\n            ${D("objectBinormal")}  = binormal;\n            `}\n        ${D("mvTangent")} ;\n        ${D("mvBinormal")} ;\n        if (use_normal_matrix) {\n            ${n.getNormalMatrixUnitVectorTransformationChunk("mvTangent","objectTangent",e)}\n            ${n.getNormalMatrixUnitVectorTransformationChunk("mvBinormal","objectBinormal",e)}\n        } else {\n            ${n.getModelViewUnitVectorTransformationChunk("mvTangent","objectTangent",e)}\n            ${n.getModelViewUnitVectorTransformationChunk("mvBinormal","objectBinormal",e)}\n        }\n\n        ${U("vTangent")} = mvTangent;\n        ${U("vBinormal")} = mvBinormal;\n\n        ${e.PDSFX?`\n            _viewTangentSpace.Tangent = ${U("vTangent")};\n            _viewTangentSpace.Binormal = ${U("vBinormal")};\n            `:o}\n        `:o},needCheckNaNonTangentBinormal:function(n){return n.alphaTest||n.skipTranspar||n.PDSFX||n.isDecal||n.useOIT||n.subsurface},tangent_Binormal_pars_fragment:function(n){var e=`     \n        ${d("getGeomT","v3",[c("N")])} {\n            ${D("normN")}  = normalize(N);\n            ${_("x")} = normN.x;\n            ${_("y")} = normN.y;\n            ${_("z")} = normN.z;\n\n            ${D("T")} = ${D()}(0.0);\n\n            if ( abs(z) > 0.0) {\n                T.y += 0.0;\n                T.x += 1.0;\n                T.z += - x / z;\n                return normalize(T);\n            }\n            if ( abs(y) > 0.0) {\n                T.x += 0.0;\n                T.z += 1.0;\n                T.y += - z / y;\n                return normalize(T);\n            }\n\n            if ( abs(x) > 0.0) {\n                T.z += 0.0;\n                T.y += 1.0;\n                T.x += - y / x;\n                return normalize(T);\n            }\n            return ${D()}(0.0);\n        }\n\n        ${d("getGeomB","v3",[c("N"),c("T")])} {\n            ${D("tmp1")} = normalize(N);\n            ${D("tmp2")} = normalize(T);\n            return normalize(cross(tmp1, tmp2));\n        }\n        `;return n.needTangentBinormal?`\n            ${z(n)}\n\n            ${e}\n\n            ${d("computeGPUTB",null,[c("i_viewPosition"),c("i_normal"),$("io_tangent"),$("io_binormal")])} {\n\n                ${D("p_x")} = ${l.dpdx("-i_viewPosition.xyz")};\n                ${D("p_y")} = ${l.dpdy("-i_viewPosition.xyz")};\n                ${n.useUV?`\n                    ${T("tc_x")} = ${l.dpdx("uvToUse.xy")};\n                    ${T("tc_y")} = ${l.dpdy("uvToUse.xy")};\n\n                ${_("alphaT")} = step(0.00001, abs(tc_x.y) + abs(tc_y.y));\n                ${_("alphaB")} = step(0.00001, abs(tc_x.x) + abs(tc_y.x));\n                ${_("alphaBT")} = 1.0 - max(alphaB, alphaT);\n\n                tc_x.y = alphaT * tc_x.y - (1.0 - alphaT)*(alphaB * tc_y.x);\n                tc_y.y = alphaT * tc_y.y + (1.0 - alphaT)*(alphaB * tc_x.x) + alphaBT;\n\n                tc_x.x = alphaB * tc_x.x - (1.0 - alphaB)*(alphaT * tc_y.y) + alphaBT;\n                tc_y.x = alphaB * tc_y.x + (1.0 - alphaB)*(alphaT * tc_x.y);\n                    `:`\n                    ${T("tc_x")}  = ${T()}(1.0,0.0);\n                    ${T("tc_y")}  = ${T()}(0.0,1.0);\n                    `}\n\n               \n\n                ${u("io_tangent")} = normalize(  p_x * tc_y.y - p_y * tc_x.y );\n                ${u("io_binormal")} = normalize(  p_y * tc_x.x - p_x * tc_y.x);\n\n                ${D("x")} = cross(i_normal,${u("io_tangent")});\n                ${u("io_tangent")} = normalize(cross(x,i_normal));\n                x = cross(${u("io_binormal")},i_normal);\n                ${u("io_binormal")} = normalize(cross(i_normal,x));\n            }\n            ${this.needCheckNaNonTangentBinormal(n)?`${d("isVectorValid","b",[c("vector")])} {\n                    return (( vector.x < 0.0 || 0.0 < vector.x || vector.x == 0.0 ) && ( vector.y < 0.0 || 0.0 < vector.y || vector.y == 0.0 ) && ( vector.z < 0.0 || 0.0 < vector.z || vector.z == 0.0 ) && length(vector)!=0.0);\n                }`:o}\n        `:e},tangent_Binormal_fragment:function(e){if(!e.needTangentBinormal)return o;var t=""+(e.gpuTangentBinormal?f("computeGPUTB",null,[c("viewPositionTB"),c("normalTB"),p("fragmentTangent"),p("fragmentBinormal")])+";":`\n                ${e.PDSFX?"\n                    fragmentTangent =  INTERNAL_varying_viewTangent ;\n                    fragmentBinormal = INTERNAL_varying_viewBinormal ;\n                    ":`\n                    fragmentTangent = ${M("vTangent")};\n                    fragmentBinormal = ${M("vBinormal")};\n                    `}\n                `);return`\n        ${D("fragmentTangent")} ;\n        ${D("fragmentBinormal")} ;\n        ${e.PDSFX?`\n            ${D("viewPositionTB")}  = INTERNAL_computed_viewPosition;\n            ${D("normalTB")}  = INTERNAL_computed_viewNormal;\n            `:`\n            ${e.isDecal?`\n                ${D("viewPositionTB")}  = dViewPosition;\n                ${D("normalTB")}  = decalNormal;\n                `:`\n                ${D("viewPositionTB")} = ${M("vViewPosition")};\n                ${D("normalTB")} = ${M("vNormal")};\n                `}\n            `}\n        ${e.mappingType>-1&&!0===e.mappingUseFragment&&!e.isDecal?`\n            if(${S("mappingType",e)}>0){\n                fragmentTangent = normalize( tangent );\n                fragmentBinormal = normalize( binormal );\n                if (use_normal_matrix){\n                    ${n.getNormalMatrixUnitVectorTransformationChunk("fragmentTangent","fragmentTangent",e)}\n                    ${n.getNormalMatrixUnitVectorTransformationChunk("fragmentBinormal","fragmentBinormal",e)}\n\n                } else {\n\n                    ${n.getModelViewUnitVectorTransformationChunk("fragmentTangent","fragmentTangent",e)}\n                    ${n.getModelViewUnitVectorTransformationChunk("fragmentBinormal","fragmentBinormal",e)}\n                }\n            }else{\n                ${t}\n            }`:t}\n        \n        if(${this.needCheckNaNonTangentBinormal(e)?"!isVectorValid(fragmentTangent) || !isVectorValid(fragmentBinormal)":"dot(fragmentTangent,fragmentTangent)<1e-6 || dot(fragmentBinormal,fragmentBinormal)<1e-6"}){\n            fragmentTangent = ${f("getGeomT","v3",[c("normalTB")])};\n            fragmentBinormal = ${f("getGeomB","v3",[c("normalTB"),c("fragmentTangent")])};\n        }\n\n        tangent = normalize(fragmentTangent);\n        binormal = normalize(fragmentBinormal);\n        `},_worldpos_vertex:function(n){return`\n            ${C("worldPosition")} = ${C()}( vertexLocalPosition, 1.0 );\n            worldPosition = ${f("getModelTransformation","v4",[(e="worldPosition",i.parameterV4(e))])};\n        `;var e},morphtarget_pars_vertex:function(n){return o},morphtarget_vertex:function(n){if(n.morphTargets){var e=`\n                ${D("morphed")} = ${D()}( 0.0 );\n                //morphed += ( morphTarget0 - position_ ) * ${h("morphTargetInfluences")}[ 0 ].x;\n                //morphed += ( morphTarget1 - position_ ) * ${h("morphTargetInfluences")}[ 0 ].y;\n                //morphed += ( morphTarget2 - position_ ) * ${h("morphTargetInfluences")}[ 0 ].z;\n                //morphed += ( morphTarget3 - position_ ) * ${h("morphTargetInfluences")}[ 0 ].w;\n            `;return n.morphNormals||(e=`\n                    ${e}\n                    //morphed += ( morphTarget4 - position_ ) * ${h("morphTargetInfluences")}[ 1 ].x;\n                    //morphed += ( morphTarget5 - position_ ) * ${h("morphTargetInfluences")}[ 1 ].y;\n                    //morphed += ( morphTarget6 - position_ ) * ${h("morphTargetInfluences")}[ 1 ].z;\n                    //morphed += ( morphTarget7 - position_ ) * ${h("morphTargetInfluences")}[ 1 ].w;\n                `),`\n                ${e}\n                morphed += position_;\n             `}return o},morphnormal_vertex:function(n){return n.morphNormals?`\n                ${D("morphedNormal")}  = ${D()}( 0.0 );\n\n                //morphedNormal +=  ( morphNormal0 - normal ) * ${h("morphTargetInfluences")}[ 0 ].x;\n                //morphedNormal +=  ( morphNormal1 - normal ) * ${h("morphTargetInfluences")}[ 0 ].y;\n                //morphedNormal +=  ( morphNormal2 - normal ) * ${h("morphTargetInfluences")}[ 0 ].z;\n                //morphedNormal +=  ( morphNormal3 - normal ) * ${h("morphTargetInfluences")}[ 0 ].w;\n\n                morphedNormal += normal;\n            `:o},skinning_pars_vertex:function(n){if(n.skinning){var e="";if(n.useEulerAngles&&(e=`\n                    ${e}\n                    ${d("getMatrixFromEulerAngles","m4",[c("angles"),c("offset")])}{\n\t\t\t\t\t\t${_("cosx")}  = cos(angles.y);\n\t\t\t\t\t\t${_("cosy")}  = cos(angles.z);\n\t\t\t\t\t\t${_("cosz")}  = cos(angles.x);\n\t\t\t\t\t\t${_("sinx")}  = sin(angles.y);\n\t\t\t\t\t\t${_("siny")}  = sin(angles.z);\n\t\t\t\t\t\t${_("sinz")}  = sin(angles.x);\n\n\t\t\t\t\t\t${_("cosycosz")}  = cosy*cosz;\n\t\t\t\t\t\t${_("sinxsiny")}  = sinx*siny;\n\t\t\t\t\t\t${_("a11")}  = cosycosz - sinxsiny*sinz;\n\t\t\t\t\t\t${_("a12")}  = -cosx*sinz;\n\t\t\t\t\t\t${_("a13")}  = cosz*siny + cosy*sinx*sinz;\n\t\t\t\t\t\t${_("a21")}  = cosz*sinxsiny + cosy*sinz;\n\t\t\t\t\t\t${_("a22")}  = cosx*cosz;\n\t\t\t\t\t\t${_("a23")}  = siny*sinz - cosycosz*sinx;\n\t\t\t\t\t\t${_("a31")}  = -cosx*siny;\n\t\t\t\t\t\t${_("a32")}  = sinx;\n\t\t\t\t\t\t${_("a33")}  = cosx*cosy;\n\t\t\t\t\t\t${P("bone")}  = ${P()}(\n\t\t\t\t\t\t\t\t\t${C()}(a11, a21, a31, 0.0),\n\t\t\t\t\t\t\t\t\t${C()}(a12, a22, a32, 0.0),\n\t\t\t\t\t\t\t\t\t${C()}(a13, a23, a33, 0.0),\n\t\t\t\t\t\t\t\t\t${C()}(offset, 1.0));\n\t\t\t\t\t\treturn bone;\n\t\t\t\t\t}\n                `),n.isMultiInstanced){const t=n.skinningInstancingMapsInfo.lastTextureSizeX.toFixed(1),r=n.skinningInstancingMapsInfo.lastTextureSizeY.toFixed(1),a=n.skinningInstancingMapsInfo.maxTextureSize.toFixed(1),i=n.skinningInstancingMapsInfo.nbBones.toFixed(1);let s=function(){let e="";for(let t=0;t<n.skinningInstancingMapsInfo.nbTextures;t++)e+=`if(texId==${t}){\n                            v0 = ${V(g("skinningInstancingMaps",t),`${T()}(dx * (x + 0.5), dy * (y + 0.5))`)}.xyz;\n                            v1 = ${V(g("skinningInstancingMaps",t),`${T()}(dx * (x + 1.5), dy * (y + 0.5))`)}.xyz;\n                            ${n.useEulerAngles?o:`\n                                v2 = ${V(g("skinningInstancingMaps",t),`${T()}(dx * (x + 2.5), dy * (y + 0.5))`)}.xyz;\n                                v3 = ${V(g("skinningInstancingMaps",t),`${T()}(dx * (x + 3.5), dy * (y + 0.5))`)}.xyz;                      \n                                `}\n                        }`;return e};e=`\n                    ${e}\n                    ${v({uniformName:"skinningInstancingMaps",uniformType:"t2v",size:n.skinningInstancingMapsInfo.nbTextures})} \n\n                    ${d("getBoneMatrix","m4",[m("i")])}{\n\n                        if (i >= 0.0) {\n                            ${_("real_instanceId")}  = instanceId/5.0 -1.0;\n                            ${_("matId")};\n                            ${n.useEulerAngles?`matId = real_instanceId * ${i} * 2.0 + 2.0 * i;`:`matId = real_instanceId * ${i} * 4.0 + 4.0 * i;`}\n                            ${y("texId")}  = ${y()}(floor(matId/(${a}*${a})));\n\n                            ${_("dx")};\n                            ${_("dy")};\n                            ${_("x")};\n                            ${_("y")};\n                            ${_("xyInTex")} = matId - ${_()}(texId) * (${a}*${a});\n                            if (texId == ${n.skinningInstancingMapsInfo.nbTextures} - 1) {\n                                dx = 1.0 / ${t};\n                                dy = 1.0 / ${r};\n                                y = floor(xyInTex/${t});\n                                x = xyInTex - y*${t};\n                            } else {\n                                dx = 1.0 / ${a};\n                                dy = 1.0 / ${a};\n                                y = floor(xyInTex/${a});\n                                x = xyInTex - y*${a};\n                            }\n\n                            ${D("v0")};\n                            ${D("v1")};\n                            ${D("v2")};\n                            ${D("v3")};\n                            ${s()}                       \n                            ${n.useEulerAngles?`\n                                ${D("offset")}  = v0;\n                                ${D("angles")}  = v1;\n                                ${P("bone")}  = ${f("getMatrixFromEulerAngles","m4",[c("angles"),c("offset")])};\n                                `:`${P("bone")}  = ${P()}(${C()}(v0, 0.0), ${C()}(v1, 0.0), ${C()}(v2, 0.0), ${C()}(v3, 1.0));`}\n                            return bone;\n                        } else {\n                            return ${P()}(1.0, 0.0, 0.0, 0.0,\n                                            0.0, 1.0, 0.0, 0.0,\n                                            0.0, 0.0, 1.0, 0.0,\n                                            0.0, 0.0, 0.0, 1.0);\n                        }\n                    }\n                `}else{const s=n.skinningMapWidth.toFixed(1),u=n.skinningMapHeight.toFixed(1),$=(i={uniformName:"skinningMap"},t.getObjectTextureUniform(i));e=`\n                    ${e}\n                    ${v({uniformName:"skinningMap",uniformType:"t2"})} \n                    ${d("getBoneMatrix","m4",[m("i")])}{\n                        if (i >= 0.0) {\n                            ${_("j")};\n                            ${n.useEulerAngles?"j = i * 2.0;":"j = i * 4.0;"}\n                            ${_("x")}  = ${r="j",a=s,l.modulo(r,a)};\n                            ${_("y")}  = floor( j / ${s} );\n\n                            ${N("dx")}  = 1.0 / ${s};\n                            ${N("dy")}  = 1.0 / ${u};\n\n                            y = dy * ( y + 0.5 );\n\n                            ${D("v0")}  = ${V($,`${T()}( dx * ( x + 0.5 ), y )`)}.xyz;\n                            ${D("v1")}  = ${V($,`${T()}( dx * ( x + 1.5 ), y )`)}.xyz;\n                            ${n.useEulerAngles?o:`\n                                ${D("v2")}  = ${V($,`${T()}( dx * ( x + 2.5 ), y )`)}.xyz;\n                                ${D("v3")}  = ${V($,`${T()}( dx * ( x + 3.5 ), y )`)}.xyz;\n                                `}\n\n                            ${n.useEulerAngles?`\n                                ${D("offset")}  = v0;\n                                ${D("angles")}  = v1;\n                                ${P("bone")} = ${f("getMatrixFromEulerAngles","m4",[c("angles"),c("offset")])};\n                                `:`${P("bone")} = ${P()}(${C()}(v0, 0.0), ${C()}(v1, 0.0), ${C()}(v2, 0.0), ${C()}(v3, 1.0));`}\n                            return bone;\n                        } else {\n                            return ${P()}(1.0, 0.0, 0.0, 0.0,\n                                            0.0, 1.0, 0.0, 0.0,\n                                            0.0, 0.0, 1.0, 0.0,\n                                            0.0, 0.0, 0.0, 1.0);\n                        }\n                    }\n                `}return e}var r,a,i;return o},skinbase_vertex:function(n){return n.skinning?`\n                ${P("boneMatX")}  = ${f("getBoneMatrix","m4",[m("skinIndex.x")])};\n                ${P("boneMatY")}  = ${f("getBoneMatrix","m4",[m("skinIndex.y")])};\n                ${P("boneMatZ")}  = ${f("getBoneMatrix","m4",[m("skinIndex.z")])};\n                ${P("boneMatW")}  = ${f("getBoneMatrix","m4",[m("skinIndex.w")])};\n\n                ${P("skinMatrix")}  = skinWeight.x * boneMatX;\n                skinMatrix \t+= skinWeight.y * boneMatY;\n                skinMatrix \t+= skinWeight.z * boneMatZ;\n                skinMatrix \t+= skinWeight.w * boneMatW;\n            `:o},skinning_vertex:function(n){if(n.skinning){var e=`${C("skinned")} = skinMatrix * skinVertex;`;return e=n.morphTargets?`\n                    ${C("skinVertex")}  = ${C()}( morphed, 1.0 );\n                    ${e}\n                `:`\n                    ${C("skinVertex")}  = ${C()}( position_, 1.0 );\n                    ${e}\n                `}return o},skinnormal_vertex:function(n){return n.skinning?n.morphNormals?`${C("skinnedNormal")}  = skinMatrix * ${C()}( morphedNormal, 0.0 );`:`${C("skinnedNormal")}  = skinMatrix * ${C()}( normal, 0.0 );`:o},position_vertex:function(n){var e="\n        ";return n.skinning&&!n.displacementMap&&(e=`\n                ${e}\n                vertexLocalPosition = skinned.xyz;\n            `),n.skinning||!n.morphTargets||n.displacementMap||(e=`\n                ${e}\n                vertexLocalPosition = morphed;\n            `),n.displacementMap&&(e=`\n                ${e}\n                vertexLocalPosition = displacedPosition;\n            `),n.skinning||n.morphTargets||n.displacementMap||(e=`\n                ${e}\n                vertexLocalPosition = position_;\n            `),e},default_vertex:function(n){return`\n        ${F(n)}\n        ${n.PDSFX?`\n            _viewTangentSpace.Position = mvPosition.xyz;      \n            ${I(n)}\n            `:o}\n        ${w("position")} = ${x("projectionMatrix")} * mvPosition;\n        `},default_vertex_with_normal:function(n){return F(n)},defaultnormal_vertex:function(e){const t=f("getModelViewMatrix","m4",[]);return`\n\t\t${D("objectNormal")} ;\n        ${e.skinning&&!e.displacementMap?"objectNormal = skinnedNormal.xyz;":o}\n        \n        ${e.skinning||!e.morphNormals||e.displacementMap?o:"objectNormal = morphedNormal;"}\n\n        ${e.displacementMap?"objectNormal = displacedNormal;":o}\n\n        ${e.skinning||e.morphNormals||e.displacementMap?o:"objectNormal = normal;"}\n        ${e.flipSided?"objectNormal = -objectNormal;":o}\n\n        if (length(objectNormal) < 1e-6) {\n            if (${x("projectionMatrix")}[3][3] > 0.5) {\n                objectNormal = ${D()}(0.0,0.0,1.0);\n            } else {\n                objectNormal = normalize(-mvPosition.xyz);\n            }\n            ${e.billboard||e.fixedSize?`${f("setSimpleNodeData",null,[])};`:o}\n            objectNormal = (${C()}(objectNormal, 0.0) * ${t}).xyz;\n            ${e.billboard?`objectNormal = (${C()}(objectNormal, 0.0) * simpleNodeData.billboardMatrix).xyz;`:o}\n            objectNormal = normalize(objectNormal);\n        }\n\n        ${D("transformedNormal")} ;\n        if (use_normal_matrix) {\n            ${n.getNormalMatrixUnitVectorTransformationChunk("transformedNormal","objectNormal",e)}\n        } else {\n            ${n.getModelViewUnitVectorTransformationChunk("transformedNormal","objectNormal",e)}\n        }\n        transformedNormal = normalize(transformedNormal);\n        ${e.PDSFX?`\n            _viewTangentSpace.Position = mvPosition.xyz;\n            _viewTangentSpace.Normal = transformedNormal;\n            ${I(e)}\n            `:o}\n        ${w("position")} = ${x("projectionMatrix")} * mvPosition;\n        `}}})),define("DS/ShaderBuilders/PBRUtils/PBRShaderBuilderUtils",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a){"use strict";const o="",i=r.ParameterUtils,s=r.FunctionHandler,l=r.BridgeFunctions,u=(n,e)=>i.parameter(n,e),m=n=>i.parameterV2(n),c=n=>i.parameterV3(n),$=(n,e,t)=>s.callFunction(n,e,t),p=n=>e.addUniform(n),d=n=>{var t={uniformName:n};return e.getUniform(t)},f=n=>{var t={uniformName:n};return e.getTextureUniform(t)},h=(n,t)=>t.highFrequencyColors?(n=>e.addHighFrequencyUniform(n))(n):p(n),v=(n,t)=>t.mappingFromMatApp?(n=>{var t={uniformName:n};return e.getHighFrequencyUniform(t)})(n):d(n),g=(n=null)=>{var e={name:n};return a.mat3(e)},x=(n,e)=>l.sample2DTexture(n,e);let S=function(n,t,r){var o,i,s=v("uvSlot",r),l=d(`${n}UvTransform`);return`\n                ${((n=null,e=0)=>{var t={name:n,size:e};return a.vec2(t)})(t)} = uvToUse;\n                if (${s} != 1) {\n                    ${t} = uv2ToUse;\n                }\n                ${r.isDecal?`\n                    if (${o="decalExplicitUv",i={uniformName:o},e.getObjectUniform(i)} == 0) {\n                        ${g("decalUVTransformWithTranslation")} = ${l} * ${g()}(\n                            1.0, 0.0, 0.0,\n                            0.0, 1.0, 0.0,\n                            0.5, 0.5, 1.0\n                        );\n                        ${t} =  ${$("applyUVCombination","v2",[m(t),u("m3","decalUVTransformWithTranslation")])};  \n                    } else {                 \n                        ${t} =  ${$("applyUVCombination","v2",[m(t),u("m3",`${l}`)])};     \n                    }\n                    `:`\n                ${t} =  ${$("applyUVCombination","v2",[m(t),u("m3",`${l}`)])};     \n                `}         \n            `},y=function(n,e){return`\n            ${p({uniformName:e+"MulCoef",uniformType:n})}\n            ${p({uniformName:e+"AddCoef",uniformType:n})}\n        `},_=function(n,e,t){return`\n            ${t?`\n                ${p({uniformName:e+"Map",uniformType:"t2"})}\n                ${p({uniformName:e+"UvTransform",uniformType:"m3"})}\n                `:p({uniformName:e,uniformType:n})}\n        `},T=function(n,e,t,r,a="f"){return r.PDSFX?{backup:`\n                ${n} = ${e};\n            `,solve:` \n                ${e} = ${$(t,a,[])};\n                ${!r.WebGPU&&r.Linux?`\n                    ${e} = mix(${e}, ${n}, 1e-12);\n                    `:o}\n            `}:{backup:o,solve:o}};return{textureSlotString:S,addVec3MADs:function(n){return y("v3",n)},addVec2MADs:function(n){return y("v2",n)},addFloatMADs:function(n){return y("f",n)},addTexturableVec3Uniform:function(n,e){return _("v3",n,e)},addTexturableVec2Uniform:function(n,e){return _("v2",n,e)},addTexturableFloatUniform:function(n,e){return _("f",n,e)},addTexturableFloatHighFrequencyUniform:function(n,e,t){return function(n,e,t,r){return`\n            ${t?`\n                ${p({uniformName:e+"Map",uniformType:"t2"})}\n                ${p({uniformName:e+"UvTransform",uniformType:"m3"})}\n                `:h({uniformName:e,uniformType:n},r)}\n        `}("f",n,e,t)},addPDSFX:T,addColorPDSFX:function(n,e,t,r,a){if(!a.PDSFX)return{backup:o,solve:o};let i=T(n,e,t,a,"v3");return r&&(i.solve=`\n                ${i.solve}\n                if (!all(${l.equal(e,n)})) {\n                    ${e} = ${$("convertToLinear","v3",[c(`${e}`)])};\n                }\n            `),i},addFloatParameterResolution:function(n,e,t,r,s,l,u="r",m=null,c=null,p=!0){const h=l.fromGLTF;let v=e+"UV",g=f(e+"Map"),y=d(e+"MulCoef"),_=d(e+"AddCoef"),T=`${n} = ${x(g,v)}.${u};`;if(m){let e=`${n} = ${x(g,v)}.${m};`;if(c){let t=`${n} = ${x(g,v)}.${c};`;T=`\n                    ${h?`                     \n                        ${2===h?t:e}\n                        `:T}\n                `}else T=`\n                    ${h?e:T}\n                `}return`\n            ${s?((n=null)=>{var e={name:n};return a.float(e)})(n)+";":o}\n            ${t?`\n                ${S(e,v,l)}\n                ${T}\n                `:`\n                ${n} = ${d(e)};\n                `}\n            ${r?`\n                ${p?`\n                    ${n} = ${y} * ${n} + ${_};\n                    `:`\n                    ${n} = ${$("saturate","f",[(D=`${y} * ${n} + ${_}`,i.parameterF(D))])};\n                    `}\n                `:o}\n        `;var D},addColorParameterResolution:function(n,e,t,r,i,s,l,u=!0){let m=e+"UV",p=f(e+"Map"),h=d(e+"MulCoef"),v=d(e+"AddCoef"),g=`${n} = ${x(p,m)}.rgb;`;return`\n            ${s?((n=null,e=0)=>{var t={name:n,size:e};return a.vec3(t)})(n)+";":o}\n            ${t?`\n                ${S(e,m,l)}\n                ${g}\n                ${i?`${n} = ${$("convertToLinear","v3",[c(`${n}.rgb`)])};`:o}\n                `:`\n                ${n} = ${d(e)};\n                `}\n            ${r?`            \n                ${u?`\n                    ${n} = ${h} * ${n} + ${v};\n                    `:`\n                    ${n} = ${$("saturate","v3",[c(`${h} * ${n} + ${v}`)])};\n                    `}\n                `:o}\n        `},addBorderColorGeneric:function(n,e,t,r,a){return`     \n            ${t?`\n                if (${e}.x < 0.0 || ${e}.x > 1.0) {\n                    ${n} = ${d(a)};\n                }\n                `:o}\n            ${r?`\n                if (${e}.y < 0.0 || ${e}.y > 1.0) {\n                    ${n} = ${d(a)};\n                }\n                `:o}\n            `}}})),define("DS/ShaderBuilders/Commons/PDSFX/PDSFXFragmentEntryPointsShaders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/ShaderUtils/AttributeUtils","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a,o){"use strict";const i=a.ParameterUtils,s=n=>i.parameterF(n),l=(n,e,t)=>a.FunctionHandler.declareFunction(n,e,t),u=[],m={__PDSFXComputeCommonValues_FS:function(n,e){return`\n                ${l("ComputeCommonValues",null,[])} {\n                    ${e(n,[])}\n                }\n            `},PDSFXComputeCommonValues_FS:function(n,e){return""},__PDSFXComputeDiscard_FS:function(n,e){return`\n                ${l("ComputeDiscard","b",[])} {\n                    ${e(n,[])}\n                }\n            `},PDSFXComputeDiscard_FS:function(n,e){return"return false;"},__PDSFX_ComputeDiffuseTexel_FS:function(n,e){return`\n                ${l("_ComputeDiffuseTexel","v4",[])} {\n                    ${e(n,[])}\n                }\n            `},PDSFX_ComputeDiffuseTexel_FS:function(n,e){return`\n                return ${((n=null)=>{var e={name:n};return o.vec4(e)})()}(1.0);\n            `},__PDSFXComputeViewPosition_FS:function(n,e){return`\n                ${l("ComputeViewPosition","v3",[])} {\n                    ${e(n,[])}\n                }\n            `},PDSFXComputeViewPosition_FS:function(n,e){return"return INTERNAL_computedvar_viewPosition;"},__PDSFXComputeViewNormal_FS:function(n,e){return`\n                ${l("ComputeViewNormal","v3",[])} {\n                    ${e(n,[])}\n                }\n            `},PDSFXComputeViewNormal_FS:function(n,e){return"return normalize(INTERNAL_computedvar_viewNormal);"},__PDSFXProcessFinalColor_FS:function(n,e){return`\n                ${l("ProcessFinalColor",null,[(t="ioFinalColor",i.parameterInOutV4(t))])} {\n                    ${e(n,["ioFinalColor"])}\n                }\n            `;var t},PDSFXProcessFinalColor_FS:function(n,e){return""},__PDSFXProcessLinePattern_FS:function(n,e){return`\n                ${l("ProcessLinePattern",null,[(t="patternValue",i.parameterInOutF(t)),s("currentDistance")])} {\n                    ${e(n,["patternValue","currentDistance"])}\n                }\n            `;var t},PDSFXProcessLinePattern_FS:function(n,e){return""}};var c=function(n,e,t,r,a=!1){u.push({type:r,name:t,getterName:e}),m["PDSFX"+n+"_FS"]=function(n,e){return`return ${a?"normalize":""}(${t});`},m["__PDSFX"+n+"_FS"]=function(e,t){return`\n                    ${l(n,r,[])} {\n                        ${t(e,[])}\n                    }\n                `}},$=function(n,e,t){c(n,e,t,"f",!1)},p=function(n,e,t,r=!1){c(n,e,t,"v3",r)};return $("ComputeHalfWidth","vGetHalfWidth","INTERNAL_backup_halfWidth"),$("ComputeOpacity","vGetOpacity","_DSopacity_"),$("ComputeTranslucency","vGetTranslucency","INTERNAL_backup_translucency"),$("ComputeThickness","vGetThickness","INTERNAL_backup_thickness"),$("ComputeTransparency","vGetTransparency","INTERNAL_backup_transparency"),$("ComputeRoughness","vGetRoughness","INTERNAL_backup_roughness"),$("ComputeClearcoat","vGetClearcoat","INTERNAL_backup_clearcoat"),$("ComputeClearcoatRoughness","vGetClearcoatRoughness","INTERNAL_backup_clearcoatRoughness"),$("ComputeFlakeCoverage","vGetFlakeCoverage","INTERNAL_backup_flakesCoverage"),$("ComputeFlakeRoughness","vGetFlakeRoughness","INTERNAL_backup_flakesRoughness"),$("ComputeFlakeSize","vGetFlakeSize","INTERNAL_backup_flakesSize"),$("ComputeFlipFlop","vGetFlipFlop","INTERNAL_backup_flipFlop"),$("ComputeSheen","vGetSheen","INTERNAL_backup_sheen"),$("ComputeSheenRoughness","vGetSheenRoughness","INTERNAL_backup_sheenRoughness"),$("ComputeMetallic","vGetMetallic","INTERNAL_backup_metalness"),$("ComputeSpecular","vGetSpecular","INTERNAL_backup_specularContribution"),$("ComputeAnisotropy","vGetAnisotropy","INTERNAL_backup_anisotropy"),$("ComputeAnisotropyRotation","vGetAnisotropyRotation","INTERNAL_backup_anisotropyAngle"),$("ComputeIridescence","vGetIridescence","INTERNAL_backup_iridescence"),$("ComputeIridescenceThickness","vGetIridescenceThickness","INTERNAL_backup_iridescenceThickness"),p("ComputeEmissive","vGetEmissive","INTERNAL_backup_emissive"),p("ComputeSpecularReflectance","vGetSpecularReflectance","INTERNAL_backup_specular"),p("ComputeAlbedo","vGetAlbedo","INTERNAL_backup_diffuse"),p("ComputeClearcoatViewNormal",null,"INTERNAL_backup_clearcoatViewNormal",!0),p("ComputeClearcoatColor","vGetClearcoatColor","INTERNAL_backup_clearcoatColor"),p("ComputeTranslucencyColor","vGetTranslucencyColor","INTERNAL_backup_translucencyColor"),p("ComputeFlakeColor","vGetFlakeColor","INTERNAL_backup_flakesColor"),p("ComputeFlipFlopColor","vGetFlipFlopColor","INTERNAL_backup_flipFlopColor"),p("ComputeSheenColor","vGetSheenColor","INTERNAL_backup_sheenColor"),{PDSFXFragmentEntryPointsShaders:m,__backUpVariablesFragment:u}})),define("DS/ShaderBuilders/PBRUtils/PBRFragmentAnalyticalLightsShaderBuilderUtils",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a){"use strict";const o="",i=t.ParameterUtils,s=t.FunctionHandler,l=t.BridgeFunctions,u=n=>a.dereference(n),m=(n,e)=>i.parameter(n,e),c=n=>i.parameterI(n),$=n=>i.parameterF(n),p=n=>i.parameterV2(n),d=n=>i.parameterV3(n),f=n=>i.parameterInOutV3(n),h=n=>i.parameterRefV3(n),v=n=>i.parameterV4(n),g=(n,e,t)=>s.declareFunction(n,e,t),x=(n,e,t)=>s.callFunction(n,e,t),S=n=>r.getShaderOutput(n),y=n=>r.getVarying(n,r.ShaderStages.in),_=n=>x("saturate","f",[$(n)]),T=n=>`max(${n}, 0.0)`,D=n=>x("vMax","f",[d(n)]),C=n=>x("pow2","f",[$(n)]),P=n=>x("vNormalize","v3",[d(n)]),N=()=>[f("diffuse"),f("specular"),d("L")],b=n=>x("SpecGlossEnergyConservationTerm","f",[d(n)]),M=(n,e,t)=>x("FresnelSchlick","v3",[d(n),d(e),$(t)]),U=(n,e,t,r)=>x("doFullShadowApplication","v3",[d(n),d(e),$(t),v(r)]),w=(n,e)=>x("doShadowApplication","v3",[d(n),$(e)]),V=(n,e,t,r)=>x("doLightingModel",null,[d(n),h(e),h(t),d(r)]),z=(n,e)=>x("TranslucencySpecularModel","v3",[d(n),d(e)]),F=(n,e)=>x("TranslucencyDiffuseModel","v3",[d(n),d(e)]),I=(n,e)=>x("multiSampleTransmittanceFromIndex","v3",[c(n),m("b",e)]),R=n=>e.addObjectUniform(n),A=n=>e.addLightUniform(n),L=n=>{var t={uniformName:n};return e.getLightUniform(t)},B=n=>{var t={uniformName:n};return e.getLightTextureUniform(t)},E=n=>{var t={uniformName:n};return e.getShadowUniform(t)},k=n=>{var t={uniformName:n};return e.getGlobalUniform(t)},O=(n=null)=>{var e={name:n};return a.bool(e)},G=(n=null)=>{var e={name:n};return a.int(e)},H=(n=null)=>{var e={name:n};return a.float(e)},X=(n=null)=>{var e={name:n};return a.vec2(e)},W=(n=null,e=0)=>{var t={name:n,size:e};return a.vec3(t)},j=(n=null,e=0)=>{var t={name:n,size:e};return a.vec4(t)},q=(n=null)=>{var e={name:n};return a.mat3(e)},Z=n=>{var e={name:n,constant:!0};return a.float(e)},Y=n=>{var e={name:n,constant:!0};return a.vec2(e)},J=(n,e)=>l.sample2DTexture(n,e),K=(n,e)=>l.atan2(n,e);let Q,nn,en,tn,rn,an,on,sn,ln;{let cn=function(n,e){return`\n                    ${W("lightColor")}  = ${L("directionalLightColor")}[ ${n} ].xyz;\n            \n                    ${W("diffuse")}   = ${W()}( 0.0 );\n                    ${W("specular")}  = ${W()}( 0.0 );\n\n                    ${j("lDirection")}  = ${k("viewMatrix")} * ${j()}( ${L("directionalLightDirection")}[ ${n} ].xyz, 0.0 );\n                    ${W("lVector")}  = normalize( lDirection.xyz );\n                \n                    ${H("shadowExposure")}  = 1.0;\n                    ${j("transparentExposure")}  = ${j()}(1.0);\n                    ${e.shadowMapEnabled?`\n                        ${e.shadowMapCascade?`${"0"===n?`shadowExposure = ${x("getExposureCascaded","f",[(t="transparentExposure",i.parameterRefV4(t))])};`:o}`:`\n                            if(${n}<SHADOWS_DIR_END){\n                                shadowExposure = ${x("getExposureFromIndex","f",[m("i",`${n}`)])};\n                                ${e.transparentShadowEnabled?`transparentExposure = ${x("getTransparentExposureFromIndex","v4",[m("i",`${n}`)])};`:o}\n                            }\n                            `}\n                        `:o}\n\n                    \n                    ${e.invisiblePlaneMaterial?`\n                        lightColor = ${W()}(${D("lightColor")});\n                        lightNormalizationFactor += lightColor * step(0.0, dot(surfaceData.viewNormal, lVector));\n                        `:o}\n                    ${e.shadowMapEnabled&&e.transparentShadowEnabled?`\n                        ${W("lightColorNoIntensity")}  = ${E("directionalLightColorNoIntensity")}[ ${n} ].xyz;\n                        ${e.invisiblePlaneMaterial?`\n                            lightColorNoIntensity = ${W()}(${D("lightColorNoIntensity")});\n                            `:o}\n                        ${W("E")}  = ${U("lightColor","lightColorNoIntensity","shadowExposure","transparentExposure")};\n                        `:`${W("E")} = ${w("lightColor","shadowExposure")};`}\n\n                    ${V("E","diffuse","specular","lVector")};\n\n                    ${e.subsurface?`\n                        ${O("doThicknessBasedTransmittance")}  = true;\n                        ${e.useMapTransmittance?`\n                            if (${n} < SHADOWS_DIR_END) {\n                                ${W("dirAttenuation")}  = lightColor *  ${I(`${n}`,"true")};\n                                totalTransmissive += dirAttenuation * ${z("lVector","materialData.transparentColor")};\n                                ${e.dspbrWithTranslucency?`totalTransmissive += materialData.translucency * dirAttenuation * ${F("lVector","materialData.translucencyColor")};`:o}\n                                doThicknessBasedTransmittance = false;\n                            }\n                            `:o}\n                        ${e.thicknessBasedTransmittance?`\n                            if (doThicknessBasedTransmittance) {\n                                ${W("dirAttenuation")} = lightColor *  materialData.transmittanceColor;\n                                totalTransmissive += dirAttenuation * ${z("lVector","materialData.transparentColor")};\n                                ${e.dspbrWithTranslucency?`totalTransmissive += materialData.translucency * dirAttenuation * ${F("lVector","materialData.translucencyColor")};`:o}\n                            }\n                            `:o}\n                        `:`\n                        ${e.dspbrWithTranslucency?`totalTransmissive += materialData.translucency * lightColor * ${F("lVector","materialData.translucencyColor")};`:o}\n                        `}\n\n                    totalDiffuse += diffuse ;\n                    totalSpecular += specular;\n            `;var t},$n=function(n){return`\n            ${A({uniformName:"directionalLightColor",uniformType:"fv4",size:n.maxDirLights})}    \n            ${A({uniformName:"directionalLightDirection",uniformType:"fv4",size:n.maxDirLights})}\n        `},pn=function(n){return n.shadowMapEnabled&&n.shadowMapCascade?`\n                {\n                    ${cn("0",n)}\n                }\n                ${n.maxDirLights>1?`\n                    for( ${G("i")} = 1; i < ${n.maxDirLights} ; i ++ ) { \n                        ${cn("i",n)}\n                    }\n                    `:o}\n                `:`\n                ${n.maxDirLights>0?`\n                    for( ${G("i")} = 0; i < ${n.maxDirLights} ; i ++ ) { \n                        ${cn("i",n)}\n                    }\n                    `:o}\n                `};Q=function(n){return n.maxDirLights>0?[$n(n),pn(n)]:[o,o]}}{let dn=function(n){return`\n            ${A({uniformName:"directionalIBLLightColor",uniformType:"fv4",size:n.maxDirIBLLights})}  \n            ${A({uniformName:"directionalIBLLightDirection",uniformType:"fv4",size:n.maxDirIBLLights})}  \n        `},fn=function(n){return n.envMap&&n.useMapTransmittance&&!n.shadowMapDebugMaterial?`        \n                    for( ${G("i")} = 0; i < ${n.maxDirIBLLights}; i ++ ) {\n                        ${W("lightColor")}  = ${L("directionalIBLLightColor")}[i].xyz;\n                        if (lightColor.r < 1e-6) {\n                            continue;\n                        }\n                        ${j("lWorldDirection")}  = ${j()}( ${L("directionalIBLLightDirection")}[ i ].xyz, 0.0 );\n                        ${j("lDirection")}  = ${k("viewMatrix")} * lWorldDirection;\n                        ${W("lVector")}  = normalize( lDirection.xyz );\n\n                        ${X("normalUV")}  = ${x("getEnvMapUV","v2",[d("normalize(lWorldDirection.xyz)")])};\n                        ${n.envMapDiffuse?`${H("diffMip")}  = 6.0;`:`${H("diffMip")}  = 5.0;`}\n                        ${X("diffuseUV")}  = ${x("getUVFromMips","v2",[$("diffMip"),p("normalUV"),p("mipsTexelSize")])};\n                        ${j("diffuseColor")}  = ${x("texture2DBilinearIBL","v4",[(e="envMap2",i.parameterT2(e)),p("diffuseUV"),p("mipsSize"),p("mipsTexelSize")])};\n\n                        ${W("E")}  = PI * diffuseColor.rgb * lightColor * ${L("envMapExposureDiffuse")};\n                        if (i + SHADOWS_DIR_IBL_START < SHADOWS_DIR_IBL_END) {\n                            ${W("dirAttenuation")}  =${I("i + SHADOWS_DIR_IBL_START","true")};\n                            totalTransmissive += dirAttenuation * E *  ${z("lVector","materialData.transparentColor")};\n                            ${n.dspbrWithTranslucency?`totalTransmissive += materialData.translucency * dirAttenuation * E * ${F("lVector","materialData.translucencyColor")};`:o}\n                        }    \n                    }\n                `:o;var e};nn=function(n){return n.maxDirIBLLights>0?[dn(n),fn(n)]:[o,o]}}{let hn=function(n){return`\n            ${A({uniformName:"pointLightColor",uniformType:"fv4",size:n.maxPointLights})} \n            ${A({uniformName:"pointLightPosition",uniformType:"fv4",size:n.maxPointLights})} \n        `},vn=function(n){return`\n            for ( ${G("i")} = 0; i < ${n.maxPointLights}; i ++ ) {\n                ${W("diffuse")}  = ${W()}( 0.0 );\n                ${W("specular")}  = ${W()}( 0.0 );\n\n                ${j("lPosition")} = ${k("viewMatrix")} * ${j()}( ${L("pointLightPosition")}[ i ].xyz, 1.0 );\n                ${W("lVector")}  = lPosition.xyz + surfaceData.viewPosition.xyz;\n\n                ${H("lAttenuation")}  = 1.0;\n                if (${L("pointLightColor")}[ i ].w > 0.0){\n                    lAttenuation = 1.0 / (dot(lVector,lVector) * ${L("pointLightPosition")}[ i ].w);\n                }else {\n                    if ( ${L("pointLightPosition")}[ i ].w > 0.0 ) {\n                        lAttenuation = 1.0 - min( ( length( lVector ) / ${L("pointLightPosition")}[ i ].w ), 1.0 );\n                    }\n                }\n                lVector = normalize( lVector );\n                \n                ${H("shadowExposure")} = 1.0;\n                ${j("transparentExposure")} = ${j()}(1.0);\n                ${n.shadowMapCubeEnabled?`\n                    if (i<${n.maxShadowsCube}){\n                        shadowExposure = ${x("getExposureFromIndexCube","f",[m("i","i"),d(y("vWorldPosition"))])};\n                        ${n.transparentShadowEnabled?`transparentExposure =  ${x("getTransparentExposureFromIndexCube","v4",[m("i","i"),d(y("vWorldPosition"))])};`:o}\n                    }\n                    `:o}\n                 ${W("lightColor")} = ${L("pointLightColor")}[ i ].xyz;\n                ${n.invisiblePlaneMaterial?`\n                    lightColor =${W()}(${D("lightColor")});\n                    lightNormalizationFactor += lAttenuation * lightColor * step(0.0, dot(surfaceData.viewNormal, lVector));\n                    `:o}\n                ${n.shadowMapCubeEnabled&&n.transparentShadowEnabled?`\n                    ${W("lightColorNoIntensity")} = ${E("pointLightColorNoIntensity")}[ i ].xyz;\n                    ${n.invisiblePlaneMaterial?`\n                        lightColorNoIntensity =${W()}(${D("lightColorNoIntensity")});\n                        `:o}\n                     ${W("E")} = lAttenuation * ${U("lightColor","lightColorNoIntensity","shadowExposure","transparentExposure")};\n                    `:` ${W("E")} = lAttenuation * ${w("lightColor","shadowExposure")};`}\n\n                ${V("E","diffuse","specular","lVector")};\n\n                ${n.subsurface?`\n                    ${O("doThicknessBasedTransmittance")} = true;\n                    ${n.useCubeTransmittance?`\n                        if (i < ${n.maxShadowsCube}) {\n                            ${W("pointAttenuation")} = lAttenuation * lightColor * \n                                                ${x("multiSampleCubeTransmittanceFromIndex","v3",[c("i"),d("surfaceData.worldPosition")])};\n                            totalTransmissive += pointAttenuation * ${z("lVector","materialData.transparentColor")};\n                            ${n.dspbrWithTranslucency?`totalTransmissive += materialData.translucency * pointAttenuation * ${F("lVector","materialData.translucencyColor")};`:o}\n                            doThicknessBasedTransmittance = false;\n                        }\n                        `:o}\n                    ${n.thicknessBasedTransmittance?`\n                        if(doThicknessBasedTransmittance) {\n                            ${W("pointAttenuation")} = lAttenuation * lightColor * materialData.transmittanceColor;\n                            totalTransmissive += pointAttenuation * ${z("lVector","materialData.transparentColor")};\n                            ${n.dspbrWithTranslucency?`totalTransmissive += materialData.translucency * pointAttenuation * ${F("lVector","materialData.translucencyColor")};`:o}\n                        }\n                        `:o}\n                    `:`\n                    ${n.dspbrWithTranslucency?`totalTransmissive +=  materialData.translucency * lAttenuation * lightColor * ${F("lVector","materialData.translucencyColor")};`:o}\n                    `}\n\n                totalDiffuse += diffuse;\n                totalSpecular += specular;\n            }\n        `};en=function(n){return n.maxPointLights?[hn(n),vn(n)]:[o,o]}}{let gn=function(n){return`\n            ${A({uniformName:"iesLightColor",uniformType:"fv4",size:n.maxIESLights})} \n            ${A({uniformName:"iesLightTexture",uniformType:"t2v",size:n.maxIESLights})} \n            ${A({uniformName:"matrixWorldInv",uniformType:"m4v",size:n.maxIESLights})} \n\n            ${A({uniformName:"iesLightPosition",uniformType:"fv4",size:n.maxIESLights})} \n        `},xn=function(n){let t=o;for(let s=0;s<n.maxIESLights;s++)t=`\n                    {\n\n                    ${W("diffuse")}  = ${W()}( 0.0 );\n                    ${W("specular")}  = ${W()}( 0.0 );\n    \n                    ${j("lPosition")} = ${k("viewMatrix")} * ${j()}( ${L("iesLightPosition")}[ ${s} ].xyz, 1.0 );\n                    ${W("lVector")} = lPosition.xyz + surfaceData.viewPosition.xyz;\n    \n                    ${H("lAttenuation")}  = 1.0;\n                    if (${L("iesLightColor")}[ ${s} ].w > 0.0){\n                        lAttenuation = 1.0 / (dot(lVector,lVector) * ${L("iesLightPosition")}[ ${s} ].w);\n                    }else {\n                        if ( ${L("iesLightPosition")}[ ${s} ].w > 0.0 ) {\n                            lAttenuation = 1.0 - min( ( length( lVector ) / ${L("iesLightPosition")}[ ${s} ].w ), 1.0 );\n                        }\n                    }\n    \n                    lVector = normalize( lVector );\n    \n                     ${W("E")} = ${L("iesLightColor")}[ ${s} ].xyz * lAttenuation * PI;\n    \n                    ${j("coordInIESWorld")}  = normalize(${L("matrixWorldInv")}[${s}] * ${j()}(surfaceData.worldPosition,1.0));\n                    ${H("stepTexture")}  = 1.0/128.0*72.0;\n                    ${H("phi")}  = acos(-coordInIESWorld.z)*INV_PI;\n                    ${H("theta")}  = ${x("myAtan2","f",[$("coordInIESWorld.x"),$("-coordInIESWorld.y")])}*INV_PI;\n                    if(theta < 0.0){ theta *= -1.0;};\n                    E *= ${J((r="iesLightTexture",a=s,i=void 0,i={uniformName:r,uniformIndex:a},e.getLightTextureUniform(i)),`${X()}(phi,theta)`)}.x;\n    \n                    ${V("E","diffuse","specular","lVector")};\n                    \n                    ${n.subsurface&&n.thicknessBasedTransmittance?`\n                        ${W("iesAttenuation")} = E * materialData.transmittanceColor;\n                        totalTransmissive += iesAttenuation * ${z("lVector","materialData.transparentColor")};\n                        ${n.dspbrWithTranslucency?`totalTransmissive += materialData.translucency * iesAttenuation * ${F("lVector","materialData.translucencyColor")};`:o} \n                        `:o}  \n                    ${n.dspbrWithTranslucency&&!n.subsurface?`totalTransmissive += materialData.translucency * E * ${F("lVector","materialData.translucencyColor")};`:o}\n    \n                    totalDiffuse  += diffuse;\n                    totalSpecular += specular;\n                    }\n                `;var r,a,i;return t};tn=function(n){return n.maxIESLights&&!n.shadowMapDebugMaterial?[gn(n),xn(n)]:[o,o]}}{let Sn=function(n){return`\n            ${A({uniformName:"spotLightColor",uniformType:"fv4",size:n.maxSpotLights})} \n            ${A({uniformName:"spotLightPosition",uniformType:"fv4",size:n.maxSpotLights})} \n            ${A({uniformName:"spotLightDirection",uniformType:"fv4",size:n.maxSpotLights})} \n            ${A({uniformName:"spotLightPhysicalAttenuation",uniformType:"iv4",size:n.maxSpotLights})} \n        `},yn=function(n){return`\n            for ( ${G("i")} = 0; i < ${n.maxSpotLights}; i ++ ) {\n                ${W("diffuse")}  = ${W()}( 0.0 );\n                ${W("specular")}  = ${W()}( 0.0 );\n\n                ${j("lPosition")} = ${k("viewMatrix")} * ${j()}( ${L("spotLightPosition")}[ i ].xyz, 1.0 );\n                ${W("lVector")} = lPosition.xyz + surfaceData.viewPosition.xyz;\n\n                ${H("lAttenuation")}  = 1.0;\n                if (${L("spotLightPhysicalAttenuation")}[ i ].x> 0){\n                    lAttenuation =1.0 / (dot(lVector,lVector) * ${L("spotLightColor")}[ i ].w );\n                } else {\n                    if ( ${L("spotLightColor")}[ i ].w > 0.0 ) {\n                        lAttenuation = 1.0 - min( ( length( lVector ) / ${L("spotLightColor")}[ i ].w ), 1.0 );\n                    }\n                }\n                lVector = normalize( lVector );\n                ${H("spotEffect")}  = dot( ${L("spotLightDirection")}[ i ].xyz, normalize( ${L("spotLightPosition")}[ i ].xyz - surfaceData.worldPosition ) );\n\n                if ( spotEffect > ${L("spotLightPosition")}[ i ].w ) {\n                \n                    ${H("shadowExposure")} = 1.0;\n                    ${j("transparentExposure")} = ${j()}(1.0);\n                    ${n.shadowMapEnabled?`\n                        if((i + SHADOWS_SPOT_START)<SHADOWS_SPOT_END){\n                            shadowExposure = ${x("getExposureFromIndex","f",[m("i","i + SHADOWS_SPOT_START")])};\n                            ${n.transparentShadowEnabled?`transparentExposure =  ${x("getTransparentExposureFromIndex","v4",[m("i","i + SHADOWS_SPOT_START")])};`:o}\n                        }\n                        `:o}\n\n                    spotEffect = 1.0 - smoothstep( ${L("spotLightDirection")}[ i ].w,${L("spotLightPosition")}[ i ].w,spotEffect );\n\n                     ${W("lightColor")} =  ${L("spotLightColor")}[ i ].xyz;\n                    ${n.invisiblePlaneMaterial?`\n                        lightColor =${W()}(${D("lightColor")});\n                        lightNormalizationFactor += spotEffect * lAttenuation * lightColor * step(0.0, dot(surfaceData.viewNormal, lVector));\n                        `:o}\n                    ${n.shadowMapEnabled&&n.transparentShadowEnabled?`\n                        ${W("lightColorNoIntensity")} = ${E("spotLightColorNoIntensity")}[ i ].xyz;\n                        ${n.invisiblePlaneMaterial?`\n                            lightColorNoIntensity =${W()}(${D("lightColorNoIntensity")});\n                            `:o}\n                         ${W("E")} = spotEffect * lAttenuation * ${U("lightColor","lightColorNoIntensity","shadowExposure","transparentExposure")};\n                        `:` ${W("E")} = spotEffect * lAttenuation * ${w("lightColor","shadowExposure")};`}\n\n                    ${V("E","diffuse","specular","lVector")};\n\n                    ${n.subsurface?`\n                        ${O("doThicknessBasedTransmittance")} = true;\n                        ${n.useMapTransmittance?`\n                            if ((i + SHADOWS_SPOT_START)<SHADOWS_SPOT_END) {\t\t\n                                ${W("spotAttenuation")} = lightColor * lAttenuation * spotEffect *  ${I("i + SHADOWS_SPOT_START","false")};\n                                \n                                totalTransmissive += spotAttenuation * ${z("lVector","materialData.transparentColor")};\n                                ${n.dspbrWithTranslucency?`totalTransmissive += materialData.translucency * spotAttenuation *  ${F("lVector","materialData.translucencyColor")};`:o}\n                                doThicknessBasedTransmittance = false;\n                            }\n                            `:o}\n                        ${n.thicknessBasedTransmittance?`\n                            if (doThicknessBasedTransmittance) {\n                                ${W("spotAttenuation")} = lightColor * lAttenuation * spotEffect * materialData.transmittanceColor;\n                                totalTransmissive += spotAttenuation * ${z("lVector","materialData.transparentColor")};\n                                ${n.dspbrWithTranslucency?`totalTransmissive += materialData.translucency * spotAttenuation * ${F("lVector","materialData.translucencyColor")};`:o}\n                            }\n                            `:o}\n                        `:`\n                        ${n.dspbrWithTranslucency?`totalTransmissive += materialData.translucency * lightColor * lAttenuation * spotEffect *  ${F("lVector","materialData.translucencyColor")};`:o}\n                        `}\n\n                    totalDiffuse += diffuse;\n                    totalSpecular += specular;\n                }\n            }\n        `};rn=function(n){return n.maxSpotLights?[Sn(n),yn(n)]:[o,o]}}{let _n=function(n){return`\n            ${A({uniformName:"rectangleLightColor",uniformType:"fv4",size:n.maxRectangleLights})} \n            ${A({uniformName:"rectangleLightPosition",uniformType:"fv4",size:n.maxRectangleLights})} \n            ${A({uniformName:"rectangleLightNormal",uniformType:"fv4",size:n.maxRectangleLights})} \n            ${A({uniformName:"rectangleLightUp",uniformType:"fv4",size:n.maxRectangleLights})} \n        `},Tn=function(n){return`\n            for (${G("i")} = 0; i < ${n.maxRectangleLights}; i++) {                \n                ${W("transmissive")} = ${W()}(0.0);\n                ${W("diffuse")}  = ${W()}( 0.0 );\n                ${W("specular")}  = ${W()}( 0.0 );\n\n                ${j("lPosition")} = ${k("viewMatrix")} * ${j()}( ${L("rectangleLightPosition")}[ i ].xyz, 1.0 );\n                ${j("lNormal")} = ${k("viewMatrix")} * ${j()}( ${L("rectangleLightNormal")}[ i ].xyz, 0.0 );\t\t\n\n                ${H("hw")}  = 0.5*${L("rectangleLightPosition")}[i].w;\n                ${H("hh")} = 0.5*${L("rectangleLightNormal")}[i].w;\n                ${W("up")} = (${k("viewMatrix")} * ${j()}( ${L("rectangleLightUp")}[i].xyz,0.0)).xyz;\n                ${W("right")} = normalize(cross(lNormal.xyz, up));\n                ${W("p0")} = lPosition.xyz + right * hw - up * hh;\n                ${W("p1")} = lPosition.xyz - right * hw - up * hh;\n                ${W("p2")} = lPosition.xyz - right * hw + up * hh;\n                ${W("p3")} = lPosition.xyz + right * hw + up * hh;\n                ${x("areaRectangleLightModel",null,[h("specular"),h("diffuse"),h("transmissive"),d("p0"),d("p1"),d("p2"),d("p3")])};\n\n                 ${W("lightColor")} = ${L("rectangleLightColor")}[i].xyz;\n                ${H("attenuation")} = ${x("cropRectangleLight","f",[d("lPosition.xyz"),d("p0"),d("p1"),d("p2"),d("p3"),d("surfaceData.viewNormal")])};                   \n                totalDiffuse += attenuation * lightColor * diffuse;\n                totalSpecular += attenuation * lightColor * specular;\n                ${n.subsurface||n.dspbrWithTranslucency?`\n                    totalTransmissive += transmissive * lightColor * ${x("cropRectangleLight","f",[d("lPosition.xyz"),d("p0"),d("p1"),d("p2"),d("p3"),d("-surfaceData.viewNormal")])};\n                    `:o}\n            }\n        `};an=function(n){return n.maxRectangleLights&&!n.shadowMapDebugMaterial?[_n(n),Tn(n)]:[o,o]}}{let Dn=function(n){return`         \n            ${A({uniformName:"diskLightColor",uniformType:"fv4",size:n.maxDiskLights})} \n            ${A({uniformName:"diskLightPosition",uniformType:"fv4",size:n.maxDiskLights})} \n            ${A({uniformName:"diskLightNormal",uniformType:"fv4",size:n.maxDiskLights})} \n            ${A({uniformName:"diskLightUp",uniformType:"fv4",size:n.maxDiskLights})}\n        `},Cn=function(n){return`\n            for (${G("i")} = 0; i < ${n.maxDiskLights}; i++) {\n                ${W("transmissive")} =${W()}(0.0);\n                ${W("diffuse")}  = ${W()}( 0.0 );\n                ${W("specular")}  = ${W()}( 0.0 );\n\n                ${j("lPosition")} = ${k("viewMatrix")} * ${j()}( ${L("diskLightPosition")}[ i ].xyz, 1.0 );\n                ${j("lNormal")} = ${k("viewMatrix")} * ${j()}( ${L("diskLightNormal")}[ i ].xyz, 0.0 );\n                ${H("radius")} = ${L("diskLightPosition")}[i].w;\n                ${W("up")} = (${k("viewMatrix")} * ${j()}( ${L("diskLightUp")}[i].xyz,0.0)).xyz;\n                ${W("right")} = normalize(cross(lNormal.xyz, up));\n                ${W("p0")} = lPosition.xyz + right * radius - up * radius;\n                ${W("p1")} = lPosition.xyz - right * radius - up * radius;\n                ${W("p2")} = lPosition.xyz - right * radius + up * radius;\n                ${x("areaDiskLightModel",null,[h("specular"),h("diffuse"),h("transmissive"),d("p0"),d("p1"),d("p2")])};\n                ${H("attenuation")} = ${x("cropDiskLight","f",[d("lPosition.xyz"),d("p0"),d("p1"),d("surfaceData.viewNormal")])};\n\n                 ${W("lightColor")} = ${L("diskLightColor")}[i].xyz;\n                totalDiffuse += attenuation * lightColor*diffuse;\n                totalSpecular += attenuation * lightColor*specular;\n                ${n.subsurface||n.dspbrWithTranslucency?`\n                    totalTransmissive += transmissive * lightColor*${x("cropDiskLight","f",[d("lPosition.xyz"),d("p0"),d("p1"),d("-surfaceData.viewNormal")])};\n                    `:o}\n            }\n        `};on=function(n){return n.maxDiskLights&&!n.shadowMapDebugMaterial?[Dn(n),Cn(n)]:[o,o]}}{let Pn=function(n){return`\n            ${A({uniformName:"sphereLightColor",uniformType:"fv4",size:n.maxSphereLights})} \n            ${A({uniformName:"sphereLightPosition",uniformType:"fv4",size:n.maxSphereLights})} \n            ${A({uniformName:"sphereLightData",uniformType:"fv4",size:n.maxSphereLights})} \n        `},Nn=function(n){return`\n            for (${G("i")} = 0; i < ${n.maxSphereLights} ; i++) {\n                ${W("transmissive")} =${W()}(0.0);\n                ${W("diffuse")}  = ${W()}( 0.0 );\n                ${W("specular")}  = ${W()}( 0.0 );\n\n                ${W("lPosition")} = (${k("viewMatrix")} * ${j()}( ${L("sphereLightPosition")}[ i ].xyz, 1.0 )).xyz;\t\t\n                ${H("radius")} =  ${L("sphereLightPosition")}[i].w;\n                ${W("p0")};\n                ${W("p1")};\n                ${W("p2")};\n                ${x("getSphereLightPoints",null,[h("lPosition"),$("radius"),h("p0"),h("p1"),h("p2")])};\n                ${x("areaDiskLightModel",null,[h("specular"),h("diffuse"),h("transmissive"),d("p0"),d("p1"),d("p2")])};\n                ${H("attenuation")} = ${x("cropDiskLight","f",[d("lPosition"),d("p0"),d("p1"),d("surfaceData.viewNormal")])};\n                \n                 ${W("lightColor")} = ${L("sphereLightColor")}[i].xyz;\n                totalDiffuse += attenuation * lightColor*diffuse;\n                totalSpecular += attenuation * lightColor*specular;\n                ${n.subsurface||n.dspbrWithTranslucency?`\n                    totalTransmissive += transmissive * lightColor* ${x("cropDiskLight","f",[d("lPosition"),d("p0"),d("p1"),d("-surfaceData.viewNormal")])};\n                    `:o}\n            }\n        `};sn=function(n){return n.maxSphereLights&&!n.shadowMapDebugMaterial?[Pn(n),Nn(n)]:[o,o]}}{let bn=function(n){return`    \n            ${A({uniformName:"tubeLightColor",uniformType:"fv4",size:n.maxTubeLights})} \n            ${A({uniformName:"tubeLightPosition",uniformType:"fv4",size:n.maxTubeLights})} \n            ${A({uniformName:"tubeLightRight",uniformType:"fv4",size:n.maxTubeLights})} \n        `},Mn=function(n){const e=(n,e,t,r,a,o,i)=>x("illuminanceTube","f",[d(n),d(e),d(t),d(r),d(a),$(o),$(i)]);return`\n            for (${G("i")} = 0; i < ${n.maxTubeLights} ; i++) {\n                ${W("diffuse")}  = ${W()}( 0.0 );\n                ${W("specular")}  = ${W()}( 0.0 );\n\n                ${j("lPosition")} = ${k("viewMatrix")} * ${j()}( ${L("tubeLightPosition")}[ i ].xyz, 1.0 );\n                ${H("lRadius")} = ${L("tubeLightPosition")}[i].w;\n                ${H("lWidth")} = ${L("tubeLightRight")}[i].w;\n                ${W("lRight")}  = (${k("viewMatrix")} * ${j()}( ${L("tubeLightRight")}[i].xyz,0.0)).xyz;\n                ${W("P0")}  = lPosition.xyz - lRight * lWidth * 0.5;\n                ${W("P1")}  = lPosition.xyz + lRight * lWidth * 0.5;\n\n                ${W("lightColor")} = ${L("tubeLightColor")}[i].xyz;\n                ${W("E")} = lightColor * ${e("P0","P1","lPosition.xyz","surfaceData.viewNormal","lRight","0.5*lWidth","lRadius")};\n                ${W("closestPoint")}  = ${x("closestPointTube","v3",[d("P0"),d("P1"),d("viewReflect"),d("lPosition.xyz"),$("lRadius")])};\n                ${x("doAreaLightingModel",null,[d("E"),h("diffuse"),h("specular"),d("closestPoint")])};\n\n                ${n.subsurface&&n.thicknessBasedTransmittance?`\n                    ${W("tubeAttenuation")}  = lightColor * ${e("P0","P1","lPosition.xyz","-surfaceData.viewNormal","lRight","0.5*lWidth","lRadius")}  * materialData.transmittanceColor;\n                    totalTransmissive += tubeAttenuation * ${x("_TranslucencySpecularModel","v3",[d("closestPoint"),d("materialData.transparentColor")])};\n                    ${n.dspbrWithTranslucency?`totalTransmissive += materialData.translucency * tubeAttenuation * ${x("_TranslucencyDiffuseModel","v3",[d("closestPoint"),d("materialData.translucencyColor")])};`:o}   \n                    `:o} \n                ${n.dspbrWithTranslucency&&!n.subsurface?`totalTransmissive += materialData.translucency * lightColor * ${e("P0","P1","lPosition.xyz","-surfaceData.viewNormal","lRight","0.5*lWidth","lRadius")} * ${x("_TranslucencyDiffuseModel","v3",[d("closestPoint"),d("materialData.translucencyColor")])};`:o}\n\n                totalDiffuse += diffuse;\n                totalSpecular += specular;\n            }\n        `};ln=function(n){return n.maxTubeLights&&!n.shadowMapDebugMaterial?[bn(n),Mn(n)]:[o,o]}}let un,mn;{function Un(n,e,t,r,a,o,i){for(var s=[d(e),d(t),d(r),m("m3",a)],l=0;l<o.length;l++)s.push(d(o[l]));return x(n,"f",s)}let wn=function(n,e,t){function r(t,r,a,o){return Un(n,t,r,a,o,e)}return t.subsurface?`\n                        ${t.specgloss?`${u("diffuse")} *= materialData.scatteringColor;`:`\n                            ${W("baseDiffuseValue")}  = ${u("diffuse")};\n                            ${t.dspbrWithTranslucency?`${u("diffuse")} = mix(${u("diffuse")}, materialData.scatteringColor * baseDiffuseValue, materialData.translucency);`:o}\n                            ${u("diffuse")} = mix(${u("diffuse")}, materialData.scatteringColor * baseDiffuseValue, materialData.transparency);\n                            `}\n                        ${t.thicknessBasedTransmittance?`\n                            ${W("attenuation")}  = materialData.transmittanceColor;\n                            ${t.dspbrWithTranslucency?`${u("transmissive")} = materialData.translucency * materialData.translucencyColor * attenuation * ${r("-N","V","P",`${q()}(1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0)`)} * materialData.diffuseEnergyConservationConstant;`:o}\n                            ${t.dspbr?`${H("fTrans")}  = 1.0 - materialData.specularContribution * ${D("materialData.specularBlendingSR0 * areaData.fresnel.x + areaData.fresnel.y")};`:`${H("fTrans")} = 1.0 - ${D("fresnelCore")};`}\n                            ${u("transmissive")} += attenuation * materialData.transparentColor * fTrans * ${r("-N","coreView","P","areaData.Minv")};\n                            `:o}\n                `:`\n                    ${t.dspbrWithTranslucency?`\n                        ${u("diffuse")} *= (1.0 - materialData.translucency);\n                        ${u("transmissive")} = materialData.translucency * materialData.translucencyColor * ${r("-N","V","P",`${q()}(1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0)`)} * materialData.diffuseEnergyConservationConstant;\n                        `:o}\n            `},Vn=function(n,e,t){if(!t.specGlossFlakes)return o;function r(t,r,a,o){return Un(n,t,r,a,o,e)}return`\n                            ${W("fresnelMetal")}  = metalFlakes.flakesSR0Color * areaData.fresnelMetalFlakes.x;\n                            ${W("flakesVal")}  = fresnelMetal * ${r("N","V","P","areaData.MinvMetalFlakes")};\n                            ${H("energyFlakes")}  = ${b("fresnelMetal")};\n                            ${u("specular")} *= energyFlakes;\n                            ${u("diffuse")} *= energyFlakes;\n                            ${u("transmissive")} *= energyFlakes;\n                            ${u("specular")} += flakesVal;\n\n                            fresnelMetal = metal.flakesSR0Color * areaData.fresnelMetal.x;\n                            flakesVal = fresnelMetal * ${r("N","V","P","areaData.MinvMetal")};\n                            energyFlakes = ${b("fresnelMetal")};\n                            ${u("specular")} *= energyFlakes;\n                            ${u("diffuse")} *= energyFlakes;\n                            ${u("transmissive")} *= energyFlakes;\n                            ${u("specular")} += flakesVal;\n\n                            ${t.pearlFlakesActivated?`\n                                fresnelMetal = pearlFlakes.flakesSR0Color * areaData.fresnelPearlFlakes.x;\t\t\t\n                                flakesVal = fresnelMetal * ${r("N","V","P","areaData.MinvPearlFlakes")};\n                                energyFlakes = ${b("fresnelMetal")};\n                                ${u("specular")} *= energyFlakes;\n                                ${u("diffuse")} *= energyFlakes;\n                                ${u("transmissive")} *= energyFlakes;\n                                ${u("specular")} += flakesVal;\n                                `:o}\n            `},zn=function(n,e,t){if(!t.dspbrFlakes)return o;function r(t,r,a,o){return Un(n,t,r,a,o,e)}return`\t\n                    ${W("flakesVal")} = ${W()}(0.0);\n                    if (flakesData.smoothWeight > 0.0) {\n                        flakesVal += flakesData.smoothFlakesColor *  ${r("N","V","P","areaData.MinvMetal")};\n                    }\n                    ${t.dspbrFlakesThreeLayers?`\n                        if (flakesData.stochasticWeight > 0.0) {\n                            flakesVal += flakesData.stochasticHemisphereFlakesColor * ${r("flakesData.stochasticHemisphereFlakesNormal","V","P","areaData.MinvMetalSto")};\n                        }\n                        `:o}\n                    ${t.dspbrFlakesOneLayer?o:`               \n                        if (flakesData.closeupWeight > 0.0) {\n                            flakesVal += flakesData.closeupFlakesColor * ${r("flakesData.closeupFlakesNormal","V","P","areaData.MinvMetalClose")};\n                        }\n                        `}\n                    \n                    ${u("diffuse")} *= flakesData.baseWeight;\n                    ${u("specular")} *= flakesData.baseWeight;\n                    ${u("transmissive")} *= flakesData.baseWeight;\n                    ${u("specular")} += flakesVal;\n            `},Fn=function(n,e,t){if(!t.clearCoat)return o;return`\n                    ${W("fresnelCoat")}  = materialData.clearCoatSR0Color * areaData.fresnelCC.x + materialData.clearCoatSR90Color * areaData.fresnelCC.y;\n                    ${t.dspbr?`\n                        ${H("NcoV")}  = ${T("dot(surfaceData.clearCoatNormal,V)")};\n                        ${W("fresnelCoating")}  = ${M("materialData.clearCoatSR0Color","materialData.clearCoatSR90Color","NcoV")};\n                        ${H("fresnelEnergy")}  = 1.0 - materialData.clearCoat * ${D("fresnelCoating")};\n                        `:`${H("fresnelEnergy")}  = ${b("fresnelCoat")};`}\n                    ${W("coat")} = fresnelCoat * ${r="N",a="V",i="P",s="areaData.MinvCC",Un(n,r,a,i,s,e)};\n                    ${u("diffuse")} *= fresnelEnergy;\n                    ${u("specular")} *= fresnelEnergy;\n                    ${u("transmissive")} *= fresnelEnergy;\n                    ${u("specular")} += materialData.clearCoat * coat;\n            `;var r,a,i,s},In=function(n,e,t){function r(t,r,a,o){return Un(n,t,r,a,o,e)}return`                \n                ${W("coreView")}  = V;\n                ${W("fresnelCore")}  = materialData.sr0Color * areaData.fresnel.x + materialData.sr90Color * areaData.fresnel.y;\n                ${u("specular")} = fresnelCore;\n                ${u("specular")} *= ${r("N","coreView","P","areaData.Minv")};\n\n                ${H("diffuseValue")}  = ${r("N","V","P",`${q()}(1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0)`)};\n                ${t.dspbr?`\n                    ${u("specular")} += diffuseValue * materialData.specularEnergyConservationConstant;\n                    diffuseValue *= materialData.diffuseEnergyConservationConstant;\n                    `:`diffuseValue *= ${b("fresnelCore")};`}\n                ${u("diffuse")} = materialData.diffuseColor * diffuseValue;\n            `},Rn=function(n,e,t){if(!t.sheen||!t.dspbrWithSheenColorRoughness)return o;return`\n                ${W("sheen")}  =${W()}(${r="N",a="V",i="P",s="areaData.MinvSheen",Un(n,r,a,i,s,e)});\n                ${H("sheenBlending")}  = 1.0 - materialData.sheenEnergyConservationConstant;\n                ${u("diffuse")} *= sheenBlending;\n                ${u("specular")} *= sheenBlending;\n                ${u("transmissive")} *= sheenBlending;\n                ${u("specular")} += materialData.sheen * sheen * materialData.sheenColor;\n            `;var r,a,i,s},An=function(n,e,t){if(!t.sheen||t.dspbrWithSheenColorRoughness)return o;return`\n                ${W("sheen")}  =${W()}(${a="N",i="V",s="P",l="areaData.MinvSheen",Un(n,a,i,s,l,e)});\n                ${H("sheenBlending")}  = 1.0 - ${r="1.0-materialData.sheen",x("pow5","f",[$(r)])};\n                diffuse *= PI * sheen * sheenBlending + (1.0 - sheenBlending);\n            `;var r,a,i,s,l},Ln=function(n){return`   \n            ${g("_doCommonLightingModel",null,N())} {   \n                ${n.anisotropy?`${x("CoreModelAniso",null,N())};`:`${x("CoreModel",null,N())};`}\n                ${n.shadowMapDebugMaterial?"return;":o}\n                ${n.sheen?`${x("SheenModel",null,N())};`:o}\n\n                ${n.specGlossFlakes?`${x("SpecGlossFlakesModel",null,N())};`:o}\n                ${n.dspbrFlakes?`${x("DSPBRFlakesModel",null,N())};`:o}\n\n                ${n.clearCoat?`${x("ClearCoatModel",null,N())};`:o}\n            }\n\n            ${g("doShadowApplication","v3",[d("light"),$("shadowExposure")])} {\n                return light*shadowExposure;\n            }\n            \n            ${g("doFullShadowApplication","v3",[d("light"),d("lightColor"),$("shadowExposure"),v("transparentExposure")])}{\n                ${W("intensity")}  = max(light / lightColor,${W()}(0.0));\n                return intensity * min(lightColor,transparentExposure.rgb)*min(shadowExposure,transparentExposure.a);\n            }\n\n            ${g("doLightingModel",null,[d("E"),f("diffuse"),f("specular"),d("L")])} {\n                ${W("N")} = surfaceData.viewNormal;\n                ${W("V")} = surfaceData.view;\n                ${n.shadowMapDebugMaterial?"N = L;":o}\n                ${x("_doCommonLightingModel",null,N())};\n                ${n.invisiblePlaneMaterial?`${W("ENoL")} = PI * E * (step(0.0, dot(N, L)));`:`${W("ENoL")} = E * ${T("dot(N, L)")};`}\n                ${n.shadowMapDebugMaterial?`\n                    ${u("diffuse")} *= ENoL; \n                    ${u("specular")} *= 0.0; \n                    `:`\n                    ${n.subsurface?`\n                        ${W("sssENoL")} = E * ${x("getScattering","v3",[$("dot(N, L)"),$("surfaceData.curvature")])};\n                        ${n.specgloss?`${u("diffuse")} *= sssENoL;`:`\n                            ${W("baseDiffuseValue")} = ${u("diffuse")};       \n                            ${n.dspbrWithTranslucency?`${u("diffuse")} *= mix(ENoL, sssENoL, materialData.translucency);`:`${u("diffuse")} *= ENoL;`}\n                            ${u("diffuse")} = mix(${u("diffuse")}, sssENoL * baseDiffuseValue, materialData.transparency);\n                            `}\n                        `:`\n                        ${n.dspbrWithTranslucency?`${u("diffuse")} *= ENoL * (1.0 - materialData.translucency);`:`${u("diffuse")} *= ENoL;`}\n                        `}\n                    ${u("specular")} *= ENoL;\n                    `}\n               \n              }\n            `},Bn=function(n){const e=[{type:"m3",name:"Minv"},{type:"v2",name:"fresnel"}];n.clearCoat&&(e.push({type:"m3",name:"MinvCC"}),e.push({type:"v2",name:"fresnelCC"})),n.sheen&&e.push({type:"m3",name:"MinvSheen"}),n.specGlossFlakes&&(e.push({type:"m3",name:"MinvMetal"}),e.push({type:"v2",name:"fresnelMetal"}),e.push({type:"m3",name:"MinvMetalFlakes"}),e.push({type:"v2",name:"fresnelMetalFlakes"}),n.pearlFlakesActivated&&(e.push({type:"m3",name:"MinvPearlFlakes"}),e.push({type:"v2",name:"fresnelPearlFlakes"}))),n.dspbrFlakes&&(e.push({type:"m3",name:"MinvMetal"}),e.push({type:"v2",name:"fresnelMetal"}),e.push({type:"m3",name:"MinvMetalSto"}),e.push({type:"v2",name:"fresnelMetalSto"}),e.push({type:"m3",name:"MinvMetalClose"}),e.push({type:"v2",name:"fresnelMetalClose"}));const t=B("precomputedAreaTexture");return`\n            ${a.createStruct({structName:"areaLightingData",attributes:e})}\n            ${a.struct({name:"areaData",structName:"areaLightingData",addressSpace:"private"})};\n                \n            ${Z("AREA_LIGHT_LUT_SIZE")}  = 128.0;\n            ${Z("AREA_LIGHT_LUT_UV_NORMALIZATION")}  = 1.0 / (5.0 * AREA_LIGHT_LUT_SIZE + 4.0);\n            ${Y("AREA_LIGHT_LUT_UV_FACTOR")}  = ${X()}(AREA_LIGHT_LUT_SIZE * AREA_LIGHT_LUT_UV_NORMALIZATION, 1.0);\n            ${Y("AREA_LIGHT_UV_CLAMP_MIN")} = ${X()}(0.5 / 128.0, 0.0);\n            ${Y("AREA_LIGHT_UV_CLAMP_MAX")} = ${X()}(1.0, 1.0) - AREA_LIGHT_UV_CLAMP_MIN;\n            // offsets\n            ${Y("AREA_LIGHT_GGX_START")}  = ${X()}(0.0, 0.0) * AREA_LIGHT_LUT_UV_NORMALIZATION;\n            ${Y("AREA_LIGHT_FRESNEL_FACTOR_START")}  = ${X()}(129.0, 0.0) * AREA_LIGHT_LUT_UV_NORMALIZATION;\n            ${Y("AREA_LIGHT_BECKMANN_START")}  = ${X()}(258.0, 0.0) * AREA_LIGHT_LUT_UV_NORMALIZATION;\n            ${Y("AREA_LIGHT_ESTEVEZ_START")}  = ${X()}(387.0, 0.0) * AREA_LIGHT_LUT_UV_NORMALIZATION;\n            ${Y("AREA_LIGHT_ASHIKMIN_START")}  = ${X()}(516.0, 0.0) * AREA_LIGHT_LUT_UV_NORMALIZATION;\n\n            ${((n=null)=>{var e={name:n,addressSpace:"private"};return a.vec2(e)})("currentAreaFresnel")};\n            ${((n=null)=>{var e={name:n,addressSpace:"private"};return a.mat3(e)})("currentAreaMinv")};\n            ${n.sheen?`\n                ${g("setAreaSheenData",null,[$("roughness"),$("NoV")])}{\n                    ${X("uvAr")} = clamp(${X()}(roughness, 1.0 - sqrt(1.0 - NoV)), AREA_LIGHT_UV_CLAMP_MIN, AREA_LIGHT_UV_CLAMP_MAX) * AREA_LIGHT_LUT_UV_FACTOR;\n                    ${n.useVelvet?`${j("t1")} = ${J(t,"uvAr + AREA_LIGHT_ASHIKMIN_START")};`:o}\n                    ${n.useSoftVelvet?`${j("t1")} = ${J(t,"uvAr + AREA_LIGHT_ESTEVEZ_START")};`:o}\n                    ${n.useSatin?`${j("t1")} = ${J(t,"uvAr + AREA_LIGHT_BECKMANN_START")};`:o}\n                    currentAreaMinv = ${q()}(\n                       ${W()}(t1.x,  0, t1.y),\n                       ${W()}(  0, 1.0,   0),\n                       ${W()}(t1.z,  0, t1.w)\n                    );\n                }\n                `:o}\n            ${g("setAreaGGXData",null,[$("roughness"),$("NoV")])}{\n                ${X("uvAr")} = clamp(${X()}(roughness, 1.0 - sqrt(1.0 - NoV)), AREA_LIGHT_UV_CLAMP_MIN, AREA_LIGHT_UV_CLAMP_MAX) * AREA_LIGHT_LUT_UV_FACTOR;\n                ${j("t1")} = ${J(t,"uvAr + AREA_LIGHT_GGX_START")};\n                ${j("t2")} = ${J(t,"uvAr + AREA_LIGHT_FRESNEL_FACTOR_START")};\n                currentAreaMinv = ${q()}(\n                   ${W()}(t1.x,  0, t1.y),\n                   ${W()}(  0, 1.0,   0),\n                   ${W()}(t1.z,  0, t1.w)\n                );\n                currentAreaFresnel = ${X()}(t2.z,t2.y);\n            }\n            ${g("cropRectangleLight","f",[d("lP"),d("p0"),d("p1"),d("p2"),d("p3"),d("N")])}{\n                ${W("P")} = -surfaceData.viewPosition;\n                ${H("A")}  = dot(${P("lP - P")}, N);\n                ${H("B")}  = dot(${P("p0 - P")}, N);\n                ${H("C")}  = dot(${P("p1 - P")}, N);\n                ${H("D")}  = dot(${P("p2 - P")}, N);\n                ${H("E")}  = dot(${P("p3 - P")}, N);\n                if (max(A, max(B, max(C, max(D,E)))) <= 1e-6) {\n                    return 0.0;\n                }\n                return 1.0;\n            }\n        `},En=function(n){const e=B("precomputedAreaTexture");return`   \n            ${g("IntegrateEdgeVec","v3",[d("v1"),d("v2")])}{     \n                ${H("x")} = dot(v1, v2);\n                ${H("y")}  = abs(x);\n\n                ${H("a")}  = 0.8543985 + (0.4965155 + 0.0145206*y)*y;\n                ${H("b")}  = 3.4175940 + (4.1616724 + y)*y;\n                ${H("v")}  = a / b;\n\n                ${H("theta_sintheta")};\n                if (x > 0.0) {\n                    theta_sintheta = v;\n                } else {\n                    theta_sintheta = 0.5*${l.inverseSqrt("1.0 - x*x")} - v;\n                }\n                return cross(v1, v2)*theta_sintheta;\n            }\n\n            ${g("areaRectangleLight","f",[d("N"),d("V"),d("P"),m("m3","Minv"),d("p0"),d("p1"),d("p2"),d("p3")])} {\n                \n                ${W("dir")}  = p0 - P;\n                ${W("lightNormal")}  = cross(p1 - p0, p3 - p0);\n                ${O("behind")}  = (dot(dir, lightNormal) < 0.0);\n                if (behind) {\n                    return 0.0;\n                }\n                ${W("T")}  = normalize(V-N*dot(V,N));\n                ${W("B")}  = cross(N,T);\n                ${q("TBN")} = ${q()}(T,B,N);\n                ${q("M")}  = Minv*${x("transposeMatrix","m3",[m("m3","TBN")])};\n\n                ${W("L",4)};\n                L[0] = normalize(M * (p0 - P));\n                L[1] = normalize(M * (p1 - P));\n                L[2] = normalize(M * (p2 - P));\n                L[3] = normalize(M * (p3 - P));\n\n                ${W("F")}  = ${x("IntegrateEdgeVec","v3",[d("L[0]"),d("L[1]")])};\n                F += ${x("IntegrateEdgeVec","v3",[d("L[1]"),d("L[2]")])};\n                F += ${x("IntegrateEdgeVec","v3",[d("L[2]"),d("L[3]")])};\n                F += ${x("IntegrateEdgeVec","v3",[d("L[3]"),d("L[0]")])};\n\n                ${H("formFactor")}  = length(F);\n                ${H("z")} = F.z/formFactor;\n                \n                ${X("uv")} = ${X()}(z*0.5 + 0.5, 1.0 - formFactor);\n                uv = clamp(uv, AREA_LIGHT_UV_CLAMP_MIN, AREA_LIGHT_UV_CLAMP_MAX) * AREA_LIGHT_LUT_UV_FACTOR + AREA_LIGHT_FRESNEL_FACTOR_START;\n                ${H("scale")}  = ${J(e,"uv ")}.w;\n\n                return ${_("scale * formFactor")};\n            }\n        `},kn=function(n){const e=B("precomputedAreaTexture");return`\n            ${g("SolveCubic","v3",[v("Coefficient")])} {\n                ${j("coef")} = Coefficient;\n                coef.x /= coef.w;\n                coef.y /= 3.0 * coef.w;\n                coef.z /= 3.0 * coef.w;\n\n                ${H("A")} = coef.w;\n                ${H("B")} = coef.z;\n                ${H("C")}  = coef.y;\n                ${H("D")}  = coef.x;\n\n                ${W("Delta")}  =${W()}(\n                    -B*B + C,\n                    -C*B + D,\n                    dot(${X()}(B, -C), coef.xy)\n                );\n\n                ${H("Discriminant")}  = abs(dot(${X()}(4.0*Delta.x, -Delta.y), Delta.zy));\n\n                ${W("RootsA")};\n                ${W("RootsD")};\n\n                ${X("xlc")};\n                ${X("xsc")};\n\n                {\n                    ${H("A_a")}  = 1.0;\n                    ${H("C_a")}  = Delta.x;\n                    ${H("D_a")}  = -2.0*B*Delta.x + Delta.y;\n\n                    ${H("Theta")}  = ${K("sqrt(Discriminant)","-D_a")}/3.0;\n\n                    ${H("x_1a")}  = 2.0*sqrt(-C_a)*cos(Theta);\n                    ${H("x_3a")}  = 2.0*sqrt(-C_a)*cos(Theta + (2.0/3.0)*PI);\n\n                    ${H("xl")} ;\n                    if ((x_1a + x_3a) > 2.0*B) {\n                        xl = x_1a;\n                    } else {\n                        xl = x_3a;\n                    }\n\n                    xlc = ${X()}(xl - B, A);\n                }\n\n                {\n                    ${H("A_d")}  = D;\n                    ${H("C_d")}  = Delta.z;\n                    ${H("D_d")}  = -D*Delta.y + 2.0*C*Delta.z;\n\n                    ${H("Theta")}  = ${K("D*sqrt(Discriminant)","-D_d")}/3.0;\n\n                    ${H("x_1d")}  = 2.0*sqrt(-C_d)*cos(Theta);\n                    ${H("x_3d")}  = 2.0*sqrt(-C_d)*cos(Theta + (2.0/3.0)*PI);\n\n                    ${H("xs")} ;\n                    if (x_1d + x_3d < 2.0*C) {\n                        xs = x_1d;\n                    } else {\n                        xs = x_3d;\n                    }\n\n                    xsc = ${X()}(-D, xs + C);\n                }\n\n                ${H("E")}  =  xlc.y*xsc.y;\n                ${H("F")}  = -xlc.x*xsc.y - xlc.y*xsc.x;\n                ${H("G")}  =  xlc.x*xsc.x;\n\n                ${X("xmc")} = ${X()}(C*F - B*G, -B*F + C*E);\n\n                ${W("Root")}  =${W()}(xsc.x/xsc.y, xmc.x/xmc.y, xlc.x/xlc.y);\n\n                if (Root.x < Root.y && Root.x < Root.z) {\n                    Root = Root.yxz;\n                } else if (Root.z < Root.x && Root.z < Root.y) {\n                    Root = Root.xzy;\n                }\n\n                return Root;\n            }\n\n            ${g("areaDiskLight","f",[d("N"),d("V"),d("P"),m("m3","Minv"),d("p0"),d("p1"),d("p2")])}{\n                ${W("T")}  = normalize(V-N*dot(V,N));\n                ${W("B")}  = cross(N,T);\n\n                ${q("TBN")} = ${q()}(T,B,N);\n                ${q("R")} = ${x("transposeMatrix","m3",[m("m3","TBN")])};\n\n                ${W("L",3)};\n                L[0] = R * (p0 - P);\n                L[1] = R * (p1 - P);\n                L[2] = R * (p2 - P);\n\n                ${W("c")}   = Minv *(0.5 * (L[0] + L[2]));\n                ${W("v1")}  = Minv *(0.5 * (L[1] - L[2]));\n                ${W("v2")}  = Minv *(0.5 * (L[1] - L[0]));\n\n                if(dot(cross(v1, v2), c) < 0.0){ return 0.0;}\n\n                ${H("a")};\n                ${H("b")} ;\n                ${H("d11")}  = dot(v1, v1);\n                ${H("d22")}  = dot(v2, v2);\n                ${H("d12")}  = dot(v1, v2);\n                if (abs(d12)/sqrt(d11*d22) > 0.005) {\n                    ${H("tr")}  = d11 + d22;\n                    ${H("det")}  = -d12*d12 + d11*d22;\n\n                    det = sqrt(det);\n                    ${H("u")}  = 0.5*sqrt(tr - 2.0*det);\n                    ${H("v")}  = 0.5*sqrt(tr + 2.0*det);\n                    ${H("e_max")}  = ${C("u + v")};\n                    ${H("e_min")}  = ${C("u - v")};\n\n                    ${W("v1_")};\n                    ${W("v2_")} ;\n\n                    if (d11 > d22) {\n                        v1_ = d12*v1 + (e_max - d11)*v2;\n                        v2_ = d12*v1 + (e_min - d11)*v2;\n                    }\n                    else {\n                        v1_ = d12*v2 + (e_max - d22)*v1;\n                        v2_ = d12*v2 + (e_min - d22)*v1;\n                    }\n\n                    a = 1.0 / e_max;\n                    b = 1.0 / e_min;\n                    v1 = normalize(v1_);\n                    v2 = normalize(v2_);\n                }\n                else {\n                    a = 1.0 / dot(v1, v1);\n                    b = 1.0 / dot(v2, v2);\n                    v1 *= sqrt(a);\n                    v2 *= sqrt(b);\n                }\n\n                ${W("v3")}  = normalize(cross(v1, v2));\n                if (dot(c, v3) < 0.0){ v3 *= -1.0;}\n\n                ${H("L_")}   = dot(v3, c);\n                ${H("x0")}  = dot(v1, c) / L_;\n                ${H("y0")}  = dot(v2, c) / L_;\n\n                ${H("E1")}  = ${l.inverseSqrt("a")};\n                ${H("E2")}  = ${l.inverseSqrt("b")};\n\n                a *= L_*L_;\n                b *= L_*L_;\n\n                ${H("c0")}  = a*b;\n                ${H("c1")}  = a*b*(1.0 + x0*x0 + y0*y0) - a - b;\n                ${H("c2")}  = 1.0 - a*(1.0 + x0*x0) - b*(1.0 + y0*y0);\n                ${H("c3")}  = 1.0;\n\n                ${W("roots")}  = ${x("SolveCubic","v3",[v("vec4(c0, c1, c2, c3)")])};\n                ${H("e1")}  = roots.x;\n                ${H("e2")}  = roots.y;\n                ${H("e3")}  = roots.z;\n\n                ${W("avgDir")}  =${W()}(a*x0/(a - e2), b*y0/(b - e2), 1.0);\n\n                ${q("rotate")}  = ${q()}(v1, v2, v3);\n\n                avgDir = rotate*avgDir;\n                avgDir = normalize(avgDir);\n\n                ${H("L1")}  = sqrt(-e2/e3);\n                ${H("L2")}  = sqrt(-e2/e1);\n\n                ${H("formFactor")}  = L1*L2*${l.inverseSqrt("(1.0 + L1*L1)*(1.0 + L2*L2)")};\n\n                ${X("uv")} = ${X()}(avgDir.z*0.5 + 0.5, 1.0 - formFactor);\n                uv = clamp(uv, AREA_LIGHT_UV_CLAMP_MIN, AREA_LIGHT_UV_CLAMP_MAX) * AREA_LIGHT_LUT_UV_FACTOR + AREA_LIGHT_FRESNEL_FACTOR_START;\n                ${H("scale")}  = ${J(e,"uv")}.w;\n                \n                return ${_("formFactor*scale")};\n            }\n            \n            ${g("cropDiskLight","f",[d("lP"),d("p0"),d("p1"),d("N")])}{\n                ${W("p2")} = lP - (p0 - lP);\n                ${W("p3")} = lP - (p1 - lP);\n                return ${x("cropRectangleLight","f",[d("lP"),d("p0"),d("p1"),d("p2"),d("p3"),d("N")])};\n            }\n            \n            ${g("getSphereLightPoints",null,[f("lP"),$("radius"),f("p0"),f("p1"),f("p2")])} {            \n                ${W("P")} = -surfaceData.viewPosition;\n                ${W("toUse")}  = ${P(`P - ${u("lP")}`)};\n                ${u("lP")} += radius * toUse;\n                ${W("right")} = ${x("getGeomT","v3",[d("toUse")])};\n                ${W("up")} = ${x("getGeomB","v3",[d("toUse"),d("right")])};\n                ${u("p0")} = ${u("lP")}.xyz + right * radius - up * radius;\n                ${u("p1")} = ${u("lP")}.xyz - right * radius - up * radius;\n                ${u("p2")} = ${u("lP")}.xyz - right * radius + up * radius;\n            }\n        `},On=function(n){return`     \n            ${g("solidAngleRect","f",[d("viewPos"),d("p0"),d("p1"),d("p2"),d("p3")])} {            \n                ${W("v0")}  = p0 - viewPos;\n                ${W("v1")}  = p1 - viewPos;\n                ${W("v2")}  = p2 - viewPos;\n                ${W("v3")}  = p3 - viewPos;\n\n                ${W("n0")}  = normalize(cross(v0,v1));\n                ${W("n1")}  = normalize(cross(v1,v2));\n                ${W("n2")}  = normalize(cross(v2,v3));\n                ${W("n3")}  = normalize(cross(v3,v0));\n\n                ${H("g0")}  = acos(dot(-n0,n1));\n                ${H("g1")}  = acos(dot(-n1,n2));\n                ${H("g2")}  = acos(dot(-n2,n3));\n                ${H("g3")}  = acos(dot(-n3,n0));\n\n                return g0 + g1 + g2 + g3 - 2.0 * PI;\n            }\n\n            ${g("closestOnLine","v3",[d("a"),d("b"),d("c")])} {\n                ${W("ab")} = b - a;\n                ${H("t")} = dot(c - a , ab) / dot(ab,ab);\n                return a + t * ab;\n            }\n\n            ${g("closestOnSegment","v3",[d("a"),d("b"),d("c")])} {             \n                ${W("ab")} = b - a;\n                ${H("t")} = dot(c - a , ab) / dot(ab,ab);\n                return a + ${_("t")} * ab;\n            }\n\n            ${g("closestPointSphere","v3",[d("L"),d("R"),$("radius")])} {\n                ${W("centerToRay")}  = dot(L, R) * R - L;\n                ${W("closestPoint")}  = L + centerToRay * ${_("radius / length(centerToRay)")};\n                return normalize(closestPoint);\n            }\n\n            ${g("closestPointTube","v3",[d("P0"),d("P1"),d("R"),d("Lp"),$("radius")])} {\n                ${W("N")} = surfaceData.viewNormal;\n                ${W("P")} = -surfaceData.viewPosition;\n                ${W("L0")}  = P0 - P;\n                ${W("L1")}  = P1 - P;\n                ${W("Ld")}  = L1 - L0;\n                ${H("coeff")}  = dot(R,L0)*dot(R,Ld) - dot(L0,Ld);\n                coeff /= dot(Ld,Ld) - ${C("dot(R,Ld)")};\n                ${W("L")}  = L0 + ${_("coeff")} * Ld;\n\n                return ${x("closestPointSphere","v3",[d("L"),d("R"),$("radius")])};\n            }\n\n            ${g("illuminanceRectangle","f",[d("p0"),d("p1"),d("p2"),d("p3"),d("lightPosition"),d("viewPosition"),d("N")])}{\n                ${H("angle")}  =  ${x("solidAngleRect","f",[d("viewPosition"),d("p0"),d("p1"),d("p2"),d("p3")])};\n                ${H("coeff")}  = ${T("dot(normalize(lightPosition - viewPosition),N)")};\n                coeff += ${T("dot(normalize(p0 - viewPosition),N)")} + ${T("dot(normalize(p1 - viewPosition),N)")};\n                coeff += ${T("dot(normalize(p2 - viewPosition),N)")} + ${T("dot(normalize(p3 - viewPosition),N)")};\n                return angle * 0.2*coeff;\n            }\n\n            ${g("illuminanceTube","f",[d("P0"),d("P1"),d("lightPosition"),d("N"),d("lRight"),$("lHWidth"),$("lRadius")])}{\n                ${W("viewPosition")} = -surfaceData.viewPosition;\n                ${W("forw")}  = normalize(${x("closestOnLine","v3",[d("P0"),d("P1"),d("viewPosition")])} - viewPosition);\n                ${W("right")} = lRight;\n                ${W("up")} = cross(right, forw);\n            \n                ${W("p0")} = lightPosition.xyz + right * lHWidth + up * lRadius;\n                ${W("p1")} = lightPosition.xyz + right * lHWidth + up * -lRadius;\n                ${W("p2")} = lightPosition.xyz + right * -lHWidth + up * -lRadius;\n                ${W("p3")} = lightPosition.xyz + right * -lHWidth + up * lRadius;\n\n                ${H("illu")} = ${x("illuminanceRectangle","f",[d("p0"),d("p1"),d("p2"),d("p3"),d("lightPosition"),d("viewPosition"),d("N")])};\n\n                ${W("sphPos")}  = ${x("closestOnSegment","v3",[d("P0"),d("P1"),d("viewPosition")])};\n                ${W("sphNorm")} = sphPos - viewPosition;\n                ${W("sphL")}  = normalize(sphNorm);\n                ${H("sqrSphDist")}  = dot(sphNorm, sphNorm);\n                ${H("illu2")}  = PI * ${T("dot(sphL, N)")} * (lRadius*lRadius)/sqrSphDist;\n                return illu+illu2;\n            }\n        `};un=function(n){let e=o;if(n.hasAreaLights){let t="areaRectangleLight",r=["p0","p1","p2","p3"],a="areaDiskLight",i=["p0","p1","p2"],s=o;n.maxRectangleLights&&(s=`           \n                        ${En(n)}      \n    \n                        ${g("areaRectangleLightModel",null,[f("specular"),f("diffuse"),f("transmissive"),d("p0"),d("p1"),d("p2"),d("p3")])} {\t     \n                            ${W("N")} = surfaceData.viewNormal;\n                            ${W("V")} = surfaceData.view;     \n                            ${W("P")} = -surfaceData.viewPosition;\n                            ${In(t,r,n)}\n                            ${An(t,r,n)}\n                            ${wn(t,r,n)}\n                            ${Rn(t,r,n)}\n                            ${Vn(t,r,n)}\n                            ${zn(t,r,n)}\n                            ${Fn(t,r,n)}            \n                        }\n                    `);let l=o;(n.maxDiskLights||n.maxSphereLights)&&(l=`\n                 \n                    ${kn(n)}\n    \n                    ${g("areaDiskLightModel",null,[f("specular"),f("diffuse"),f("transmissive"),d("p0"),d("p1"),d("p2")])} {\t          \n                        ${W("N")} = surfaceData.viewNormal;\n                        ${W("V")} = surfaceData.view;     \n                        ${W("P")} = -surfaceData.viewPosition;\n                        ${In(a,i,n)}\n                        ${An(a,i,n)}                    \n                        ${wn(a,i,n)}\n                        ${Rn(a,i,n)}\n                        ${Vn(a,i,n)}                \n                        ${zn(a,i,n)}\n                        ${Fn(a,i,n)}                    \n                    }\n                    `),e=`\n                    ${Bn(n)}\n                    ${s}\n                    ${l}\n                `}return n.maxTubeLights&&(e=`\n                    ${e}  \n                    ${On(n)}\n                            \n                    ${g("doAreaLightingModel",null,[d("E"),f("diffuse"),f("specular"),d("L")])}{\n                        ${x("_doCommonLightingModel",null,N())};\n                        ${n.subsurface?`\n                            ${W("sssE")}  = E * materialData.scatteringColor;\n                            ${n.specgloss?`${u("diffuse")} *= sssE;`:`                  \n                                ${W("baseDiffuseValue")} = ${u("diffuse")};       \n                                ${n.dspbrWithTranslucency?`${u("diffuse")} *= mix(E, sssE, materialData.translucency);`:`${u("diffuse")} *= E;`}\n                                ${u("diffuse")} = mix(${u("diffuse")}, sssE * baseDiffuseValue, materialData.transparency);\n                                `}\n                            `:`\n                            ${n.dspbrWithTranslucency?`${u("diffuse")} *= E * (1.0 - materialData.translucency);`:`${u("diffuse")} *= E;`}\n                            `}\n                        ${u("specular")} *= E;\n                    }\n                `),`\n                ${Ln(n)}\n                ${e}\n            `}}return mn=function(n){if(!n.hasAreaLights)return[o,n.maxTubeLights>0?`${W("viewReflect")} = reflect(-surfaceData.view, surfaceData.viewNormal);`:o];const e=(n,e)=>x("setAreaGGXData",null,[$(n),$(e)]),t=(n,e)=>x("setAreaSheenData",null,[$(n),$(e)]);let r=`\n                ${A({uniformName:"precomputedAreaTexture",uniformType:"t2"})} \n            `,a=`\n                ${W("viewReflect")}  = reflect(-surfaceData.view, surfaceData.viewNormal);\n                ${H("areaNoV")} = NoV;\n                ${H("areaRoughness")} = ${n.useSpecularAA?"materialData.roughnessAACorrected":"materialData.roughness"};\n                ${n.anisotropy?`\n                    ${W("areaBitangent")}  = normalize(sin(2.0 * PI * materialData.anisotropyAngle) * surfaceData.tangent + cos(2.0 * PI * materialData.anisotropyAngle) * surfaceData.binormal);\n                    ${W("anisotropicAreaTangent")}  = cross(areaBitangent, surfaceData.view);\n                    ${W("anisotropicAreaNormal")}  = cross(anisotropicAreaTangent, areaBitangent);\n                    ${W("bentAreaNormal")}  = normalize(mix(surfaceData.viewNormal, anisotropicAreaNormal, materialData.anisotropy));\n                    ${W("reflArea")}  = -reflect( surfaceData.view, bentAreaNormal );\n                    areaNoV = ${T("dot(surfaceData.viewNormal, reflArea)")};\n                    `:o}\n                ${e("areaRoughness","NoV")};\n                areaData.fresnel = currentAreaFresnel;\n                areaData.Minv = currentAreaMinv;\n                \n            `;return n.clearCoat&&(a=`\n                    ${a}     \n                    ${H("areaCCRoughness")} = ${n.useSpecularAA?"materialData.clearCoatRoughnessAACorrected":"materialData.clearCoatRoughness"}; \n                    ${e("areaCCRoughness",`${T("dot(surfaceData.clearCoatNormal,surfaceData.view)")}`)};\n                    areaData.fresnelCC = currentAreaFresnel;\n                    areaData.MinvCC = currentAreaMinv;\n                `),n.sheen&&(a=`\n                    ${a}   \n                    ${H("sheenRough_AL")};\n                    ${n.dspbrWithSheenColorRoughness?"sheenRough_AL = materialData.sheenRoughness;":"sheenRough_AL = materialData.sheen;"}\n                    ${n.useVelvet||n.useSoftVelvet?`\n                        ${n.dspbrWithSquaredEstevezKullaRoughness?`${t("sheenRough_AL * sheenRough_AL","NoV")};`:`${t("sheenRough_AL","NoV")};`}\n                        `:`${t("0.3","NoV")};`}\n                    areaData.MinvSheen = currentAreaMinv;\n                `),n.specGlossFlakes&&(a=`\n                    ${a}                       \n                    ${e("metal.flakesRoughness",`${T("dot(metal.flakesNormal,surfaceData.view)")}`)};\n                    areaData.fresnelMetal = currentAreaFresnel;\n                    areaData.MinvMetal = currentAreaMinv;\n                    ${e("metalFlakes.flakesRoughness",`${T("dot(metalFlakes.flakesNormal,surfaceData.view)")}`)};\n                    areaData.fresnelMetalFlakes = currentAreaFresnel;\n                    areaData.MinvMetalFlakes = currentAreaMinv;\n                    ${n.pearlFlakesActivated?`\n                        ${e("pearlFlakes.flakesRoughness",`${T("dot(pearlFlakes.flakesNormal,surfaceData.view)")}`)};               \n                        areaData.fresnelPearlFlakes = currentAreaFresnel;\n                        areaData.MinvPearlFlakes = currentAreaMinv;\n                        `:o}\n                `),n.dspbrFlakes&&(a=`\n                    ${a}                                              \n                    if (flakesData.smoothWeight > 0.0) {\n                        ${e("flakesData.flakesRoughness","NoV")};\n                        areaData.fresnelMetal = currentAreaFresnel;\n                        areaData.MinvMetal = currentAreaMinv;\n                    }\n                    ${n.dspbrFlakesThreeLayers?`                    \n                        if (flakesData.stochasticWeight > 0.0) {\n                            ${H("NdotVSto")}  = ${T("dot(flakesData.stochasticHemisphereFlakesNormal, surfaceData.view)")};\n                            ${e("flakesData.flakesRoughness","NdotVSto")};\n                            areaData.fresnelMetalSto = currentAreaFresnel;\n                            areaData.MinvMetalSto = currentAreaMinv;\t\n                        }\n                        `:o}\t\n                    ${n.dspbrFlakesOneLayer?o:`               \n                        if (flakesData.closeupWeight > 0.0) {       \n                            ${H("NdotVClose")}  = ${T("dot(flakesData.closeupFlakesNormal, surfaceData.view)")};\n                            ${e("flakesData.flakesRoughness","NdotVClose")};\t\n                            areaData.fresnelMetalClose = currentAreaFresnel;\n                            areaData.MinvMetalClose = currentAreaMinv;\n                        }\t\n                        `}\n                    \n                `),[r,a]},{getAnalyticalLightShaders:function(t,a){if(!t)return[o,o,o];let i=Q(a),s=tn(a),l=nn(a),u=en(a),m=rn(a),c=mn(a),p=an(a),f=on(a),h=sn(a),v=ln(a),y=o,_=o;var C,P;a.lightMap&&(y=`\n                    ${R({uniformName:"lightMap",uniformType:"t2"})}\n                    ${R({uniformName:"lightMapUvTransform",uniformType:"m3"})}\n                    ${R({uniformName:"lightMapUvSlot",uniformType:"i"})}\n                    ${R({uniformName:"lightMapMappingType",uniformType:"i"})}\n                `,_=`\n                    ${W("aoValue")}  = ${J((C="lightMap",P={uniformName:C},e.getObjectTextureUniform(P)),"lightMapUV")}.rgb;\n                    ${a.lightMapLinear?o:"aoValue *= aoValue;"}\n                    ${1===a.lightMapMode?`\n                        totalDiffuse =${W()}(0.0);\n                        totalSpecular *= ${(n=>x("saturate","v3",[d(n)]))("aoValue")};  \n                        `:o}\n                `);let N=`\n                ${i[0]}\n                ${l[0]}\n                ${u[0]}\n                ${s[0]}\n                ${m[0]}\n                ${c[0]}\n                ${p[0]}\n                ${f[0]}\n                ${h[0]}\n                ${v[0]}\n                ${function(n){return n.useEmission?`\n\n        ${g("doEmission","v3",[$("NoV")])} {\n            ${W("V")} = surfaceData.view;\n            ${W("emissionColor")} = materialData.emissionColor;\n            ${W("res")}  = ${W()}(0.0);\n            ${n.emissionNormalized?`\n                ${W("aux")}  =${W()}(0.2126729,0.7151522,0.0721750);\n                res = materialData.emissionValue * emissionColor/max(dot(emissionColor,aux),1e-6);\n                `:"res = materialData.emissionValue * emissionColor;"}\n            ${n.dspbrWithClearCoatAboveEmissive?`\n                ${n.clearCoat?`\n                    ${H("NcoV")}  = ${T("dot(surfaceData.clearCoatNormal,V)")};\n                    ${W("fresnelCoating")}  = ${M("materialData.clearCoatSR0Color","materialData.clearCoatSR90Color","NcoV")};\n                    ${H("fresnelEnergy")}  = 1.0 - materialData.clearCoat * ${D("fresnelCoating")};\n                    res *= fresnelEnergy;\n                    `:o}\n                return res*INV_PI;\n                `:`           \n                ${n.dspbr?"return res*INV_PI;":"return res;"}\n                `}\n        }\n    `:o}(a)}\n                ${y}\n            `,b=`\n                ${W("totalDiffuse")} = ${W()}(0.0);\n                ${W("totalSpecular")} = ${W()}(0.0);\n                ${a.dspbrWithTranslucency||a.subsurface?`\n                    ${W("totalTransmissive")} = ${W()}(0.0);\n                    `:o}\n                \n                ${a.invisiblePlaneMaterial?`${W("lightNormalizationFactor")}  = ${W()}(0.0);`:o}\n\n                ${!a.shadowMapEnabled||a.shadowMapType!==n.PCFPoissonShadowMap&&a.shadowMapType!==n.PCFInterpolShadowMap?o:`\n                        globalPCFPoissonFragCoord =${(n=>r.getShaderInput(n))("fragCoord")};\n                        ${x("initDiskPCF",null,[])};`}\n                ${i[1]}\n                ${l[1]}\n                ${u[1]}\n                ${s[1]}\n                ${m[1]}\n                ${c[1]}\n                ${p[1]}\n                ${f[1]}\n                ${h[1]}\n                ${v[1]}\n                ${_}\n\t\t\t\t${W("totalAnalyticalColor")} = totalDiffuse + totalSpecular;\n\t\t\t`;return b=`\n                ${b}\n                ${S("out0")} = ${j()}(totalAnalyticalColor, ${S("out0")}.a);\n                ${a.useEmission?`\n                    ${W("totalEmission")} = ${x("doEmission","v3",[$("NoV")])};\n                    `:o}\n                \n            `,[N,b,un(a)]}}})),define("DS/ShaderBuilders/Commons/PDSFX/PDSFXVertexCoreShaders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/ShaderUtils/AttributeUtils","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a,o){"use strict";const i="",s=a.ParameterUtils,l=n=>s.parameterRefPrivateV2(n),u=(n,e,t)=>a.FunctionHandler.callFunction(n,e,t),m=n=>{var e={uniformName:n};return t.getUniform(e)},c=(n,e)=>e.mappingFromMatApp?(n=>{var e={uniformName:n};return t.getHighFrequencyUniform(e)})(n):m(n),$=(n,e=null)=>r.getVarying(n,r.ShaderStages.out,e),p=n=>r.getShaderOutput(n),d=(n=null)=>{var e={name:n,addressSpace:"private"};return o.vec2(e)},f=(n=null)=>{var e={name:n,addressSpace:"private"};return o.vec3(e)},h=(n=null)=>{var e={name:n,addressSpace:"private"};return o.vec4(e)};return{PDSFX_header_vertex:function(n){var e=i;n.cpuPattern&&!n.WebGPU&&(e=`\n                    ${e}\n                    #define PDSFX_PIXEL_LINEDISTANCE\n                `),e=`\n                ${e}\n                // Backup variables for all overridable entry points\n                ${f("INTERNAL_backup_position")} ;\n                ${f("INTERNAL_backup_normal")} ;\n                ${f("INTERNAL_backup_tangent")} ;\n                ${f("INTERNAL_backup_binormal")} ;\n                ${f("INTERNAL_backup_previousPos")} ;\n                ${f("INTERNAL_backup_followingPos")} ;\n                ${h("INTERNAL_backup_uv")} ;\n                ${h("INTERNAL_backup_uv2")} ;\n                ${h("INTERNAL_backup_uv3")} ;\n                ${d("_hack_PDSFX_UV1_FOR_CITY_")} ;\n                ${d("_hack_PDSFX_UV2_FOR_CITY_")} ;\n            `;const t=r._context.__attributes__;for(var a in t){var s=t[a];if(s.pdsfx){var l=s.locationName;e=`\n                        ${e}\n                        ${o.declareVariable({name:l,type:s.type,addressSpace:"private"})};\n                    `}}return e},PDSFX_start_vertex:function(n){let t=i;if(n.PDSFX){const p=r._context.__attributes__;for(var a in p){var s=p[a];if(s.pdsfx){var m=s.locationName;if(n.WebGPU){const n=r._context.__customAttributes__;t="m4"===s.type?`\n                                    ${t}\n                                    ${m} = mat4x4f(\n                                                input.${m}_c0, \n                                                input.${m}_c1, \n                                                input.${m}_c2, \n                                                input.${m}_c3\n                                    );\n                                `:`\n                                    ${t}\n                                    ${n[a]?e.getCustomAttribute(m,a):`${m} = `+e.getAttribute(m)};\n                                `}else t=`\n                                ${t}\n                                ${m} = ${e.getAttribute(a)};\n                            `}}t=`\n                    ${t}\n                    ${n.WebGPU?`\n                        INTERNAL_builtin_VertexID = i32(${$="vertexIndex",r.getShaderInput($)});\n                        `:"\n                        INTERNAL_builtin_VertexID = 0;\n                        "}\n                    INTERNAL_backup_position = position_;\n                    INTERNAL_backup_normal = normal;\n                    INTERNAL_backup_uv = uv;\n                    INTERNAL_backup_uv2 = uv2;\n                    INTERNAL_backup_uv3 = uv3;\n                    INTERNAL_backup_tangent = tangent;\n                    INTERNAL_backup_binormal = binormal;\n                    ${u("ComputeCommonValues",null,[])};\n                    position_ = ${u("ComputeObjectPosition","v3",[])};\n                    normal = ${u("ComputeObjectNormal","v3",[])};\n                    ${n.dashedLine?`\n                        ${u("ProcessLineDistance",null,[l("lineDistance")])};\n                        `:i}\n                    ${n.wideLine?`\n                        INTERNAL_backup_followingPos = followingPos;\n                        INTERNAL_backup_previousPos = previousPos;\n                        previousPos = ${u("ComputeObjectPreviousPosition","v3",[])}; \n                        followingPos = ${u("ComputeObjectFollowingPosition","v3",[])};\n                        `:i}\n                    uv = ${u("ComputeObjectTexCoord0","v4",[])};\n\t\t\t\t\t_hack_PDSFX_UV1_FOR_CITY_ = uv.xy;\n                    uv2 = ${u("ComputeObjectTexCoord1","v4",[])};\n\t\t\t\t\t_hack_PDSFX_UV2_FOR_CITY_ = uv2.xy;\n                    uv3 = ${u("ComputeObjectTexCoord2","v4",[])};\n                    tangent = ${u("ComputeObjectTangent","v3",[])}; \n                    binormal = ${u("ComputeObjectBinormal","v3",[])};           \n                    ${o.struct({name:"_viewTangentSpace",structName:"TangentSpace"})};\n                    ${n.useUV&&(n.mappingType>-1||n.lightMapMappingType>-1)?`INTERNAL_backup_mappingUVTransformation = ${c("mappingUVTransformation",n)};`:i}\n                `}var $;return t},PDSFX_start_particle_vertex:function(n){return n.PDSFX?`\n                INTERNAL_backup_size = ${m("size")};\n                INTERNAL_backup_scale = ${m("scale")};\n                INTERNAL_backup_sizeForGLPointSize = INTERNAL_backup_size;\n            `:i},PDSFX_point_size_vertex:function(n){var e=i;const t=n.WebGPU;return e=n.PDSFX?`\n                    ${e}\n                    ${t?`var wgpuPointSize = ${u("ComputePointSize","f",[])} * length( mvPosition.xyz ) ;`:`gl_PointSize = ${u("ComputePointSize","f",[])};`}\n                `:n.sizeAttenuation?`\n                        ${e}\n                        ${t?`var wgpuPointSize = ${m("size")} * ( ${m("scale")} );`:`gl_PointSize = ${m("size")} * ( ${m("scale")} / length( mvPosition.xyz ) );`}\n                    `:`\n                        ${e}\n                        ${t?`var wgpuPointSize = ${m("size")} * length( mvPosition.xyz ) ;`:`gl_PointSize = ${m("size")};`}\n                    `,n.primitiveHighlight&&n.mobileHL&&(e=`\n                    ${e}\n                    ${t?"wgpuPointSize = wgpuPointSize + 2.0 * length( mvPosition.xyz ) ;":"gl_PointSize += 2.0;"}\n                `),e},PDSFX_end_vertex:function(e,t=""){let a=i;if(e.PDSFX){a=`\n                    ${a}\n                    ${u("ProcessClipSpacePosition",null,[(c=p("position"),s.parameterRefV4(c))])};\n                    ${t}\n                    ${e.materialToUse===n.MaterialToUse.depthRGBAMaterial?`\n                        ${$("clipPos_Deferred")} = ${p("position")}; // TZW: for Point Cloud HQ dev\n                        `:i}\n                    ${u("ComputeVaryingValues",null,[])};\n                    ${$("INTERNAL_varying_clipPosition")} = ${p("position")};\n                    ${$("INTERNAL_varying_viewPosition")}  = _viewTangentSpace.Position;\n                    ${$("INTERNAL_varying_viewNormal")}  = _viewTangentSpace.Normal;\n                    ${$("INTERNAL_varying_viewTangent")}  = _viewTangentSpace.Tangent;\n                    ${$("INTERNAL_varying_viewBinormal")}  = _viewTangentSpace.Binormal;\n                `;const d=r._context.__varyings__;for(var o in d){var l=d[o];if(l.pdsfx){var m=o.replace("_IPCV","");if(l.size>0)for(let n=0;n<l.size;n++)a=`\n                                    ${a}\n                                    ${$(o,n)} = ${m}[${n}];\n                                `;else a=`\n                                ${a}\n                                ${$(o)} = ${m};\n                            `}}}var c;return a}}})),define("DS/ShaderBuilders/Commons/PDSFX/PDSFXVertexGetterShaders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/ShaderUtils/AttributeUtils","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a,o){"use strict";a.ParameterUtils;const i=(n,e,t)=>a.FunctionHandler.declareFunction(n,e,t);return{PDSFX_getters_vertex:function(n){var e="";return e=`\n            ${e}\n            ${i("vGetInstanceID","i",[])}{\n                ${n.isMultiInstanced?`return ${((n=null)=>{var e={name:n};return o.int(e)})()}(instanceId/5.0 - 1.0);`:"return 0;"}\n            }\n      \n            ${((n=null)=>{var e={name:n,addressSpace:"private"};return o.int(e)})("INTERNAL_builtin_VertexID")};\n            ${i("vGetVertexID","i",[])}{\n                return INTERNAL_builtin_VertexID;\n            }\n            \n            ${i("vGetAttribPosition","v3",[])}{\n                return INTERNAL_backup_position;\n            }\n\n            ${i("vGetAttribPreviousPosition","v3",[])}{\n                return INTERNAL_backup_previousPos;\n            }\n\n            ${i("vGetAttribFollowingPosition","v3",[])}{\n                return INTERNAL_backup_followingPos;\n            }\n            \n            ${i("vGetAttribNormal","v3",[])}{\n                return INTERNAL_backup_normal;\n            }\n            \n            ${i("vGetAttribColor","v3",[])}{\n                return color.xyz;\n            }\n\n            ${i("vGetAttribColorAlpha","f",[])}{\n                return color.a;\n            }\n            \n            ${i("vGetAttribTexCoord0","v4",[])}{\n                return INTERNAL_backup_uv;\n            }\n            \n            ${i("vGetAttribTexCoord1","v4",[])}{\n                return INTERNAL_backup_uv2;\n            }\n            \n            ${i("vGetAttribTexCoord2","v4",[])}{\n                return INTERNAL_backup_uv3;\n            }\n            \n            ${i("vGetAttribTangent","v3",[])}{\n                return INTERNAL_backup_tangent;\n            }  \n\n            ${i("vGetAttribBinormal","v3",[])}{\n                return INTERNAL_backup_binormal;\n            }\n\n            ${((n=null)=>{var e={name:n,addressSpace:"private"};return o.float(e)})("INTERNAL_backup_halfWidth")} ;\n            ${i("vGetHalfWidth","f",[])}{\n                return INTERNAL_backup_halfWidth;\n            }\n\n            `}}})),define("DS/ShaderBuilders/Commons/PDSFX/PDSFXFragmentGetterShaders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/Commons/PDSFX/PDSFXFragmentEntryPointsShaders","DS/ShaderBuilders/ShaderUtils/AttributeUtils","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a,o,i){"use strict";const s=o.ParameterUtils,l=n=>s.parameterV2(n),u=n=>s.parameterM3(n),m=(n,e,t)=>o.FunctionHandler.declareFunction(n,e,t),c=(n,e,t)=>o.FunctionHandler.callFunction(n,e,t),$=(n=null)=>{var e={name:n,addressSpace:"private"};return i.bool(e)},p=(n=null)=>{var e={name:n,addressSpace:"private"};return i.float(e)},d=(n=null)=>{var e={name:n};return i.vec2(e)},f=(n=null)=>{var e={name:n,addressSpace:"private"};return i.vec3(e)},h=(n=null)=>{var e={name:n};return i.vec4(e)},v=(n=null)=>{var e={name:n,addressSpace:"private"};return i.vec4(e)},g=e.__backUpVariablesFragment;return{PDSFX_getters_fragment:function(n){let e="";for(var t=0;t<g.length;t++){var r=g[t];e=`\n                    ${e}\n                    ${i.declareVariable({name:r.name,type:r.type,addressSpace:"private"})};\n                    ${r.getterName?`\n                        ${m(r.getterName,r.type,[])} {\n                            return ${r.name};\n                        }`:""}\n                `}return`\n            ${v("INTERNAL_builtin_FragCoord")};\n            ${m("vGetFragCoord","v4",[])}{\n                // Warning ! In WebGPU, FragCoord doesn't have the same convention than WebGL.\n                // WebGL is (0,0) on the top-left going right-down and WebGPU is (0,0) on the bottom-left going right-up\n                return INTERNAL_builtin_FragCoord;\n            }\n\n            ${((n=null)=>{var e={name:n,addressSpace:"private"};return i.int(e)})("INTERNAL_builtin_SampleID")};\n            ${m("vGetSampleID","i",[])}{\n                return INTERNAL_builtin_SampleID;\n            }\n            \n            ${$("INTERNAL_builtin_FragDepthUsed")};\n            ${p("INTERNAL_builtin_FragDepthValue")};\n            ${m("vSetFragDepth",null,[(a="iDepth",s.parameterF(a))])}{\n                INTERNAL_builtin_FragDepthUsed = true;\n                INTERNAL_builtin_FragDepthValue = iDepth;\n            }\n            \n            ${$("INTERNAL_builtin_FrontFacing")};\n            ${m("vIsFrontFacing","b",[])}{\n                return INTERNAL_builtin_FrontFacing;\n            }\n            \n            ${((n=null)=>{var e={name:n,addressSpace:"private"};return i.vec2(e)})("INTERNAL_computedvar_pointCoord")};\n            ${m("vGetPointCoord","v2",[])}{\n                // Warning ! gl_PointCoord doesn't exist in WebGPU, but can be emulated with UVs.\n                // Those UVs should always be available in WebGPU with point rendering since we generate them in the vertex shader of ParticleBasicMaterial\n                // We generate UVs with 0,0 in bottom left but gl_PointCoord is origin_upper_left, so we flip the V coordinate\n                return ${n.WebGPU?`${d()}(INTERNAL_computedvar_pointCoord.x, 1.0 - INTERNAL_computedvar_pointCoord.y);`:"gl_PointCoord"};\n            }\n            \n            ${f("INTERNAL_computedvar_viewPosition")};\n            ${m("vGetViewPosition","v3",[])}{\n                return INTERNAL_computedvar_viewPosition;\n            }\n\n            ${f("INTERNAL_computedvar_viewNormal")};\n            ${m("vGetViewNormal","v3",[])}{\n                return normalize(INTERNAL_computedvar_viewNormal);\n            }\n            \n            ${f("INTERNAL_computedvar_viewTangent")};\n            ${m("vGetViewTangent","v3",[])}{\n                return normalize(INTERNAL_computedvar_viewTangent);\n            }\n            \n            ${f("INTERNAL_computedvar_viewBinormal")};\n            ${m("vGetViewBinormal","v3",[])}{\n                return normalize(INTERNAL_computedvar_viewBinormal);\n            }\n            ${n.WebGPU?"":`\n                    ${m("applyUVCombination","v2",[l("uvToTransform"),u("uvTransform")])};\n                `}\n            \n            ${v("_uvToUse")} ;\n            ${m("vGetTexCoord0","v4",[])}{\n                return _uvToUse;\n            }\n            \n            ${v("_uvToUse2")} ;\n            ${m("vGetTexCoord1","v4",[])}{\n                return _uvToUse2;\n            }\n\n            ${v("_uvToUse3")} ;\n            ${m("vGetTexCoord2","v4",[])}{\n                return _uvToUse3;\n            }\n            /*\n            ${v("_uvToUseMappingOperator")} ;\n            ${m("vGetMappingOperatorTexCoord0","v4",[u("uvTransform")])}{\n                ${d("uv_2")} = ${c("applyUVCombination","v2",[l("_uvToUseMappingOperator.xy"),u("uvTransform")])};\n                return ${h()}(uv_2.x, uv_2.y, _uvToUseMappingOperator.z, _uvToUseMappingOperator.w);\n            }\n\n            ${v("_uvToUseMappingOperator2")} ;\n            ${m("vGetMappingOperatorTexCoord1","v4",[u("uvTransform")])}{\n                ${d("uv_2")} = ${c("applyUVCombination","v2",[l("_uvToUseMappingOperator2.xy"),u("uvTransform")])};\n                return ${h()}(uv_2.x, uv_2.y, _uvToUseMappingOperator2.z, _uvToUseMappingOperator2.w);\n            }\n\n            ${v("_uvToUseMappingOperator3")} ;\n            ${m("vGetMappingOperatorTexCoord2","v4",[u("uvTransform")])}{\n                ${d("uv_2")} = ${c("applyUVCombination","v2",[l("_uvToUseMappingOperator3.xy"),u("uvTransform")])};\n                return ${h()}(uv_2.x, uv_2.y, _uvToUseMappingOperator3.z, _uvToUseMappingOperator3.w);\n            }\n            */\n            ${v("INTERNAL_computedvar_clipPosition")};\n            ${m("vGetClipSpacePosition","v4",[])}{\n                return INTERNAL_computedvar_clipPosition;\n            }\n\n            ${p("INTERNAL_IOR")};\n            ${m("vGetIndexOfRefraction","f",[])} {\n                return INTERNAL_IOR;\n            }\n\n            ${e}\n            `;var a}}})),define("DS/ShaderBuilders/Commons/PDSFX/PDSFXVertexEntryPointsShaders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/ShaderUtils/AttributeUtils","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a,o){"use strict";const i=a.ParameterUtils,s=(n,e,t)=>a.FunctionHandler.declareFunction(n,e,t);return{__PDSFXComputeCommonValues_VS:function(n,e){return`\n                ${s("ComputeCommonValues",null,[])} {\n                    ${e(n,[])}\n                }\n            `},PDSFXComputeCommonValues_VS:function(n,e){return""},__PDSFXComputeObjectPosition_VS:function(n,e){return`\n                ${s("ComputeObjectPosition","v3",[])} {\n                    ${e(n,[])}\n                }\n            `},PDSFXComputeObjectPosition_VS:function(n,e){return"return INTERNAL_backup_position;"},__PDSFXComputeObjectPreviousPosition_VS:function(n,e){return`\n                ${s("ComputeObjectPreviousPosition","v3",[])} {\n                    ${e(n,[])}\n                }\n            `},PDSFXComputeObjectPreviousPosition_VS:function(n,e){return"return INTERNAL_backup_previousPos;"},__PDSFXComputeObjectFollowingPosition_VS:function(n,e){return`\n                ${s("ComputeObjectFollowingPosition","v3",[])} {\n                    ${e(n,[])}\n                }\n            `},PDSFXComputeObjectFollowingPosition_VS:function(n,e){return"return INTERNAL_backup_followingPos;"},__PDSFXComputeObjectNormal_VS:function(n,e){return`\n                ${s("ComputeObjectNormal","v3",[])} {\n                    ${e(n,[])}\n                }\n            `},PDSFXComputeObjectNormal_VS:function(n,e){return"return INTERNAL_backup_normal;"},__PDSFXComputeObjectTexCoord0_VS:function(n,e){return`\n                ${s("ComputeObjectTexCoord0","v4",[])} {\n                    ${e(n,[])}\n                }\n            `},PDSFXComputeObjectTexCoord0_VS:function(n,e){return"return INTERNAL_backup_uv;"},__PDSFXComputeObjectTexCoord1_VS:function(n,e){return`\n                ${s("ComputeObjectTexCoord1","v4",[])} {\n                    ${e(n,[])}\n                }\n            `},PDSFXComputeObjectTexCoord1_VS:function(n,e){return"return INTERNAL_backup_uv2;"},__PDSFXComputeObjectTexCoord2_VS:function(n,e){return`\n                ${s("ComputeObjectTexCoord2","v4",[])} {\n                    ${e(n,[])}\n                }\n            `},PDSFXComputeObjectTexCoord2_VS:function(n,e){return"return INTERNAL_backup_uv3;"},__PDSFXComputeObjectTangent_VS:function(n,e){return`\n                ${s("ComputeObjectTangent","v3",[])} {\n                    ${e(n,[])}\n                }\n            `},PDSFXComputeObjectTangent_VS:function(n,e){return"return INTERNAL_backup_tangent;"},__PDSFXComputeObjectBinormal_VS:function(n,e){return`\n                ${s("ComputeObjectBinormal","v3",[])} {\n                    ${e(n,[])}\n                }\n            `},PDSFXComputeObjectBinormal_VS:function(n,e){return"return INTERNAL_backup_binormal;"},__PDSFXProcessViewTangentSpace_VS:function(n,e){return`\n                ${s("ProcessViewTangentSpace",null,[i.parameterInOutStruct("TangentSpace","ioWorldViewTS")])} {\n                    ${e(n,["ioWorldViewTS"])}\n                }\n            `},PDSFXProcessViewTangentSpace_VS:function(n,e){return""},__PDSFXProcessLineDistance_VS:function(n,e){return`\n                ${s("ProcessLineDistance",null,[(t="lineDistance",i.parameterInOutPrivateV2(t))])} {\n                    ${e(n,["lineDistance"])}\n                }\n            `;var t},PDSFXProcessLineDistance_VS:function(n,e){return""},__PDSFXProcessClipSpacePosition_VS:function(n,e){return`\n                ${s("ProcessClipSpacePosition",null,[(t="ioPosition",i.parameterInOutV4(t))])} {\n                    ${e(n,["ioPosition"])}\n                }\n            `;var t},PDSFXProcessClipSpacePosition_VS:function(n,e){return""},__PDSFXComputePointSize_VS:function(n,e){return`\n                ${s("ComputePointSize","f",[])} {\n                    ${e(n,[])}\n                }\n            `},PDSFXComputePointSize_VS:function(n,e){return"return INTERNAL_backup_sizeForGLPointSize;"},__PDSFXComputeVaryingValues_VS:function(n,e){return`\n                ${s("ComputeVaryingValues",null,[])} {\n                    ${e(n,[])}\n                }\n            `},PDSFXComputeVaryingValues_VS:function(n,e){return""},__PDSFXComputeHalfWidth_VS:function(n,e){return`\n                ${s("ComputeHalfWidth","f",[])} {\n                    ${e(n,[])}\n                }\n            `},PDSFXComputeHalfWidth_VS:function(n,e){return"return INTERNAL_backup_halfWidth;"}}})),define("DS/ShaderBuilders/PBRUtils/PBRVertexShaderBuilderUtils",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/ShaderUtils/AttributeUtils","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a,o){"use strict";var i="";const s=a.ParameterUtils,l=a.FunctionHandler,u=a.BridgeFunctions,m=(n,e)=>s.parameter(n,e),c=n=>s.parameterV2(n),$=n=>s.parameterV3(n),p=n=>s.parameterRefV3(n),d=(n,e,t)=>l.declareFunction(n,e,t),f=(n,e,t)=>l.callFunction(n,e,t),h=n=>t.addUniform(n),v=n=>{var e={uniformName:n};return t.getUniform(e)},g=n=>{var e={uniformName:n};return t.getTextureUniform(e)},x=(n,e)=>e.mappingFromMatApp?(n=>{var e={uniformName:n};return t.getHighFrequencyUniform(e)})(n):v(n),S=(n=null)=>{var e={name:n};return o.float(e)},y=(n=null)=>{var e={name:n};return o.vec2(e)},_=(n=null,e=0)=>{var t={name:n,size:e};return o.vec3(t)},T=(n=null,e=0)=>{var t={name:n,size:e};return o.vec4(t)},D=n=>r.addVarying(n),C=n=>r.getVarying(n,r.ShaderStages.out),P=(n,e)=>u.sample2DTextureGrad(n,e),N=(n,e)=>f("ComputeDisplacedPosition","v3",[c(n),$(e)]);var b=function(n){return`\n            ${h({uniformName:"displacementMap",uniformType:"t2"})} \n            ${h({uniformName:"displacementMapSize",uniformType:"v2"})} \n            ${e={uniformName:"displacementRadius",uniformType:"f"},t.addObjectUniform(e)} \n            ${h({uniformName:"displacementUvTransform",uniformType:"m3"})} \n\n            \n            ${o.createStruct({structName:"DisplacementData",attributes:[{type:"v3",name:"normal"},{type:"v3",name:"tangent"},{type:"v3",name:"binormal"}]})}\n            ${o.struct({name:"displacementData",structName:"DisplacementData",addressSpace:"private"})};\n\n            ${n.specgloss?`\n                ${h({uniformName:"displacementBias",uniformType:"f"})} \n                ${h({uniformName:"displacementScale",uniformType:"f"})} \n\n                ${d("ComputeDisplacedPosition","v3",[c("iDisplacementUV"),$("positionToDisplace")])}{\n                    ${y("displacementUV")} = iDisplacementUV;\n                    ${n.mappingType>-1?`\n                        ${_("tmpTangent")} = displacementData.tangent;\n                        ${_("tmpBinormal")} = displacementData.binormal;\n                        displacementUV = ${f("applyMappingOperator","v2",[c("displacementUV"),$("positionToDisplace"),$("displacementData.normal"),p("tmpTangent"),p("tmpBinormal")])};\n                        displacementData.tangent = tmpTangent;\n                        displacementData.binormal = tmpBinormal;\n                        `:i}\n                    displacementUV = ${f("applyUVCombination","v2",[c("displacementUV"),m("m3",`${v("displacementUvTransform")}`)])};\n                    ${_("dv")}  = 2.0 * ${P(g("displacementMap"),"displacementUV")}.xyz - 1.0;\n                    ${S("df")}  = ${v("displacementScale")} * dv.x + ${v("displacementBias")};\n                    return positionToDisplace + normalize(displacementData.normal) * df;\n                }\n                `:`\n                ${n.displacementAddCoef&&n.displacementMulCoef?`\n                    ${h({uniformName:"displacementAddCoef",uniformType:"v3"})} \n                    ${h({uniformName:"displacementMulCoef",uniformType:"v3"})} \n                    `:i}\n\n                ${d("ComputeDisplacedPosition","v3",[c("iDisplacementUV"),$("positionToDisplace")])}{\n                    ${y("displacementUV")} = iDisplacementUV;\n                    ${n.mappingType>-1?`        \n                        ${_("tmpTangent")} = displacementData.tangent;\n                        ${_("tmpBinormal")} = displacementData.binormal;\n                        displacementUV = ${f("applyMappingOperator","v2",[c("displacementUV"),$("positionToDisplace"),$("displacementData.normal"),p("tmpTangent"),p("tmpBinormal")])};\n                        displacementData.tangent = tmpTangent;\n                        displacementData.binormal = tmpBinormal;\n                        `:i}\n                    displacementUV = ${f("applyUVCombination","v2",[c("displacementUV"),m("m3",`${v("displacementUvTransform")}`)])};\n                    ${_("dv")}  = 2.0 * ${P(g("displacementMap"),"displacementUV")}.xyz - 1.0;\n                    ${n.displacementAddCoef&&n.displacementMulCoef?`dv = ${v("displacementMulCoef")} * dv + ${v("displacementAddCoef")};`:i}\n                    ${_("df")}  = normalize(displacementData.normal) * dv.z + normalize(displacementData.tangent) * dv.x + normalize(displacementData.binormal) * dv.y;\n                    return positionToDisplace + df;\n                }\n                `}\n\n            ${d("ComputeDisplacedNormal","v3",[c("displacementUV"),$("displacedPosition"),$("positionToDisplace")])}{\n                ${S("displacementDelta")}  = length(displacedPosition - positionToDisplace);\n                if (displacementDelta <= 1e-3) {\n                    return normal;\n                }\n                ${y("uvOffsetFactor")}  = 1.25 / ${v("displacementMapSize")};\n                ${S("objectOffsetFactor")}  = 0.00872664625 * ${(n=>{var e={uniformName:n};return t.getObjectUniform(e)})("displacementRadius")} / max(max(length(${v("displacementUvTransform")}[0]),length(${v("displacementUvTransform")}[1])), 1.0);\n                ${_("t")}  = displacementData.tangent * objectOffsetFactor;\n                ${_("b")} = displacementData.binormal * objectOffsetFactor;\n                \n                ${y("offset")} = ${y()}(1.0,0.0);\n                ${_("A")}  = ${N("displacementUV + uvOffsetFactor * offset","positionToDisplace + t")} - displacedPosition;\n                A = ${f("vNormalize","v3",[$("A")])};\n\n                offset = ${y()}(0.0,1.0);\n                ${_("C")}  = ${N("displacementUV + uvOffsetFactor * offset","positionToDisplace + b")} - displacedPosition;\n                C = ${f("vNormalize","v3",[$("C")])};\n\n                offset = ${y()}(-1.0,0.0);\n                ${_("E")}  = ${N("displacementUV + uvOffsetFactor * offset","positionToDisplace - t")} - displacedPosition;\n                E = ${f("vNormalize","v3",[$("E")])};\n\n                offset = ${y()}(0.0,-1.0);\n                ${_("G")}  = ${N("displacementUV + uvOffsetFactor * offset","positionToDisplace - b")} - displacedPosition;\n                G = ${f("vNormalize","v3",[$("G")])};\n             \n                offset = ${y()}(1.0,1.0);\n                ${_("B")}  = ${N("displacementUV + uvOffsetFactor * offset","positionToDisplace + t + b")} - displacedPosition;\n                B = ${f("vNormalize","v3",[$("B")])};\n\n                offset = ${y()}(-1.0,1.0);\n                ${_("D")}  = ${N("displacementUV + uvOffsetFactor * offset","positionToDisplace - t + b")} - displacedPosition;\n                D = ${f("vNormalize","v3",[$("D")])};\n\n                offset = ${y()}(-1.0,-1.0);\n                ${_("F")}  = ${N("displacementUV + uvOffsetFactor * offset","positionToDisplace - t - b")} - displacedPosition;\n                F = ${f("vNormalize","v3",[$("F")])};\n\n                offset = ${y()}(1.0,-1.0);\n                ${_("H")}  = ${N("displacementUV + uvOffsetFactor * offset","positionToDisplace + t - b")} - displacedPosition;\n                H = ${f("vNormalize","v3",[$("H")])};\n\n\n                ${_("displacedNormal")}  = cross(A, B) + cross(B, C) + cross(C, D) + cross(D,E)+ cross(E,F)+ cross(F,G)+ cross(G,H)+ cross(H,A);\n                ${S("dotNdN")}  = dot(displacedNormal, displacementData.normal);\n                ${_("res")}  = (sign(dotNdN) + 1e-2)* displacedNormal;\n                return ${f("vNormalize","v3",[$("res")])};\n            }\n    `;var e},M=function(n){return`\n            displacementData.tangent = normalize(objectTangent.xyz);\n            displacementData.binormal = normalize(objectBinormal.xyz);\n            ${y("displacementUv")};\n            if (${x("uvSlot",n)} == 1) {\n                displacementUv = ${y()}(uv.xy);\n            } else {\n                displacementUv = ${y()}(uv2.xy);\n            }\n            ${n.skinning?`\n                displacementData.normal = skinnedNormal.xyz;\n                ${_("displacedPosition")}  = ${N("displacementUv","position_.xyz")};\n                ${_("displacedNormal")}  = ${f("ComputeDisplacedNormal","v3",[c("displacementUv"),$("displacedPosition"),$("skinned.xyz")])};\n                `:`\n                displacementData.normal = normal.xyz;\n                ${_("displacedPosition")}  = ${N("displacementUv","position_.xyz ")};\n                ${_("displacedNormal")}  = ${f("ComputeDisplacedNormal","v3",[c("displacementUv"),$("displacedPosition"),$("position_.xyz")])};\n                `}\n    `},U=function(n){return`\n            ${C("decalPositionVS")} = mvPosition;\n            ${C("decalPositionCS")} = ${e="position",r.getBuiltin(e,r.ShaderStages.out)};\n        `;var e},w=function(t){var r=t.mappingType>-1&&!t.mappingUseFragment,a=t.mappingType>-1&&t.mappingUseFragment;function o(n,e){return`         \n            ${n} = ${n} * ${T()}(${v("repeatBumpMap")}, 1.0, 1.0) +  ${T()}(${v("offsetBumpMap")}, 0.0, 0.0);\n            ${r?`\n                ${t.needTangentBinormal?`\n                    {\n                        ${_("tmpTangent")} = tangent;\n                        ${_("tmpBinormal")} = binormal;\n                        ${n}  =  ${T()}(${f("applyMappingOperator","v2",[c(`${e}.xy`),$("position_"),$("normal"),p("tmpTangent"),p("tmpBinormal")])}, 0.0, 0.0);\n                        tangent = tmpTangent;\n                        binormal = tmpBinormal;\n                    }\n                    `:`\n                    ${n}  =  ${T()}(${f("applyMappingOperator","v2",[c(`${e}.xy`),$("position_"),$("normal")])}, 0.0, 0.0);\n                    `}\n                `:i}\n            `}return`    \n        ${t.useUV?`  \n            ${n._ShaderChunk.map_varying_set_vertex(t)}\n            ${o(C("vUv"),"uv")}\n            ${e._useUv2(t)?o(C("vUv2"),"uv2"):i}\n            ${e._useUv3(t)?o(C("vUv3"),"uv3"):i}\n            `:i}\n\n        ${a?`\n            ${C("localPosition")} = position_;\n            ${C("localNormal")} = normal;\n            `:i}\n    `};return{getDisplacementShaders:function(n){return n.displacementMap?[b(n),M(n)]:[i,i]},getDecalShaders:function(n){return n.isDecal?[`\n            ${D({varyingName:"decalPositionVS",varyingType:"v4"})}\n            ${D({varyingName:"decalPositionCS",varyingType:"v4"})}\n    `,U()]:[i,i]},getMappingShaders:function(e){return[`\n                ${e.useUV?`\n                    ${n._ShaderChunk.map_pars_varying_declare_vertex_fragment(e)}\n                    ${h({uniformName:"offsetBumpMap",uniformType:"v2"})}     \n                    ${h({uniformName:"repeatBumpMap",uniformType:"v2"})} \n                    `:i}\n                ${n._DefaultShaderChunk.map_pars_vertex_fragment(e)}\n            `,w(e)]}}})),define("DS/ShaderBuilders/PBRUtils/PBRFragmentIBLShaderBuilderUtils",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PBRUtils/PBRShaderBuilderUtils","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a,o){"use strict";const i="",s=r.ParameterUtils,l=r.FunctionHandler,u=r.BridgeFunctions,m=n=>s.parameterF(n),c=n=>s.parameterV2(n),$=n=>s.parameterV3(n),p=n=>s.parameterT2(n),d=(n,e,t)=>l.declareFunction(n,e,t),f=(n,e,t)=>l.callFunction(n,e,t),h=n=>t.addUniform(n),v=n=>t.addGlobalUniform(n),g=n=>t.addLightUniform(n),x=n=>{var e={uniformName:n};return t.getUniform(e)},S=n=>{var e={uniformName:n};return t.getTextureUniform(e)},y=n=>{var e={uniformName:n};return t.getLightTextureUniform(e)},_=n=>{var e={uniformName:n};return t.getGlobalTextureUniform(e)},T=n=>{var e={uniformName:n};return t.getGlobalUniform(e)},D=n=>{var e={uniformName:n};return t.getLightUniform(e)},C=n=>a.getShaderOutput(n),P=n=>f("vMax","f",[$(n)]),N=n=>f("unpackFrom16","f",[c(n)]),b=(n,e,t)=>f("sampleBRDFTexture","v4",[m(n),m(e),c(t)]),M=(n,e,t)=>f("computeHorizonFade","f",[$(n),$(e),m(t)]),U=n=>f("getMips","v2",[m(n)]),w=n=>f("getEnvMapUV","v2",[$(n)]),V=(n,e,t)=>f("getUVFromMips","v2",[m(n),c(e),c(t)]),z=(n,e)=>f("getUVBoxFromMips","v4",[m(n),c(e)]),F=(n,e,t,r,a)=>f("sampleMipMapRoughness","v4",[c(n),m(e),m(t),p(r),p(a)]),I=(n,e,t,r,a)=>{return f("texture2DBilinearIBLwBox","v4",[p(n),(o=e,s.parameterV4(o)),c(t),c(r),c(a)]);var o},R=(n,e)=>f("correctParallaxFinite","v3",[$(n),$(e)]),A=(n,e)=>f("correctParallax","v3",[$(n),$(e)]),L=(n,e,t)=>f("FresnelSchlick","v3",[$(n),$(e),m(t)]),B=n=>f("SpecGlossEnergyConservationTerm","f",[$(n)]),E=(n=null,e=!1)=>{var t={name:n,constant:e};return o.float(t)},k=(n=null)=>{var e={name:n,constant:!0};return o.float(e)},O=(n=null,e="",t=0)=>{var r={name:n,addressSpace:e,size:t};return o.vec2(r)},G=(n=null)=>O(n,"private"),H=(n=null,e=!1,t=0)=>{var r={name:n,constant:e,size:t};return o.vec3(r)},X=(n=null,e=!1,t=0)=>{var r={name:n,constant:e,size:t};return o.vec4(r)},W=(n,e)=>u.sample2DTexture(n,e);let j,q;{let e=function(n){return`      \n                ${n.sslreflection||n.sslrefraction||n.useSSAO?v({uniformName:"invScreenSize",uniformType:"v2"}):i}\n                ${n.sslreflection?v({uniformName:"reflectionColorTexture",uniformType:"t2"}):i}\n                ${n.sslrefraction?v({uniformName:"refractionColorTexture",uniformType:"t2"}):i}\n                ${n.useSSAO?`\n                    ${v({uniformName:"aoTexture",uniformType:"t2"})}\n                    ${v({uniformName:"aoParams",uniformType:"v2"})}\n                    `:i}\n                \n                ${k("oneOverMax16int")} = 0.000015259021896696422;\n\n                ${d("unpackFrom16","f",[c("pack")])}{\n                    return 255.0 * oneOverMax16int * (256.0 * pack.x + pack.y);\n                }\n                \n                ${k("E_130_OVER_258")}  = 0.50387596899;\n                ${k("E_128_OVER_258")}  = 0.496124031;\n                ${k("E_1_OVER_128")}  = 0.0078125;\n                ${G("PRECOMPUTED_TEXTURE_LOWER_NEAREST")} = ${O()}(1e-2, 0.5 * E_1_OVER_128);\n                ${G("PRECOMPUTED_TEXTURE_UPPER_NEAREST")} = ${O()}(1.0 - 0.5 * E_1_OVER_128);\n                \n                // contains G * pow5(1 - VoH) on xy and G * (1 - pow5(1 - VoH)) on zw for the GGX BRDF\n                ${G("PRECOMPUTED_TEXTURE_1")}  = E_130_OVER_258 * ${O()}(0.0,1.0);\n                // Contains G of the Beckmann BRDF on xy and G of the Ashikmin BRDF on zw\n                ${G("PRECOMPUTED_TEXTURE_2")}  = E_130_OVER_258 * ${O()}(1.0,1.0);\n                // Contains G of the GGX BRDF on xy and G of the Estevez Kulla BRDF on zw\n                ${G("PRECOMPUTED_TEXTURE_3")}  = E_130_OVER_258 * ${O()}(0.0,0.0);\n\n                ${n.envMap||n.useIBLColor||n.sslreflection||n.sslrefraction&&n.useTransparency?`\n                    ${g({uniformName:"precomputedTexture",uniformType:"t2"})}\n                    ${d("sampleBRDFTexture","v4",[m("NdotV"),m("roughness"),c("offset")])}{\n                        ${O("uv")} = E_128_OVER_258 * clamp(${O()}(NdotV,roughness), PRECOMPUTED_TEXTURE_LOWER_NEAREST, PRECOMPUTED_TEXTURE_UPPER_NEAREST) + offset;\n                        return ${W(y("precomputedTexture"),"uv")};\n                    }\n                    `:i}\n\n            `},t=function(n){return`   \n            ${h({uniformName:"combine",uniformType:"i"})}      \n            ${h({uniformName:"reflectivity",uniformType:"f"})}\n            ${h({uniformName:"reflectivityEnvMap",uniformType:"t2"})}\n\n            ${d("sampleReflectivityEnvMap","v3",[$("reflectVec"),$("color")])}{\n                ${H("endColor")};\n                ${E("probeR")} = INV_PI * acos( reflectVec.z ) / length(reflectVec.xy);\n                ${H("fetchedColor")} = ${W(S("reflectivityEnvMap"),"0.5 * (probeR * reflectVec.xy + 1.0)")}.xyz;\n                ${H("mapColor")}  = ${f("convertToLinear","v3",[$("fetchedColor")])};\n                if ( ${x("combine")} == 1 ) {\n\n                    endColor = mix( color, mapColor,  ${x("reflectivity")} );\n\n                } else if ( ${x("combine")} == 2 ) {\n\n                    endColor = color + mapColor * ${x("reflectivity")};\n\n                } else {\n\n                    endColor = mix( color, color * mapColor, ${x("reflectivity")} );\n\n                }\n                return endColor;\n            }\n        `},r=function(n){function e(e){return`\n                ${e}  = ${f("texture2DBilinearIBL","v4",[p("map0"),c("uv"),c("hdrSize"),c("hdrTexelSize")])};\n                ${n.envMapsRGB?`${e}  *= ${X()}(${e} .xyz, 1.0);`:i}\n                `}function t(e){return`\n                ${n.nonRepeatIBLSampling?`uvAtlas = ${X()}(${V("atlasLevel","uv","mipsTexelSize")}, uv1.zw);`:`uvAtlas = ${z("atlasLevel","mipsTexelSize")};`}\n                ${e} = ${I("map1","uvAtlas","uv","mipsSize","mipsTexelSize")};\n                `}return`   \n                ${g({uniformName:"envMap",uniformType:"t2"})}\n                ${g({uniformName:"envMap2",uniformType:"t2"})}\n                ${g({uniformName:"ambienceMatrix",uniformType:"m4"})}\n                ${g({uniformName:"envMapExposureSpecular",uniformType:"f"})}\n                ${g({uniformName:"envMapExposureDiffuse",uniformType:"f"})}\n                ${n.envMapHDR?`\n                    ${g({uniformName:"mapHDRSize",uniformType:"v2"})}\n                    ${g({uniformName:"envMapHDRSize",uniformType:"v2"})}\n                    ${g({uniformName:"envMapHDRToMipsRatio",uniformType:"f"})}\n\n                    ${G("hdrSize")};\n                    ${G("hdrTexelSize")};\n                    ${G("mipsSize")};\n                    ${G("mipsTexelSize")};\n                    `:i}\n                \n                ${d("computeHorizonFade","f",[$("R"),$("N"),m("roughness")])}{\n                    ${E("coeff")}  = mix(0.5, 1.0, 1.0 - ${o="roughness",f("pow2","f",[m(o)])});\n                    return clamp(1.0 + coeff * dot(R, N), 0.0, 1.0);\n                }\n\n                ${d("getMips","v2",[m("roughnessValue")])}{\n                    ${E("mipValue")}  = max(6.0 + 1.15 * log2(roughnessValue + 0.0000001), 0.0);\n                    ${E("mipCoef")}  = fract(mipValue);\n                    if (mipValue > 6.0) {\n\n                        mipValue = 6.0;\n                        mipCoef = 1.0;\n                    }\n                    return ${O()}(mipValue,mipCoef);\n                }\n\n                ${d("getMipsLinearInverted","v2",[m("roughnessValue")])}{\n                    ${E("mipValue")}  = max(5.0 * (1.0 - roughnessValue) + 1.0, 0.0);\n                    ${E("mipCoef")}  = fract(mipValue);\n                    if (mipValue > 6.0) {\n\n                        mipValue = 6.0;\n                        mipCoef = 1.0;\n                    }\n                    return ${O()}(mipValue,mipCoef);\n                }\n\n                ${d("getMipsLinear","v2",[m("roughnessValue")])}{\n                    ${E("mipValue")}  = max(5.0 * (roughnessValue) + 1.0, 0.0);\n                    ${E("mipCoef")}  = fract(mipValue);\n                    if (mipValue > 6.0) {\n\n                        mipValue = 6.0;\n                        mipCoef = 1.0;\n                    }\n                    return ${O()}(mipValue,mipCoef);\n                }\n\n                ${d("getEnvMapUV","v2",[$("vector")])} {\n                    ${H("tmpVector")} = normalize((${D("ambienceMatrix")}*${X()}(vector,0.0)).xyz);\n                    if (abs(tmpVector.x) < 1e-6) {\n                        tmpVector.x = 1e-6;\n                    }\n                    ${E("phi")} = ${r="tmpVector.y",a="tmpVector.x",u.atan2(r,a)};\n                    ${E("theta")} = acos(tmpVector.z);\n                    return ${O()}(fract(0.5 + 0.5 * INV_PI * phi), 1.0 - INV_PI * theta);\n                }\n\n                ${d("getUVFromMips","v2",[m("mip"),c("uv"),c("texelSize")])} {\n                    ${E("t10")}  = pow(2.0, -floor(log2(mip + 1.0)));\n                    ${E("t11")}  = 2.0 - (mip + 2.0) * t10;\n                    ${E("t12")}  = 0.5 * t10;\n                    return ${O()}(t11 + 1.5 * texelSize.x + (2.0 * t12 - 3.0 * texelSize.x) * uv.x, t12 + 1.5 * texelSize.x + (t12 - 3.0 * texelSize.x) * uv.y);\n                }\n\n                ${d("getUVBoxFromMips","v4",[m("mip"),c("texelSize")])} {\n                    ${E("t10")}  = pow(2.0, -floor(log2(mip + 1.0)));\n                    ${E("t11")}  = 2.0 - (mip + 2.0) * t10;\n                    ${E("t12")}  = 0.5 * t10;\n                    return ${X()}(t11, t12 + 1.5 * texelSize.x , 2.0 * t12, t12 - 3.0 * texelSize.x);\n                }\n\n                ${d("sampleMipMapRoughness","v4",[c("uv"),m("mip"),m("coef"),p("map0"),p("map1")])} {\n                    ${X("color1")};\n                    ${X("color2")};\n                    ${X("uvAtlas")};\n                    ${E("atlasLevel")};\n                    ${n.envMapHDR?`\n                        ${n.WebGPU?`\n                            ${X("colorBase")};\n                            ${X("colorFromAtlas")};\n                            ${e("colorBase")}\n                            atlasLevel  = clamp(floor(mip) - 1.0, 0.0, 4.0);\n                            ${t("colorFromAtlas")}\n                            if (mip < 1.0) {\n                                color1 = colorBase;\n                            } else {\n                                color1 = colorFromAtlas;\n                            }\n                            `:`\n                            if (mip < 1.0) {                     \n                                ${e("color1")}\n                            } else {\n                                atlasLevel = clamp(floor(mip) - 1.0, 0.0, 4.0);\n                                ${t("color1")}\n                                \n                            }\n                            `}                   \n                        atlasLevel  = clamp(floor(mip), 0.0, 5.0);\n                        ${t("color2")}\n\n                        return mix(color1, color2, coef);\n                        `:`return ${W("map1","uv")};`}\n                }\n\n                ${n.useFiniteEnvMap?`\n                    ${g({uniformName:"sphereCenter",uniformType:"v3"})}\n                    ${g({uniformName:"projectionCenter",uniformType:"v3"})}\n                    ${g({uniformName:"sphereRadius",uniformType:"f"})}\n\n                    ${d("correctParallaxFinite","v3",[$("rayDir"),$("rayOrig")])}{\n                        ${n.reflectionProbes?"\n                            return rayDir;\n                            ":`             \n                            ${E("t")}  = 0.0;\n                            ${H("dist")}  = rayOrig - ${D("sphereCenter")};\n                            ${E("B")}  = 2.0*dot(rayDir, dist);\n                            ${E("C")}  = dot(dist, dist) - ${D("sphereRadius")}*${D("sphereRadius")};\n                            ${E("disc")}  = B*B - 4.0*C;\n                            if (disc < 0.0) {\n                                t = -1.0;\n                            } else {\n                                t = (-B + sqrt(disc)) / 2.0; \n                            }\n                            ${H("hitPos")}  = rayOrig + t*rayDir;\n                            ${H("sn")}  = (hitPos - ${D("projectionCenter")});\n                            return normalize(sn);\n                            `}\n                    }\n                    `:i}\n            `;var r,a,o},a=function(n){return`\n            ${h({uniformName:"envMapSheen",uniformType:"t2"})}\n            \n            ${d("sampleMipMapRoughnessSheen","v4",[c("uv"),m("mip"),m("coef"),p("map1")])} {\n                ${X("color1")} ;\n                ${X("color2")} ;\n\n                ${X("uv1")} ;\n                ${X("uv2")} ;\n\n                ${E("level1")}  = clamp(floor(mip) - 1.0, 0.0, 4.0);\n                ${n.nonRepeatIBLSampling?`\n                    ${O("uvFromMips")} = ${V("level1","uv","mipsTexelSize")};\n                    uv1.x = uvFromMips.x;\n                    uv1.y = uvFromMips.y;\n                    `:`uv1 = ${z("level1","mipsTexelSize")};`}\n                color1 = ${I("map1","uv1","uv","mipsSize","mipsTexelSize")};\n\n                ${E("level2")}  = clamp(floor(mip), 0.0, 5.0);\n                ${n.nonRepeatIBLSampling?`\n                    ${O("uv2FromMips")} = ${V("level2","uv","mipsTexelSize")};\n                    uv2.x = uv2FromMips.x;\n                    uv2.y = uv2FromMips.y;\n                    `:`uv2 = ${z("level2","mipsTexelSize")};`}\n                color2 = ${I("map1","uv2","uv","mipsSize","mipsTexelSize")};\n\n                return mix(color1, color2, coef);\n            }\n        `},o=function(n){return`   \n            ${h({uniformName:"reflectionProbeProxyMin",uniformType:"v3"})} \n            ${h({uniformName:"reflectionProbeProxyMax",uniformType:"v3"})}\n            ${h({uniformName:"reflectionProbePos",uniformType:"v3"})}\n\n            ${d("correctParallax","v3",[$("worldPos"),$("reflectVec")])} {\n\n                ${H("rbmax")}  = (${x("reflectionProbeProxyMax")} - worldPos) / reflectVec;\n                ${H("rbmin")}  = (${x("reflectionProbeProxyMin")} - worldPos) / reflectVec;\n\n                ${H("rbminmax")}  = max(rbmax, rbmin);\n\n                ${E("distance")}  = min(min(rbminmax.x, rbminmax.y), rbminmax.z);\n\n                ${H("intersectPos")}  = worldPos + reflectVec * distance;\n\n                return normalize(intersectPos - ${x("reflectionProbePos")});\n            }\n        `};j=function(i){let s=`\n                ${e(i)}\n            `;return i.envMap?(s=`\n                    ${s}\n                    ${i.nonRepeatIBLSampling?n._DefaultShaderChunk.ibl_sample_methods(i):n._DefaultShaderChunk.ibl_sample_methods_repeat(i)}\n                    ${r(i)}\n                `,i.sheen&&i.envMapSheen&&(s=`\n                        ${s}\n                        ${a(i)}\n                    `),i.reflectionProbes&&(s=`\n                        ${s}\n                        ${o(i)}\n                    `)):s=`\n                    ${s}\n                    ${g({uniformName:"ambientLightColor",uniformType:"v4"})}\n                `,i.reflectivityEnvMap&&(s=`\n                    ${s}\n                    ${t(i)}\n                `),s}}{let e,t,r=function(e){return` \n\t\t\t\t${H("ambientTerm")}  = ${D("ambientLightColor")}.xyz;\n                ${e.invisiblePlaneMaterial?`\n                    ambientTerm = ${H()}(${P("ambientTerm")});\n                    lightNormalizationFactor += ambientTerm;\n                    `:i}\n\t\t\t\t${H("ambientColor")}  = albedo;\n\t\t\t\t${e.subsurface?"ambientColor *= materialData.scatteringColor;":i}\n                ${e.sslreflection||e.sslrefraction?`\n                    ${H("specularColor")}  = ${H()}(0.0);\n                    ${E("NdotV")}  = dot(surfaceData.viewNormal, surfaceData.view);\n                    `:i}\n                ${e.sslreflection?`\n                    ${X("preCompGGX")}  = ${b("NdotV","materialData.roughness","PRECOMPUTED_TEXTURE_1")};\n                    ${H("GFresnelVoH")}  = materialData.sr0Color* ${N("preCompGGX.xy")} + materialData.sr90Color * ${N("preCompGGX.zw")};\n                    ${X("ssrColor")}  = ${W(_("reflectionColorTexture"),`${n._DefaultShaderChunk.getScreenUVs(e)}`)};\n                    specularColor += GFresnelVoH * ssrColor.w * ssrColor.xyz; \n                    `:i}\n                ${e.sslrefraction&&e.useTransparency?`\n                    if (materialData.transparency > 0.0 && materialData.metalness < 1.0) {\n                        ${O("preCompRefraction")}  = ${b("-NdotV","materialData.roughness","PRECOMPUTED_TEXTURE_3")}.xy;\n                        ${E("GRefract")}  = ${N("preCompRefraction")};\n                        ${X("ssrefractionColor")}  = ${W(_("refractionColorTexture"),`${n._DefaultShaderChunk.getScreenUVs(e)}`)};\n                        ${H("refractionFresnel")}  = ${L("materialData.specularBlendingSR0",`${H()}(1.0)`,"NdotV")};\n                        ${H("refractColorFactor")} = GRefract * materialData.transparentColor * (1.0 - materialData.specularContribution * ${P("refractionFresnel")});\n                        specularColor += refractColorFactor * ssrefractionColor.w * ssrefractionColor.xyz;\n                    } \n                    `:i}\n                ${e.lightMap?`\n                    ${1===e.lightMapMode?`${C("out0")} += ${X()}(aoValue * ambientColor, 0.0);`:`${C("out0")} += ${X()}(aoValue * ambientColor * ambientTerm, 0.0);`}\n                    `:`${C("out0")} += ${X()}(ambientColor * ambientTerm, 0.0);`}         \n                ${e.sslreflection||e.sslrefraction?`\n                    ${C("out0")} += ${X()}(specularColor, 0.0);\n                    `:i}   \n                ${e.invisiblePlaneMaterial?`\n                    if (length(lightNormalizationFactor) < 1e-6) {\n                        ${C("out0")} = ${X()}(1.0, 1.0, 1.0, ${C("out0")}.a);\n                    } else {\n                        ${C("out0")} /= ${X()}(lightNormalizationFactor, 1.0);\n                    }\n                    `:i}\n            `},a=function(n){return`\n            ${E("NdotV")} = dot(surfaceData.viewNormal, surfaceData.view);\n            ${H("specularIBLValue")} = ${H()}(0.0);\n            ${H("diffuseIBLValue")} = ${H()}(0.0);\n            ${n.envMap?`\n                ${H("cameraToVertex")} = normalize( ${H()}( (${X()}( -surfaceData.view, 0.0 ) * ${T("viewMatrix")}).xyz ) );\n                ${n.normalMap||n.clearCoatNormalMap||n.specGlossFlakes?`\n                    ${H("worldVertexNormal")} = normalize( ${H()}( (${X()}( viewNormal, 0.0 ) * ${T("viewMatrix")}).xyz ) );\n                    `:i}\n                \n                ${H("reflectVec")} = ${H()}(0.0);\n                ${O("reflectionUV")} = ${O()}(0.0);\n                \n                ${E("expoSpecular")} = ${D("envMapExposureSpecular")};\n                ${E("expoDiffuse")} = ${D("envMapExposureDiffuse")};\n                `:`\n                ${X("IBLColor")} = ${D("ambientLightColor")};\n                `}\n        `},o=function(n){return`\n                ${n.invisiblePlaneMaterial?`\n                    diffuseIBLValue = ${H()}(${P("diffuseIBLValue")});\n                    lightNormalizationFactor += diffuseIBLValue;\n                    `:i}\n                ${H("totalIBLValue")}  = specularIBLValue + diffuseIBLValue;\n                ${n.lightMap?`\n                    ${1===n.lightMapMode?`totalIBLValue *= ${e="aoValue",f("saturate","v3",[$(e)])};`:"totalIBLValue *= aoValue;"}\n                    `:i}\n                ${C("out0")} += ${X()}(totalIBLValue, 0.0);\n                ${n.invisiblePlaneMaterial?`\n                    if (length(lightNormalizationFactor) < 1e-6) {\n                        ${C("out0")} = ${X()}(1.0, 1.0, 1.0, ${C("out0")}.a);\n                    } else {\n                        ${C("out0")} /= ${X()}(lightNormalizationFactor, 1.0);\n                    }\n                    `:i}\n            `;var e},s=function(e){return`\n                \n                ${E("hOcclusion")}  = 1.0;\n                ${E("roughnessToUse")} = ${e.useSpecularAA?"materialData.roughnessAACorrected":"materialData.roughness"};\n                ${e.envMap?`\n                    ${O("mips")}  = ${U("roughnessToUse")};\n                    ${e.reflectionProbes?`reflectVec = ${A("surfaceData.worldPosition","reflectVec")};`:i}\n                    ${e.useFiniteEnvMap?`reflectVec = ${R("reflectVec","surfaceData.worldPosition")};`:i}\n                    reflectionUV = ${w("reflectVec")};\n                    ${X("cubeColor")} = expoSpecular * ${F("reflectionUV","mips.x","mips.y",y("envMap"),y("envMap2"))};\n                    ${e.normalMap?`\n                        hOcclusion  = ${M("reflectVec","worldVertexNormal","roughnessToUse")};\n                        hOcclusion *= hOcclusion;\n                        `:i}\n                    `:`             \n                    ${X("cubeColor")} = IBLColor;\n                    `}\n                ${X("preCompGGX")}  = ${b("NdotV","roughnessToUse","PRECOMPUTED_TEXTURE_1")};\n                ${H("GFresnelVoH")}  = materialData.sr0Color * ${N("preCompGGX.xy")} + materialData.sr90Color * ${N("preCompGGX.zw")};         \n                specularIBLValue = cubeColor.xyz * GFresnelVoH;\n                ${e.sslreflection?`\n                    ${X("ssrColor")}  = ${W(_("reflectionColorTexture"),`${n._DefaultShaderChunk.getScreenUVs(e)}`)};\n                    specularIBLValue = mix(specularIBLValue, GFresnelVoH * ssrColor.xyz, ssrColor.w);\n                    `:i}\n                specularIBLValue *= hOcclusion;\n                ${e.sslrefraction&&e.useTransparency?`\n                    if (materialData.transparency > 0.0 && materialData.metalness < 1.0) {\n                        ${e.envMap?`\n                            ${H("refractVec")}  = refract(cameraToVertex, surfaceData.worldNormal, ${e.thinWalled?"1.0":"1.0/materialData.adjustedIoR"});\n                            ${e.reflectionProbes?`refractVec = ${A("surfaceData.worldPosition","refractVec")};`:i}\n                            ${e.useFiniteEnvMap?`refractVec = ${R("refractVec","surfaceData.worldPosition")};`:i}\n                            ${O("refractionUV")}  = ${w("refractVec")};\n                            ${X("cubeRefractColor")}  = expoSpecular * ${F("refractionUV","mips.x","mips.y",y("envMap"),y("envMap2"))};\n                            `:`\n                            ${X("cubeRefractColor")}  = IBLColor;\n                            `}\n                        \n                        ${O("preCompRefraction")}  = ${b("-NdotV","roughnessToUse","PRECOMPUTED_TEXTURE_3")}.xy;\n                        ${E("GRefract")}  = ${N("preCompRefraction")};\n                        ${X("ssrefractionColor")}  = ${W(_("refractionColorTexture"),`${n._DefaultShaderChunk.getScreenUVs(e)}`)};\n                        ${H("refractionColor")} = mix(cubeRefractColor.xyz, ssrefractionColor.xyz, ssrefractionColor.w);\n                        ${e.dspbr?`\n                            ${H("refractionFresnel")}  = ${L("materialData.specularBlendingSR0",`${H()}(1.0)`,"NdotV")};\n                            ${E("fTransRefraction")}  = 1.0 - materialData.specularContribution * ${P("refractionFresnel")};`:`\n                            ${H("refractionFresnel")} = ${L("materialData.sr0Color","materialData.sr90Color","NdotV")};\n                            ${E("fTransRefraction")} = 1.0 -  ${P("refractionFresnel")};\n                            `}\n                        refractionColor *= GRefract * materialData.transparentColor * fTransRefraction;\n                        ${e.subsurface?`          \n                            ${e.thicknessBasedTransmittance?"refractionColor *= materialData.transmittanceColor;":`          \n                                ${e.sssLUT?`\n                                    ${E("transS")}  = ${P(x("maxTranslucencyDepth"))}/ 15.0;\n                                    `:`\n                                    ${E("transS")} = 1.0 / ${P(x("absorptionCoefficients"))};\n                                    `}\n                                refractionColor *= ${f("GetTransmittance","v3",[m("transS")])};\n                                `}\n                            `:i}\n                        specularIBLValue += refractionColor;\n                        \n                    }\n                    `:i}\n            `},l=function(n){return`\n                ${X("diffuseTexelColor")} = ${X()}(0.0);\n                ${n.envMap?`\n                    ${O("normalUV")} = ${w("normalize(surfaceData.worldNormal)")};\n                    ${n.envMapDiffuse?`${E("diffMip")} = 6.0;`:`${E("diffMip")} = 5.0;`}\n                    ${X("diffUVBox")};\n                    ${n.nonRepeatIBLSampling?`diffUVBox = ${X()}(${V("diffMip","normalUV","mipsTexelSize")}, diffUVBox.zw);`:`diffUVBox = ${z("diffMip","mipsTexelSize")};`}\n                    diffuseTexelColor = expoDiffuse * ${I(S("envMap2"),"diffUVBox","normalUV","mipsSize","mipsTexelSize")};\n                    `:"\n                    diffuseTexelColor = IBLColor;\n                    "}\n                ${n.dspbr?"\n                    specularIBLValue += diffuseTexelColor.rgb * materialData.specularEnergyConservationConstant;\n                    diffuseTexelColor *= materialData.diffuseEnergyConservationConstant;\n                    ":`diffuseTexelColor *= ${B("GFresnelVoH")};`}\n                diffuseIBLValue = materialData.diffuseColor * diffuseTexelColor.xyz;\n            `},u=function(n){return`\n                ${s(n)}\n                ${l(n)}\n            `};{let n=function(n){return`\n                    ${H("diffuseInvIBLValue")} = ${H()}(0.0);\n                    ${!n.dspbrWithTranslucency||n.subsurface&&!n.thicknessBasedTransmittance?i:`\n                        if (materialData.translucency > 1e-6) {\n                            ${n.envMap?`\n                                ${O("normalInvUV")}  = ${w("normalize(-surfaceData.worldNormal)")};\n                                ${X("diffuseInvTexelColor")}  = expoDiffuse * ${I(S("envMap2"),"diffUVBox","normalInvUV","mipsSize","mipsTexelSize")};\n                                `:`\n                                ${X("diffuseInvTexelColor")} = IBLColor;\n                                `}\n                            diffuseInvIBLValue = materialData.translucencyColor * diffuseInvTexelColor.rgb * materialData.diffuseEnergyConservationConstant;\n                        }\n                        `}\n                `},t=function(n){return`   \n                    ${n.specgloss?"diffuseIBLValue *= materialData.scatteringColor;":`\n                        ${H("baseDiffuseIBLValue")}  = diffuseIBLValue;\n                        ${n.dspbrWithTranslucency?`\n                            diffuseIBLValue = mix(diffuseIBLValue, materialData.scatteringColor * baseDiffuseIBLValue, materialData.translucency);\n                            ${n.thicknessBasedTransmittance?"\n                                diffuseIBLValue = mix(diffuseIBLValue,  materialData.transmittanceColor * diffuseInvIBLValue, materialData.translucency);\n                                ":i}\n                            `:i}\n                        diffuseIBLValue = mix(diffuseIBLValue, materialData.scatteringColor * baseDiffuseIBLValue, materialData.transparency);\n                        `} \n                `},r=function(n){return`            \n                    ${n.dspbrWithTranslucency?"diffuseIBLValue = mix(diffuseIBLValue, diffuseInvIBLValue, materialData.translucency);":i}\n                `};e=function(e){return e.subsurface?`\n                        ${n(e)}\n                        ${t(e)}\n                    `:`\n                    ${n(e)}\n                    ${r(e)}\n                `}}{let n=function(n){return`\n                    ${E("NdotVcoating")}  = dot(surfaceData.clearCoatNormal, surfaceData.view);\n                    ${E("ccRoughnesstoUse")} = ${n.useSpecularAA?"materialData.clearCoatRoughnessAACorrected":"materialData.clearCoatRoughness"};\n                    ${n.envMap?`\n                        ${H("reflectVecCoating")}  = reflect( cameraToVertex, surfaceData.clearCoatWorldNormal );\n                        ${O("mipsC")}  = ${U("ccRoughnesstoUse")};\n                        ${n.reflectionProbes?`reflectVecCoating = ${A("surfaceData.worldPosition","reflectVecCoating")};`:i}\n                        ${n.useFiniteEnvMap?`reflectVecCoating = ${R("reflectVecCoating","surfaceData.worldPosition")};`:i}\n                        ${O("reflectionUVcoating")}  = ${w("reflectVecCoating")};\n                        ${X("cubeColorcoating")} = expoSpecular * ${F("reflectionUVcoating","mipsC.x","mipsC.y",y("envMap"),y("envMap2"))};\n                        ${n.clearCoatNormalMap?`\n                            ${E("chOcclusion")} = ${M("reflectVecCoating","worldVertexNormal","ccRoughnesstoUse")};\n                            chOcclusion *= chOcclusion;\n                            cubeColorcoating *= chOcclusion;\n                            `:i}   \n                        `:`\n                        ${X("cubeColorcoating")} = IBLColor;\n                        `}            \n                    ${X("precompCoat")}  = ${b("NdotVcoating","ccRoughnesstoUse","PRECOMPUTED_TEXTURE_1")};\n                    ${H("GFresnelVoHCoat")}  = ${N("precompCoat.xy")} * materialData.clearCoatSR0Color + ${N("precompCoat.zw")} * materialData.clearCoatSR90Color;\n                    ${H("clearCoatIBLValue")} = cubeColorcoating.xyz * GFresnelVoHCoat;\n                    ${n.dspbr?`\n                        ${H("coatingFresnel")}  = ${L("materialData.clearCoatSR0Color","materialData.clearCoatSR90Color",""+(e="NdotVcoating",`max(${e}, 0.0)`))};\n                        ${E("energyCoating")}  = 1.0 - materialData.clearCoat* ${P("coatingFresnel")};\n                        `:`\n                        ${E("energyCoating")} = ${B("GFresnelVoHCoat")};\n                        `}\n                    specularIBLValue *= energyCoating;\n                    diffuseIBLValue *= energyCoating;\n                    specularIBLValue += clearCoatIBLValue * materialData.clearCoat;\n                `;var e};t=function(e){return e.clearCoat?n(e):i}}let d,h,v=function(n){return n.envMap?n.anisotropy?`\n                    ${H("bitangent")}  = normalize((\n                            ${X()}(sin(2.0 * PI * materialData.anisotropyAngle) * surfaceData.tangent + cos(2.0 * PI * materialData.anisotropyAngle) * surfaceData.binormal, 0.0) * ${T("viewMatrix")}\n                        ).xyz);\n                    ${H("anisotropicTangent")}  = cross(bitangent, -cameraToVertex);\n                    ${H("anisotropicNormal")}  = cross(anisotropicTangent, bitangent);\t\t\n                    ${H("bentNormal")}  = normalize(mix(surfaceData.worldNormal, anisotropicNormal, 0.22*materialData.anisotropy));\n                    reflectVec = reflect( cameraToVertex, bentNormal );\n                `:"\n                reflectVec = reflect( cameraToVertex, surfaceData.worldNormal );             \n            ":i},g=function(n){return n.envMap&&n.anisotropy?`\n                    reflectVec = reflect( cameraToVertex, surfaceData.worldNormal );\n                    ${n.reflectionProbes?`reflectVec = ${A("surfaceData.worldPosition","reflectVec")};`:i}\n                    ${n.useFiniteEnvMap?`reflectVec = ${R("reflectVec","surfaceData.worldPosition")};`:i}        \n                    reflectionUV = ${w("reflectVec")};   \n                `:i};{let n=function(n){return`             \n                    ${E("NdotVMetalFlakes")}  = dot(metalFlakes.flakesNormal, surfaceData.view);\n                    ${n.envMap?`\n                        ${H("reflectVecMetalFlakes")}  = reflect( cameraToVertex, metalFlakes.flakesWorldNormal );\n                        ${O("mipsMetalFlakes")}  = ${U("metalFlakes.flakesRoughness")};\n                        ${n.reflectionProbes?`reflectVecMetalFlakes = ${A("surfaceData.worldPosition","reflectVecMetallicFlakes")};`:i}\n                        ${n.useFiniteEnvMap?`reflectVecMetalFlakes = ${R("reflectVecMetalFlakes","surfaceData.worldPosition")};`:i}                    \n                        ${O("reflectionUVMetalFlakes")}  = ${w("reflectVecMetalFlakes")};\n                        ${X("cubeColorMetalFlakes")} = expoSpecular * ${F("reflectionUVMetalFlakes","mipsMetalFlakes.x","mipsMetalFlakes.y",S("envMap"),S("envMap2"))};\n                        ${E("mFhOcclusion")}  = ${M("reflectVecMetalFlakes","worldVertexNormal","metalFlakes.flakesRoughness")};\n                        mFhOcclusion *= mFhOcclusion;\n                        cubeColorMetalFlakes *= mFhOcclusion;\n                        `:`\n                        ${X("cubeColorMetalFlakes")} = IBLColor;\n                        `}\n                    ${X("precompMetalFlakes")}  = ${b("NdotVMetalFlakes","metalFlakes.flakesRoughness","PRECOMPUTED_TEXTURE_1")};\n                    ${H("GFresnelVoHMetalFlakes")}  = ${N("precompMetalFlakes.xy")} * metalFlakes.flakesSR0Color ;             \n                    ${H("metalFlakesIBLValue")} = cubeColorMetalFlakes.xyz * GFresnelVoHMetalFlakes;       \n                    ${E("energyMetalFlakes")}  = ${B("GFresnelVoHMetalFlakes")};\n                    diffuseIBLValue *= energyMetalFlakes;\n                    specularIBLValue *= energyMetalFlakes;\n                    specularIBLValue += mFhOcclusion*metalFlakesIBLValue;\n                `},e=function(n){return`             \n                    ${E("NdotVMetal")} = NdotV;\n                    ${n.envMap?`\n                        ${O("mipsMetal")} = ${U("metal.flakesRoughness")};\n                        ${O("reflectionUVMetal")} = reflectionUV;\n                        ${X("cubeColorMetal")} = expoSpecular * ${F("reflectionUVMetal","mipsMetal.x","mipsMetal.y",S("envMap"),S("envMap2"))};\n                        `:`\n                        ${X("cubeColorMetal")} = IBLColor;\n                        `}\n                    ${X("precompMetal")}  = ${b("NdotVMetal","metal.flakesRoughness","PRECOMPUTED_TEXTURE_1")};\n                    ${H("GFresnelVoHMetal")}  = ${N("precompMetal.xy")} * metal.flakesSR0Color ;                   \n                    ${H("metalIBLValue")} = cubeColorMetal.xyz * GFresnelVoHMetal;\n                    ${E("energyMetal")} = ${B("GFresnelVoHMetal")};\n                    diffuseIBLValue *= energyMetal;\n                    specularIBLValue *= energyMetal;\n                    specularIBLValue += hOcclusion*metalIBLValue;\n                `},t=function(n){return`\n                        ${E("NdotVPearlFlakes")}  = dot(pearlFlakes.flakesNormal, surfaceData.view);\n                        ${n.envMap?`\n                            ${H("reflectVecPearlFlakes")}  = reflect( cameraToVertex, pearlFlakes.flakesWorldNormal );               \n                            ${O("mipsPearl")}  = ${U("pearlFlakes.flakesRoughness")};\n                            ${n.reflectionProbes?`reflectVecPearlFlakes = ${A("surfaceData.worldPosition","reflectVecPearlFlakes")};`:i}\n                            ${n.useFiniteEnvMap?`reflectVecPearlFlakes = ${R("reflectVecPearlFlakes","surfaceData.worldPosition")};`:i}              \n                            ${O("reflectionUVPearlFlakes")}  = ${w("reflectVecPearlFlakes")};\n                            ${X("cubeColorPearlFlakes")} = expoSpecular * ${F("reflectionUVPearlFlakes","mipsPearl.x","mipsPearl.y",y("envMap"),y("envMap2"))};\n                            ${E("pFhOcclusion")}  = ${M("reflectVecPearlFlakes","worldVertexNormal","pearlFlakes.flakesRoughness")};\n                            pFhOcclusion *= pFhOcclusion;\n                            cubeColorPearlFlakes *= pFhOcclusion;\n                            `:"\n                            cubeColorPearlFlakes = IBLColor;\n                            "}\n                        ${X("precompPearlFlakes")}  = ${b("NdotVPearlFlakes","pearlFlakes.flakesRoughness","PRECOMPUTED_TEXTURE_1")};\n                        ${H("GFresnelVoHPearlFlakes")}  = ${N("precompPearlFlakes.xy")} * pearlFlakes.flakesSR0Color ;\n                        ${H("pearlFlakesIBLValue")} = cubeColorPearlFlakes.xyz * GFresnelVoHPearlFlakes;\n                        ${E("energyPearlFlakes")}  = ${B("GFresnelVoHPearlFlakes")};\n                        diffuseIBLValue *= energyPearlFlakes;\n                        specularIBLValue *= energyPearlFlakes;\n                        specularIBLValue += pearlFlakesIBLValue;\n                `},r=function(n){return`\n                    ${H("flakesIBLValue")}  = ${H()}(0.0);\n                    ${n.envMap?`\n                        ${O("mipsDSPBRFlakes")}  = ${U("flakesData.flakesRoughness")};    \n                        `:i}       \n                    if (flakesData.smoothWeight > 0.0) {                \n                        ${n.envMap?`\n                            ${O("reflectionUVSmoothFlakes")}  = reflectionUV;\n                            ${X("cubeColorSmoothFlakes")}  = expoSpecular * ${F("reflectionUVSmoothFlakes","mipsDSPBRFlakes.x","mipsDSPBRFlakes.y",y("envMap"),y("envMap2"))};  \n                            `:`\n                            ${X("cubeColorSmoothFlakes")} = IBLColor;\n                            `}     \n                        ${O("preCompDSPBRSmoothFlakes")}  = ${b("NdotV","flakesData.flakesRoughness","PRECOMPUTED_TEXTURE_3")}.xy;\n                        ${E("GSmoothFlakes")}  = ${N("preCompDSPBRSmoothFlakes")};\n                        flakesIBLValue += cubeColorSmoothFlakes.xyz * GSmoothFlakes * flakesData.smoothFlakesColor;\n                    }\n                    ${n.dspbrFlakesThreeLayers?`                      \n                        if (flakesData.stochasticWeight > 0.0) {\n                            ${E("NdotVSto")}  = dot(flakesData.stochasticHemisphereFlakesNormal, surfaceData.view);\n                            ${n.envMap?`                      \n                                ${H("worldReflStoFlakes")}  = normalize( ( ${X()}( flakesData.stochasticHemisphereFlakesReflect, 0.0 ) * ${T("viewMatrix")} ).xyz );\n                                ${n.reflectionProbes?`worldReflStoFlakes = ${A("surfaceData.worldPosition","worldReflStoFlakes")};`:i}\n                                ${n.useFiniteEnvMap?`worldReflStoFlakes = ${R("worldReflStoFlakes","surfaceData.worldPosition")};`:i}\n                                ${O("stoFlakesEnvMapUV")}  = ${w("worldReflStoFlakes")};\n                                ${X("stoFlakesTexelColor")}  = expoSpecular * ${F("stoFlakesEnvMapUV","mipsDSPBRFlakes.x","mipsDSPBRFlakes.y",y("envMap"),y("envMap2"))};\n                                `:`\n                                ${X("stoFlakesTexelColor")} = IBLColor;\n                                `}  \n                            ${O("preCompDSPBRStoFlakes")}  = ${b("NdotVSto","flakesData.flakesRoughness","PRECOMPUTED_TEXTURE_3")}.xy;\n                            ${E("GStoFlakes")}  = ${N("preCompDSPBRStoFlakes")};\n                            flakesIBLValue += flakesData.stochasticHemisphereFlakesColor * stoFlakesTexelColor.xyz * GStoFlakes;\n                        }\n                        `:i}\n                    ${n.dspbrFlakesOneLayer?i:`\n                        if (flakesData.closeupWeight > 0.0) {\n                            ${E("NdotVClose")}  = dot(flakesData.closeupFlakesNormal, surfaceData.view);\n                            ${n.envMap?`   \n                                ${H("worldReflCloseFlakes")}  = normalize( ( ${X()}( flakesData.closeupFlakesReflect, 0.0 ) * ${T("viewMatrix")} ).xyz );\n                                ${n.reflectionProbes?`worldReflCloseFlakes = ${A("surfaceData.worldPosition","worldReflCloseFlakes")};`:i}     \n                                ${n.useFiniteEnvMap?`worldReflCloseFlakes = ${R("worldReflCloseFlakes","surfaceData.worldPosition")};`:i}\n                                ${O("closeFlakesEnvMapUV")}  = ${w("worldReflCloseFlakes")};\n                                ${X("closeFlakesTexelColor")}  = expoSpecular * ${F("closeFlakesEnvMapUV","mipsDSPBRFlakes.x","mipsDSPBRFlakes.y",y("envMap"),y("envMap2"))};\n                                ${O("preCompDSPBRCloseFlakes")}  = ${b("NdotVClose","flakesData.flakesRoughness","PRECOMPUTED_TEXTURE_3")}.xy;\n                                `:`\n                                ${X("closeFlakesTexelColor")} = IBLColor;\n                                `}  \n                            ${E("GCloseFlakes")}  = ${N("preCompDSPBRCloseFlakes")};\n                            flakesIBLValue += flakesData.closeupFlakesColor * closeFlakesTexelColor.xyz * GCloseFlakes;\n                        }\n                        `}\n                \n                    diffuseIBLValue *= flakesData.baseWeight;\n                    specularIBLValue *= flakesData.baseWeight;\n                    specularIBLValue += flakesIBLValue;\n                    `};d=function(a){return a.dspbrFlakes?r(a):a.specGlossFlakes?`\n                        ${e(a)}\n                        ${n(a)}\n                        ${a.pearlFlakesActivated?t(a):i}\n                    `:i}}{let e=function(e){return`        \n                    ${e.dspbrWithSheenColorRoughness?`\n                        ${E("sheenRough_IBL")}  = materialData.sheenRoughness;                                             \n                        ${e.dspbrWithSquaredEstevezKullaRoughness?"sheenRough_IBL *= sheenRough_IBL;":i}\n                        `:`${E("sheenRough_IBL")}  = materialData.sheen;`}\n                    ${e.sheenMode===n.SheenMode.SATIN?"sheenRough_IBL = 0.3;":i}\n                    ${e.envMap?`\n                        ${e.sheenMode===n.SheenMode.VELVET||e.sheenMode===n.SheenMode.VELVET_SOFT?`\n                            ${O("mipsF")}  = ${f("getMipsLinearInverted","v2",[m("sheenRough_IBL")])};\n                            `:`\n                            ${O("mipsF")} = ${f("getMipsLinear","v2",[m("sheenRough_IBL")])};\n                            `}\n                        ${X("sheenColor")}  = expoSpecular * ${f("sampleMipMapRoughnessSheen","v4",[c("reflectionUV"),m("mipsF.x"),m("mipsF.y"),p(S("envMapSheen"))])};\n                        `:`\n                        ${X("sheenColor")}  = IBLColor;\n                        `}\n                    ${e.sheenMode===n.SheenMode.VELVET?`\n                        ${O("precompSheen")}  = ${b("NdotV","sheenRough_IBL","PRECOMPUTED_TEXTURE_2")}.zw;\n                        `:`\n                        ${e.sheenMode===n.SheenMode.VELVET_SOFT?`\n                            ${O("precompSheen")}  = ${b("NdotV","sheenRough_IBL","PRECOMPUTED_TEXTURE_3")}.zw;\n                            `:`\n                            ${O("precompSheen")}  = ${b("NdotV","sheenRough_IBL","PRECOMPUTED_TEXTURE_2")}.xy;\n                            `}\n                        `}\n                    ${E("GFab")}  = ${N("precompSheen")};\n                    ${H("sheenIBLValue")} = GFab * sheenColor.rgb;\n                    ${e.dspbrWithSheenColorRoughness?`\n                        ${E("sheenBlending")} = 1.0 - materialData.sheenEnergyConservationConstant;\n                        diffuseIBLValue *= sheenBlending;\n                        specularIBLValue *= sheenBlending;\n                        specularIBLValue +=  materialData.sheen * materialData.sheenColor * sheenIBLValue;\n                        `:`\n                        ${E("sheenBlending")}  = 1.0 - ${t="1.0-materialData.sheen",f("pow5","f",[m(t)])};\n                        diffuseIBLValue *= PI * sheenBlending * sheenIBLValue + (1.0 - sheenBlending);\n                        `}\n                `;var t};h=function(n){return n.sheen&&(n.envMapSheen||n.useIBLColor)?e(n):i}}q=function(n){if(!n.envMap&&!n.useIBLColor)return r(n);return`\n                ${a(n)}\n                ${v(n)}\n                ${u(n)}\n                ${g(n)}\n                ${e(n)}\n                ${h(n)}\n                ${d(n)}\n                ${t(n)}\n                ${o(n)}\n            `}}return{getIndirectLightShaders:function(n,e){return n?[j(e),e.shadowMapDebugMaterial?i:q(e)]:[i,i]}}})),define("DS/ShaderBuilders/LineUtils/LineBasicFragmentShaderBuilderUtils",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a){"use strict";const o="",i=r.ParameterUtils,s=r.BridgeFunctions,l=n=>i.parameterF(n),u=n=>i.parameterRefF(n),m=n=>i.parameter("b",n),c=n=>i.parameterV2(n),$=n=>i.parameterV3(n),p=n=>i.parameterV4(n),d=(n,e,t)=>r.FunctionHandler.declareFunction(n,e,t),f=(n,e,t)=>r.FunctionHandler.callFunction(n,e,t),h=n=>e.addUniform(n),v=n=>{var t={uniformName:n};return e.getUniform(t)},g=(n=null)=>{var e={name:n};return a.bool(e)},x=(n=null)=>{var e={name:n};return a.int(e)},S=(n=null)=>{var e={name:n};return a.float(e)},y=(n=null)=>{var e={name:n};return a.vec2(e)},_=(n=null,e=0)=>{var t={name:n,size:e};return a.vec3(t)},T=(n=null,e=0)=>{var t={name:n,size:e};return a.vec4(t)},D=n=>t.addVarying(n),C=n=>t.getVarying(n,t.ShaderStages.in),P=n=>t.getShaderOutput(n),N=(n,e)=>s.modulo(n,e);let b=function(e){let t=o,r=o;const i=e.useLineGap&&e.materialToUse!==n.MaterialToUse.pickingMaterial&&e.materialToUse!==n.MaterialToUse.pickingInstancingMaterial;if(e.wideLine){let o=n._ShaderChunk;r=`\n                ${r}                       \n                fragCoordLines = ${C("vFragCoordLineGap")}.xy;\n            `,t=`\n                ${t}\n                ${o.PDSFX_halfWidth_pars_vertex_fragment(e)}\n                ${D({varyingName:"vFragCoordLineGap",varyingType:"v4"})}\n                ${((n=null)=>{var e={name:n,addressSpace:"private"};return a.vec2(e)})("fragCoordLines")};\n            `,i&&(r=`\n                    ${r}\n                    lineGapF = ${C("vFragCoordLineGap")}.z;\n                `,t=`\n                    ${t}\n                    ${((n=null)=>{var e={name:n,addressSpace:"private"};return a.float(e)})("lineGapF")};\n\n                    ${d("projectToSegmentFactor","f",[c("next"),c("prev")])}{\n                        ${y("direction")}  = next-prev;\n                        ${S("l")}  = length(direction);\n                        ${y("proj")} = dot(fragCoordLines.xy - prev, direction)/(l*l) * direction + prev;\n                        return dot(fragCoordLines.xy - prev, direction)/(l*l);\n                    }\n                    \n                    ${d("projectToSegment","v2",[c("next"),c("prev")])}{\n                        ${y("direction")}  = next-prev;\n                        ${y("proj")} = ${f("projectToSegmentFactor","f",[c("next"),c("prev")])} * direction + prev;\n                        return proj;\n                    }\n                    ${d("getDistanceToSegment","f",[c("next"),c("prev")])}{\n                        return length(fragCoordLines.xy - ${f("projectToSegment","v2",[c("next"),c("prev")])});\n                    }\n                `,e.useLineGapColor&&(t=`\n                        ${t}                  \n                        ${h({uniformName:"lineGapColor",uniformType:"v3"})}\n                    `),(!e.dashedLine||e.dashedLine&&e.worldSizePattern)&&(t=`\n                        ${t}                \n                        ${D({varyingName:"vPointNextPrec",varyingType:"v4"})}\n                        ${D({varyingName:"vConstantNextPrec",varyingType:"v4"})}\n                        ${D({varyingName:"vConstantCurr_LineDistanceAltResetSecondDist",varyingType:"v4"})}\n                    `)),"round"===e.linejoin&&(t=`\n                    ${t}\n                    ${D({varyingName:"centerJoin",varyingType:"v4"})}\n                    ${D({varyingName:"centerRightJoin",varyingType:"v4"})}\n                    ${D({varyingName:"centerLeftJoin",varyingType:"v4"})}\n\n                    ${d("doCentralJoin",null,[p("iCenterJoin")])} {\n                        ${S("distanceJoin")}  = 0.0;\n                        ${S("varJoinC")}  = 0.0;\n                        if (dot(fragCoordLines - iCenterJoin.xy, iCenterJoin.zw) <= 0.0) {\n                            return;\n                        }\n                        distanceJoin = length(fragCoordLines - iCenterJoin.xy) / ${f("getHalfWidth","f",[])};\n                        if (distanceJoin > 1.0) {\n                            discard;\n                        }\n                    }\n\n                    ${d("doSideJoins",null,[p("iCenterRightJoin"),p("iCenterLeftJoin")])} {\n                        ${g("rightJoin")}  = abs(length(fwidth(iCenterRightJoin))) < 1e-2 && dot(fragCoordLines - iCenterRightJoin.xy, iCenterRightJoin.zw) > 0.0;\n                        ${g("leftJoin")}  =  abs(length(fwidth(iCenterLeftJoin))) < 1e-2 && dot(fragCoordLines - iCenterLeftJoin.xy, iCenterLeftJoin.zw) > 0.0;\n                        ${S("distanceRight")}  = 0.0;\n                        ${S("distanceLeft")}  = 0.0;\n                        ${S("varJoinR")}  = 0.0;\n                        ${S("varJoinL")}  = 0.0;\n                        if (rightJoin) {\n                            distanceRight = length(fragCoordLines - iCenterRightJoin.xy) / ${f("getHalfWidth","f",[])};\n                            if (distanceRight > 1.0) {\n                                discard;\n                            }\n                        }\n                        if (leftJoin) {\n                            distanceLeft = length(fragCoordLines - iCenterLeftJoin.xy) / ${f("getHalfWidth","f",[])};\n                            if (distanceLeft > 1.0) {\n                                discard;\n                            }\n                        }\n                    }\n\n                    ${d("doRoundJoins",null,[p("iCenterJoin"),p("iCenterRightJoin"),p("iCenterLeftJoin")])} {\n                        ${g("isOnJoin")}  = abs(length(fwidth(iCenterJoin))) < 1e-2;\n                        if (isOnJoin) {\n                            ${f("doCentralJoin",null,[p("iCenterJoin")])};\n                            return;\n                        }\n                        ${f("doSideJoins",null,[p("iCenterRightJoin"),p("iCenterLeftJoin")])};\n                     }\n                `,r=`\n                    ${r}\n                    ${f("doRoundJoins",null,[p(C("centerJoin")),p(C("centerRightJoin")),p(C("centerLeftJoin"))])};\n                `),"round"===e.linecap&&(t=`\n                    ${t}\n                    ${D({varyingName:"infosCenterCap",varyingType:"v4"})}\n                    ${D({varyingName:"centerLeftRight",varyingType:"v4"})}\n\n                    ${d("doLeftCap","b",[m("leftSide"),c("iInfos"),c("iCenterLeft")])} {\n                        ${g("leftCap")}  = leftSide && iInfos.x < 0.0;\n                        if (!leftCap) {\n                            return false;\n                        }\n                        ${S("distanceL")}  = length(fragCoordLines - iCenterLeft)/${f("getHalfWidth","f",[])};\n                        if (distanceL > 1.0) {\n                            discard;\n                        }\n                        return true;\n                    }\n\n                    ${d("doRightCap","b",[m("rightSide"),c("iInfos"),c("iCenterCap"),c("iCenterRight")])} {\n                        ${g("rightCap")}  = rightSide  && iInfos.x > length(iCenterRight - iCenterCap);\n                        if (!rightCap) {\n                            return false;\n                        }\n                        ${S("distanceR")}  = length(fragCoordLines - iCenterRight) / ${f("getHalfWidth","f",[])};\n                        if (distanceR > 1.0) {\n                             discard;\n                        }\n                        return true;\n                    }\n\n                    ${d("doRoundCap",null,[c("iInfos"),c("iCenterCap"),c("iCenterRight"),c("iCenterLeft")])} {\n                        ${g("centerSide")}  = abs(length(fwidth(iCenterCap))) < 1e-2;\n                        ${g("capToCap")}   = abs(fwidth(iInfos.y)) < 1e-2 && iInfos.y > 0.0;\n                        ${g("leftSide")}   = abs(length(fwidth(iCenterLeft))) < 1e-2 ;\n                        ${g("rightSide")}   = abs(length(fwidth(iCenterRight))) < 1e-2 ;\n                        ${g("toTreat")}   = ! (leftSide && rightSide && centerSide) || capToCap;\n                        if (!toTreat) {\n                            return;\n                        }\n                        ${g("leftCap")}   = ${f("doLeftCap","b",[m("leftSide"),c("iInfos"),c("iCenterLeft")])};\n                        ${g("rightCap")}   = ${f("doRightCap","b",[m("rightSide && centerSide"),c("iInfos"),c("iCenterCap"),c("iCenterRight")])};\n                    }\n                `,r=`\n                    ${r}\n                    ${f("doRoundCap",null,[c(C("infosCenterCap.xy")),c(C("infosCenterCap.zw")),c(C("centerLeftRight.zw")),c(C("centerLeftRight.xy"))])};\n                `)}return[t,r]};return function(e,t){let r=n._ShaderChunk;const a=e.useLineGap&&e.materialToUse!==n.MaterialToUse.pickingMaterial&&e.materialToUse!==n.MaterialToUse.pickingInstancingMaterial;let i=`\n            ${r.PDSFX_Color_pars_fragment(e)}\n            ${t}\n        `,s="";if(e.wideLine||e.dashedLine){let[n,t]=b(e),[r,m]=function(n){let e=o,t=o;if(n.dashedLine){function r(){let n=o,e=["x","y","z","w"];for(let t=0;t<4;t++)n=`\n                        ${n};\n                        cur = dashInfo.${e[t]};\n                        if (cur > dist) {\n                            break;\n                        }\n                        prec = cur;\n                        index++;\n                    `;return n}e=`\n                ${e}          \n                ${h({uniformName:"scale",uniformType:"f"})}\n                ${h({uniformName:"totalSize",uniformType:"f"})}\n                ${h({uniformName:"patternOffset",uniformType:"f"})}\n                ${n.patternSize?h({uniformName:"dashPattern",uniformType:"fv4",size:n.patternSize}):""}\n                ${D({varyingName:"vLineDistance",varyingType:"v2"})}\n            `,t=`\n                ${t}\n                ${S("dist")}  = ${C("vLineDistance")}.x;\n                ${S("dist2")}  = 0.0;\n            `,n.wideLine&&(t=n.worldSizePattern?`\n                        ${t}         \n                        ${_("connectionVector")} = ${_()} (\n                            ${C("vConstantNextYZ_CurXY")}.zw,\n                            ${C("vConstantCurrZ_PrecXYZ")}.x\n                        );\n                        ${g("isConnection")}  = length(fwidth(connectionVector)) < 1e-10;\n                        ${g("resetDist2")}  = fwidth(${C("vPointPrecZ_LineDistanceAltResetSecondDist_ConstantNextX")}).z > 1e-2;\n                    `:`\n                        ${t}         \n                        ${g("isConnection")}  = length(fwidth(${C("vConstantCurr_LineDistanceAltResetSecondDist")}.xy)) < 1e-10;\n                        ${g("resetDist2")}  = fwidth(${C("vConstantCurr_LineDistanceAltResetSecondDist")}).w > 1e-2;\n                    `),n.worldSizePattern?(e=`\n                    ${e}       \n                    ${n.worldSizePattern2?D({varyingName:"vPatternStartEnd",varyingType:"v2"}):o}\n                `,n.wideLine&&(e=`\n                        ${e}\n                        ${D({varyingName:"vPointCurrXYZ_NextX",varyingType:"v4"})}\n                        ${D({varyingName:"vPointNextYZ_PrecXY",varyingType:"v4"})}\n                        ${D({varyingName:"vPointPrecZ_LineDistanceAltResetSecondDist_ConstantNextX",varyingType:"v4"})}\n                        ${D({varyingName:"vConstantNextYZ_CurXY",varyingType:"v4"})}\n                        ${D({varyingName:"vConstantCurrZ_PrecXYZ",varyingType:"v4"})}\n                        \n                        ${d("getDistance","f",[$("pointCurr"),$("next"),$("prev")])}{\n                            ${_("resPoint")}  = ${_()}(0.0);\n                            ${_("direction")}  = next-prev;\n                            ${S("lxy")}  = length(direction.xy);\n                            ${y("dirXY")}  = ${f("vNormalize","v2",[c("direction.xy")])};\n                            ${S("dotVal")}  = dot(pointCurr.xy - prev.xy, dirXY);\n                            resPoint.x = dotVal * dirXY.x;\n                            resPoint.y = dotVal * dirXY.y;\n                            resPoint.z = length(resPoint.xy) / lxy * direction.z;\n                            return clamp(length(resPoint), 0.0, length(direction));\n                        }\n\n                        ${d("getDistance","f",[$("pointCurr"),$("next"),$("prev"),$("origin")])}{\n                            ${_("resPoint")}  = ${_()}(0.0);\n                            ${_("direction")}  = next-prev;\n                            ${S("lxy")}  = length(direction.xy);\n                            ${y("dirXY")} = ${f("vNormalize","v2",[c("direction.xy")])};\n                            ${S("dotVal")}  = dot(pointCurr.xy - origin.xy, dirXY);\n                            resPoint.x = dotVal * dirXY.x;\n                            resPoint.y = dotVal * dirXY.y;\n                            resPoint.z = length(resPoint.xy) / lxy * direction.z;\n                            return clamp(length(resPoint), 0.0, length(direction));\n                        }\n                    `,t=`\n                        ${t}             \n                        ${_("pointCurr")} = ${C("vPointCurrXYZ_NextX")}.xyz;\n                        ${_("pointNext")} = ${_()}(\n                            ${C("vPointCurrXYZ_NextX")}.w, \n                            ${C("vPointNextYZ_PrecXY")}.xy\n                        );\n                        ${_("pointPrec")} = ${_()}(\n                                ${C("vPointNextYZ_PrecXY")}.zw, \n                                ${C("vPointPrecZ_LineDistanceAltResetSecondDist_ConstantNextX")}.x\n                        );\n                        if (!isConnection){           \n                            dist += ${f("getDistance","f",[$("pointCurr"),$("pointNext"),$("pointPrec")])};\n                        } else  {            \n                            ${_("constantCurr")} = ${_()}(\n                                    ${C("vConstantNextYZ_CurXY")}.zw,\n                                    ${C("vConstantCurrZ_PrecXYZ")}.x\n                            );\n                            ${_("constantPrec")} = ${C("vConstantCurrZ_PrecXYZ")}.xyz;\n                            ${_("constantNext")} = ${_()}(\n                                    ${C("vPointPrecZ_LineDistanceAltResetSecondDist_ConstantNextX")}.w, \n                                    ${C("vConstantNextYZ_CurXY")}.xy\n                            );\n                            dist = ${C("vPointPrecZ_LineDistanceAltResetSecondDist_ConstantNextX")}.y + ${f("getDistance","f",[$("pointCurr"),$("constantCurr"),$("constantPrec"),$("constantCurr")])};\n                            dist2 = ${f("getDistance","f",[$("pointCurr"),$("constantNext"),$("constantCurr"),$("constantCurr")])};             \n                            if (!resetDist2) {\n                                dist2 += ${C("vPointPrecZ_LineDistanceAltResetSecondDist_ConstantNextX")}.y;\n                            }\n                        }\n                    `)):n.wideLine&&(e=`\n                    ${e}\n                    ${D({varyingName:"vPointNextPrec",varyingType:"v4"})}\n                    ${D({varyingName:"vLineDistanceLeftRight",varyingType:"v4"})}\n                    ${D({varyingName:"vConstantNextPrec",varyingType:"v4"})}\n                    ${D({varyingName:"vConstantCurr_LineDistanceAltResetSecondDist",varyingType:"v4"})}\n                \n                    ${d("getDistance","f",[c("lineDistance"),c("next"),c("prev")])}{\n                        ${S("res")}  = 0.0;\n                        ${y("direction")}  = next-prev;\n                        ${S("l")}  = length(direction);\n                        res = dot(fragCoordLines.xy  - prev, direction)/(l*l);\n                        return res * (lineDistance.y - lineDistance.x);\n                    }\n\n                    ${d("getDistance","f",[c("next"),c("prev"),c("origin"),l("ratio")])}{\n                        ${S("res")}  = 0.0;\n                        ${y("direction")}  = next-prev;\n                        ${S("l")}  = length(direction);\n                        res = dot(fragCoordLines.xy - origin, direction)/(l*l);\n                        return res* ratio;\n                    }\n                `,t=`\n                    ${t}             \n                    if (!isConnection){           \n                        dist += ${f("getDistance","f",[c(C("vLineDistance")),c(C("vPointNextPrec.xy")),c(C("vPointNextPrec.zw"))])};                       \n                    } else  {\n                        ${y("constantCurr")} = ${C("vConstantCurr_LineDistanceAltResetSecondDist")}.xy;\n                        ${y("constantPrec")} = ${C("vConstantNextPrec")}.zw;\n                        ${y("constantNext")} = ${C("vConstantNextPrec")}.xy;\n                        ${y("lineDistanceLeft")} = ${C("vLineDistanceLeftRight")}.xy;\n                        ${y("lineDistanceRight")} = ${C("vLineDistanceLeftRight")}.zw;\n                        dist = ${C("vConstantCurr_LineDistanceAltResetSecondDist")}.z + ${f("getDistance","f",[c("constantCurr"),c("constantPrec"),c("constantCurr"),l("lineDistanceLeft.y - lineDistanceLeft.x")])};\n                        dist2 = ${f("getDistance","f",[c("constantNext"),c("constantCurr"),c("constantCurr"),l("lineDistanceRight.y - lineDistanceRight.x")])};\n                        if (!resetDist2) {\n                            dist2 += ${C("vConstantCurr_LineDistanceAltResetSecondDist")}.z;\n                        }\n                    }\n                `),n.patternSize&&(e=`\n                    ${e}\n\n                    ${d("getPatternInfo","v3",[l("dist")])}{\n                        ${x("index")}  = 0;\n                        ${S("prec")}  = 0.0;\n                        ${S("cur")}  = 0.0;\n                        for (${x("i")} = 0; i < ${n.patternSize}; i++) {\n                            ${T("dashInfo")} = max(${v("scale")},1e-6)* ${v("dashPattern")}[i];\n                            ${r()}\n                        }\n                        return ${_()}(${S()}(index),prec,cur);\n                    }\n\n                    ${d("getPatternDistance","f",[l("dist")])}{\n                        ${"butt"===n.linecap?`return dist + ${v("patternOffset")};`:`\n                            ${!n.wideLine||n.worldSizePattern?`return dist + ${v("patternOffset")};`:`return dist + ${f("getHalfWidth","f",[])} + ${v("patternOffset")};`}\n                            `}\n                    }\n\n                    ${d("getPatternAlpha","f",[l("dist"),c("patternStartEnd")])}{\n                        ${S("repeat")} = max(${v("scale")},1e-6)*${v("totalSize")};\n                        ${S("mDist")}  = ${N("dist","repeat")};\n                        ${n.worldSizePattern2?"\n                            if (patternStartEnd.x > -0.5) {\n                                mDist -= patternStartEnd.x;\n                                if (mDist < 0.0 || mDist > patternStartEnd.y - patternStartEnd.x) {\n                                    return 1.0;\n                                }\n                            }\n                            ":""}\n                        ${_("patternInfo")}  = ${f("getPatternInfo","v3",[l("mDist")])};\n                        ${n.invertedPattern?`\n                            if (abs(${N("patternInfo.x","2.0")}) < 0.5) {\n                                return 1.0;\n                            }\n                            return 0.0;\n                            `:`\n                            if (abs(${N("patternInfo.x","2.0")}) < 0.5) {\n                                return 0.0;\n                            }\n                            return 1.0;\n                            `}\n                    }\n                `,t=`\n                    ${t}\n                    ${y("patternStartEnd")} = ${n.worldSizePattern2?C("vPatternStartEnd"):`${y()}(0.0,0.0)`};\n                    ${S("ajdustedDist")}  = ${f("getPatternDistance","f",[l("dist")])};\n                    ${S("patternAlpha")}  = ${f("getPatternAlpha","f",[l("ajdustedDist"),c("patternStartEnd")])};\n                    ${n.PDSFX?`${f("ProcessLinePattern",null,[u("patternAlpha"),l("ajdustedDist")])};`:o}\n                    if (abs(dist2) > 1e-6) {\n                        ${S("ajdustedDist2")}  = ${f("getPatternDistance","f",[l("dist2")])};\n                        ${S("patternAlpha2")}  = ${f("getPatternAlpha","f",[l("ajdustedDist2"),c("patternStartEnd")])};\n                        ${n.PDSFX?`${f("ProcessLinePattern",null,[u("patternAlpha2"),l("ajdustedDist2")])};`:o}\n                        patternAlpha = min(patternAlpha, patternAlpha2);\n                    }\n                    if (patternAlpha > 0.5) {\n                        discard;\n                    }\n                `)}return[e,t]}(e);i=`\n                ${i}\n                ${n}\n                ${r}\n            `,s=`\n                ${s}\n                ${t}\n                ${m}\n            `,a&&(s=`\n                    ${s}               \n                    ${!e.dashedLine||e.dashedLine&&e.worldSizePattern?`       \n                        ${g("isConnectionGap")}  = length(fwidth(${C("vConstantCurr_LineDistanceAltResetSecondDist")}.xy)) < 1e-10;           \n                        `:`         \n                        ${g("isConnectionGap")}  = isConnection;   \n                        `}\n                    ${S("hw")} = ${f("getHalfWidth","f",[])};\n                    if (!isConnectionGap) {\n                        ${S("distToSeg")} = ${f("getDistanceToSegment","f",[c(C("vPointNextPrec.xy")),c(C("vPointNextPrec.zw"))])};\n                        ${e.useLineGapColor?`\n                            if (distToSeg < lineGapF + 1e-6) {                       \n                                ${P("out0")} = ${T()}( ${v("lineGapColor")}, opacityToUse );\n                            }\n                            `:"            \n                            if (distToSeg < lineGapF + 1e-6) {\n                                discard;\n                            }\n                            "}\n                    } else {              \n                        ${y("constantCurr")} = ${C("vConstantCurr_LineDistanceAltResetSecondDist")}.xy;\n                        ${y("constantPrec")} = ${C("vConstantNextPrec")}.zw;\n                        ${y("constantNext")} = ${C("vConstantNextPrec")}.xy;\n                        ${S("distToSegPrec")} = ${f("getDistanceToSegment","f",[c("constantCurr"),c("constantPrec")])};\n                        ${S("distToSegNext")} = ${f("getDistanceToSegment","f",[c("constantNext"),c("constantCurr")])};    \n                        if (${f("projectToSegmentFactor","f",[c("constantPrec"),c("constantCurr")])} < 0.0 || \n                               ${f("projectToSegmentFactor","f",[c("constantNext"),c("constantCurr")])} < 0.0 ) {   \n                            ${y("toProjOnVector")} = normalize(normalize(constantCurr - constantPrec) + normalize(constantNext - constantCurr));\n                            ${S("connectionLineGap")} = ${C("vFragCoordLineGap")}.w ;\n                            ${S("distToConnectionSeg")} = ${f("getDistanceToSegment","f",[c("constantCurr + toProjOnVector"),c("constantCurr - toProjOnVector")])};\n                            ${g("gapCondition")} = distToSegPrec < lineGapF + 1e-6 && distToSegNext < lineGapF + 1e-6 && distToConnectionSeg < connectionLineGap + 1e-6;\n                            ${e.useLineGapColor?`\n                                if (gapCondition) {\n                                    ${P("out0")} = ${T()}( ${v("lineGapColor")}, opacityToUse );\n                                }\n                                `:"              \n                                if (gapCondition) {\n                                    discard;\n                                }\n                                "}                 \n                        } else {  \n                            ${g("gapCondition")} = distToSegPrec < lineGapF + 1e-6 || distToSegNext < lineGapF + 1e-6;\n                            ${e.useLineGapColor?`\n                                if (gapCondition) {\n                                    ${P("out0")} = ${T()}( ${v("lineGapColor")}, opacityToUse );\n                                }\n                                `:"              \n                                if (gapCondition) {\n                                    discard;\n                                }\n                                "}\n                        }\n                    }\n                `)}return[i,s]}})),define("DS/ShaderBuilders/PBRUtils/PBRFragmentEquationsShaderBuilderUtils",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/PBRUtils/PBRShaderBuilderUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a){"use strict";const o="",i=r.ParameterUtils,s=r.FunctionHandler,l=r.BridgeFunctions,u=n=>a.dereference(n),m=(n,e)=>i.parameter(n,e),c=n=>i.parameterI(n),$=n=>i.parameterF(n),p=n=>i.parameterV2(n),d=n=>i.parameterV3(n),f=n=>i.parameterInOutV3(n),h=n=>i.parameterV4(n),v=n=>i.parameterT2(n),g=n=>i.parameterTC(n),x=(n,e,t)=>s.declareFunction(n,e,t),S=(n,e,t)=>s.callFunction(n,e,t),y=(n=null)=>{var e={name:n};return a.int(e)},_=(n=null)=>{var e={name:n};return a.float(e)},T=(n=null)=>{var e={name:n};return a.vec2(e)},D=(n=null,e=0)=>{var t={name:n,size:e};return a.vec3(t)},C=(n=null,e=0)=>{var t={name:n,size:e};return a.vec4(t)},P=(n=null)=>{var e={name:n};return a.mat3(e)},N=n=>`max(${n}, 0.0)`,b=n=>S("saturate","v2",[p(n)]),M=n=>S("vMax","f",[d(n)]),U=n=>S("pow2","f",[$(n)]),w=n=>{var t={uniformName:n};return e.getShadowUniform(t)},V=(n,t)=>{var r={uniformName:n,uniformIndex:t};return e.getShadowTextureUniform(r)},z=()=>[f("diffuse"),f("specular"),d("L")],F=(n,e)=>S("DistributionGGX","f",[$(n),$(e)]),I=(n,e,t)=>S("GGXVisibility","f",[$(n),$(e),$(t)]),R=(n,e,t)=>S("GeometricSchlick","f",[$(n),$(e),$(t)]),A=(n,e,t)=>S("FresnelSchlick","v3",[d(n),d(e),$(t)]),L=n=>S("DiffuseLambertBRDF","v3",[d(n)]),B=(n,e,t,r)=>S("SpecularBRDF","f",[$(n),$(e),$(t),$(r)]),E=(n,e,t,r,a,o,i,s,l,u)=>S("SpecularAnisoBRDF","f",[$(n),$(e),$(t),$(r),$(a),d(o),d(i),d(s),d(l),$(u)]),k=(n,e,t,r,a,o,i,s,l,u,m,c)=>S("TransmissionAnisoBRDF","f",[$(n),$(e),$(t),$(r),$(a),$(o),$(i),d(s),d(l),d(u),d(m),$(c)]),O=(n,e,t,r)=>S("SpecGlossEnergyConservationTerm","f",[$(n),$(e),d(t),d(r)]);let G,H,X,W,j,q,Z;{let n=function(n){return`\n            ${x("SheenModel",null,z())} {           \n                ${D("N")} = surfaceData.viewNormal;\n                ${D("V")} = surfaceData.view;\n                ${D("H")} = normalize(L+V);\n                ${_("NoH")}  = max(dot(N,H), 0.0);\n                ${_("NoL")}  = max(dot(N,L), 0.0);\n                ${_("NoV")}  = max(dot(N,V), 0.0);\n                ${n.dspbrWithSheenColorRoughness?`\n                    ${D("sheenColor")}  = materialData.sheen * materialData.sheenColor * ${S("SheenDistribution","f",[$("NoH"),$("materialData.sheenRoughness")])}* SheenVisGeometricSchlick(NoL,NoV);\n                    ${_("blending")}  = 1.0 - materialData.sheenEnergyConservationConstant;\n                    ${u("specular")} *= blending;\n                    ${u("diffuse")} *= blending;\n                    ${u("specular")} += sheenColor;\n                    `:`\t\t\t\t\n                    ${_("sheen")}  = ${S("SheenDistribution","f",[$("NoH"),$("materialData.sheen")])} * SheenVisGeometricSchlick(NoL,NoV);\n                    ${_("blending")}  = 1.0 - ${e="1.0-materialData.sheen",S("pow5","f",[$(e)])};\n                    ${u("diffuse")} *= PI * sheen * blending + (1.0 - blending);\n                    `}\n            }\n        `;var e},e="\n        ";G=function(t){return t.sheen?[n(t),e]:["",""]}}{let n=function(n){return`\n                ${n.useTransmittance?`\n                    ${n.depthBasedTransmittance?`\n                        ${n.useMapTransmittance?`\n                            ${x("getDepthValue","f",[v("iShadowMap"),p("coord")])} {\n                                ${C("fetchedValue")} = ${l.sample2DTexture("iShadowMap","coord")};\n                                ${n.useESMTransmittance?`\n                                    ${_("unpacked")}  = ${S("unpackDepthESM","f",[h("fetchedValue")])};\n                                    return 2.0 * ONEOVER80*log(unpacked) - 1.0;\n                                    `:`\n                                    ${_("unpacked")} = ${S("unpackRGBA","f",[h("fetchedValue")])};\n                                    return 2.0*unpacked - 1.0;\n                                    `}  \n                            }\n\n                            ${x("multiSampleTransmittance","v3",[h("shadowMapCoord"),p("shadowNearFar"),p("iShadowMapSize"),v("iShadowMap"),m("b","ortho")])} {\n                                ${D("depthMapCoord")}  = shadowMapCoord.xyz/shadowMapCoord.w;\n                                ${T("currentCoord")} ;\n                                ${_("currentDepth")}  = ${S("clipToEye","f",[$("2.0*depthMapCoord.z-1.0"),p("shadowNearFar"),m("b","ortho")])};\n                                ${_("depth")}  = ${S("getDepthValue","f",[v("iShadowMap"),p("depthMapCoord.xy")])};\n                                ${_("fetchedDepth")}  = ${S("clipToEye","f",[$("depth"),p("shadowNearFar"),m("b","ortho")])};\n                                ${_("s")}  = max( currentDepth - fetchedDepth,0.0);\n                                ${T("multiplier")}  = ${b("2.0 / iShadowMapSize")};\n                                for (${y("i")} = 0; i < TRANS_SAMPLE; i++) {\n                                    ${T("offset")}  =  multiplier* poisson25[i];\n                                    currentCoord = ${b("depthMapCoord.xy + offset")};\n                                    depth = ${S("getDepthValue","f",[v("iShadowMap"),p("currentCoord.xy")])};\n                                    s += max( currentDepth - ${S("clipToEye","f",[$("depth"),p("shadowNearFar"),m("b","ortho")])},0.0);\n                                }\n                                return ${S("GetTransmittance","v3",[$(`s / ${_()}(TRANS_SAMPLE + 1)`)])};\n                            }\n\n                            ${x("multiSampleTransmittanceFromIndex","v3",[c("index"),m("b","ortho")])} {\n                                ${function(){let e="";for(var t=0;t<n.maxShadows;t++)e=`\n                    ${e}\n                    if (index == ${t}) {\n                        return ${S("multiSampleTransmittance","v3",[h(`gShadowCoord[${t}]`),p(`${w("shadowMapNearFar")}[${t}].xy`),p(`${w("shadowMapSizeDarknessBias")}[${t}].xy`),v(V("shadowMap",t)),m("b","ortho")])};\n                    }`;return e}()}\n                                return ${D()}(0.0, 0.0, 0.0);\n                            }\n                            `:o}\n\n                        ${n.useCubeTransmittance?`\n                            ${x("getCubeDepthValue","f",[g("shadowCubeMap"),d("coord")])} {\n                                ${C("fetchedValue")} = ${l.sampleCubeTexture("shadowCubeMap","coord")};\n                                ${n.useESMTransmittance?`\n                                    ${_("unpacked")}  = ${S("unpackDepthESM","f",[h("fetchedValue")])};\n                                    return 2.0 * ONEOVER80*log(unpacked) - 1.0;\n                                    `:`\n                                    ${_("unpacked")}  = ${S("unpackRGBA","f",[h("fetchedValue")])};\n                                    return 2.0* unpacked - 1.0;\n                                    `}   \n                            }\n\n                            ${x("multiSampleCubeTransmittance","v3",[d("worldPos"),d("lightPosition"),p("shadowNearFar"),$("shadowCubeSize"),g("shadowCubeMap"),m("b","ortho")])} {\n                                ${D("pointVector")}  = worldPos.xyz - lightPosition.xyz;\n\n                                ${D("cubeMapCoord")}  = normalize( pointVector );\n                                ${_("currentDepth")}  = length(pointVector);\n                                ${_("depth")}  = ${S("getCubeDepthValue","f",[g("shadowCubeMap"),d("cubeMapCoord")])};\n                                ${_("fetchedDepth")}  = ${S("clipToEye","f",[$("depth"),p("shadowNearFar"),m("b","ortho")])};\n                                ${_("s")}  = max( currentDepth - fetchedDepth,0.0);\n\n                                ${_("pixelSize")}  = 4.0 / shadowCubeSize;\n                                ${D("right")}  = ${S("getGeomT","v3",[d("cubeMapCoord.xyz")])} * pixelSize;\n                                ${D("up")}  = ${S("getGeomB","v3",[d("cubeMapCoord.xyz"),d("right")])} * pixelSize;\n                                ${D("currentCoord")} ;\n\n                                for (${y("i")} = 0; i < TRANS_SAMPLE; i++) {\n                                    ${T("offset")}  =  poisson25[i];\t\t\t\n                                    currentCoord = normalize(cubeMapCoord + offset.x * right + offset.y * up);\n                                    depth = ${S("getCubeDepthValue","f",[g("shadowCubeMap"),d("currentCoord")])};\n                                    s += max( currentDepth - ${S("clipToEye","f",[$("depth"),p("shadowNearFar"),m("b","ortho")])},0.0);\n                                }\n                                return ${S("GetTransmittance","v3",[$(`s / ${_()}(TRANS_SAMPLE + 1)`)])};\n                            }\n                                \n                            ${x("multiSampleCubeTransmittanceFromIndex","v3",[c("index"),d("worldPosition")])} {\n                                ${function(){let e="";for(var t=0;t<n.maxShadowsCube;t++)e=`\n                    ${e}\n                    if (index == ${t}) {\n                        ${T("nearFar")} = ${T()}(${w("shadowCubeInfos")}[${t}].z, ${w("shadowCubeInfos")}[${t}].w);\n                        return ${S("multiSampleCubeTransmittance","v3",[d("worldPosition"),d(`${w("shadowPointPosition")}[${t}].xyz`),p("nearFar"),$(`${w("shadowPointPosition")}[${t}].w`),g(V("shadowMapCube",t)),m("b","false")])};\n                    }`;return e}()}\n                                return ${D()}(0.0, 0.0, 0.0);\n                            }\n                            `:o}\n                        `:o}\n                    `:o} \n            `},e="\n        ";H=function(t){return t.subsurface?[n(t),e]:["",""]}}{let n=function(n){return`\n                ${x("ClearCoatModel",null,z())} {          \n                    ${D("V")} = surfaceData.view;\n                    ${D("N")} = surfaceData.clearCoatNormal;\n                    ${_("r")} = materialData.clearCoatRoughness;\n                    ${D("H")}  = normalize(L+V);\n                    ${_("NoH")}  = ${N("dot(N,H)")};\n                    ${_("NoV")}  = ${N("dot(N,V)")};\n                    ${_("NoL")}  = ${N("dot(N,L)")};\n                    ${_("VoH")}  = ${N("dot(V,H)")};\n\n                    ${D("ccSpecular")} = ${A("materialData.clearCoatSR0Color","materialData.clearCoatSR90Color","VoH")};\n                    ${n.useSpecularAA?`\n                        //${P("TBN")}  = surfaceData.TBNMatrixForSpecularAA;\n                        ${D("Htbn")}  = H;\n                        ${T("roughnesses")} = ${T()}(r, r);\n                        roughnesses = ${S("AxisAlignedNDFFiltering","v2",[d("Htbn"),p("roughnesses")])};\n                        ccSpecular *= ${E("roughnesses.x","roughnesses.y","NoV","NoL","NoH","N","H","surfaceData.TForSpecularAA","surfaceData.BForSpecularAA","0.0")};\n                        `:`ccSpecular *= ${B("r","NoV","NoL","NoH")};`}\n\n                    ${n.dspbr?`\n                        ${D("fresnelNoL")}  = ${A("materialData.clearCoatSR0Color","materialData.clearCoatSR90Color","NoL")};\n                        ${D("fresnelNoV")}  = ${A("materialData.clearCoatSR0Color","materialData.clearCoatSR90Color","NoV")};\n                        ${_("fresnelEnergy")}  = 1.0 - materialData.clearCoat * ${M("max(fresnelNoL,fresnelNoV)")};\n                        `:`\n                        ${_("fresnelEnergy")} = ${O("NoL","NoV","materialData.clearCoatSR0Color","materialData.clearCoatSR90Color")};\n                        `}\n                    ${u("diffuse")} *= fresnelEnergy;\n                    ${u("specular")} *= fresnelEnergy;\n\n                    ${u("specular")} += materialData.clearCoat * ccSpecular;\n                }\n            `},e="\n        ";X=function(t){return t.clearCoat?[n(t),e]:["",""]}}{let n=function(n){return`\n                ${x("SpecGlossFlakesModel",null,z())} {           \n                    ${D("N")} = surfaceData.viewNormal;\n                    ${D("V")} = surfaceData.view;\n                    ${D("H")} = normalize(L+V);\n                    ${D("vector3Zero")} = ${D()}(0.0);\n                    ${_("VoH")}  = ${N("dot(V,H)")};\n                    {\n                        ${_("NoH")}  = ${N("dot(metalFlakes.flakesNormal,H)")};\n                        ${_("NoV")}  = ${N("dot(metalFlakes.flakesNormal,V)")};\n                        ${_("NoL")}  = ${N("dot(metalFlakes.flakesNormal,L)")};\n                        ${_("distrib")}  = ${F("metalFlakes.flakesRoughness","NoH")};\n                        ${_("geomVis")}  = ${I("metalFlakes.flakesRoughness","NoV","NoL")};\n                        ${D("fresnel")}  = ${A("metalFlakes.flakesSR0Color","vector3Zero","VoH")};\n                        ${_("fresnelEnergy")}  = ${O("NoL","NoV","metalFlakes.flakesSR0Color","vector3Zero")};\n                        ${u("diffuse")} *= fresnelEnergy;\n                        ${u("specular")} *= fresnelEnergy;\n                        ${u("specular")} += distrib * fresnel * geomVis;\n                    }\n                    {\n                        ${_("NoH")}  = ${N("dot(metal.flakesNormal,H)")};\n                        ${_("NoV")}  = ${N("dot(metal.flakesNormal,V)")};\n                        ${_("NoL")}  = ${N("dot(metal.flakesNormal,L)")};\n                        ${_("distrib")}  = ${F("metal.flakesRoughness","NoH")};\n                        ${_("geomVis")}  = ${I("metal.flakesRoughness","NoV","NoL")};\n                        ${D("fresnel")}  = ${A("metal.flakesSR0Color","vector3Zero","VoH")};\n                        ${_("fresnelEnergy")}  = ${O("NoL","NoV","metal.flakesSR0Color","vector3Zero")};\n                        ${u("diffuse")} *= fresnelEnergy;\n                        ${u("specular")} *= fresnelEnergy;\n                        ${u("specular")} += distrib * fresnel * geomVis;\n                    }\n                    ${n.pearlFlakesActivated?`\n                        {\n                            ${_("NoH")}  = ${N("dot(pearlFlakes.flakesNormal,H)")};\n                            ${_("NoV")}  = ${N("dot(pearlFlakes.flakesNormal,V)")};\n                            ${_("NoL")}  = ${N("dot(pearlFlakes.flakesNormal,L)")};\n                            ${_("distrib")}  = ${F("pearlFlakes.flakesRoughness","NoH")};\n                            ${_("geomVis")}  = ${I("pearlFlakes.flakesRoughness","NoV","NoL")};\n                            ${D("fresnel")}  = ${A("pearlFlakes.flakesSR0Color","vector3Zero","VoH")};\n                            ${_("fresnelEnergy")}  = ${O("NoL","NoV","pearlFlakes.flakesSR0Color","vector3Zero")};\n                            ${u("diffuse")} *= fresnelEnergy;\n                            ${u("specular")} *= fresnelEnergy;\n                            ${u("specular")} += distrib * fresnel * geomVis;\n                        }\n                        `:o}\n                }\n            `},e="\n        ";W=function(t){return t.specGlossFlakes?[n(t),e]:["",""]}}{let n=function(n){return`\n                ${x("stochasticFlakesPattern","v3",[d("V"),d("L"),d("N"),$("limit")])} {\n                    ${T("c")} =  ${S("contributingStochasticFlakes","v2",[d("V"),d("L"),d("N"),$("limit")])};\n                    ${_("d")} = c.x;\n                    ${n.dspbrWithFlipFlopColor?`return ${S("computeFlakesTint","v3",[$("c.y")])}* d;`:`return ${S("computeFlakesTint","v3",[])} * d;`}\n                }\n\n                ${x("stochasticFlakesBRDF","v3",[d("V"),d("L"),d("N"),$("VoH"),$("NoL"),$("NoV")])}{\n                    ${_("g")} = ${R("flakesData.flakesRoughness","NoL","NoV")};\n                    ${D("pattern")}  = ${S("stochasticFlakesPattern","v3",[d("V"),d("L"),d("N"),$("flakesData.flakesCosConeAngle")])};\n                    return VoH * g * pattern/ max(NoL*NoV * flakesData.flakesConeSolidAngle,1e-6) ;\n                }\n\n                ${x("closeFlakesPattern","f",[d("L"),$("limit")])}{\n                    return step(0.0, dot(flakesData.closeupFlakesReflect, L) - limit);\n                }\n\n                ${x("closeFlakesBRDF","f",[d("L"),$("NoL")])}{\n                    ${_("pattern")}  = ${S("closeFlakesPattern","f",[d("L"),$("flakesData.flakesCosConeAngle")])};\n                    return  pattern / max(flakesData.flakesConeSolidAngle  * NoL, 1e-6);\n                }\n\n                ${x("DSPBRFlakesModel",null,z())}{\t           \n                    ${D("N")} = surfaceData.viewNormal;\n                    ${D("V")} = surfaceData.view;\n                    ${D("H")}  = normalize(V+L);\n                    ${_("VoH")}  = dot(V,H);\n                    ${_("NoL")}  = ${N("dot(N,L)")};\n                    ${_("NoV")}  = ${N("dot(N,V)")};\n                    ${_("NoH")}  = ${N("dot(N,H)")};\n\n                    ${D("res")}  = flakesData.smoothFlakesColor * ${B("flakesData.flakesRoughness","NoV","NoL","NoH")};\n                    ${n.dspbrFlakesThreeLayers?`\n                        if (flakesData.stochasticWeight > 0.0) {\n                            res += flakesData.stochasticWeight * ${S("stochasticFlakesBRDF","v3",[d("V"),d("L"),d("N"),$("VoH"),$("NoL"),$("NoV")])};\n                        }\n                        `:o}\n                    ${n.dspbrFlakesOneLayer?o:`               \n                        if (flakesData.closeupWeight > 0.0) {\n                            res += flakesData.closeupFlakesColor * ${S("closeFlakesBRDF","f",[d("L"),$("NoL")])};\n                        }\n                        `}\n                    ${u("diffuse")} *= flakesData.baseWeight;\n                    ${u("specular")} *= flakesData.baseWeight;\n                    ${u("specular")} += res;\n                }\n            `},e="\n        ";j=function(t){return t.dspbrFlakes?[n(t),e]:["",""]}}{let n=function(n){return`\n                ${D("Lt")}  = L - 2.0 * dot(L,N) * N;\n                ${_("NoLt")}  = ${N("dot(N, Lt)")};\n                ${D("brdf")}  = ${L("color")};\n                ${n.specgloss?`\n                    ${_("NoV")}  = ${N("dot(N,V)")};\n                    ${_("fTrans")}  = ${O("NoLt","NoV","materialData.sr0Color","materialData.sr90Color")};\n                    `:`${_("fTrans")} = materialData.diffuseEnergyConservationConstant;`}\n            `},e=function(n){function e(){return`\n                    \n                    //${P("TBN")} = surfaceData.TBNMatrixForSpecularAA;\n                    ${D("Htbn")}  = Ht;\n                    ${T("roughnesses")} = ${T()}(rX, rY);\n                    roughnesses = ${S("AxisAlignedNDFFiltering","v2",[d("Htbn"),p("roughnesses")])};\n                    rX = roughnesses.x;\n                    rY = roughnesses.y;\n                `}function t(){return`\n                //${P("TBN")} = surfaceData.TBNMatrixForSpecularAA;\n                ${D("Htbn")}  = Ht;\n                ${T("roughnesses")} = ${T()}(materialData.roughness, materialData.roughness);\n                roughnesses = ${S("AxisAlignedNDFFiltering","v2",[d("Htbn"),p("roughnesses")])};\n                `}return`\n                    ${D("Lt")}  = L - 2.0 * dot(L,N) * N;\n                    ${_("NoLt")}  = ${N("dot(N,Lt)")};\n                    ${_("NoV")} = ${N("dot(N,V)")};\n                    ${n.thinWalled?`\n                        ${D("Ht")}  = normalize(Lt+V);\n                        ${_("NoHt")}  = ${N("dot(N,Ht)")};\n                        ${_("VoHt")}  = ${N("dot(V,Ht)")};\n                        ${n.anisotropy?`\n                            ${_("rX")}  = materialData.roughness;\n                            ${_("rY")}  = rX * (1.0 - materialData.anisotropy);\n                            \n                            ${n.useSpecularAA?`\n                                ${e()}\n                                `:o}\n                            ${D("brdf")} = color * ${E("rX","rY","NoV","NoLt","NoHt","N","Ht","surfaceData.tangent","surfaceData.binormal","materialData.anisotropyAngle")};\n                            `:`\n                            ${n.useSpecularAA?`\n                                ${t()}\n                                ${D("brdf")} = color * ${E("roughnesses.x","roughnesses.y","NoV","NoLt","NoHt","N","Ht","surfaceData.TForSpecularAA","surfaceData.BForSpecularAA","0.0")};\n                                `:`${D("brdf")} = color * ${B("materialData.roughness","NoV","NoLt","NoHt")};`}\n                            `}                    \n                        `:`\n                        ${D("Ht")}  = normalize(Lt * materialData.ior +V);\n                        ${_("NoHt")}  = ${N("dot(N,Ht)")};\n                        ${_("VoHt")}  = ${N("dot(V,Ht)")};\n                        ${_("LtoHt")}  = ${N("dot(Lt,Ht)")};\n                        ${n.anisotropy?`\n                            ${_("rX")}  = materialData.roughness;\n                            ${_("rY")}  = rX * (1.0 - materialData.anisotropy);\n                            ${n.useSpecularAA?`\n                                ${e()}\n                                `:o}\n                            ${D("brdf")}  = color * ${k("rX","rY","NoV","NoLt","NoHt","VoHt","LtoHt","N","Ht","surfaceData.tangent","surfaceData.binormal","materialData.anisotropyAngle")};\n                            `:`\n                            ${n.useSpecularAA?`\n                                ${t()}\n                                ${D("brdf")}  = color * ${k("roughnesses.x","roughnesses.y","NoV","NoLt","NoHt","VoHt","LtoHt","N","Ht","surfaceData.TForSpecularAA","surfaceData.BForSpecularAA","materialData.anisotropyAngle")};\n                                `:`${D("brdf")}  = color * ${r="materialData.roughness",a="NoV",i="NoLt",s="NoHt",l="VoHt",u="LtoHt",S("TransmissionBRDF","f",[$(r),$(a),$(i),$(s),$(l),$(u)])};`}\n                            \n                            `}\n                        `}\n                    ${n.dspbr?`\n                        ${D("vec3One")} = ${D()}(1.0);\n                        ${D("fresnelVoHt")}  = ${A("materialData.specularBlendingSR0","vec3One","VoHt")};\n                        ${_("fTrans")}  = 1.0 - materialData.specularContribution * ${M("fresnelVoHt")};\n                        `:`\n                        ${D("sr0Color")}  = materialData.sr0Color;\n                        ${D("sr90Color")}  = materialData.sr90Color;\n                        ${D("fresnelVoHt")}  = ${A("sr0Color","sr90Color","VoHt")};\n                        ${_("fTrans")}  = 1.0 - ${M("fresnelVoHt")};\n                        `}\n            `;var r,a,i,s,l,u},t=function(t){return`\n                ${x("CoreModel",null,z())}{           \n                    ${D("N")} = surfaceData.viewNormal;\n                    ${D("V")} = surfaceData.view;\n                    ${D("sr0Color")}  = materialData.sr0Color;\n                    ${D("sr90Color")}  = materialData.sr90Color;\n\n                    ${_("NoL")}  = ${N("dot(N,L)")};\n                    ${_("NoV")}  = ${N("dot(N,V)")};\n                    ${D("H")}  = normalize(L+V);\n                    ${_("NoH")}  = ${N("dot(N,H)")};\n                    ${_("VoH")}  = ${N("dot(V,H)")};\n                    ${u("specular")} = ${A("sr0Color","sr90Color","VoH")};\n                    ${t.useSpecularAA?`\n                        //${P("TBN")}  = surfaceData.TBNMatrixForSpecularAA;\n                        ${D("Htbn")}  = H;\n                        ${T("roughnesses")} = ${T()}(materialData.roughness, materialData.roughness);\n                        roughnesses = ${S("AxisAlignedNDFFiltering","v2",[d("Htbn"),p("roughnesses")])};\n                        ${u("specular")} *= ${E("roughnesses.x","roughnesses.y","NoV","NoL","NoH","N","H","surfaceData.TForSpecularAA","surfaceData.BForSpecularAA","0.0")};\n                        `:`${u("specular")} *= ${B("materialData.roughness","NoV","NoL","NoH")};`}\n                    \n                    ${t.dspbr?`\n                        ${u("diffuse")} = ${L("materialData.diffuseColor")} * materialData.diffuseEnergyConservationConstant;\n                        ${u("specular")} += ${L("materialData.specularEnergyConservationConstant")};\n                        `:`${u("diffuse")} = ${L("materialData.diffuseColor")} * ${O("NoL","NoV","sr0Color","sr90Color")};`}\n                }\n\n                ${x("TranslucencyDiffuseModel","v3",[d("L"),d("color")])} {\t\t\n                    ${D("N")} = surfaceData.viewNormal;\n                    ${D("V")} = surfaceData.view;\t\t\t\t\n                    ${n(t)}\n                    return NoLt * brdf * fTrans;\n                }\n\n                ${x("TranslucencySpecularModel","v3",[d("L"),d("color")])} {\t\n                    ${D("N")} = surfaceData.viewNormal;\n                    ${D("V")} = surfaceData.view;\t\t\t\t\n                    ${e(t)}\n                    return brdf * NoLt * fTrans;\n                }\n            `},r=function(n){return`     \n                ${x("CoreModelAniso",null,z())}{                  \n                    ${D("N")} = surfaceData.viewNormal;\n                    ${D("V")} = surfaceData.view;\n                    ${_("r")}  = materialData.roughness;\t\n                    ${D("sr0Color")}  = materialData.sr0Color;\n                    ${D("sr90Color")}  = materialData.sr90Color;\n\n                    ${_("NoL")}  = ${N("dot(N,L)")};\n                    ${_("NoV")}  = ${N("dot(N,V)")};\n                    ${D("H")}  = normalize(L+V);\n                    ${_("NoH")}  = ${N("dot(N,H)")};\n                    ${_("VoH")}  = ${N("dot(V,H)")};\n                    ${_("rX")}  = r;\n                    ${_("rY")}  = r * (1.0 - materialData.anisotropy);\n\n                    ${u("specular")} = ${A("sr0Color","sr90Color","VoH")};\n                    ${n.useSpecularAA?`\n                        //${P("TBN")} = surfaceData.TBNMatrixForSpecularAA;\n                        ${D("Htbn")}  = H;\n                        ${T("roughnesses")} = ${T()}(rX, rY);\n                        roughnesses = ${S("AxisAlignedNDFFiltering","v2",[d("Htbn"),p("roughnesses")])};\n                        ${u("specular")} *= ${E("roughnesses.x","roughnesses.y","NoV","NoL","NoH","N","H","surfaceData.tangent","surfaceData.binormal","materialData.anisotropyAngle")};\n                        `:`${u("specular")} *= ${E("rX","rY","NoV","NoL","NoH","N","H","surfaceData.tangent","surfaceData.binormal","materialData.anisotropyAngle")};`}\n                    ${n.dspbr?`\n                        ${u("diffuse")} = ${L("materialData.diffuseColor")} * materialData.diffuseEnergyConservationConstant;\n                        ${u("specular")} += ${L("materialData.specularEnergyConservationConstant")};\n                        `:`${u("diffuse")} = ${L("materialData.diffuseColor")} * ${O("NoL","NoV","sr0Color","sr90Color")};`}\n                }\n            `},a="\n        ";q=function(o){let i=`     \n                ${x("DiffuseLambertBRDF","v3",[d("diffuseColor")])}{\n                    return (diffuseColor * INV_PI);\n                }   \n                ${x("SpecularBRDF","f",[$("roughness"),$("NoV"),$("NoL"),$("NoH")])}{\n                    ${_("distrib")}  = ${F("roughness","NoH")};\n                    ${_("geomVis")}  = ${I("roughness","NoV","NoL")};\n                    return distrib*geomVis;\n                }\n                ${x("TransmissionBRDF","f",[$("roughness"),$("NoV"),$("NoL"),$("NoH"),$("VoH"),$("LoH")])}{\n                    ${_("ior2")}  = ${U("materialData.ior")};\n                    ${_("coeff")}  = abs(LoH * VoH) / (max(abs(NoL), 1e-3) * max(abs(NoV),1e-3));\n                    coeff *= ior2;\n                    coeff /= max(${U("materialData.ior*LoH + VoH")}, 1e-3);\n                    ${_("distrib")}  = ${F("roughness","NoH")};\n                    ${_("geomVis")}  = ${R("roughness","NoL","NoV")};\n                    return coeff*distrib*geomVis;\n                }\n            `;return o.useSpecularAA&&(i=`\n                    ${i}\n                    ${x("AxisAlignedNDFFiltering","v2",[d("halfvectorTS"),p("roughness2")])}{\n                        ${T("halfvector2D")}  = halfvectorTS.xy;\n                        ${T("bounds")}  = fwidth(halfvector2D);\n                        ${_("SIGMA2")}  = 0.15915494;\n                        ${T("kernelRoughness2")}  = 2.0 * SIGMA2 * (bounds * bounds);\n                        ${_("KAPPA")}  = 0.18;\n                        ${T("clampedKernelRoughness2")}  = min(kernelRoughness2, KAPPA);\n                        ${T("filteredRoughness2")}  = ${b("roughness2 + clampedKernelRoughness2")};\n                        return filteredRoughness2;\n                    }\n                `),(o.anisotropy||o.useSpecularAA)&&(i=` \n                    ${i}        \n                    ${x("TransmissionAnisoBRDF","f",[$("roughnessX"),$("roughnessY"),$("NoV"),$("NoL"),$("NoH"),$("VoH"),$("LoH"),d("iNormal"),d("H"),d("iTangent"),d("iBinormal"),$("iAnisotropyAngle")])}{\n                        ${_("ior2")}  = materialData.ior * materialData.ior;\n                        ${_("coeff")}  = abs(LoH * VoH) / max(abs(NoL*NoV),1e-3);\n                        coeff *= ior2;\n                        coeff /= materialData.ior * LoH + ior2 *VoH*VoH;\n                        ${_("distrib")}  = ${S("AnisotropicDistributionGGX","f",[d("iTangent"),d("iBinormal"),d("iNormal"),d("H"),$("NoH"),$("roughnessX"),$("roughnessY"),$("iAnisotropyAngle")])};\n                        ${_("geomVis")}  = ${S("AnisotropicGGXVisibility","f",[$("roughnessX"),$("roughnessY"),$("NoV"),$("NoL"),$("iAnisotropyAngle")])};\n                        return coeff*distrib*geomVis;\n                    }\n                    ${x("SpecularAnisoBRDF","f",[$("roughnessX"),$("roughnessY"),$("NoV"),$("NoL"),$("NoH"),d("iNormal"),d("H"),d("iTangent"),d("iBinormal"),$("iAnisotropyAngle")])}{\n                        ${_("distrib")}  = ${S("AnisotropicDistributionGGX","f",[d("iTangent"),d("iBinormal"),d("iNormal"),d("H"),$("NoH"),$("roughnessX"),$("roughnessY"),$("iAnisotropyAngle")])};\n                        ${_("geomVis")}  = ${S("AnisotropicGGXVisibility","f",[$("roughnessX"),$("roughnessY"),$("NoV"),$("NoL"),$("iAnisotropyAngle")])};\n                        return distrib*geomVis;\n                    }\n                `),i=`\n                ${i}      \n                ${t(o)}\n            `,o.anisotropy&&(i=`\n                    ${i}\n                    ${r(o)}\n                `),o.maxTubeLights&&(i=`\n                    ${i}         \n\n                    ${x("_TranslucencySpecularModel","v3",[d("L"),d("color")])} {\n                        ${D("N")} = surfaceData.viewNormal;\n                        ${D("V")} = surfaceData.view;\n                        ${e(o)}\n                        return brdf * fTrans;\n                    }          \n                    ${x("_TranslucencyDiffuseModel","v3",[d("L"),d("color")])} {\n                        ${D("N")} = surfaceData.viewNormal;\n                        ${D("V")} = surfaceData.view;\n                        ${n(o)}\n                        return brdf * fTrans;\n                    }\n                `),[i,a]}}return Z=function(n){if(!n.iridescence)return[o,o];return[`\n                ${((n=null)=>{var e={name:n,constant:!0};return a.mat3(e)})("XYZ_TO_REC709")}  = ${P()}(\n                    3.2404542, -0.9692660,  0.0556434,\n                    -1.5371385,  1.8760108, -0.2040259,\n                    -0.4985314,  0.0415560,  1.0572252\n                );\n\n                ${x("EvalSensitivity","v3",[$("OPD"),d("shift")])}{\n                    ${_("phase")}  = 2.0 * PI * OPD * 1.0e-9;\n                    ${D("val")}  = ${D()}(5.4856e-13, 4.4201e-13, 5.2481e-13);\n                    ${D("pos")}  = ${D()}(1.6810e+06, 1.7953e+06, 2.2084e+06);\n                    ${D("vari")}  = ${D()}(4.3278e+09, 9.3046e+09, 6.6121e+09);\n                \n                    ${D("xyz")}  = val * sqrt(2.0 * PI * vari) * cos(pos * phase + shift) * exp(-${U("phase")} * vari);\n                    xyz.x += 9.7470e-14 * sqrt(2.0 * PI * 4.5282e+09) * cos(2.2399e+06 * phase + shift[0]) * exp(-4.5282e+09 * ${U("phase")});\n                    xyz /= 1.0685e-7;\n                \n                    ${D("rgb")}  = XYZ_TO_REC709 * xyz;\n                    return rgb;\n                }\n\n                ${x("IoRToFresnel0","f",[$("transmittedIoR"),$("incidentIoR")])} {\n                    return ${U("(transmittedIoR - incidentIoR) / (transmittedIoR + incidentIoR)")};\n                }\n\n                ${x("IoRToFresnel0","v3",[d("transmittedIoR"),$("incidentIoR")])}{\n                    ${_("r")}  = ${S("IoRToFresnel0","f",[$("transmittedIoR.r"),$("incidentIoR")])};\n                    ${_("g")}  = ${S("IoRToFresnel0","f",[$("transmittedIoR.g"),$("incidentIoR")])};\n                    ${_("b")}  = ${S("IoRToFresnel0","f",[$("transmittedIoR.b"),$("incidentIoR")])};\n                    return ${D()}(r, g, b);\n                }\n\n                ${x("Fresnel0ToIoR","v3",[d("fresnel0")])}{\n                    ${D("sqrtF0")}  = sqrt( fresnel0 );\n                    return ( ${D()}( 1.0 ) + sqrtF0 ) / ( ${D()}( 1.0 ) - sqrtF0 );\n                }\n\n                ${x("ComputeIridescenceFresnel","v4",[$("outsideIoR"),$("iridescenceIoR"),d("sr0Color"),$("iridescenceThickness"),$("cosTheta1")])}{\n                    ${_("sinTheta2Sq")}  = ${U("outsideIoR / iridescenceIoR")} * ( 1.0 - ${U("cosTheta1")} );\n                    ${_("cosTheta2Sq")}  = 1.0 - sinTheta2Sq;\n                    if ( cosTheta2Sq < 0.0 ) {\n                        return ${C()}( 1.0, 1.0, 1.0, 1.0 );\n                    }\n                    ${_("cosTheta2")}  = sqrt(cosTheta2Sq);\n\n                    ${_("R0")}  = ${S("IoRToFresnel0","f",[$("iridescenceIoR"),$("outsideIoR")])};\n                    ${_("R12")}  = ${S("FresnelSchlick","f",[$("R0"),$("1.0"),$("cosTheta1")])};\n                    ${_("R21")}  = R12;\n                    ${_("T121")}  = 1.0 - R12;\n                    ${_("phi12")}  = 0.0;\n                    if (iridescenceIoR < outsideIoR) {\n                        phi12 = PI;\n                    }\n                    ${_("phi21")}  = PI - phi12;\n\n                    ${D("upThreshold")} = ${D()}(1.0 - 1e-2);\n                    ${D("baseIoR")}  = ${S("Fresnel0ToIoR","v3",[d("min(sr0Color, upThreshold)")])};\n                    ${D("R1")}  = ${S("IoRToFresnel0","v3",[d("baseIoR"),$("iridescenceIoR")])};\n                    ${D("R23")}  = ${A("R1",`${D()}(1.0)`,"cosTheta2")};\n                    ${D("phi23")}  = ${D()}(0.0);\n                    if (baseIoR.x < iridescenceIoR) {\n                        phi23.x = PI;\n                    }\n                    if (baseIoR.y < iridescenceIoR) {\n                        phi23.y = PI;\n                    }\n                    if (baseIoR.z < iridescenceIoR) {\n                        phi23.z = PI;\n                    }\n\n                    ${_("OPD")}  = 2.0 * iridescenceIoR * iridescenceThickness * cosTheta2;\n                    ${D("phi")}  = ${D()}( phi21 ) + phi23;\n\n                    ${D("R123")}  = clamp( R12 * R23, ${D()}(1e-6), ${D()}(1.0 - 1e-6) );\n                    ${D("r123")}  = sqrt( R123 );\n                    ${D("Rs")}  = ${U("T121")} * R23 / ( ${D()}( 1.0 ) - R123 );\n\n                    ${D("C0")}  = R12 + Rs;\n                    ${D("I")}  = C0;\n\n                    ${D("Cm")}  = Rs - T121;\n                    for (${y("m")} = 1; m <= 2; m++) {\n                        Cm *= r123;\n                        ${_("mFloat")} = ${_()}(m);\n                        ${D("Sm")}  = 2.0 * ${S("EvalSensitivity","v3",[$("mFloat * OPD"),d("mFloat * phi")])};\n                        I += Cm * Sm;\n                    }\n                    I = max(I, ${D()}(0.0));\n                    return ${C()}(I, abs(dot(C0, luminanceVector)));\n                }\n            `,o]},{getEquationsShaders:function(n,e){if(!n)return["",""];let t=q(e),r=G(e),a=X(e),o=H(e),i=W(e),s=j(e),l=Z(e);return[`\n                ${t[0]}\n                ${r[0]}\n                ${a[0]}\n                ${o[0]}\n                ${i[0]}\n                ${s[0]}\n                ${l[0]}\n            `,"\n            "]}}})),define("DS/ShaderBuilders/LineUtils/LineBasicVertexShaderBuilderUtils",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a){"use strict";const o="",i=r.ParameterUtils,s=r.BridgeFunctions,l=(n,e)=>i.parameter(n,e),u=n=>i.parameterF(n),m=n=>i.parameter("b",n),c=n=>i.parameterV2(n),$=n=>i.parameterV3(n),p=n=>i.parameterV4(n),d=(n,e,t)=>r.FunctionHandler.declareFunction(n,e,t),f=(n,e,t)=>r.FunctionHandler.callFunction(n,e,t),h=n=>f("isNull","b",[u(n)]),v=n=>f("vNormalize","v3",[$(n)]),g=n=>f("vNormalize","v2",[c(n)]),x=n=>{var t={uniformName:n};return e.getGlobalUniform(t)},S=(n=null)=>{var e={name:n};return a.bool(e)},y=(n=null)=>{var e={name:n};return a.float(e)},_=(n=null,e=0)=>{var t={name:n,size:e};return a.bvec2(t)},T=(n=null)=>{var e={name:n};return a.vec2(e)},D=(n=null,e=0)=>{var t={name:n,size:e};return a.vec3(t)},C=(n=null,e=0)=>{var t={name:n,size:e};return a.vec4(t)},P=(n=null)=>{var e={name:n};return a.mat4(e)},N=n=>t.addVarying(n),b=n=>t.getVarying(n,t.ShaderStages.out),M=n=>t.getBuiltin(n,t.ShaderStages.out),U=(n,e,t)=>f("getViewSpaceConvertedPosition","v3",[c(n),c(e),u(t)]),w=(n,e)=>s.modulo(n,e),V=(n,e)=>s.lessThan(n,e);let z=function(t){let r=o,a=o;if(t.wideLine){let s=n._ShaderChunk;r=`\n                ${N({varyingName:"vFragCoordLineGap",varyingType:"v4"})}\n                ${s.PDSFX_halfWidth_pars_vertex_fragment(t)}\n                ${d("getSegmentDepthValue","f",[$("dir"),$("posToComp")])}{\n                    ${D("nDir")}  = ${v("dir")};\n                    return min(1e18,(dot(posToComp,nDir) * nDir).z);\n                }\n            `,t.useLineGap&&(r=`\n                    ${r}\n                    ${i={uniformName:"lineGap",uniformType:"f"},e.addUniform(i)}\n\n                    ${d("getDistanceToSegment","f",[c("pt"),c("next"),c("prev")])}{\n                        ${T("direction")}  = next-prev;\n                        ${y("l")}  = length(direction);\n                        ${T("proj")} = dot(pt.xy - prev, direction)/(l*l) * direction + prev;\n                        return length(pt.xy - proj);\n                    }\n                `,(!t.dashedLine||t.dashedLine&&t.worldSizePattern)&&(r=`\n                        ${r}\n                        ${N({varyingName:"vPointNextPrec",varyingType:"v4"})}\n                        ${N({varyingName:"vConstantNextPrec",varyingType:"v4"})}\n                        ${N({varyingName:"vConstantCurr_LineDistanceAltResetSecondDist",varyingType:"v4"})}\n                    `)),a=`\n                ${a}\n                ${n._DefaultShaderChunk.getModelViewTransformationChunk(`${C("mvPositionPrec")} `,`${C()}(previousPos.xyz, 1.0)`,t)}\n                ${n._DefaultShaderChunk.getModelViewTransformationChunk(`${C("mvPositionSuiv")} `,`${C()}(followingPos.xyz, 1.0)`,t)}\n                ${C("pmvPosition")}  = ${x("projectionMatrix")} * mvPosition;\n                ${C("pmvPositionPrec")}  = ${x("projectionMatrix")} * mvPositionPrec;\n                ${C("pmvPositionSuiv")}  = ${x("projectionMatrix")} * mvPositionSuiv;\n                ${D("eps")}  = ${D()}(1e-6);\n\n                ${S("bPrecCurr")}  = !all(${V("abs(position_.xyz - previousPos.xyz)","eps")});\n                ${S("bCurrNext")}  = !all(${V("abs(followingPos.xyz - position_.xyz)","eps")});\n                \n            ${S("clipped")}  = false;\n            ${D("testClip")}  = ${D()}(sign(pmvPositionPrec.w + pmvPositionPrec.z), sign(pmvPosition.w + pmvPosition.z), sign(pmvPositionSuiv.w + pmvPositionSuiv.z));\n            if (bPrecCurr && testClip.x * testClip.y < 0.0 ){\n                ${y("a")}  = (pmvPositionPrec.w + pmvPositionPrec.z)/((pmvPositionPrec.w + pmvPositionPrec.z) - (pmvPosition.w + pmvPosition.z));\n                if (testClip.x < 0.0) {\n                    pmvPositionPrec = (1.0 - a) * pmvPositionPrec + a * pmvPosition;\n                    clipped = true;\n                } else if (abs(${w("sideExtrusion","2.0")}) == 1.0) {\n                   pmvPosition = (1.0 - a) * pmvPositionPrec + a * pmvPosition;\n                    pmvPositionSuiv = pmvPosition;\n                    bCurrNext = false;\n                    clipped = true;\n                }\n\n            }\n            if (bCurrNext && testClip.y * testClip.z < 0.0 ){\n                ${y("a")}  = (pmvPosition.w + pmvPosition.z)/((pmvPosition.w + pmvPosition.z) - (pmvPositionSuiv.w + pmvPositionSuiv.z));\n                if (testClip.z < 0.0) {\n                    pmvPositionSuiv = (1.0 - a) * pmvPosition + a * pmvPositionSuiv;\n                    clipped = true;\n                } else if (abs(${w("sideExtrusion","2.0")}) == 0.0){\n                    pmvPosition = (1.0 - a) * pmvPosition + a * pmvPositionSuiv;\n                    pmvPositionPrec = pmvPosition;\n                    bPrecCurr = false;\n                    clipped = true;\n                }\n\n            }\n    \n                ${"round"===t.linecap||"round"===t.linejoin?`\n                    ${C("mvpPositionPrecR")}  = pmvPositionPrec;\n                    ${C("mvpPositionR")}  = pmvPosition;\n                    ${C("mvpPositionSuivR")}  = pmvPositionSuiv;\n                    `:o}\n                pmvPosition.y *= ${x("pixelSize")}.x/${x("pixelSize")}.y;\n                pmvPositionPrec.y *= ${x("pixelSize")}.x/${x("pixelSize")}.y;\n                pmvPositionSuiv.y *= ${x("pixelSize")}.x/${x("pixelSize")}.y;\n                ${y("oldW")}  = abs(pmvPosition.w);\n                ${y("oldWPrec")}  = abs(pmvPositionPrec.w);\n                ${y("oldWSuiv")}  = abs(pmvPositionSuiv.w);\n                pmvPosition /= oldW;\n                pmvPositionPrec /= oldWPrec;\n                pmvPositionSuiv /= oldWSuiv;\n                ${y("offset")}  = ${f("getHalfWidth","f",[])}  * ${x("pixelSize")}.x ;\n                ${t.useLineGap?`\n                    ${b("vFragCoordLineGap")}.z = ${(n=>{var t={uniformName:n};return e.getUniform(t)})("lineGap")}  * worldSizeToPixelCurr;\n                    offset = 2.0 * offset + ${b("vFragCoordLineGap")}.z * ${x("pixelSize")}.x;\n                    `:o}\n                ${T("pos")} ;\n                ${T("posPrecCurr")} ;\n                ${T("posCurrNext")} ;\n                ${T("dirPrecCurr")} ;\n                ${T("dirCurrNext")} ;\n                ${y("orientation")}  = sign(sideExtrusion);\n                ${S("parity")}  = abs(${w("sideExtrusion","2.0")}) < 0.5;\n                if (${h("length(pmvPosition.xy - pmvPositionPrec.xy)")}) {\n                    bPrecCurr = false;\n                }\n                if (${h("length(pmvPositionSuiv.xy - pmvPosition.xy)")}) {\n                    bCurrNext = false;\n                }\n                ${function(n){return`\n            if (bPrecCurr){\n                dirPrecCurr = pmvPosition.xy - pmvPositionPrec.xy;\n                dirPrecCurr = ${g("dirPrecCurr")};\n                posPrecCurr = pmvPosition.xy + offset * orientation * ${T()}(-dirPrecCurr.y, dirPrecCurr.x);\n            } else if (bCurrNext) {\n                dirPrecCurr = pmvPosition.xy - pmvPositionSuiv.xy;\n                dirPrecCurr = ${g("dirPrecCurr")};\n                posPrecCurr = pmvPosition.xy + offset * dirPrecCurr.xy;\n            }\n            \n            if (bCurrNext){\n                dirCurrNext = pmvPositionSuiv.xy - pmvPosition.xy;\n                dirCurrNext = ${g("dirCurrNext")};\n                posCurrNext = pmvPosition.xy + offset * orientation * ${T()}(-dirCurrNext.y, dirCurrNext.x);\n            } else if (bPrecCurr) {\n                dirCurrNext = pmvPosition.xy - pmvPositionPrec.xy;\n                dirCurrNext = ${g("dirCurrNext")};\n                posCurrNext = pmvPosition.xy + offset * dirCurrNext.xy;\n            }\n            \n            ${T("dir")}  = ${g("dirCurrNext.xy - dirPrecCurr.xy")};\n            ${S("col")}  = false;\n            if ( bPrecCurr && bCurrNext){\n                if (${h("length(dir)")}){\n                    dir = ${T()}(-dirCurrNext.y, dirCurrNext.x);\n                    col = true;\n                }\n                ${S("realCol")}  = length(${v("followingPos.xyz - position_.xyz")} - ${v("position_.xyz - previousPos.xyz")}) < 1e-2;\n                ${y("sinAlpha")}  = dir.y * dirPrecCurr.x - dir.x * dirPrecCurr.y;\n                ${y("alpha")}  = asin(abs(sinAlpha));\n                ${y("distPoints")}  = min(distance(pmvPosition.xy, pmvPositionPrec.xy), distance(pmvPosition.xy, pmvPositionSuiv.xy)) + offset;\n                ${y("dist")}  = offset/ sinAlpha;\n                ${y("limitAlpha")} = radians(45.0);\n                if (sign(sinAlpha) == -orientation) {\n                    if ( alpha < limitAlpha) {\n                    ${"round"===n.linejoin?`\n                        if (parity){\n                            pos = pmvPosition.xy - sign(sinAlpha) * offset * ${T()}(-dirCurrNext.y,dirCurrNext.x);\n                            pos -= offset * dirCurrNext;\n                        } else {\n                            pos = pmvPosition.xy - sign(sinAlpha) *offset * ${T()}(-dirPrecCurr.y,dirPrecCurr.x);\n                            pos += offset * dirPrecCurr;\n                        }\n                        `:`\n                        if (parity){\n                            pos = posCurrNext - offset * dirCurrNext;\n                        } else {\n                            pos = posPrecCurr + offset * dirPrecCurr;\n                        }\n                        ${n.useLineGap?`\n                            ${T("lineGapDistDir")} = ${T()}(-dir.y, dir.x);\n                            ${b("vFragCoordLineGap")}.w = ${f("getDistanceToSegment","f",[c("pos"),c("pmvPosition.xy + lineGapDistDir"),c("pmvPosition.xy - lineGapDistDir")])} / ${x("pixelSize")}.x - ${f("getHalfWidth","f",[])} * 2.0 * (1.0 - abs(sinAlpha));\n                            `:o}\n                        `}\n                    } else {\n                        pos = pmvPosition.xy - dir *abs(dist);\n                    }\n                    if (col && !realCol) {\n                        if (parity){\n                            pos += dist * dirCurrNext*orientation;\n                        } else {\n                            pos -= dist * dirPrecCurr *orientation;\n                        }\n                    }\n                } else {\n                    if (max(distPoints, offset) < abs(dist)){\n                        dist = max(distPoints - offset, offset)*sign(sinAlpha);\n                        if (alpha < limitAlpha * 0.5){\n                            if (parity){\n                                pos = posCurrNext + dist * dirCurrNext*orientation;\n                            } else {\n                                pos = posPrecCurr - dist * dirPrecCurr *orientation;\n                            }\n                            if (col && !realCol) {\n                                if (parity){\n                                    pos += dist * dirCurrNext*orientation;\n                                } else {\n                                    pos -= dist * dirPrecCurr *orientation;\n                                }\n                            }\n                        } else {\n                            pos = pmvPosition.xy + dir * max(distPoints, offset);\n\n                            if (col && !realCol) {\n                                if (parity){\n                                    pos += dist * dirCurrNext*orientation;\n                                } else {\n                                    pos -= dist * dirPrecCurr *orientation;\n                                }\n                            }\n                        }\n                    } else {\n                        pos = pmvPosition.xy + dir *abs(dist);\n                        if (col && !realCol) {\n                            if (parity){\n                                pos += dist * dirCurrNext*orientation;\n                            } else {\n                                pos -= dist * dirPrecCurr *orientation;\n                            }\n                        }\n                    }\n                }\n            } else if(bPrecCurr || bCurrNext) {\n                ${"butt"===n.linecap?`pos = pmvPosition.xy + offset * ${T()}(-dirCurrNext.y, dirCurrNext.x)*orientation;`:"pos = (posCurrNext - pmvPosition.xy)  + posPrecCurr;"}\n            } else {\n                pos = pmvPosition.xy + offset;\n            }\n        \n        `}(t)}\n                ${t.dashedLine||"round"===t.linejoin||"round"===t.linecap?`${D("auxVec")}  = ${D()}(pos.x, pos.y * ${x("pixelSize")}.y/${x("pixelSize")}.x,0.0);`:o}\n                ${t.dashedLine&&t.worldSizePattern?`\n                    ${T("zwCur")} = ${T()}(pmvPosition.z, pmvPosition.w);\n                    ${D("pointCurr")} = ${U("pos.xy","zwCur","oldW")};\n                    ${b("vPointCurrXYZ_NextX")}.x = pointCurr.x;\n                    ${b("vPointCurrXYZ_NextX")}.y = pointCurr.y;\n                    ${b("vPointCurrXYZ_NextX")}.z = pointCurr.z;\n                    `:o} \n                ${b("vFragCoordLineGap")}.x = (pos.x + 1.0) / ${x("pixelSize")}.x;\n                ${b("vFragCoordLineGap")}.y = (pos.y * ${x("pixelSize")}.y/${x("pixelSize")}.x + 1.0) / ${x("pixelSize")}.y;\n\n                ${y("finalZ")} = ${f("getFinalZ","f",[m("clipped"),l("b2",`${_()}(bPrecCurr && !col,bCurrNext)`),$("pmvPosition.xyz"),$("pmvPositionPrec.xyz"),$("pmvPositionSuiv.xyz"),c("pos"),u("oldW"),$("mvPosition.xyz"),u("worldSizeToPixelCurr")])};\n            `,r=t.projectLineZToPolygon?`\n                    ${r}\n                    ${d("getPlanEquation","v4",[$("v1"),$("v2"),$("randomPosition")])}{\n                        ${D("normal")}  = cross(v1,v2);\n                        normal = ${v("normal")};\n                        ${y("d")} ;\n                        d = -dot(normal,randomPosition);\n                        return ${C()}(normal,d);\n                    }\n\n                    ${d("getViewSpaceConvertedPosition","v3",[c("pos"),c("zw"),u("w")])}{\n                        ${C("res")} = ${C()}(pos,zw);\n                        res *= w;\n                        res.y *= ${x("pixelSize")}.y/${x("pixelSize")}.x;\n                        ${P("projMatrix")}  = ${x("projectionMatrix")};\n                        ${P("inverseProjection")}  = ${P()}(projMatrix);\n                        if (! ${h("projMatrix[3][3]")} ) {\n                            inverseProjection[0][0] = 1.0 / projMatrix[0][0];\n                            inverseProjection[1][1] = 1.0 / projMatrix[1][1];\n                            inverseProjection[2][2] = 1.0 / projMatrix[2][2];\n                            inverseProjection[3][2] = -projMatrix[3][2] / projMatrix[2][2];\n                            inverseProjection[3][3] = 1.0;\n                        } else {\n                            inverseProjection[0][0] = 1.0 / projMatrix[0][0]; \n                            inverseProjection[1][1] = 1.0 / projMatrix[1][1];\n                            inverseProjection[2][2] = 0.0;\n                            inverseProjection[2][3] = 1.0 / projMatrix[3][2];\n                            inverseProjection[3][2] = 1.0 / projMatrix[2][3];\n                            inverseProjection[3][3] = -projMatrix[2][2] / (projMatrix[3][2] * projMatrix[2][3]);\n                        }\n                        res = inverseProjection * res;\n                        return res.xyz/res.w;\n                    }\n\n                    ${d("getFinalZ","f",[m("clipped"),l("b2","precNext"),$("pmvPosition"),$("pmvPositionPrec"),$("pmvPositionSuiv"),c("pos"),u("oldW"),$("mvPosition"),u("worldSizeToPixel")])}{\n                        ${D("computedPosition")}  = ${D()}(pos.x, pos.y,pmvPosition.z);\n                        ${y("finalZ")}  = pmvPosition.z;\n                        ${D("precDir")} ;\n                        ${D("nextDir")} ;\n                        if (precNext.y) {\n                            nextDir = pmvPositionSuiv.xyz - pmvPosition.xyz;\n                        }\n                        if (precNext.x) {\n                            precDir = pmvPosition.xyz - pmvPositionPrec.xyz;\n                        }\n                        if (precNext.x && precNext.y && length(cross(nextDir,precDir)) > 1e-6) {\n                            ${C("equationP")}  = ${f("getPlanEquation","v4",[$("nextDir"),$("precDir"),$("pmvPosition.xyz")])};\n                            finalZ = - (equationP.x * computedPosition.x + equationP.y * computedPosition.y + equationP.w)/equationP.z;\n                            ${T("zw")} = ${T()}(finalZ,1.0);\n                            ${D("mvComputedPos")}  = ${U("pos","zw","oldW")};\n                            ${D("positionToComputed")}  = mvComputedPos.xyz - mvPosition;\n                            if (abs(positionToComputed.z) > 10.0*${f("getHalfWidth","f",[])} / worldSizeToPixel) {\n                                mvComputedPos.z = mvPosition.z + 10.0*${f("getHalfWidth","f",[])} / worldSizeToPixel * sign(positionToComputed.z);\n                            }\n                            ${C("mvpComputedPos")}  = ${x("projectionMatrix")} * ${C()}(mvComputedPos,1.0);\n                            mvpComputedPos /= abs(mvpComputedPos.w);\n                            finalZ = mvpComputedPos.z;\n                        } else if (precNext.x) {\n                            finalZ = ${f("getSegmentDepthValue","f",[$("precDir"),$("computedPosition.xyz - pmvPosition.xyz")])} + pmvPosition.z;\n                        } else if (precNext.y) {\n                            finalZ = ${f("getSegmentDepthValue","f",[$("nextDir"),$("computedPosition.xyz - pmvPosition.xyz")])} + pmvPosition.z;\n                        }\n                        return 0.99999*finalZ;\n                    }\n                `:`\n                    ${r}\n                    ${d("getFinalZ","f",[m("clipped"),l("b2","precNext"),$("pmvPosition"),$("pmvPositionPrec"),$("pmvPositionSuiv"),c("pos"),u("oldW"),$("mvPosition"),u("worldSizeToPixel")])}{\n                        ${D("computedPosition")}  = ${D()}(pos.x, pos.y,pmvPosition.z);\n                        ${y("finalZ")}  = pmvPosition.z;\n                        if (!clipped) {\n                            return finalZ;\n                        }\n                        if (precNext.x) {\n                            finalZ = ${f("getSegmentDepthValue","f",[$("pmvPosition.xyz - pmvPositionPrec.xyz"),$("computedPosition.xyz - pmvPosition.xyz")])} + pmvPosition.z;\n                        } else if (precNext.y) {\n                            finalZ = ${f("getSegmentDepthValue","f",[$("pmvPositionSuiv.xyz - pmvPosition.xyz"),$("computedPosition.xyz - pmvPosition.xyz")])} + pmvPosition.z;\n                        }\n                        return finalZ;\n                    }\n                `,t.useLineGap&&(!t.dashedLine||t.dashedLine&&t.worldSizePattern)&&(a=`\n                        ${a}  \n                        {       \n                            ${C("mvpPositionPrec")}  = ${x("projectionMatrix")} * mvPositionPrec;\n                            ${C("mvpPosition")}  = ${x("projectionMatrix")} * mvPosition;\n                            ${C("mvpPositionSuiv")}  = ${x("projectionMatrix")} * mvPositionSuiv;\n                            ${T("constantCurr")} = (mvpPosition.xy / mvpPosition.w + 1.0) / ${x("pixelSize")};\n                            ${T("constantPrec")} = (mvpPositionPrec.xy / mvpPositionPrec.w + 1.0) / ${x("pixelSize")};\n                            ${T("constantNext")} = (mvpPositionSuiv.xy / mvpPositionSuiv.w + 1.0)/ ${x("pixelSize")};\n                            ${b("vConstantNextPrec")} = ${C()}(\n                                        constantNext,\n                                        constantPrec\n                            );\n                            ${b("vConstantCurr_LineDistanceAltResetSecondDist")}.x = constantCurr.x;\n                            ${b("vConstantCurr_LineDistanceAltResetSecondDist")}.y = constantCurr.y;\n                            if (!parity){\n                                ${b("vPointNextPrec")}.x = constantCurr.x;\n                                ${b("vPointNextPrec")}.y = constantCurr.y;\n                                ${b("vPointNextPrec")}.z = constantPrec.x;\n                                ${b("vPointNextPrec")}.w = constantPrec.y;\n                            } else {\n                                ${b("vPointNextPrec")}.x = constantNext.x;\n                                ${b("vPointNextPrec")}.y = constantNext.y;\n                                ${b("vPointNextPrec")}.z = constantCurr.x;\n                                ${b("vPointNextPrec")}.w = constantCurr.y;\n                            }\n                        }\n                    `),t.dashedLine&&(a=t.worldSizePattern?`\n                        ${a}\n                        ${b("vPointPrecZ_LineDistanceAltResetSecondDist_ConstantNextX")}.y = ${b("vLineDistance")}.x;\n                        ${D("constantNext")} = ${U("pmvPositionSuiv.xy",`${T()}(pmvPositionSuiv.z, pmvPositionSuiv.w)`,"oldWSuiv")};\n                        ${D("constantPrec")} = ${U("pmvPositionPrec.xy",`${T()}(pmvPositionPrec.z, pmvPositionPrec.w)`,"oldWPrec")};\n                        ${D("constantCurr")} = ${U("pmvPosition.xy",`${T()}(pmvPosition.z, pmvPosition.w)`,"oldW")};\n                        ${b("vPointPrecZ_LineDistanceAltResetSecondDist_ConstantNextX")}.w = constantNext.x;\n                        ${b("vConstantNextYZ_CurXY")}.x = constantNext.y;\n                        ${b("vConstantNextYZ_CurXY")}.y = constantNext.z;\n                        ${b("vConstantCurrZ_PrecXYZ")}.y = constantPrec.x;\n                        ${b("vConstantCurrZ_PrecXYZ")}.z = constantPrec.y;\n                        ${b("vConstantCurrZ_PrecXYZ")}.w = constantPrec.z;\n                        ${b("vConstantNextYZ_CurXY")}.z = constantCurr.x;\n                        ${b("vConstantNextYZ_CurXY")}.w = constantCurr.y;\n                        ${b("vConstantCurrZ_PrecXYZ")}.x = constantCurr.z;\n                        ${b("vLineDistance")}.x = lineDistance.x* modelMatrixScaleX;\n                        ${b("vLineDistance")}.y = lineDistance.y* modelMatrixScaleX;\n                        ${b("vPointPrecZ_LineDistanceAltResetSecondDist_ConstantNextX")}.z = 0.0;\n                        if (!parity){\n                            ${b("vPointPrecZ_LineDistanceAltResetSecondDist_ConstantNextX")}.y = ${b("vLineDistance")}.y;\n                            ${b("vPointNextYZ_PrecXY")}.z = constantPrec.x;\n                            ${b("vPointNextYZ_PrecXY")}.w = constantPrec.y;\n                            ${b("vPointPrecZ_LineDistanceAltResetSecondDist_ConstantNextX")}.x = constantPrec.z;\n                            ${b("vPointCurrXYZ_NextX")}.w = constantCurr.x;\n                            ${b("vPointNextYZ_PrecXY")}.x = constantCurr.y;\n                            ${b("vPointNextYZ_PrecXY")}.y = constantCurr.z;\n                        } else {\n                            ${b("vPointPrecZ_LineDistanceAltResetSecondDist_ConstantNextX")}.y = ${b("vLineDistance")}.x;\n                            ${b("vPointNextYZ_PrecXY")}.z = constantCurr.x;\n                            ${b("vPointNextYZ_PrecXY")}.w = constantCurr.y;\n                            ${b("vPointPrecZ_LineDistanceAltResetSecondDist_ConstantNextX")}.x = constantCurr.z;\n                            ${b("vPointCurrXYZ_NextX")}.w = constantNext.x;\n                            ${b("vPointNextYZ_PrecXY")}.x = constantNext.y;\n                            ${b("vPointNextYZ_PrecXY")}.y = constantNext.z;\n                            if (abs(lineDistance.x - lineDistance.y) < 1e-6) {\n                                ${b("vPointPrecZ_LineDistanceAltResetSecondDist_ConstantNextX")}.z = 1.0;\n                            }\n                        }\n                    `:`\n                        ${a}         \n                        ${b("vConstantCurr_LineDistanceAltResetSecondDist")}.z = ${b("vLineDistance")}.x;\n                        ${C("mvpPositionPrec")}  = ${x("projectionMatrix")} * mvPositionPrec;\n                        ${C("mvpPosition")}  = ${x("projectionMatrix")} * mvPosition;\n                        ${C("mvpPositionSuiv")}  = ${x("projectionMatrix")} * mvPositionSuiv;\n                        ${T("constantCurr")} = (mvpPosition.xy / mvpPosition.w + 1.0) / ${x("pixelSize")};\n                        ${T("constantPrec")} = (mvpPositionPrec.xy / mvpPositionPrec.w + 1.0) / ${x("pixelSize")};\n                        ${T("constantNext")} = (mvpPositionSuiv.xy / mvpPositionSuiv.w + 1.0)/ ${x("pixelSize")};\n                        ${b("vConstantNextPrec")} = ${C()}(\n                                    constantNext,\n                                    constantPrec\n                        );\n                        ${b("vConstantCurr_LineDistanceAltResetSecondDist")}.x = constantCurr.x;\n                        ${b("vConstantCurr_LineDistanceAltResetSecondDist")}.y = constantCurr.y;\n                        ${t.cpuPattern?`${b("vLineDistance")}.x = lineDistance.x ; ${b("vLineDistance")}.y = lineDistance.y ;`:o}\n                        ${y("worldSizeToPixelPrec")} = ${f("computeWorldSizeToPixel","f",[p("mvpPositionPrec")])};\n                        ${y("worldSizeToPixelNext")} = ${f("computeWorldSizeToPixel","f",[p("mvpPositionSuiv")])};\n                        ${b("vConstantCurr_LineDistanceAltResetSecondDist")}.w = 0.0;\n                        if (!parity){\n                            ${b("vConstantCurr_LineDistanceAltResetSecondDist")}.z = ${b("vLineDistance")}.y;\n                            ${b("vPointNextPrec")}.x = constantCurr.x;\n                            ${b("vPointNextPrec")}.y = constantCurr.y;\n                            ${b("vPointNextPrec")}.z = constantPrec.x;\n                            ${b("vPointNextPrec")}.w = constantPrec.y;\n                            ${t.cpuPattern?`\n                                ${b("vLineDistanceLeftRight")}.x = lineDistance.x;\n                                ${b("vLineDistanceLeftRight")}.y = lineDistance.y;\n                                ${b("vLineDistanceLeftRight")}.z = lineDistance.y;\n                                ${b("vLineDistanceLeftRight")}.w = (lineDistance.y + length(constantNext.xy - constantCurr.xy));\n                                `:`\n                                ${b("vLineDistance")}.x = lineDistance.x * modelMatrixScaleX * worldSizeToPixelPrec;\n                                ${b("vLineDistance")}.y = lineDistance.y * modelMatrixScaleX * worldSizeToPixelCurr;\n                                ${b("vLineDistanceLeftRight")}.x = lineDistance.x * modelMatrixScaleX * worldSizeToPixelPrec;\n                                ${b("vLineDistanceLeftRight")}.y = lineDistance.y * modelMatrixScaleX * worldSizeToPixelCurr;\n                                ${b("vLineDistanceLeftRight")}.z = lineDistance.y * modelMatrixScaleX * worldSizeToPixelCurr;\n                                ${b("vLineDistanceLeftRight")}.w = (lineDistance.y + length(followingPos.xyz - position_.xyz)) * modelMatrixScaleX * worldSizeToPixelNext;\n                                `}\n                        } else {\n                            ${b("vConstantCurr_LineDistanceAltResetSecondDist")}.z = ${b("vLineDistance")}.x;\n                            ${b("vPointNextPrec")}.x = constantNext.x;\n                            ${b("vPointNextPrec")}.y = constantNext.y;\n                            ${b("vPointNextPrec")}.z = constantCurr.x;\n                            ${b("vPointNextPrec")}.w = constantCurr.y;\n                            ${t.cpuPattern?`\n                                ${b("vLineDistanceLeftRight")}.x = (lineDistance.x - length(constantCurr.xy - constantPrec.xy));\n                                ${b("vLineDistanceLeftRight")}.y = lineDistance.x;\n                                ${b("vLineDistanceLeftRight")}.z = lineDistance.x;\n                                ${b("vLineDistanceLeftRight")}.w = lineDistance.y;\n                                `:`\n                                ${b("vLineDistance")}.x = lineDistance.x * modelMatrixScaleX* worldSizeToPixelCurr;\n                                ${b("vLineDistance")}.y = lineDistance.y * modelMatrixScaleX* worldSizeToPixelNext;\n                                ${b("vLineDistanceLeftRight")}.x = (lineDistance.x - length(position_.xyz - previousPos.xyz)) * modelMatrixScaleX * worldSizeToPixelPrec;\n                                ${b("vLineDistanceLeftRight")}.y = lineDistance.x * modelMatrixScaleX * worldSizeToPixelCurr;\n                                ${b("vLineDistanceLeftRight")}.z = lineDistance.x * modelMatrixScaleX * worldSizeToPixelCurr;\n                                ${b("vLineDistanceLeftRight")}.w = lineDistance.y * modelMatrixScaleX * worldSizeToPixelNext;\n                                `}\n                            if (${h("lineDistance.x - lineDistance.y")}) {\n                                ${t.cpuPattern?`\n                                    ${b("vLineDistanceLeftRight")}.w += length(constantNext.xy -  constantCurr.xy );\n                                    `:`\n                                    ${b("vLineDistanceLeftRight")}.w += length(followingPos.xyz -  position_.xyz )* modelMatrixScaleX * worldSizeToPixelNext;\n                                    `}\n                                ${b("vConstantCurr_LineDistanceAltResetSecondDist")}.w = 1.0;\n                            }\n                        }\n                    `),"round"===t.linecap&&(r=`\n                    ${r}\n                    ${N({varyingName:"infosCenterCap",varyingType:"v4"})}\n                    ${N({varyingName:"centerLeftRight",varyingType:"v4"})}\n                `,a=`\n                    ${a}                \n                    ${T("following")}  = (mvpPositionSuivR.xy / mvpPositionSuivR.w + 1.0)/ ${x("pixelSize")};\n                    ${T("previous")}  = (mvpPositionPrecR.xy / mvpPositionPrecR.w + 1.0) / ${x("pixelSize")};\n                    ${T("current")}  = (mvpPositionR.xy / mvpPositionR.w + 1.0) / ${x("pixelSize")};\n                    ${T("computedCurrent")}  = (auxVec.xy + 1.0) / ${x("pixelSize")};\n                    if (!bPrecCurr) {\n                        ${b("centerLeftRight")}.x = current.x;\n                        ${b("centerLeftRight")}.y = current.y;\n                        ${b("infosCenterCap")}.z = current.x;\n                        ${b("infosCenterCap")}.w = current.y;\n                        ${b("centerLeftRight")}.z = following.x;\n                        ${b("centerLeftRight")}.w = following.y;\n                        ${b("infosCenterCap")}.x = -${f("getHalfWidth","f",[])};\n                        ${b("infosCenterCap")}.y = 1.0;\n                    } else if (!bCurrNext) {\n                        ${b("centerLeftRight")}.x = previous.x;\n                        ${b("centerLeftRight")}.y = previous.y;\n                        ${b("infosCenterCap")}.z = previous.x;\n                        ${b("infosCenterCap")}.w = previous.y;\n                        ${b("centerLeftRight")}.z = current.x;\n                        ${b("centerLeftRight")}.w = current.y;\n                        ${b("infosCenterCap")}.x = length(current.xy-previous.xy) + ${f("getHalfWidth","f",[])};\n                        ${b("infosCenterCap")}.y = 1.0;\n                    } else {\n                        ${b("centerLeftRight")}.x = previous.x;\n                        ${b("centerLeftRight")}.y = previous.y;\n                        ${b("infosCenterCap")}.z = current.x;\n                        ${b("infosCenterCap")}.w = current.y;\n                        ${b("centerLeftRight")}.z = following.x;\n                        ${b("centerLeftRight")}.w = following.y;\n                        if (parity) {\n                            ${b("infosCenterCap")}.x = dot(computedCurrent.xy - current.xy,  ${g("following.xy - current.xy")});\n                        } else {\n                            ${b("infosCenterCap")}.x = length(current.xy - previous.xy) + dot(computedCurrent.xy - current.xy, ${g("current.xy - previous.xy")});\n                        }\n                        ${b("infosCenterCap")}.y = 0.0;\n                    }\n                `),"round"===t.linejoin&&(r=`\n                    ${r}\n                    ${N({varyingName:"centerJoin",varyingType:"v4"})}\n                    ${N({varyingName:"centerRightJoin",varyingType:"v4"})}\n                    ${N({varyingName:"centerLeftJoin",varyingType:"v4"})}\n                `,a=`\n                    ${a}\n                    ${T("followingJoin")}  = (mvpPositionSuivR.xy / mvpPositionSuivR.w + 1.0)/ ${x("pixelSize")};\n                    ${T("previousJoin")}  = (mvpPositionPrecR.xy / mvpPositionPrecR.w + 1.0) / ${x("pixelSize")};\n                    ${T("currentJoin")}  = (mvpPositionR.xy / mvpPositionR.w + 1.0) / ${x("pixelSize")};\n\n                    ${b("centerLeftJoin")} = ${C()}(0.0);\n                    ${b("centerRightJoin")} = ${C()}(0.0);\n                    ${b("centerJoin")} = ${C()}(0.0);\n                    if (!bPrecCurr) {\n                        ${b("centerLeftJoin")}.x = followingJoin.x;\n                        ${b("centerLeftJoin")}.y = followingJoin.y;\n                        ${b("centerJoin")}.x = currentJoin.x;\n                        ${b("centerJoin")}.y = currentJoin.y;\n                        ${b("centerRightJoin")}.x = followingJoin.x;\n                        ${b("centerRightJoin")}.y = followingJoin.y;\n                        ${b("centerRightJoin")}.z = dirCurrNext.x;\n                        ${b("centerRightJoin")}.w = dirCurrNext.y;\n                    } else if (!bCurrNext) {\n                        ${b("centerLeftJoin")}.x = previousJoin.x;\n                        ${b("centerLeftJoin")}.y = previousJoin.y;\n                        ${b("centerJoin")}.x = currentJoin.x;\n                        ${b("centerJoin")}.y = currentJoin.y;\n                        ${b("centerRightJoin")}.x = previousJoin.x;\n                        ${b("centerRightJoin")}.y = previousJoin.y;\n                        ${b("centerLeftJoin")}.z = -dirPrecCurr.x;\n                        ${b("centerLeftJoin")}.w = -dirPrecCurr.y;\n                    } else {\n                        if (parity) {\n                            ${b("centerLeftJoin")}.x = currentJoin.x;\n                            ${b("centerLeftJoin")}.y = currentJoin.y;\n                            ${b("centerJoin")}.x = currentJoin.x;\n                            ${b("centerJoin")}.y = currentJoin.y;\n                            ${b("centerRightJoin")}.x = followingJoin.x;\n                            ${b("centerRightJoin")}.y = followingJoin.y;\n                            ${b("centerLeftJoin")}.z = -dirCurrNext.x;\n                            ${b("centerLeftJoin")}.w = -dirCurrNext.y;\n                            ${b("centerRightJoin")}.z = dirCurrNext.x;\n                            ${b("centerRightJoin")}.w = dirCurrNext.y;\n                            ${b("centerJoin")}.z = -dir.x;\n                            ${b("centerJoin")}.w = -dir.y;\n                        } else {\n                            ${b("centerLeftJoin")}.x = previousJoin.x;\n                            ${b("centerLeftJoin")}.y = previousJoin.y;\n                            ${b("centerJoin")}.x = currentJoin.x;\n                            ${b("centerJoin")}.y = currentJoin.y;\n                            ${b("centerRightJoin")}.x = currentJoin.x;\n                            ${b("centerRightJoin")}.y = currentJoin.y;\n                            ${b("centerLeftJoin")}.z = -dirPrecCurr.x;\n                            ${b("centerLeftJoin")}.w = -dirPrecCurr.y;\n                            ${b("centerRightJoin")}.z = dirPrecCurr.x;\n                            ${b("centerRightJoin")}.w = dirPrecCurr.y;\n                            ${b("centerJoin")}.z = -dir.x;\n                            ${b("centerJoin")}.w = -dir.y;\n                        }\n                    }\n                `),a=`\n                ${a}\n                ${M("position")} = ${C()}(pos.x, pos.y * ${x("pixelSize")}.y/${x("pixelSize")}.x,finalZ, pmvPosition.w);\n            `}var i;return[r,a]};return function(n,t){let r=`\n            ${t}\n        `,a="";if(n.wideLine||n.dashedLine){let[t,s]=function(n){let e=o,t=o;return n.dashedLine&&(e=`\n                ${e}\n                ${N({varyingName:"vLineDistance",varyingType:"v2"})}\n            `,t=n.cpuPattern?`\n                    ${t}\n                    ${b("vLineDistance")} = lineDistance;\n                `:`\n                    ${t}\n                    ${y("modelMatrixScaleX")}  = length(modelMatrix[0]);\n                    ${n.defaultInstancing?"\n                        modelMatrixScaleX *= length(multipliedDefaultInstancingMatrix[0]);\n                        ":o}\n                    ${n.fixedSize?"modelMatrixScaleX *= simpleNodeData.fixedSizeScale;":o}\n                    ${n.worldSizePattern?`${b("vLineDistance")} = modelMatrixScaleX * lineDistance;`:`${b("vLineDistance")} = worldSizeToPixelCurr * modelMatrixScaleX * lineDistance;`}\n                `,n.worldSizePattern?(e=`\n                    ${e}\n                    ${n.worldSizePattern2?N({varyingName:"vPatternStartEnd",varyingType:"v2"}):o}\n                `,t=`\n                    ${t}\n                    ${n.worldSizePattern2?`${b("vPatternStartEnd")} = patternStartEnd;`:o}                \n                `,n.wideLine&&(e=`\n                        ${e}\n                        ${N({varyingName:"vPointCurrXYZ_NextX",varyingType:"v4"})}\n                        ${N({varyingName:"vPointNextYZ_PrecXY",varyingType:"v4"})}\n                        ${N({varyingName:"vPointPrecZ_LineDistanceAltResetSecondDist_ConstantNextX",varyingType:"v4"})}\n                        ${N({varyingName:"vConstantNextYZ_CurXY",varyingType:"v4"})}\n                        ${N({varyingName:"vConstantCurrZ_PrecXYZ",varyingType:"v4"})}\n                    `)):n.wideLine&&(e=`\n                    ${e}\n                    ${N({varyingName:"vPointNextPrec",varyingType:"v4"})}\n                    ${N({varyingName:"vLineDistanceLeftRight",varyingType:"v4"})}\n                    ${N({varyingName:"vConstantNextPrec",varyingType:"v4"})}\n                    ${N({varyingName:"vConstantCurr_LineDistanceAltResetSecondDist",varyingType:"v4"})}\n                `)),[e,t]}(n),[l,u]=z(n);r=`\n                ${r}\n                ${i={uniformName:"pixelSize",uniformType:"v2"},e.addGlobalUniform(i)}\n\n                ${d("computeWorldSizeToPixel","f",[p("pos")])} {\n                    return abs(${x("projectionMatrix")}[0][0]/pos.w)/${x("pixelSize")}.x;\n                }\n                ${t}\n                ${l}\n            `,a=`\n                ${y("worldSizeToPixelCurr")}  = ${f("computeWorldSizeToPixel","f",[p(M("position"))])};\n                ${s}\n                ${u}\n            `}var i;return[r,a]}})),define("DS/ShaderBuilders/LineBasicShaderBuilder",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/LineUtils/LineBasicVertexShaderBuilderUtils","DS/ShaderBuilders/LineUtils/LineBasicFragmentShaderBuilderUtils","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a,o,i,s){"use strict";const l=i.ParameterUtils,u=i.FunctionHandler,m=(n,e)=>e.highFrequencyColors?(n=>{var e={uniformName:n};return a.getHighFrequencyUniform(e)})(n):(n=>{var e={uniformName:n};return a.getUniform(e)})(n);let c=function(n){return`\n        ${((n,e,t)=>i.FunctionHandler.declareFunction(n,e,t))("isNull","b",[(e="x",l.parameterF(e))])} {\n            return abs(x) < 1e-6;\n        }\n\n    `;var e},$=function(e,t){let a=n._ShaderChunk,l=n._DeferredShaderChunk,[$,p]=r(e,c()),d=`\n            ${l._debug_common_pars_fragment(e)}\n            ${a.clip_pars_fragment(e)}\n\t\t\t${a.color_pars_fragment(e)}\n            ${n._DefaultShaderChunk.viewposition_lineic_pars_fragment(e)}\n\t\t\t${$}\n            ${a.map_pars_fragment(e)}\n            ${a.fog_pars_fragment(e)}\n\t\t\t${l.oit_pars_fragment(e)}\n\t\t\t${t?`\n                ${l.depth_pars_fragment(e)}\n                ${l.picking_pars_fragment(e)}\n                ${l.picking_instancing_pars_fragment(e)}\n                ${l.highlight_pars_fragment(e)}\n                ${l.gpupos_pars_fragment(e)}\n                `:""}\n\t\t\t\n            ${a.postprocess_pars_fragment(e)}\n        `,f=`\n                ${((n=null,e=0)=>{var t={name:n,size:e};return s.vec3(t)})("diffuseToUse")}  = ${m("diffuse",e)}.rgb;\n                ${((n=null)=>{var e={name:n};return s.float(e)})("opacityToUse")}  = ${m("opacity",e)};\n                ${e.selectionMaterial?"opacityToUse = 1.0;":""}\n\t\t\t\t${a.color_fragment(e)}            \n                if(${m("diffuse",e)}.w > 0.5) {\n                    diffuseToUse = ${m("diffuse",e)}.rgb;\n                }\n                ${e.PDSFX?`\n                    ${a.PDSFX_start_fragment(e)}\n                    ${a.PDSFX_uv_fragment(e)}\n                    ${a.PDSFX_mapping_uv_transform_fragment(e)}\n                    ${a.PDSFX_Color_backup_fragment(e)}\n                    ${a.PDSFX_halfWidth_backup_fragment_vertex(e)}\n\t\t\t\t    ${h="ComputeCommonValues",v=null,g=[],i.FunctionHandler.callFunction(h,v,g)}; \n                    ${a.PDSFX_discard_fragment(e)}\n                    ${a.PDSFX_halfWidth_fragment_vertex(e)}\n                    ${a.PDSFX_Color_fragment(e)}\n                    ${a.PDSFX_viewPosition_fragment(e)}\n                    `:""}\n                ${(n=>o.getShaderOutput(n))("out0")} = ${((n=null,e=0)=>{var t={name:n,size:e};return s.vec4(t)})()}( diffuseToUse, opacityToUse );\n\n                ${n._DefaultShaderChunk.viewposition_lineic_fragment(e)}\n                ${a.clip_fragment(e)}\n\t\t\t\t${a.alphatest_fragment(e)}\n                ${p}\n\t\t\t\t${a.postprocess_fragment(e)}\n\t\t\t\t${a.linear_to_gamma_fragment(e)}\n\n\t\t\t\t${a.PDSFX_end_fragment(e)}\n                ${a.fog_fragment(e)}\n\t\t\t\t${a.backgroundviewmode_lowlight_fragment(e)}\n                ${l._debug_common_lineic_fragment(e)}\n                ${l.oit_fragment(e)}\n\t\t\t\t${t?`\n                    ${l.depth_fragment(e)}\n                    ${l.picking_fragment(e)}\n                    ${l.picking_instancing_fragment(e)}\n                    ${l.highlight_fragment_edge(e)}\n                    ${l.lineic_normal_fragment(e)}\n                    ${l.lineic_normal_depth_fragment(e)}\n                    ${l.gpupos_fragment(e)}\n                    `:""}\n        \n        `;var h,v,g;return`\n            ${d}\n            ${u.getMainFragmentStart(e)}\n                ${f}\n            ${u.getMainFragmentEnd(e)}\n        `};return new e((function(e,r,a){let o=r.isDeferredMaterial,i=$(r,o),s=function(e,r){let a=n._ShaderChunk,o=n._DeferredShaderChunk,[i,s]=t(e,c()),l=`\n            ${a.clip_pars_vertex(e)}\n\t\t\t${a.color_pars_vertex(e)}\n\t\t\t${a.morphtarget_pars_vertex(e)}\n\t\t\t${a.skinning_pars_vertex(e)}\n            ${n._DefaultShaderChunk.viewposition_lineic_pars_vertex(e)}\n            ${i}\n            ${a.fog_pars_vertex(e)}\n\n            ${a.map_pars_vertex(e)}\n\n            ${o.oit_pars_vertex(e)}\n            ${r?`\n                ${o.depth_pars_vertex(e)}\n                ${o.picking_pars_vertex(e)}\n                ${o.picking_instancing_pars_vertex(e)}\n                ${o.highlight_pars_vertex(e)}\n                ${o.gpupos_pars_vertex(e)}\n                `:""}\n        `,m=`\n            ${e.PDSFX?a.PDSFX_halfWidth_backup_fragment_vertex(e):""}\n            ${a.PDSFX_start_vertex(e)}\n            ${e.PDSFX?a.PDSFX_halfWidth_fragment_vertex(e):""}\n            ${a.map_varying_set_vertex(e)}\n            ${a.color_vertex(e)}\n            ${a.skinbase_vertex(e)}\n            ${a.morphtarget_vertex(e)}\n            ${a.skinning_vertex(e)}\n            ${a.position_vertex(e)}\n            ${a.default_vertex(e)}\n            ${n._DefaultShaderChunk.viewposition_lineic_vertex(e)}\n            ${a.clip_vertex(e)}\n            ${a.fog_vertex(e)}\n            ${s}\n            \n            ${o.oit_vertex(e)}\n            ${r?`\n                ${o.depth_vertex(e)}\n                ${o.picking_vertex(e)}\n                ${o.picking_instancing_vertex(e)}\n                ${o.highlight_vertex(e)}\n                ${o.gpupos_vertex(e)}\n                `:""}\n            ${a.PDSFX_end_vertex(e)}\n        `;return`\n            ${l}\n            ${u.getMainVertexStart(e)}\n                ${m}\n            ${u.getMainVertexEnd(e)}\n        `}(r,o);return{vertexShader:s,fragmentShader:i}}))})),define("DS/ShaderBuilders/Commons/PDSFX/PDSFXFragmentCoreShaders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/ShaderUtils/AttributeUtils","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a,o){"use strict";const i="",s=a.ParameterUtils,l=(n,e,t)=>a.FunctionHandler.callFunction(n,e,t),u=(n,e)=>e.mappingFromMatApp?(n=>{var e={uniformName:n};return t.getHighFrequencyUniform(e)})(n):(n=>{var e={uniformName:n};return t.getUniform(e)})(n),m=(n,e=null)=>r.getVarying(n,r.ShaderStages.in,e),c=n=>r.getShaderInput(n),$=n=>r.getShaderOutput(n),p=(n=null)=>{var e={name:n};return o.vec3(e)};return{PDSFX_start_fragment:function(n){var e=`\n            INTERNAL_builtin_FragCoord = ${c("fragCoord")};\n            INTERNAL_builtin_FragDepthUsed = false;\n            INTERNAL_builtin_FragDepthValue = 0.0;\n            \n            ${n.WebGPU?`\n                INTERNAL_builtin_SampleID = i32(${c("sampleIndex")});\n                `:"\n                INTERNAL_builtin_SampleID = 0;\n                "}       \n            INTERNAL_builtin_FrontFacing = ${c("frontFacing")};\n            INTERNAL_computedvar_clipPosition = ${m("INTERNAL_varying_clipPosition")};\n            INTERNAL_computedvar_viewPosition = ${m("INTERNAL_varying_viewPosition")};\n            INTERNAL_computedvar_viewNormal = ${m("INTERNAL_varying_viewNormal")};\n            INTERNAL_computedvar_viewTangent = ${m("INTERNAL_varying_viewTangent")};\n            INTERNAL_computedvar_viewBinormal = ${m("INTERNAL_varying_viewBinormal")};\n            ${n.usePointUV?`INTERNAL_computedvar_pointCoord = ${m("vUv")}.xy;`:i}\n            `;const t=r._context.__varyings__;for(var a in t){var o=t[a];if(o.pdsfx){var s=a.replace("_IPCV","");if(o.size>0)for(let n=0;n<o.size;n++)e=`\n                                ${e}\n                                ${s}[${n}] = ${m(a,n)};\n                            `;else e=`\n                                ${e}\n                                ${s} = ${m(a)};\n                            `}}return e},PDSFX_uv_fragment:function(n){if(!n.useUV)return i;let t=i;t=n.isDecal?`      \n                    _uvToUse = dUv;\n                    _uvToUse2 = dUv2;\n                    ${e._useUv3(n)?`_uvToUse3 = ${m("vUv3")};`:i}\n                `:`         \n                    _uvToUse = ${m("vUv")};\n                    ${e._useUv2(n)?`_uvToUse2 = ${m("vUv2")};`:i}\n                    ${e._useUv3(n)?`_uvToUse3 = ${m("vUv3")};`:i}\n                `;let r=i;return n.pdsfxUseMappedUv&&(r=n.mappingType>-1?`\n                        _uvToUseMappingOperator = ${l("applyMappingOperator","v4",[prmV4("_uvToUse"),prmV3(m("localPosition")),prmV3(m("localNormal"))])};\n                    `:"\n                        _uvToUseMappingOperator = _uvToUse;\n                    "),n.pdsfxUseMappedUv2&&(r=n.mappingType>-1?`\n                        _uvToUseMappingOperator2 = ${l("applyMappingOperator","v4",[prmV4("_uvToUse2"),prmV3(m("localPosition")),prmV3(m("localNormal"))])};\n                    `:"\n                        _uvToUseMappingOperator2 = _uvToUse2;\n                    "),n.pdsfxUseMappedUv3&&(r=n.mappingType>-1?`\n                        _uvToUseMappingOperator3 = ${l("applyMappingOperator","v4",[prmV4("_uvToUse3"),prmV3(m("localPosition")),prmV3(m("localNormal"))])};\n                    `:"\n                        _uvToUseMappingOperator3 = _uvToUse3;\n                    "),`\n                ${t}\n                ${r}\n            `},PDSFX_mapping_uv_transform_fragment:function(n){return n.useUV&&(n.mappingType>-1||n.lightMapMappingType>-1)?`INTERNAL_backup_mappingUVTransformation = ${u("mappingUVTransformation",n)};`:i},PDSFX_discard_fragment:function(n){return n.pdsfxUseDiscard?`\n                ${((n=null)=>{var e={name:n};return o.bool(e)})("isDiscarded")}  = ${l("ComputeDiscard","b",[])};\n                if (isDiscarded){ \n                    discard;\n                }\n            `:i},PDSFX_viewNormal_fragment:function(n){return`\n                ${p("INTERNAL_computed_viewNormal")}  = ${l("ComputeViewNormal","v3",[])};\n            `},PDSFX_viewPosition_fragment:function(n){return`\n                ${p("INTERNAL_computed_viewPosition")}  = -${l("ComputeViewPosition","v3",[])};\n            `},PDSFX_end_fragment:function(n){var e,t=i;return n.PDSFX&&(t=`\n                    ${t}\n                    ${l("ProcessFinalColor",null,[(e=$("out0"),s.parameterRefV4(e))])};\n                `,n.pdsfxUseFragDepth&&(t=`\n                        ${t}\n                        ${((n=null)=>{var e={name:n};return o.float(e)})("depthValueToUse")} = ${c("fragCoord")}.z;\n                        if (INTERNAL_builtin_FragDepthUsed) {     \n                            depthValueToUse = INTERNAL_builtin_FragDepthValue;            \n                        }                   \n                        ${2===n.WebGLVersion||n.WebGPU?`${$("fragDepth")} = INTERNAL_builtin_FragDepthValue;`:n.extFragDepth?"gl_FragDepthEXT = INTERNAL_builtin_FragDepthValue;":i}\n                    `)),t}}})),define("DS/ShaderBuilders/Commons/PDSFXShaders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/Commons/PDSFX/PDSFXVertexCoreShaders","DS/ShaderBuilders/Commons/PDSFX/PDSFXFragmentCoreShaders","DS/ShaderBuilders/Commons/PDSFX/PDSFXVertexEntryPointsShaders","DS/ShaderBuilders/Commons/PDSFX/PDSFXFragmentEntryPointsShaders","DS/ShaderBuilders/Commons/PDSFX/PDSFXVertexGetterShaders","DS/ShaderBuilders/Commons/PDSFX/PDSFXFragmentGetterShaders","DS/ShaderBuilders/ShaderUtils/AttributeUtils","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a,o,i,s,l,u,m,c){"use strict";const $="",p=m.ParameterUtils,d=(n,e,t)=>m.FunctionHandler.declareFunction(n,e,t),f=(n,e,t)=>m.FunctionHandler.callFunction(n,e,t),h=n=>l.addUniform(n),v=n=>{var e={uniformName:n};return l.getUniform(e)},g=n=>l.addObjectUniform(n),x=n=>{var e={uniformName:n};return l.getObjectUniform(e)},S=n=>l.addGlobalUniform(n),y=n=>{var e={uniformName:n};return l.getGlobalUniform(e)},_=(n,e)=>e.highFrequencyColors?(n=>l.addHighFrequencyUniform(n))(n):h(n),T=n=>u.addVarying(n),D=(n=null,e="")=>{var t={name:n,addressSpace:e};return c.float(t)},C=(n=null)=>D(n,"private"),P=(n=null,e="")=>{var t={name:n,addressSpace:e};return c.vec3(t)},N=(n=null)=>{var e={name:n};return c.vec4(e)},b=(n=null,e="")=>{var t={name:n,addressSpace:e};return c.mat3(t)};var M={PDSFX_halfWidth_pars_vertex_fragment:function(n){return`\n            ${n.PDSFX?`\n                ${h({uniformName:"INTERNAL_uniform_halfWidth",uniformType:"f",locationName:"halfWidth"})} \n\t\t\t    ${C("halfWidth")} ;\n                `:h({uniformName:"halfWidth",uniformType:"f"})}\n            ${d("getHalfWidth","f",[])}{\n                ${D("halfWidthToUse")}  = ${n.PDSFX?"halfWidth":v("halfWidth")};\n\t\t\t\treturn halfWidthToUse;\n\t\t\t}\n            `},PDSFX_halfWidth_backup_fragment_vertex:function(n){return n.wideLine?`\n                INTERNAL_backup_halfWidth = ${v("INTERNAL_uniform_halfWidth")};\n            `:$},PDSFX_halfWidth_fragment_vertex:function(n){return n.wideLine?`\n                halfWidth = ${f("ComputeHalfWidth","f",[])};\n            `:$},PDSFX_halfWidth_fragment_vertex:function(n){return n.wideLine?`\n                halfWidth = ${f("ComputeHalfWidth","f",[])};\n            `:$},PDSFX_Color_pars_fragment:function(n){return`\n            ${_({uniformName:"diffuse",uniformType:"v4"},n)}\n            ${_({uniformName:"opacity",uniformType:"f"},n)}\n            `},PDSFX_Phong_pars_fragment:function(n){return`\n            ${h({uniformName:"emissive",uniformType:"v3"})}\n            ${h({uniformName:"specular",uniformType:"v3"})}\n            `},PDSFX_Color_backup_fragment:function(n){return"\n                INTERNAL_backup_diffuse = diffuseToUse;\n                _DSopacity_ = opacityToUse;\n            "},PDSFX_Color_fragment:function(n){return`\n                diffuseToUse = ${f("ComputeAlbedo","v3",[])};\n                opacityToUse = ${f("ComputeOpacity","f",[])};\n            `},PDSFX_Diffuse_Texel_fragment:function(n){return`\n                ${n.pdsfxUseMap?`\n                    ${N("pdsfxDiffTexel")} = ${f("_ComputeDiffuseTexel","v4",[])};\n                    ${n.gammaInput?`\n                        ${P("convertedPDSFXTexelColor")} = ${f("convertToLinear","v3",[(e="pdsfxDiffTexel.xyz",p.parameterV3(e))])};\n                        pdsfxDiffTexel.x = convertedPDSFXTexelColor.x;\n                        pdsfxDiffTexel.y = convertedPDSFXTexelColor.y;\n                        pdsfxDiffTexel.z = convertedPDSFXTexelColor.z;\n                        `:$}        \n                    texelColor *= pdsfxDiffTexel; \n                    opacityToUse *= pdsfxDiffTexel.a;\n                    ${n.phong?`                   \n                        ${(n=>u.getShaderOutput(n))("out0")} *= pdsfxDiffTexel;\n                        `:"        \n                        diffuseToUse *= pdsfxDiffTexel.rgb;\n                        "}\n                    `:$}             \n                `;var e},PDSFX_Phong_backup_fragment:function(n){return"\n                INTERNAL_backup_emissive = emissiveToUse;\n                INTERNAL_backup_specular = specularToUse;\n            "},PDSFX_Phong_fragment:function(n){return`\n                emissiveToUse = ${f("ComputeEmissive","v3",[])};\n                specularToUse = ${f("ComputeSpecularReflectance","v3",[])};\n            `}},U={PDSFX_common_pars:function(n){const e=f("getModelViewMatrix","m4",[]);var t=$;const r=u._context.__varyings__;for(var a in r){var o=r[a];if(o.pdsfx){var i=a.replace("_IPCV","");t=`\n                        ${t}\n                        ${c.declareVariable({name:i,type:o.type,size:o.size,addressSpace:"private"})};\n                    `}}var s;return t=`\n            ${t}\n            \n            ${T({varyingName:"INTERNAL_varying_viewPosition",varyingType:"v3"})}\n            ${T({varyingName:"INTERNAL_varying_viewNormal",varyingType:"v3"})}\n            ${T({varyingName:"INTERNAL_varying_viewTangent",varyingType:"v3"})}\n            ${T({varyingName:"INTERNAL_varying_viewBinormal",varyingType:"v3"})}\n            ${T({varyingName:"INTERNAL_varying_clipPosition",varyingType:"v4"})}\n            \n            /**** PDSFX Common Getters ****/\n            \n            ${C("INTERNAL_backup_size")} ;\n            ${C("INTERNAL_backup_sizeForGLPointSize")} ;\n            ${C("INTERNAL_backup_scale")} ;\n\n            ${d("vGetWorldViewMatrix","m4",[])}{\n                return ${e};\n            }\n            \n\n            ${g({uniformName:"modelViewInvTranspMatrix",uniformType:"m4"})} \n            ${d("vGetWorldViewInvTranspMatrix","m4",[])}{\n                return ${x("modelViewInvTranspMatrix")};\n            }\n            \n            ${d("vGetViewMatrix","m4",[])}{\n                return ${y("viewMatrix")};\n            }\n            \n            ${d("vGetProjectionMatrix","m4",[])}{\n                return ${y("projectionMatrix")};\n            }\n            \n            ${d("vGetViewProjectionMatrix","m4",[])}{\n                return ${y("projectionMatrix")} * ${y("viewMatrix")};\n            }\n            \n\n            ${S({uniformName:"viewInvMatrix",uniformType:"m4"})} \n            ${d("vGetViewInvMatrix","m4",[])}{\n                return ${y("viewInvMatrix")};\n            }\n            \n\n            ${S({uniformName:"projectionInvMatrix",uniformType:"m4"})} \n            ${d("vGetProjectionInvMatrix","m4",[])}{\n                return ${y("projectionInvMatrix")};\n            }\n            \n\n            ${d("vGetViewProjectionInvMatrix","m4",[])}{\n                return ${y("viewInvMatrix")} * ${y("projectionInvMatrix")};\n            }\n            \n\n            ${S({uniformName:"viewInvTranspMatrix",uniformType:"m4"})} \n            ${d("vGetViewInvTranspMatrix","m4",[])}{\n                return ${y("viewInvTranspMatrix")};\n            }\n            \n\n            ${((n=null)=>b(n,"private"))("INTERNAL_backup_mappingUVTransformation")} ;\n            ${d("vGetTextureMatrix","m4",[])}{\n                ${((n=null)=>{var e={name:n};return c.mat4(e)})("matrix")} ;\n                matrix[0] = vec4(INTERNAL_backup_mappingUVTransformation[0], 0.0);\n                matrix[1] = vec4(INTERNAL_backup_mappingUVTransformation[1], 0.0);\n                matrix[2] = vec4(INTERNAL_backup_mappingUVTransformation[2], 0.0);\n                return matrix;\n            }\n            \n            ${d("vGetWorldEyePos","v3",[])}{\n                return ${y("cameraPosition")};\n            }\n            \n            ${S({uniformName:"lowlightColor",uniformType:"v3"})} \n            ${d("vGetLowlightColor","v3",[])}{\n                return ${y("lowlightColor")};\n            }\n            \n            ${d("vGetDefaultPointSize","f",[])}{\n                return INTERNAL_backup_size;\n            }\n            \n\n            ${S({uniformName:"nearFarLogFactor",uniformType:"v3"})} \n            ${d("vGetNearFarLogFactor","v3",[])}{\n                return ${y("nearFarLogFactor")};\n            }\n            \n            \n            ${S({uniformName:"viewportSize",uniformType:"v2"})} \n            ${d("vGetViewportSize","i2",[])}{\n                return ${((n=null,e="")=>{var t={name:n,addressSpace:e};return c.ivec2(t)})()}(${y("viewportSize")});\n            }\n            \n            ${d("vGet3x3WorldMatrix","m3",[])}{\n                //return ${b()}(modelMatrix); unsupported conversion from mat4 to mat3 in webgpu\n                ${b("matrix")} ;\n                matrix[0] = modelMatrix[0].xyz;\n                matrix[1] = modelMatrix[1].xyz;\n                matrix[2] = modelMatrix[2].xyz;\n                return matrix;\n            }\n            \n            \n            ${g({uniformName:"modelInvTranspMatrix",uniformType:"m4"})} \n            ${d("vGet3x3WorldInvTranspMatrix","m3",[])}{\n                //return ${b()}(${x("modelInvTranspMatrix")}); unsupported conversion from mat4 to mat3 in webgpu\n                \n                ${b("matrix")} ;\n                matrix[0] = ${x("modelInvTranspMatrix")}[0].xyz;\n                matrix[1] = ${x("modelInvTranspMatrix")}[1].xyz;\n                matrix[2] = ${x("modelInvTranspMatrix")}[2].xyz;\n                return matrix;\n            }\n\n            ${d("vComputeWorldScaling","v3",[])}{              \n                ${b("matrix")} ;\n                matrix[0] = ${x("modelInvTranspMatrix")}[0].xyz;\n                matrix[1] = ${x("modelInvTranspMatrix")}[1].xyz;\n                matrix[2] = ${x("modelInvTranspMatrix")}[2].xyz;\n                return ${P()}(length(matrix[0]),length(matrix[1]),length(matrix[2]));\n            }\n\n            // Some texture needs to be sampled here? Maybe de-packaged also?\n            // NRE is using texelFetch so for WebGL we will need to normalize the input between 0 and 1\n            // WebGPU can use textureLoad\n            ${n.usePDSFXInstancingData?`\n                ${g({uniformName:"_instancingData",uniformType:"t2"})} \n                ${g({uniformName:"_instancingDataSize",uniformType:"v2"})} \n                `:$}\n            ${d("vGetInstanceData","v4",[(s="index",p.parameterI(s))])}{              \n                return ${N()}(0.0, 0.0, 0.0, 0.0);\n            }\n            \n            `}};return Object.assign(U,M),Object.assign(U,e),Object.assign(U,o),Object.assign(U,r),Object.assign(U,t),Object.assign(U,i),Object.assign(U,a.PDSFXFragmentEntryPointsShaders),U})),define("DS/ShaderBuilders/PBRUtils/PBRFragmentUniformsShaderBuilderUtils",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PBRUtils/PBRShaderBuilderUtils","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils","DS/ShaderBuilders/Commons/DefaultShaders"],(function(n,e,t,r,a,o,i){"use strict";const s="",l=a.ParameterUtils,u=a.FunctionHandler,m=a.BridgeFunctions,c=n=>o.dereference(n),$=(n,e)=>l.parameter(n,e),p=(n,e)=>l.parameterInOut(n,e),d=(n,e)=>l.parameterRef(n,e),f=(n,e)=>l.parameterRefPrivateStruct(n,e),h=n=>l.parameterF(n),v=n=>l.parameterInOutF(n),g=n=>l.parameterRefF(n),x=n=>l.parameterI(n),S=n=>l.parameterV2(n),y=n=>l.parameterInOutV2(n),_=n=>l.parameterRefV2(n),T=n=>l.parameterV3(n),D=n=>l.parameterInOutV3(n),C=n=>l.parameterRefV3(n),P=n=>l.parameterV4(n),N=(n,e,t)=>u.declareFunction(n,e,t),b=(n,e,t)=>u.callFunction(n,e,t),M=n=>r.getVarying(n,r.ShaderStages.in),U=n=>r.getShaderOutput(n),w=n=>t.addUniform(n),V=n=>{var e={uniformName:n};return t.getUniform(e)},z=n=>{var e={uniformName:n};return t.getTextureUniform(e)},F=n=>{var e={uniformName:n};return t.getGlobalUniform(e)},I=(n,e)=>e.highFrequencyColors?(n=>t.addHighFrequencyUniform(n))(n):w(n),R=(n,e)=>e.highFrequencyColors?(n=>{var e={uniformName:n};return t.getHighFrequencyUniform(e)})(n):V(n),A=(n=null)=>{var e={name:n};return o.bool(e)},L=(n=null)=>{var e={name:n};return o.int(e)},B=(n=null)=>{var e={name:n};return o.float(e)},E=(n=null)=>{var e={name:n,addressSpace:"private"};return o.float(e)},k=(n=null,e=0,t="")=>{var r={name:n,size:e,addressSpace:t};return o.vec2(r)},O=(n=null,e=0)=>{var t={name:n,size:e};return o.vec3(t)},G=(n=null,e=0)=>{var t={name:n,size:e};return o.vec4(t)},H=(n=null)=>{var e={name:n};return o.mat3(e)},X=n=>{var e={name:n,constant:!0};return o.int(e)},W=n=>{var e={name:n,constant:!0};return o.float(e)},j=n=>{var e={name:n,constant:!0};return o.vec4(e)},q=n=>`max(${n}, 0.0)`,Z=n=>b("saturate","f",[h(n)]),Y=n=>b("vMax","f",[T(n)]),J=n=>b("vMax","f",[P(n)]),K=n=>b("vMin","f",[P(n)]),Q=n=>b("pow2","f",[h(n)]),nn=n=>b("pow3","f",[h(n)]),en=n=>b("pow5","f",[h(n)]),tn=n=>b("pow6","f",[h(n)]),rn=n=>b("vNormalize","v3",[T(n)]),an=(n,e,t)=>b("affine","f",[h(n),h(e),h(t)]),on=(n,e,t,r,a)=>b("arrayFBMMixer","f",[T(n),h(e),h(t),h(r),h(a)]),sn=(n,e)=>m.sample2DTexture(n,e),ln=n.TextureBlendOperations;let un,mn,cn,$n,pn,dn,fn,hn,vn,gn,xn,Sn,yn,_n,Tn;{let n=function(n){return`\n\n            ${I({uniformName:"diffuse",uniformType:"v4"},n)}   \n            ${n.map?`\n                ${w({uniformName:"map",uniformType:"t2"})}   \n                ${w({uniformName:"diffuseUvTransform",uniformType:"m3"})}\n                ${n.diffuseBorderColorU||n.diffuseBorderColorV?w({uniformName:"diffuseBorderColor",uniformType:"v4"}):s}\n                `:s}\n            ${n.diffuseMulCoef&&n.diffuseAddCoef?`${e.addVec3MADs("diffuse")}`:s}\n        `};un=function(t){const r=e.addColorPDSFX("INTERNAL_backup_diffuse","albedo","ComputeAlbedo",t.dspbr&&t.gammaInput,t);let a=`\n\n                ${O("albedo")} = ${R("diffuse",t)}.rgb;\n                ${t.vertexColors&&!t.objectVertexColors?`albedo *= ${M("vVertexColor")}.rgb;`:s}\n                ${t.map?`\n                    ${e.textureSlotString("diffuse","diffuseUV",t)}\n                    ${t.visuBasicForceDiffuseUV?"diffuseUV = VisuBasic_diffuseTexUvToUse;":s}\n                    ${G("texelAlbedo")} = ${sn(z("map"),"diffuseUV")};\n                    ${e.addBorderColorGeneric("texelAlbedo","diffuseUV",t.diffuseBorderColorU,t.diffuseBorderColorV,"diffuseBorderColor")}\n                    ${t.gammaInput&&!t.mapHDR?`texelAlbedo = ${G()}(${b("convertToLinear","v3",[T("texelAlbedo.rgb")])}, texelAlbedo.a);`:s}\n                    ${t.textureBlending>=0?`              \n                        ${(()=>{switch(t.textureBlending){case ln.BLEND:return"albedo = mix(albedo, texelAlbedo.rgb, texelAlbedo.w);";case ln.MODULATE:return"albedo *= texelAlbedo.rgb;";case ln.DECAL:return`albedo = mix(albedo, ${O()}(1.0), texelAlbedo.rgb);`;case ln.IGNORE:return s;case ln.REPLACE:default:return"albedo = texelAlbedo.rgb;"}})()}\n                        `:"albedo = texelAlbedo.rgb;"}\n                    `:s}\n                ${t.diffuseMulCoef&&t.diffuseAddCoef?`\n                    albedo = albedo * ${V("diffuseMulCoef")} + ${V("diffuseAddCoef")};\n                    albedo = ${o="albedo",b("saturate","v3",[T(o)])};\n                    `:s}\n                ${t.objectVertexColors?`albedo = ${M("vVertexColor")}.rgb;`:s}\n                if(${R("diffuse",t)}.w > 0.5) {\n                    albedo = ${R("diffuse",t)}.rgb;\n                }\n                ${r.backup}\n            `;var o;let i=`\n               \n                ${r.solve}\n\n                ${t.reflectivityEnvMap?`\n                    ${O("cameraToVertexLegacy")} ;\n                    if (${F("projectionMatrix")}[3][3] > 0.5) {\n                        cameraToVertexLegacy = normalize( ( ${G()}( 0.0,0.0,-1.0, 0.0 ) * ${F("viewMatrix")} ).xyz );\n                    } else {\t\n                        cameraToVertexLegacy = normalize( ( ${G()}( -surfaceData.viewPosition, 0.0 ) * ${F("viewMatrix")} ).xyz);\n                    }\n                    ${O("reflectVecLegacy")}  = reflect( cameraToVertexLegacy, surfaceData.worldNormal );\n                    albedo = ${b("sampleReflectivityEnvMap","v3",[T("reflectVecLegacy.yzx"),T("albedo")])};\n                    `:s}\n            `;return[n(t),i,a]}}{let n=function(n){return`\n            ${n.normalMap?`\n                ${w({uniformName:"normalMap",uniformType:"t2"})}  \n                ${w({uniformName:"normalUvTransform",uniformType:"m3"})}  \n                ${n.specgloss?`\n                    ${w({uniformName:"normalScale",uniformType:"v2"})}  \n                    ${n.normalScaleMap?`     \n                        ${w({uniformName:"normalScaleMap",uniformType:"t2"})}  \n                        ${w({uniformName:"normalScaleUvTransform",uniformType:"m3"})}  \n                        `:s}             \n                    ${n.normalScaleMulCoef&&n.normalScaleAddCoef?`${e.addFloatMADs("normalScale")}`:s}    \n                    `:`                   \n                    ${n.normalMulCoef&&n.normalAddCoef?`${e.addVec3MADs("normal")}`:s}\n                    `}\n                ${N("perturbNormal3Arb","v3",[T("surf_norm"),T("surf_tgt"),T("surf_binorm"),S("normalUV"),S("scale")])}{\n\n                    ${O("N")} = normalize(surf_norm);\n                    ${O("T")} = normalize(surf_tgt);\n                    T = normalize(T - dot(T, N) * N);\n                    ${O("B")} = normalize(surf_binorm);\n\n                    ${O("mapN")}  = ${sn(z("normalMap"),"normalUV")}.xyz * 2.0 - 1.0;\n\n                    ${n.specgloss?`\n                        mapN = ${O()}(scale * mapN.xy, mapN.z);\n                        ${n.normalMapFlipY?"mapN.y = - mapN.y;":s}\n                        `:`\n                        ${n.normalMulCoef&&n.normalAddCoef?`mapN = mapN * ${V("normalMulCoef")} + ${V("normalAddCoef")};`:s}\n                        mapN.z = abs(mapN.z);\n                        `}\n\n                    ${H("tbn")} = ${H()}(T, B, N);\n                    return normalize(tbn * mapN);\n\n                }\n                `:s}\n\n            ${n.specgloss&&n.bumpMap?`\n                ${w({uniformName:"bumpMap",uniformType:"t2"})}  \n                ${w({uniformName:"bumpUvTransform",uniformType:"m3"})}  \n                ${w({uniformName:"bumpScale",uniformType:"f"})}  \n                ${n.bumpScaleMap?`    \n                    ${w({uniformName:"bumpScaleMap",uniformType:"t2"})}  \n                    ${w({uniformName:"bumpScaleUvTransform",uniformType:"m3"})}  \n                    `:s}\n                ${n.bumpScaleMulCoef&&n.bumpScaleAddCoef?`${e.addFloatMADs("bumpScale")}`:s}\n                \n                ${N("dHdxy_fwd","v2",[S("bumpMapUv"),h("scale")])}{\n\n                    ${k("dSTdx")} = ${m.dpdx("bumpMapUv")};\n                    ${k("dSTdy")} = ${m.dpdy("bumpMapUv")};\n\n                    ${B("Hll")} = scale * ${sn(z("bumpMap"),"bumpMapUv")}.x;\n                    ${B("dBx")} = scale * ${sn(z("bumpMap"),"bumpMapUv + dSTdx")}.x - Hll;\n                    ${B("dBy")} = scale * ${sn(z("bumpMap"),"bumpMapUv + dSTdy")}.x - Hll;\n\n                    return ${k()}( dBx, dBy );\n\n                }\n                ${N("perturbNormalArb","v3",[T("surf_pos"),T("surf_norm"),S("dHdxy")])}{\n\n                    ${O("vSigmaX")}  = ${m.dpdx("surf_pos")};\n                    ${O("vSigmaY")}  = ${m.dpdy("surf_pos")};\n                    ${O("vN")}  = surf_norm;\n\n                    ${O("R1")}  = cross( vSigmaY, vN );\n                    ${O("R2")}  = cross( vN, vSigmaX );\n\n                    ${B("fDet")}  = dot( vSigmaX, R1 );\n\n                    ${O("vGrad")}  = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n                    return normalize( abs( fDet ) * surf_norm - vGrad );\n\n                }\n                `:s}\n        `},t=function(n,t){return`     \n            ${O("viewNormal")};\n            ${n.PDSFX?"viewNormal = INTERNAL_computed_viewNormal;":` \n                viewNormal = normalize( ${M("vNormal")} );\n                ${n.isDecal?"viewNormal = decalNormal;":s}\n                `}\n\n            ${i.planar_normal_fragment(n,"viewNormal")}\n\n            viewNormal = viewNormal * ( -1.0 + 2.0 * ${B()}( ${a="frontFacing",r.getBuiltin(a,r.ShaderStages.in)} ) );\n\n            surfaceData.viewNormal = viewNormal;\n\n            ${n.normalMap?`\n                ${e.textureSlotString("normal","normalUv",n)}\n                ${n.specgloss?`\n                    ${n.normalScaleMap?`\n                        ${e.textureSlotString("normalScale","normalScaleUv",n)}\n                        ${k("scale")}  = ${k()}(${sn(z("normalScaleMap"),"normalScaleUv")}.r);\n                        `:`${k("scale")} = ${V("normalScale")};`}\n                    ${n.normalScaleAddCoef&&n.normalScaleMulCoef?`scale = ${V("normalScaleMulCoef")} * scale + ${V("normalScaleAddCoef")};`:s}\n                    `:`${k("scale")} = ${k()}(1.0);`}\n                surfaceData.viewNormal = ${b("perturbNormal3Arb","v3",[T("viewNormal"),T("tangent"),T("binormal"),S("normalUv"),S("scale")])};\n                `:`\n                ${n.specgloss&&n.bumpMap?`      \n                    ${e.textureSlotString("bump","bumpUv",n)}   \n                    ${n.bumpScaleMap?`\n                        ${e.textureSlotString("bumpScale","bumpScaleUv",n)} \n                        ${B("scale")} = ${sn(z("bumpScaleMap"),"bumpScaleUv")}.r;\n                        `:`${B("scale")} = ${V("bumpScale")};`}\n                    ${n.bumpScaleAddCoef&&n.bumpScaleMulCoef?`scale = ${V("bumpScaleMulCoef")} * scale + ${V("bumpScaleAddCoef")};`:s}\n                    ${k("bumpDHD")}  = ${b("dHdxy_fwd","v2",[S("bumpUv"),h("scale")])};\n                    surfaceData.viewNormal = ${b("perturbNormalArb","v3",[T("-surfaceData.viewPosition"),T("viewNormal"),S("bumpDHD")])};\n                    `:s}\n                `}\n\n            ${t&&(n.envMap||n.useIBLColor||n.reflectivityEnvMap||n.specGlossFlakes)||n.thickness||n.subsurface?`             \n                surfaceData.worldNormal = normalize( ${O()}( (${G()}( surfaceData.viewNormal, 0.0 ) * ${F("viewMatrix")}).xyz ) );\n                `:s}\n            ${O("normal")} = surfaceData.viewNormal;\n            ${B("NoV")} = ${q("dot(surfaceData.viewNormal, surfaceData.view)")};\n        `;var a};mn=function(e,r){return[n(e),t(e,r)]}}{let n=function(n){return`         \n            ${e.addTexturableVec3Uniform("emissionColor",n.emissionColorMap)}\n            ${n.emissionColorMulCoef&&n.emissionColorAddCoef?`${e.addVec3MADs("emissionColor")}`:s}\n            ${w({uniformName:"emissionValue",uniformType:"f"})}\n        `},t=function(n,t){return`\n            ${e.addColorParameterResolution("materialData.emissionColor","emissionColor",n.emissionColorMap,n.emissionColorMulCoef&&n.emissionColorAddCoef,n.gammaInput&&!n.emissionColorMapLinear,!1,n)} \n            ${t.backup}\n            materialData.emissionValue = ${V("emissionValue")};\n        `},r=function(n,e){return`\n            ${e.solve}\n        `};cn=function(a){if(!a.useEmission)return[s,s,s];const o=e.addColorPDSFX("INTERNAL_backup_emissive","materialData.emissionColor","ComputeEmissive",a.dspbr&&a.gammaInput,a);return[n(a),r(a,o),t(a,o)]}}{let n=function(n){return n.useTransparency?`\n            ${e.addTexturableFloatUniform("transparency",n.transparencyMap)}\n            ${n.transparencyAddCoef&&n.transparencyMulCoef?`${e.addFloatMADs("transparency")}`:s}\n            ${n.dspbr?`\n                ${N("adjustTransparency","f",[h("transparencyValue"),T("albedo"),h("roughness")])} {\n                    ${B("adjust")}  = sqrt(dot(albedo, luminanceVector));\n                    adjust *= exp(-0.125 * roughness * roughness);\n                    return transparencyValue * adjust;\n                }\n                `:s}\n            \n            //pix: ptr<function, FragmentOutput>\n\t\t\t${N("ApplyTransparency","f",[v("outputAlpha"),v("transparencyValue"),h("metalnessValue"),T("albedo"),h("NoV")])}{\n                ${n.sslrefraction?`\n                    ${n.useLighting?s:`${c("transparencyValue")} = 0.0;`}\n                    return 1.0;\n                    `:`\n                    ${O("Ft")}  = ${b("FresnelSchlick","v3",[T("materialData.sr0Color"),T("materialData.sr90Color"),h("NoV")])};\n                    ${n.specgloss?s:`${c("transparencyValue")} = ${b("adjustTransparency","f",[h(`${c("transparencyValue")}`),T("albedo"),h("materialData.roughness")])};`}\n                    ${B("transToDivide")} = max(1.0 - (1.0 - metalnessValue) * ${c("transparencyValue")} * (1.0 - 0.3333*(Ft.x + Ft.y + Ft.z)), 1e-6);\n                    //${U("out0")}.a *= transToDivide;\n                    ${c("outputAlpha")} *= transToDivide;\n                    ${n.skipTranspar?`if ( ${c("outputAlpha")} < 1.0 - 1e-3 ) { discard; }`:s}\n                    return transToDivide;\n                    `}\n            }\n            `:s},t=function(n,t){return n.useTransparency?`\n            ${e.addFloatParameterResolution("transparencyValue","transparency",n.transparencyMap,n.transparencyAddCoef&&n.transparencyMulCoef,!0,n)}\n            ${t.backup}\n        `:s},r=function(n,e){return n.useTransparency?`\n            ${e.solve}\n            ${B("outputAlpha")} = ${U("out0")}.a;\n \t\t\t${B("transToDivide")} = ${b("ApplyTransparency","f",[g("outputAlpha"),g("transparencyValue"),h("materialData.metalness"),T(n.subsurface?"materialData.scatteringColor * albedo":"albedo"),h("NoV")])};\n            ${U("out0")}.a = outputAlpha;\n            materialData.transparency = transparencyValue;\n        `:"materialData.transparency = 0.0;"};$n=function(a){const o=e.addPDSFX("INTERNAL_backup_transparency","transparencyValue","ComputeTransparency",a);return[n(a),r(a,o),t(a,o)]}}{let t=function(n){return`    \n            ${e.addTexturableFloatHighFrequencyUniform("opacity",n.opacityMap,n)}\n            ${n.opacityBorderColorU||n.opacityBorderColorV?w({uniformName:"opacityBorderValue",uniformType:"f"}):s}\n            ${n.opacityMulCoef&&n.opacityAddCoef?`${e.addFloatMADs("opacity")}`:s}    \n        `};pn=function(r){const a=e.addPDSFX("_DSopacity_","opacityValue","ComputeOpacity",r);let o=`\n            \n\n                ${r.opacityMap?`\n                    ${e.textureSlotString("opacity","opacityUV",r)}\t\t\n                    ${B("opacityValue")} = ${sn("opacityMap","opacityUV")}.r;\n                    ${e.addBorderColorGeneric("opacityValue","opacityUV",r.opacityBorderColorU,r.opacityBorderColorV,"opacityBorderValue")}\n                    `:`    \n                    ${B("opacityValue")} = ${R("opacity",r)};\n                    ${r.selectionMaterial?"opacityValue = 1.0;":s}                \n                    ${r.vertexColors?`opacityValue *= ${M("vVertexColor")}.a;`:s}\n                    `}      \n                ${r.map&&r.textureBlending===ln.REPLACE&&1021===r.textureFormat?"opacityValue = texelAlbedo.a;":`\n                    ${r.map&&(r.textureBlending===ln.BLEND||r.textureBlending===ln.MODULATE||r.useAlphaFromDiffuseMap)?"opacityValue *= texelAlbedo.a;":s}\n                    `}\n                \n                ${r.opacityMulCoef&&r.opacityAddCoef?`\n                    opacityValue = ${V("opacityMulCoef")} * opacityValue + ${V("opacityAddCoef")};\n                    opacityValue = ${Z("opacityValue")};\n                    `:s}    \n                ${a.backup}\n            `,i=`\n                ${a.solve}\n                ${U("out0")}.a = opacityValue;\n                ${n._ShaderChunk.alphatest_fragment(r)}\n            `;return[t(r),i,o]}}{let n=function(n){return`\n            ${e.addTexturableFloatUniform("specularContrib",n.specularContribMap)}\n            ${n.specularContribAddCoef&&n.specularContribMulCoef?`${e.addFloatMADs("specularContrib")}`:s}\n            ${e.addTexturableVec3Uniform("specular",n.specularMap)}\n            ${n.specularAddCoef&&n.specularMulCoef?`${e.addVec3MADs("specular")}`:s}\n        `};dn=function(t){const r=e.addPDSFX("INTERNAL_backup_specularContribution","materialData.specularContribution","ComputeSpecular",t),a=e.addColorPDSFX("INTERNAL_backup_specular","materialData.specularTint","ComputeSpecularReflectance",t.dspbr&&t.gammaInput,t);let o=`\n                ${e.addFloatParameterResolution("materialData.specularContribution","specularContrib",t.specularContribMap,t.specularContribMulCoef&&t.specularContribAddCoef,!1,t,"r","a")}\n                ${r.backup}\n                ${e.addColorParameterResolution("materialData.specularTint","specular",t.specularMap,t.specularAddCoef&&t.specularMulCoef,t.gammaInput&&!t.specularMapLinear,!1,t,!!t.noSaturatedSpecularTint)}\n                ${a.backup}\n            `,i=`\n                ${r.solve}\n                ${a.solve}\n            `;return[n(t),i,o]}}{let n=function(n){return`\n            ${n.roughnessMap?w({uniformName:"roughnessMap",uniformType:"t2"}):w({uniformName:"roughness",uniformType:"f"})}\n            ${n.glossinessMap?w({uniformName:"glossinessMap",uniformType:"t2"}):s}\n            ${n.glossinessMap||n.roughnessMap?`\n                ${w({uniformName:"roughnessUvTransform",uniformType:"m3"})}\n                `:s}\n\n            ${n.roughnessMulCoef&&n.roughnessAddCoef?`\n                ${e.addFloatMADs("roughness")}\n                `:s}\n            ${n.glossinessMulCoef&&n.glossinessAddCoef?`\n                ${e.addFloatMADs("glossiness")}\n                `:s}\n            ${e.addTexturableFloatUniform("metalness",n.metalnessMap)}\n            ${n.metalnessMulCoef&&n.metalnessAddCoef?`\n                ${e.addFloatMADs("metalness")}\n                `:s}       \n        `};fn=function(t){const r=e.addPDSFX("INTERNAL_backup_roughness","materialData.roughness","ComputeRoughness",t),a=e.addPDSFX("INTERNAL_backup_metalness","materialData.metalness","ComputeMetallic",t);let o=`\n            \n                ${e.addFloatParameterResolution("materialData.roughness","roughness",t.roughnessMap,t.roughnessMulCoef&&t.roughnessAddCoef,!1,t,"r","g","a")}\n                ${t.glossinessMap?`\n                    ${e.textureSlotString("roughness","glossinessUV",t)}\n                    ${B("glossinessTex")}  = ${sn(z("glossinessMap"),"glossinessUV")}.r;\n                    materialData.roughness = 1.0-glossinessTex;\n                    `:s}\n                ${t.glossinessMulCoef&&t.glossinessAddCoef?`\n                    materialData.roughness = ${V("glossinessMulCoef")} * (1.0 - materialData.roughness) + ${V("glossinessAddCoef")};\n                    materialData.roughness = 1.0 - ${Z("materialData.roughness")};\n                    `:s}\n                ${r.backup}\n\n                ${e.addFloatParameterResolution("materialData.metalness","metalness",t.metalnessMap,t.metalnessMulCoef&&t.metalnessAddCoef,!1,t,"r","b")}\n                ${a.backup}\n            `,i=`\n                ${r.solve}\n                materialData.roughness = clamp(materialData.roughness, ROUGHNESS_CLAMP_MIN, ROUGHNESS_CLAMP_MAX);\n                \n                ${a.solve}\n            `;return[n(t),i,o]}}{let n=function(n){return`\n            ${e.addTexturableFloatUniform("anisotropy",n.anisotropyMap)}\n            ${n.anisotropyAddCoef&&n.anisotropyMulCoef?`\n                ${e.addFloatMADs("anisotropy")}\n                `:s}\n            ${e.addTexturableFloatUniform("anisotropyAngle",n.anisotropyAngleMap)}\n            ${n.anisotropyAngleAddCoef&&n.anisotropyAngleMulCoef?`\n                ${e.addFloatMADs("anisotropyAngle")}\n                `:s}\n        `};hn=function(t){if(!t.anisotropy)return[s,s,s];const r=e.addPDSFX("INTERNAL_backup_anisotropy","materialData.anisotropy","ComputeAnisotropy",t),a=e.addPDSFX("INTERNAL_backup_anisotropyAngle","materialData.anisotropyAngle","ComputeAnisotropyRotation",t);let o=`\n                ${e.addFloatParameterResolution("materialData.anisotropy","anisotropy",t.anisotropyMap,t.anisotropyMulCoef&&t.anisotropyAddCoef,!1,t)}\n                ${r.backup}\n\n                ${e.addFloatParameterResolution("materialData.anisotropyAngle","anisotropyAngle",t.anisotropyAngleMap,t.anisotropyAngleMulCoef&&t.anisotropyAngleAddCoef,!1,t)}\n                ${a.backup}\n            `,i=`\n                ${r.solve}\n                materialData.anisotropy = min(materialData.anisotropy, 0.975);\n\n                ${a.solve}\n\n                surfaceData.binormal = binormal;\n                surfaceData.tangent = tangent;\t\n            `;return[n(t),i,o]}}{let n=function(n){return`\n            ${n.dspbrWithNoSheenValue?s:`\n                ${e.addTexturableFloatUniform("sheen",n.sheenMap)}\n                ${n.sheenMulCoef&&n.sheenAddCoef?`\n                    ${e.addFloatMADs("sheen")}\n                    `:s}\n                `}\n            ${n.dspbrWithSheenColorRoughness?`\n                ${e.addTexturableFloatUniform("sheenRoughness",n.sheenRoughnessMap)}\n                ${n.sheenRoughnessMulCoef&&n.sheenRoughnessAddCoef?`\n                    ${e.addFloatMADs("sheenRoughness")}\n                    `:s}\n                ${e.addTexturableVec3Uniform("sheenColor",n.sheenColorMap)}\n                ${n.sheenColorMulCoef&&n.sheenColorAddCoef?`\n                    ${e.addVec3MADs("sheenColor")}\n                    `:s}\n                `:s}\n        `};vn=function(t){if(!t.sheen)return[s,s,s];const r=e.addPDSFX("INTERNAL_backup_sheen","materialData.sheen","ComputeSheen",t),a=e.addPDSFX("INTERNAL_backup_sheenRoughness","materialData.sheenRoughness","ComputeSheenRoughness",t),o=e.addColorPDSFX("INTERNAL_backup_sheenColor","materialData.sheenColor","ComputeSheenColor",t.dspbr&&t.gammaInput,t);let i=`\n                ${t.dspbrWithNoSheenValue?"materialData.sheen = 1.0;":`\n                    ${e.addFloatParameterResolution("materialData.sheen","sheen",t.sheenMap,t.sheenAddCoef&&t.sheenMulCoef,!1,t)}\n                    ${r.backup}\n                    `}\n                ${t.dspbrWithSheenColorRoughness?`\n                    ${e.addFloatParameterResolution("materialData.sheenRoughness","sheenRoughness",t.sheenRoughnessMap,t.sheenRoughnessMulCoef&&t.sheenRoughnessAddCoef,!1,t,"r","a")}\n                    ${a.backup}\n                    ${e.addColorParameterResolution("materialData.sheenColor","sheenColor",t.sheenColorMap,t.sheenColorMulCoef&&t.sheenColorAddCoef,t.gammaInput&&!t.sheenColorMapLinear,!1,t)} \n                    ${o.backup}\n                    `:s}\n            `,l=`     \n                ${t.dspbrWithNoSheenValue?s:`\n                    ${r.solve}\n                    `}\n                ${t.dspbrWithSheenColorRoughness?`\n                    ${a.solve}\n                    materialData.sheenRoughness = clamp(materialData.sheenRoughness, ROUGHNESS_CLAMP_MIN, ROUGHNESS_CLAMP_MAX);\n                    ${t.useSoftVelvet&&!t.dspbrWithSquaredEstevezKullaRoughness?"materialData.sheenRoughness = max(materialData.sheenRoughness, 0.07);":s}\n                    ${o.solve}\n                    materialData.sheenEnergyConservationConstant = materialData.sheen * ${Y("materialData.sheenColor")} * ${b("DirectionalSheenAlbedo","f",[h("NoV"),h("materialData.sheenRoughness")])};        \n                    `:s}\n            `;return[n(t),l,i]}}{let n=function(n){return`\n            ${n.dspbrWithTranslucency?`\n                ${e.addTexturableFloatUniform("translucency",n.translucencyMap)}\n                ${n.translucencyAddCoef&&n.translucencyMulCoef?`\n                    ${e.addFloatMADs("translucency")}\n                    `:s}\n                `:s}\n            ${n.dspbrWithTranslucencyColor?`\n                ${e.addTexturableVec3Uniform("translucencyColor",n.translucencyColorMap)}\n                ${w({uniformName:"useTranslucencyColorFromAlbedo",uniformType:"i"})}\n                ${n.translucencyColorMulCoef&&n.translucencyColorAddCoef?`\n                    ${e.addVec3MADs("translucencyColor")}\n                    `:s}\n                `:s}\n        `},t=function(n,t,r){return`    \n                ${n.dspbrWithTranslucency?`\n                    ${e.addFloatParameterResolution("materialData.translucency","translucency",n.translucencyMap,n.translucencyMulCoef&&n.translucencyAddCoef,!1,n)}\n                    ${t.backup}\n                    `:s}\n                ${n.dspbrWithTranslucencyColor?`\n                    if (${V("useTranslucencyColorFromAlbedo")} > 0)  {\n                        materialData.translucencyColor = albedo;\n                    } else {\n                    \t${e.addColorParameterResolution("materialData.translucencyColor","translucencyColor",n.translucencyColorMap,n.translucencyColorMulCoef&&n.translucencyColorAddCoef,n.gammaInput&&!n.translucencyColorMapLinear,!1,n)}\n                    }\n                    ${r.backup}\n                    `:s}\n            `},r=function(n,e,t){return`    \n            ${n.dspbrWithTranslucency?`\n                ${e.solve}\n                `:s}\n            ${n.dspbrWithTranslucencyColor?`\n                ${t.solve}\n                `:s}\n        `},a=function(n){return`              \n            ${n.sssLUT?`\n                ${w({uniformName:"maxTranslucencyDepth",uniformType:"v3"})}\n                ${w({uniformName:"sssLUT",uniformType:"t2"})}\n\n                ${E("maxSSSRadiusR")};\n                ${E("minSSSRadiusR")};\n\n                ${E("maxSSSRadiusG")};\n                ${E("minSSSRadiusG")};\n\n                ${E("maxSSSRadiusB")};\n                ${E("minSSSRadiusB")};\n\n                ${W("E_64_OVER_74")}  = 0.86486486486;\n                ${W("E_66_OVER_74")}  = 0.89189189189;\n                ${W("E_69_OVER_74")}  = 0.93243243243;\n                ${W("E_71_OVER_74")}  = 0.95945945945;\n                ${W("E_74_OVER_74")}  = 1.0;\n                \n                ${W("SINGLE_LINE_SAMPLING_LINEAR")}  = 0.5;\n                \n                ${j("SSSLUT")}  = ${G()}(1.0,E_64_OVER_74, 0.0, 0.0);\n                ${j("SSSIBLLUT")}  = ${G()}(1.0,E_69_OVER_74 - E_66_OVER_74, 0.0, E_66_OVER_74);\n                ${j("SSSTranslucencyLUT")}  = ${G()}(1.0,E_74_OVER_74 - E_71_OVER_74, 0.0, E_71_OVER_74);\n\n                ${N("sampleSSSLUTGeneric","v3",[S("coord"),P("factor")])} {\n                    return ${sn(z("sssLUT"),"factor.xy * coord + factor.zw")}.xyz;\n                }\n            \n                ${N("sampleSSSLUT","v3",[S("coord")])} {\n                    return ${b("sampleSSSLUTGeneric","v3",[S("coord"),P("SSSLUT")])};\n                }\n\n                ${N("sampleSSSIBLLUT","v3",[S("coord")])} {\n                    return ${b("sampleSSSLUTGeneric","v3",[S("coord"),P("SSSIBLLUT")])};\n                }\n            \n                ${N("sampleSSSTranslucencyLUT","v3",[S("coord")])} {\n                    return ${b("sampleSSSLUTGeneric","v3",[S("coord"),P("SSSTranslucencyLUT")])};\n                }\n                `:w({uniformName:"absorptionCoefficients",uniformType:"v3"})}\n\n            ${n.useTransmittance?`\n                ${N("_clipToEyePers","f",[h("iNearPlane"),h("iFarPlane"),h("iZClipSpace")])} {\n                    return (2.0 * iNearPlane * iFarPlane) / (iFarPlane + iNearPlane - iZClipSpace * (iFarPlane - iNearPlane));\n                }\n\n                ${N("_clipToEyeOrtho","f",[h("iNearPlane"),h("iFarPlane"),h("iZClipSpace")])} {\n                    return 0.5 * ((iFarPlane - iNearPlane) * iZClipSpace + iFarPlane + iNearPlane);\n                }\n            \n                ${N("clipToEye","f",[h("z"),S("lightInfo"),$("b","ortho")])} {\n                    if (ortho) {\n                        return ${b("_clipToEyeOrtho","f",[h("lightInfo.x"),h("lightInfo.y"),h("z")])};\n                    }\n                    return ${b("_clipToEyePers","f",[h("lightInfo.x"),h("lightInfo.y"),h("z")])};\n                }\n\n                ${X("TRANS_SAMPLE")} = 25;\n\n                ${k("poisson25",25,"private")};\n\n                ${N("initDisk",null,[])} {\n                    poisson25[0] = ${k()}(-0.978698, -0.0884121);\n                    poisson25[1] = ${k()}(-0.841121, 0.521165);\n                    poisson25[2] = ${k()}(-0.71746, -0.50322);\n                    poisson25[3] = ${k()}(-0.702933, 0.903134);\n                    poisson25[4] = ${k()}(-0.663198, 0.15482);\n                    poisson25[5] = ${k()}(-0.495102, -0.232887);\n                    poisson25[6] = ${k()}(-0.364238, -0.961791);\n                    poisson25[7] = ${k()}(-0.345866, -0.564379);\n                    poisson25[8] = ${k()}(-0.325663, 0.64037);\n                    poisson25[9] = ${k()}(-0.182714, 0.321329);\n                    poisson25[10] = ${k()}(-0.142613, -0.0227363);\n                    poisson25[11] = ${k()}(-0.0564287, -0.36729);\n                    poisson25[12] = ${k()}(-0.0185858, 0.918882);\n                    poisson25[13] = ${k()}(0.0381787, -0.728996);\n                    poisson25[14] = ${k()}(0.16599, 0.093112);\n                    poisson25[15] = ${k()}(0.253639, 0.719535);\n                    poisson25[16] = ${k()}(0.369549, -0.655019);\n                    poisson25[17] = ${k()}(0.423627, 0.429975);\n                    poisson25[18] = ${k()}(0.530747, -0.364971);\n                    poisson25[19] = ${k()}(0.566027, -0.940489);\n                    poisson25[20] = ${k()}(0.639332, 0.0284127);\n                    poisson25[21] = ${k()}(0.652089, 0.669668);\n                    poisson25[22] = ${k()}(0.773797, 0.345012);\n                    poisson25[23] = ${k()}(0.968871, 0.840449);\n                    poisson25[24] = ${k()}(0.991882, -0.657338);\n                }\n                \n                ${n.useESMTransmittance?`${W("ONEOVER80")} = 0.0125;`:s}\n                `:s}          \n\n            ${N("getScattering","v3",[h("NoL"),h("c")])} {\n                ${n.sssLUT?`\n                    ${B("cNoL")}  = ${an("NoL","0.5","1.0")};\n                    ${B("rr")}  = ${b("toTexCoord","f",[h("1.0/c"),h("minSSSRadiusR"),h("maxSSSRadiusR")])};\n                    ${B("rg")}  = ${b("toTexCoord","f",[h("1.0/c"),h("minSSSRadiusG"),h("maxSSSRadiusG")])};\n                    ${B("rb")}  = ${b("toTexCoord","f",[h("1.0/c"),h("minSSSRadiusB"),h("maxSSSRadiusB")])};\n                    ${k("coordR")}  = ${k()}(cNoL,rr);\n                    ${k("coordG")}  = ${k()}(cNoL,rg);\n                    ${k("coordB")}  = ${k()}(cNoL,rb);\n                    return ${O()}(\n                        ${b("sampleSSSLUT","v3",[S("coordR")])}.r,\n                        ${b("sampleSSSLUT","v3",[S("coordG")])}.g,\n                        ${b("sampleSSSLUT","v3",[S("coordB")])}.b\n                    );\n                    `:`return ${O()}(${q("NoL")});`}\n            }\n\n            ${N("SssLUTSampling","v3",[h("c")])} {\n                ${n.sssLUT?`\n                    ${B("rr")}  = ${b("toTexCoord","f",[h("1.0/c"),h("minSSSRadiusR"),h("maxSSSRadiusR")])};\n                    ${B("rg")}  = ${b("toTexCoord","f",[h("1.0/c"),h("minSSSRadiusG"),h("maxSSSRadiusG")])};\n                    ${B("rb")}  = ${b("toTexCoord","f",[h("1.0/c"),h("minSSSRadiusB"),h("maxSSSRadiusB")])};\n                    ${k("coordR")}  = ${k()}(rr,SINGLE_LINE_SAMPLING_LINEAR);\n                    ${k("coordG")}  = ${k()}(rg,SINGLE_LINE_SAMPLING_LINEAR);\n                    ${k("coordB")}  = ${k()}(rb,SINGLE_LINE_SAMPLING_LINEAR);\n                    return ${O()}(                 \n                        ${b("sampleSSSIBLLUT","v3",[S("coordR")])}.r,\n                        ${b("sampleSSSIBLLUT","v3",[S("coordG")])}.g,\n                        ${b("sampleSSSIBLLUT","v3",[S("coordB")])}.b\n                    );\n                    `:`return ${O()}(1.0);`}\n            }\n\n            ${N("GetTransmittance","v3",[h("s")])} {\n                ${n.sssLUT?`\n                    ${O("maxTransDepth")} = ${V("maxTranslucencyDepth")};\n                    ${B("rr")}  = ${b("toTexCoord","f",[h("s"),h("0.0"),h("maxTransDepth.x")])};\n                    ${B("rg")}  = ${b("toTexCoord","f",[h("s"),h("0.0"),h("maxTransDepth.y")])};\n                    ${B("rb")}  = ${b("toTexCoord","f",[h("s"),h("0.0"),h("maxTransDepth.z")])};\n                    ${k("coordR")}  = ${k()}(rr,SINGLE_LINE_SAMPLING_LINEAR);\n                    ${k("coordG")}  = ${k()}(rg,SINGLE_LINE_SAMPLING_LINEAR);\n                    ${k("coordB")}  = ${k()}(rb,SINGLE_LINE_SAMPLING_LINEAR);\n                    return ${O()}(\n                        ${b("sampleSSSTranslucencyLUT","v3",[S("coordR")])}.r,\n                        ${b("sampleSSSTranslucencyLUT","v3",[S("coordG")])}.g,\n                        ${b("sampleSSSTranslucencyLUT","v3",[S("coordB")])}.b\n                    );\n                    `:`return exp(-${V("absorptionCoefficients")} * s);`}\n            }\n        `},o=function(n){return`\n            ${n.sssLUT?`\n\n                maxSSSRadiusR  = 0.5 * ${V("maxTranslucencyDepth")}.x;\n                minSSSRadiusR  = maxSSSRadiusR / 15.0;\n\n                maxSSSRadiusG  = 0.5 * ${V("maxTranslucencyDepth")}.y;\n                minSSSRadiusG  = maxSSSRadiusG / 15.0;\n\n                maxSSSRadiusB  = 0.5 * ${V("maxTranslucencyDepth")}.z;\n                minSSSRadiusB = maxSSSRadiusB / 15.0;\n                `:s}\n            surfaceData.curvature = length(fwidth(surfaceData.worldNormal)) / length(fwidth(surfaceData.worldPosition));              \n            materialData.scatteringColor = ${b("SssLUTSampling","v3",[h("surfaceData.curvature")])};\n            ${n.useTransmittance?`\n                ${n.depthBasedTransmittance?`${b("initDisk",null,[])};`:s}\n                ${n.thicknessBasedTransmittance?`\n                    materialData.transmittanceColor = ${b("GetTransmittance","v3",[h("surfaceData.thickness")])};\n                    `:s}\n                `:s}\n        `};gn=function(i){const s=e.addPDSFX("INTERNAL_backup_translucency","materialData.translucency","ComputeTranslucency",i),l=e.addColorPDSFX("INTERNAL_backup_translucencyColor","materialData.translucencyColor","ComputeTranslucencyColor",i.dspbr&&i.gammaInput,i);return i.subsurface?[`\n                    ${n(i)}\n                    ${a(i)}\n                `,`\n                    ${r(i,s,l)}\n                    ${o(i)}\n                `,t(i,s,l)]:[n(i),r(i,s,l),t(i,s,l)]}}{let n=function(n){return`  \n            ${e.addTexturableFloatUniform("clearCoat",n.clearCoatMap)}\n            ${n.clearCoatAddCoef&&n.clearCoatMulCoef?`\n                ${e.addFloatMADs("clearCoat")}\n                `:s}\n            ${n.specgloss?`\n                ${e.addTexturableVec3Uniform("clearCoatColor",n.clearCoatColorMap)}\n                ${n.clearCoatColorAddCoef&&n.clearCoatColorMulCoef?`\n                    ${e.addVec3MADs("clearCoatColor")}\n                    `:s}\n                `:s}\n            ${n.clearCoatRoughnessMap?w({uniformName:"clearCoatRoughnessMap",uniformType:"t2"}):w({uniformName:"clearCoatRoughness",uniformType:"f"})}\n            ${n.clearCoatRoughnessMulCoef&&n.clearCoatRoughnessAddCoef?`\n                ${e.addFloatMADs("clearCoatRoughness")}\n                `:s}\n            ${n.coatingGlossinessMap?w({uniformName:"coatingGlossinessMap",uniformType:"t2"}):s}\n            ${n.coatingGlossinessMulCoef&&n.coatingGlossinessAddCoef?`\n                ${e.addFloatMADs("coatingGlossiness")}\n                `:s}\n            ${n.coatingGlossinessMap||n.clearCoatRoughnessMap?`\n                ${w({uniformName:"clearCoatRoughnessUvTransform",uniformType:"m3"})}\n                `:s}\n            ${n.specgloss?w({uniformName:"clearCoatNormalScale",uniformType:"f"}):s}\n            ${n.dspbr&&(n.clearCoatNormalMap||n.orangePeel)?`\n                ${n.clearCoatNormalAddCoef&&n.clearCoatNormalMulCoef?`\n                    ${e.addVec3MADs("clearCoatNormal")}\n                    `:s}\n                `:s}\n            ${n.clearCoatNormalMap?`\n                ${w({uniformName:"clearCoatNormalMap",uniformType:"t2"})}\n                ${w({uniformName:"clearCoatNormalUvTransform",uniformType:"m3"})}\n\n                ${N("perturbNormal3ArbCoat","v3",[T("surf_norm"),T("surf_tgt"),T("surf_binorm"),S("uv")])} {\n\n                    ${O("N")}  = normalize(surf_norm);\n                    ${O("T")}  = normalize(surf_tgt);\n                    T = normalize(T - dot(T, N) * N);\n                    ${O("B")}  = normalize(surf_binorm);\n\n                    ${O("mapN")}  = ${sn(z("clearCoatNormalMap"),"uv")}.xyz * 2.0 - 1.0;\n\n                    ${n.dspbr?`\n                        ${n.clearCoatNormalAddCoef&&n.clearCoatNormalMulCoef?`mapN = mapN * ${V("clearCoatNormalMulCoef")} + ${V("clearCoatNormalAddCoef")};`:s}\n                        mapN.z = abs(mapN.z);\n                        `:`\n                        ${n.clearCoatNormalMapFlipY?"mapN.y = - mapN.y;":s}\n                        mapN.x = ${V("clearCoatNormalScale")} * mapN.x;\n                        mapN.y = ${V("clearCoatNormalScale")} * mapN.y;\n                        `}\n                    ${H("tbn")}  = ${H()}(T, B, N);\n                    return normalize(tbn * mapN);\n                }\n                `:s}\n        `},t=function(n){return`\n            ${w({uniformName:"orangePeelScale",uniformType:"f"})}\n\n            ${N("orangePeelVisibility",null,[v("peelMask"),h("scaling")])} {\n                ${n.defaultInstancing?`\n                    ${H("mat")}  = ${b("transposeMatrix","m3",[$("m4","(modelMatrix * multipliedDefaultInstancingMatrix)")])};\n                    `:`\n                    ${H("mat")}  = ${b("transposeMatrix","m3",[$("m4","(modelMatrix)")])};\n                    `}      \n                ${O("worldScaling")}  = 1.0/${O()}(length(mat[0]),length(mat[1]),length(mat[2]));\n                ${B("dist")}  = length(worldScaling * surfaceData.viewPosition);\n                ${B("NdotV")}   = dot(surfaceData.viewNormal, surfaceData.view);\n                if (NdotV <= 0.0) {\n                    ${c("peelMask")} = 0.0;\n                    return;\n                }\n                ${B("normDist")}   = ${Z("scaling * dist * 0.00125")};\n                ${B("shortDist")}   = ${Z("1.0 - normDist")};\n                ${c("peelMask")} = shortDist;\n            }\n\n            ${N("doOrangePeel","v3",[T("orangePeelWorldNormal")])} {\n                ${B("peelMask")}   = 0.0;\n                ${B("peelScaling")}   = 0.01/max(${V("orangePeelScale")},1e-3);\n                ${b("orangePeelVisibility",null,[g("peelMask"),h("peelScaling")])};\n                ${n.dspbr?`\n                    ${B("ccNScale")}   = 1.0;\n                    ${n.clearCoatNormalAddCoef&&n.clearCoatNormalMulCoef?`\n                        ccNScale = ${Z(`${Y(`${V("clearCoatNormalMulCoef")}`)}`)};\n                        `:s}\n                    `:`${B("ccNScale")}   = ${V("clearCoatNormalScale")};`}\n                if (ccNScale < kEpsilon || peelMask < kEpsilon) {\n                    return orangePeelWorldNormal;\n                }\n                ${O("tex")}  = peelScaling * surfaceData.objectSpacePosition;\n                tex.y = -abs(tex.y);\n                tex.x = -abs(tex.x);\n                ${B("noise")}   = ${b("FBM","f",[T("tex")])};\n                ${O("peelNormal")}  = ${O()}(noise);\n                return normalize(orangePeelWorldNormal + 0.05 *ccNScale *peelMask* peelNormal);\n            }\n        `};xn=function(r){if(!r.clearCoat)return[s,s,s];let a=n(r);r.orangePeel&&(a=`\n                    ${a}\n                    ${t(r)}\n                `);const o=e.addPDSFX("INTERNAL_backup_clearcoat","materialData.clearCoat","ComputeClearcoat",r),i=e.addColorPDSFX("INTERNAL_backup_clearcoatColor","materialData.clearCoatSR0Color","ComputeClearcoatColor",r.dspbr&&r.gammaInput,r),l=e.addPDSFX("INTERNAL_backup_clearcoatRoughness","materialData.clearCoatRoughness","ComputeClearcoatRoughness",r);let u=`\n            \n                ${e.addFloatParameterResolution("materialData.clearCoat","clearCoat",r.clearCoatMap,r.clearCoatAddCoef&&r.clearCoatMulCoef,!1,r)}  \n                ${o.backup}\n                ${r.specgloss?`\n                    ${e.addColorParameterResolution("materialData.clearCoatSR0Color","clearCoatColor",r.clearCoatColorMap,r.clearCoatColorAddCoef&&r.clearCoatColorMulCoef,r.gammaInput&&!r.clearCoatColorMapLinear,!1,r)}\n                    ${i.backup}\n                    `:`materialData.clearCoatSR0Color = ${O()}(0.04);`}\n                materialData.clearCoatSR90Color = ${O()}(1.0);\n                ${e.addFloatParameterResolution("materialData.clearCoatRoughness","clearCoatRoughness",r.clearCoatRoughnessMap,r.clearCoatRoughnessAddCoef&&r.clearCoatRoughnessMulCoef,!1,r,"r","g")}\n                ${r.coatingGlossinessMap?`\n                    ${e.textureSlotString("clearCoatRoughness","ccglossinessUV",r)}\n                    ${B("ccGlossiness")}  = ${sn(z("coatingGlossinessMap"),"ccglossinessUV")}.r;\n                    materialData.clearCoatRoughness = 1.0 - ccGlossiness;\n                    `:s}\n                ${r.coatingGlossinessMulCoef&&r.coatingGlossinessAddCoef?`\n                    materialData.clearCoatRoughness = ${V("coatingGlossinessMulCoef")} * (1.0 - materialData.clearCoatRoughness) + ${V("coatingGlossinessAddCoef")};\n                    materialData.clearCoatRoughness = 1.0 - ${Z("materialData.clearCoatRoughness")};\n                    `:s}\n                ${l.backup}\n            `;const m=e.addPDSFX("INTERNAL_backup_clearcoatViewNormal","surfaceData.clearCoatNormal","ComputeClearcoatViewNormal",r,"v3");return[a,`                 \n                ${o.solve}\n                ${r.clearCoatNormalMap?`\n                    ${e.textureSlotString("clearCoatNormal","ccnormalUv",r)}\n                    surfaceData.clearCoatNormal = ${b("perturbNormal3ArbCoat","v3",[T("viewNormal"),T("tangent"),T("binormal"),S("ccnormalUv")])};\n                    `:"surfaceData.clearCoatNormal = viewNormal;"}\n                ${m.backup}\n                ${m.solve}\n                surfaceData.clearCoatWorldNormal = normalize( ( ${G()}( surfaceData.clearCoatNormal, 0.0 ) * ${F("viewMatrix")} ).xyz );\n                ${r.orangePeel?`\n                    surfaceData.clearCoatWorldNormal = ${b("doOrangePeel","v3",[T("surfaceData.clearCoatWorldNormal")])};\n                    surfaceData.clearCoatNormal = normalize( (${F("viewMatrix")} * ${G()}( surfaceData.clearCoatWorldNormal , 0.0)).xyz);\n                    `:s}\n                ${r.specgloss?`\n                    ${i.solve}\n                    `:s}\n                ${l.solve}\n                materialData.clearCoatRoughness =  clamp(materialData.clearCoatRoughness, ROUGHNESS_CLAMP_MIN, ROUGHNESS_CLAMP_MAX);\n            `,u]}}{let n=function(n){const e=[{type:"f",name:"flakesRoughness"},{type:"f",name:"flakesCoverage"},{type:"v3",name:"flakesColor"},{type:"f",name:"flakesCosConeAngle"},{type:"f",name:"flakesConeSolidAngle"},{type:"v3",name:"closeupFlakesReflect"},{type:"v3",name:"closeupFlakesNormal"},{type:"f",name:"baseWeight"},{type:"f",name:"smoothWeight"},{type:"v3",name:"smoothFlakesColor"},{type:"f",name:"closeupWeight"},{type:"v3",name:"closeupFlakesColor"},{type:"f",name:"stochasticWeight"},{type:"v2",name:"footprintPos"},{type:"v2",name:"footprintDx"},{type:"v2",name:"footprintDy"},{type:"f",name:"precisionTest"},{type:"f",name:"footprintArea"},{type:"f",name:"cellsInFootPrint"},{type:"f",name:"invDet"},{type:"f",name:"seedRes"}];return n.dspbrWithFlipFlopColor&&(e.push({type:"v3",name:"flipFlopColor"}),e.push({type:"f",name:"flipFlop"})),n.dspbrHemiFlakes&&(e.push({type:"v3",name:"stochasticHemisphereFlakesNormal"}),e.push({type:"v3",name:"stochasticHemisphereFlakesReflect"}),e.push({type:"v3",name:"stochasticHemisphereFlakesColor"})),`\n            ${n.dspbrFlakesFullGrid?`\t\n                ${W("HALF_MAXF_GRID_SIZE")}  = 2.0;\n                ${X("FLAKES_PER_CELL")} = 4;\n                `:`\t\n                ${W("HALF_MAXF_GRID_SIZE")}  = 1.0;\n                ${X("FLAKES_PER_CELL")} = 2;\n                `}\n            ${W("DSPBRFLAKES_STO_SMOOTH_TRANSITION")}  = 256.0;\n            ${W("DSPBRFLAKES_CLOSE_SMOOTH_TRANSITION")}  = 4.0;\n            ${W("DSPBRFLAKES_CLOSE_STO_TRANSITION")}  = 0.25;\n\n            \n            ${o.createStruct({structName:"rstGridData",attributes:[{type:"f",name:"minX"},{type:"f",name:"minY"},{type:"f",name:"maxX"},{type:"f",name:"maxY"},{type:"f",name:"deltaDDx"},{type:"f",name:"deltaDDy"},{type:"f",name:"dyLeftBound"},{type:"f",name:"dxLeftBound"},{type:"f",name:"dyRightBound"},{type:"f",name:"dxRightBound"}]})}\n            ${o.struct({name:"rasterizedGridData",structName:"rstGridData",addressSpace:"private"})};\n            ${o.struct({name:"rasterizedGridDataClose",structName:"rstGridData",addressSpace:"private"})};\n\n            ${o.createStruct({structName:"flData",attributes:e})}\n            ${o.struct({name:"flakesData",structName:"flData",addressSpace:"private"})};\n          \n            ${N("reorientParallelogram",null,[S("pos"),S("dx"),S("dy"),y("nPos"),y("nDx"),y("nDy")])}{\n                ${k("newPosition")} = ${k()}(pos);\n                ${k("newDx")};\n                ${k("newDy")};\n                if ((dy.x * dx.y - dy.y * dx.x) > 0.0) { \n                    newDx = ${k()}(dy); \n                    newDy = ${k()}(dx); \n                } else {\n                    newDx = ${k()}(dx);\n                    newDy = ${k()}(dy);\n                }\n                if (newDy.y < 0.0) {\n                    newPosition = newPosition + newDy;\n                    ${k("aux")}  = ${k()}(newDy);\n                    newDy = newDx;\n                    newDx = - aux;\n                }\n                if (newDy.y < 0.0) {\n                    newPosition = newPosition + newDy;\n                    ${k("aux")} = ${k()}(newDy);\n                    newDy = newDx;\n                    newDx = - aux;\n                }\n                if (newDx.y <= 0.0) {\n                    newPosition = newPosition + newDx;\n                    ${k("aux")} = ${k()}(newDx);\n                    newDx = newDy;\n                    newDy = - aux;\n                }\n                if (newDx.y <= 0.0) {\n                    newPosition = newPosition + newDx;\n                    ${k("aux")} = ${k()}(newDx);\n                    newDx = newDy;\n                    newDy = - aux;\n                }\n                ${c("nPos")} = newPosition;\n                ${c("nDx")} = newDx;\n                ${c("nDy")} = newDy;\n            }\n\n            ${N("parallelogramBBox","v4",[S("pos"),S("dx"),S("dy")])} {\n                ${k("corner1")}  = pos;\n                ${k("corner2")}  = pos + dx;\n                ${k("corner3")}  = pos + dy;\n                ${k("corner4")}  = pos + dx + dy;\n\n                ${k("minBBox")}  = ${k()}(${K(`${G()}(corner1.x,corner2.x,corner3.x,corner4.x)`)}, ${K(`${G()}(corner1.y,corner2.y,corner3.y,corner4.y)`)});\n                ${k("maxBBox")}  = ${k()}(${J(`${G()}(corner1.x,corner2.x,corner3.x,corner4.x)`)}, ${J(`${G()}(corner1.y,corner2.y,corner3.y,corner4.y)`)});\n                return ${G()}(minBBox, maxBBox);\n            }\n\n            ${N("prepareFlakesGrid",null,[(t="rstGridData",r="gridData",l.parameterInOutPrivateStruct(t,r)),$("b","close")])}{ \n                ${k("pos")} ;\n                ${k("dx")} ;\n                ${k("dy")} ;\n                if (close) {\n                    ${B("nodeSize")}  = 1.25 / flakesData.seedRes;\n                    pos = flakesData.footprintPos - nodeSize;\n                    dx = ${k()}(2.0 * nodeSize, 0.0);\n                    dy = ${k()}(0.0, 2.0 * nodeSize);\n                } else {\t\t\n                    pos = flakesData.footprintPos;\n                    dx = flakesData.footprintDx;\n                    dy = flakesData.footprintDy;\n                }\n                ${G("bbox")}  = ${b("parallelogramBBox","v4",[S("pos"),S("dx"),S("dy")])};\n                ${k("gridMin")}  = floor(flakesData.seedRes * bbox.xy);\n                ${k("gridMax")}  = ceil(flakesData.seedRes * bbox.zw);\n\n                ${k("footPrintCenter")}  = flakesData.seedRes * (pos + 0.5 * (dx + dy));\n\n                gridMin = clamp(gridMin, footPrintCenter - HALF_MAXF_GRID_SIZE, footPrintCenter + HALF_MAXF_GRID_SIZE);\n                gridMin = clamp(gridMin,  footPrintCenter - ${k()}(flakesData.seedRes), footPrintCenter + ${k()}(flakesData.seedRes));\n                gridMax = clamp(gridMax, footPrintCenter - HALF_MAXF_GRID_SIZE, footPrintCenter + HALF_MAXF_GRID_SIZE);\n                gridMax = clamp(gridMax,  footPrintCenter - ${k()}(flakesData.seedRes), footPrintCenter + ${k()}(flakesData.seedRes));\n                gridMax += ${k()}(1.0);\n                {\n                    ${k("opos")}  = pos * flakesData.seedRes;\n                    ${k("odx")}  = dx * flakesData.seedRes;\n                    ${k("ody")}  = dy * flakesData.seedRes;\t\n                    ${b("reorientParallelogram",null,[S("opos"),S("odx"),S("ody"),_("pos"),_("dx"),_("dy")])};\n                }\n                ${B("deltaDDx")}  = dx.x / abs(dx.y);\n                ${B("deltaDDy")}  = dy.x / abs(dy.y);\n                ${k("sum")}  = dx + dy;\n                ${B("minX")}  = max(min(pos.x, min(pos.x + dy.x, pos.x + sum.x)),gridMin.x);\n                ${B("maxX")}  = min(max(pos.x, max(pos.x + dx.x, pos.x + sum.x)),gridMax.x);\n                ${B("minY")}  = floor(max(gridMin.y, pos.y));\n                ${B("maxY")}  = ceil(min(gridMax.y, pos.y + sum.y));\n\n                \n                ${B("dyLeftBound")}  =  pos.x +\t(minY - pos.y) * deltaDDy;\n                if (dy.x < 0.0) {\n                    dyLeftBound += deltaDDy;\n                }\n                ${B("dxLeftBound")}  =  pos.x + dy.x + (minY - pos.y - dy.y) * deltaDDx;\n                if (dx.x < 0.0) {\n                    dxLeftBound += deltaDDx;\n                }\n                ${B("dyRightBound")}  = pos.x + dx.x +\t(minY - pos.y - dx.y) * deltaDDy;\n                if (dy.x > 0.0) {\n                    dyRightBound += deltaDDy;\n                }\n                ${B("dxRightBound")}  = pos.x +\t(minY - pos.y) * deltaDDx;\n                if (dx.x > 0.0) {\n                    dxRightBound += deltaDDx;\n                }\n\n                ${c("gridData")}.minX = minX;\n                ${c("gridData")}.maxX = maxX;\n                ${c("gridData")}.minY = minY;\n                ${c("gridData")}.maxY = maxY;\n                ${c("gridData")}.dyLeftBound = dyLeftBound;\n                ${c("gridData")}.dxLeftBound = dxLeftBound;\n                ${c("gridData")}.dyRightBound = dyRightBound;\n                ${c("gridData")}.dxRightBound = dxRightBound;\n                ${c("gridData")}.deltaDDx = deltaDDx;\n                ${c("gridData")}.deltaDDy = deltaDDy;\n            }\n            \n            ${N("triplanarMapping","v2",[T("p"),T("n"),h("scale")])}{ \n                ${k("uv")} ;\n                if (abs(n.x) >= abs(n.y) && abs(n.x) >= abs(n.z)) {\n                    uv = ${k()}(-p.z,-p.y);\n                } else if (abs(n.y) >= abs(n.z)) {\n                    uv = ${k()}( p.x, p.z);\n                } else {\n                    uv = ${k()}( p.x,-p.y);\n                }\n                return uv * scale;\n            }\n\n            ${N("computeFlakesRoughness",null,[h("flakesRoughness")])} {\n                ${B("targetConeAngle")}  = 0.122173;\n                ${B("targetConeSolidAngle")}  = 2.0 * PI * (1.0 - cos(targetConeAngle));\n                ${B("targetConeRoughness2")}  = targetConeSolidAngle / (4.0 * PI - targetConeSolidAngle);\n\n                ${B("totalFlakeRoughness2")}  = ${Q("flakesRoughness")};\n                ${B("flakeConeRoughness2")}  = min(targetConeRoughness2, 0.5 * totalFlakeRoughness2);\n                flakesData.flakesCosConeAngle = clamp(1.0 - 2.0 * flakeConeRoughness2 / (1.0 + flakeConeRoughness2), 0.0, 0.99984769502);\n                flakesData.flakesConeSolidAngle = 2.0 * PI * (1.0 - flakesData.flakesCosConeAngle);\n\n                flakesData.flakesRoughness = sqrt(totalFlakeRoughness2 - flakeConeRoughness2);\n            }\n\n            ${N("checkFlakesPrecision","b",[])} {\n                // Adreno (Snapdragon) GPUs seems to have a bizarre problem with structs and general precision on floating numbers\n                // Flakes require operation at very small scales which is not working properly when such precision issues are present\n                // When detected, we omit the rendering of individual flakes and only keep the smooth layer\n                // Apple silicones and Malis (ARM in general) are fine\n                // luckily what happens here is contant on all cells so it won't cause branching\n                ${k("x")} = ${k()}(1e-5, 1e-6);\n                ${k("y")} = ${k()}(1e-6, -1e-4);\n                flakesData.precisionTest = x.x * y.y - x.y * y.x;\n                ${B("precisionTest")} = (\n                        (1e3 * x.x) * (1e3 * y.y) - \n                        (1e3 * x.y) * (1e3 * y.x)\n                ) / 1e6;\n                 \n                if (abs((precisionTest - flakesData.precisionTest) / precisionTest) > 1e-6) {\n                    return false;\n                }\n                return true;\n            }\n\n        ${n.dspbrWithFlipFlopColor?`${N("initFlakesData",null,[T("p"),T("x"),T("y"),T("N"),h("flakesSize"),h("flakesCoverage"),T("flakesColor"),h("flakesRoughness"),h("flipFlop"),T("flipFlopColor")])} {`:`${N("initFlakesData",null,[T("p"),T("x"),T("y"),T("N"),h("flakesSize"),h("flakesCoverage"),T("flakesColor"),h("flakesRoughness")])} {`}\n                ${n.defaultInstancing?`\n                    ${H("mat")}  = ${b("transposeMatrix","m3",[$("m4","(modelMatrix * multipliedDefaultInstancingMatrix)")])};\n                    `:`\n                    ${H("mat")}  = ${b("transposeMatrix","m3",[$("m4","(modelMatrix)")])};\n                    `}   \n                ${O("worldScaling")}  = ${O()}(length(mat[0]),length(mat[1]),length(mat[2]));\n                ${O("scaledP")}  = p * worldScaling;\n\n                flakesData.flakesColor = flakesColor;\n                flakesData.flakesCoverage = flakesCoverage;\n                ${n.dspbrWithFlipFlopColor?`\n                    flakesData.flipFlopColor = flipFlopColor;\n                    flakesData.flipFlop = ${Q("1.0 / max(flipFlop, 1e-6)")};\n                    `:s}\n\n                ${b("computeFlakesRoughness",null,[h("flakesRoughness")])};\n\n                flakesData.footprintPos =  ${b("triplanarMapping","v2",[T("scaledP"),T("N"),h("1e-3")])};\n                flakesData.footprintDx =  ${b("triplanarMapping","v2",[T("x * worldScaling"),T("N"),h("1e-3")])};\n                flakesData.footprintDy =  ${b("triplanarMapping","v2",[T("y * worldScaling"),T("N"),h("1e-3")])};\n                flakesData.footprintArea = flakesData.footprintDx.x * flakesData.footprintDy.y - flakesData.footprintDx.y * flakesData.footprintDy.x;\n                flakesData.invDet = 1.0 / flakesData.footprintArea;\n\n                ${B("cellsPerArea")}  = 1.5396e6 / ${Q("flakesSize")};\n                flakesData.cellsInFootPrint = abs(flakesData.footprintArea) * cellsPerArea;\n                ${B("flakesPerArea")}  = flakesCoverage * cellsPerArea;\n                flakesData.seedRes = max(${B()}(FLAKES_PER_CELL), ${b("vRound","f",[h(`sqrt(cellsPerArea/${B()}(FLAKES_PER_CELL)))`)])};\n\n                ${b("prepareFlakesGrid",null,[f("rstGridData","rasterizedGridData"),$("b","false")])};\n                ${b("prepareFlakesGrid",null,[f("rstGridData","rasterizedGridDataClose"),$("b","true")])};\n            }\n        `;var t,r},t=function(n){return`\n    \n            ${N("ImportanceSampleGGX","v3",[S("Xi"),h("roughness")])}{\n    \n                ${O("H")} ;\n                ${B("Phi")}  = 2.0 * PI * Xi.x;\n                ${B("a")}  = roughness * roughness;\n                ${B("a2")}  = a * a;\n    \n                ${B("CosTheta")}  = clamp(sqrt((1.0 - Xi.y) / (1.0 + (a2 - 1.0) * Xi.y)),0.0,1.0);\n                ${B("SinTheta")}  = sqrt(1.0 - CosTheta * CosTheta);\n    \n                H.x = SinTheta * cos(Phi);\n                H.y = SinTheta * sin(Phi);\n                H.z = CosTheta;\n                return H;\n            }\n            \n            ${N("rnGenerator","v2",[p("i","seed")])} {\n                ${L("s")} = ${c("seed")};\n                ${L("rn")} = ${b("modI","i",[x("1140671485 * s + 12820163"),x("16777216")])};\n                s = ${b("modI","i",[x("1140671485 * rn + 12820163"),x("16777216")])};\n                ${c("seed")} = s;\n                return ${k()}(${B()}(rn) /16777216.0 ,${B()}(s) / 16777216.0);\n            }\n\n            ${N("generateFlakes",null,[p("i","seed"),T("V"),T("N"),y("pos"),D("refl"),p("b","opaque")])} {\n                ${c("pos")} = ${b("rnGenerator","v2",[p("i","seed")])};\n                ${k("uvs")}  = ${b("rnGenerator","v2",[p("i","seed")])};\t\n                ${O("H")} = ${b("ImportanceSampleGGX","v3",[S("uvs.xy"),h("flakesData.flakesRoughness")])};\n                ${c("refl")} = ${b("TangentToWorldGeom","v3",[T("H"),T("N")])};\n                ${c("refl")} = 2.0 * dot(V,${c("refl")}) * ${c("refl")} - V;\n                ${c("opaque")} = ${b("rnGenerator","v2",[p("i","seed")])}.x < flakesData.flakesCoverage;\n            }\n\n            ${N("getSeed","i",[h("i"),h("j")])} {\t\n                ${B("iF")}  = i;\n                ${B("jF")}  = j;\n                return ${L()}(length(${k()}(iF,jF)* 16892.0));\n            }\n\n            ${N("midFlakeInFootPrint","b",[S("center")])} {\n                if (abs(flakesData.footprintArea) < 1e-10) {\n                    return false;\n                } else {\n                    ${k("pp")}  = center - flakesData.footprintPos;\n                    ${k("uv")}  = flakesData.invDet * ${k()}(dot(${k()}(-pp.y,pp.x),flakesData.footprintDy), dot(${k()}(pp.y,-pp.x),flakesData.footprintDx));\n                    return 0.0 <= uv.x && uv.x <= 1.0 && 0.0 <= uv.y && uv.y <= 1.0;\n                }\n            }\n        `},r=function(n){return`\n\n            ${N("contributingStochasticFlakes","v2",[T("V"),T("L"),T("N"),h("limit")])} {\n                ${B("contributing")}  = 0.0;\n                ${B("flakesInFootPrint")}  = 0.0;\n\n                ${B("deltaDDx")}  = rasterizedGridData.deltaDDx;\n                ${B("deltaDDy")}  = rasterizedGridData.deltaDDy;\n\n                ${B("minX")}  = rasterizedGridData.minX;\n                ${B("maxX")}  = rasterizedGridData.maxX;\n                ${B("minY")}  = rasterizedGridData.minY;\n                ${B("maxY")}  = rasterizedGridData.maxY;\n\n                ${B("dyLeftBound")}  =  rasterizedGridData.dyLeftBound;\n                ${B("dxLeftBound")}  =  rasterizedGridData.dxLeftBound;\t\t\t\n                ${B("dyRightBound")}  = rasterizedGridData.dyRightBound;\n                ${B("dxRightBound")}  = rasterizedGridData.dxRightBound;\n\n                ${B("i")}  = 0.0;\n                ${B("maxI")}  = -1.0;\n                ${B("j")}  = minY;\n                ${B("jEnd")}  = maxY;\n                \n                ${B("nodeSize")}  = 1.0 / flakesData.seedRes;\n                ${n.dspbrWithFlipFlopColor?`${O("totalRefl")}  = ${O()}(0.0);`:s}\n                for (${L("loopIndex")} = 0; loopIndex < 150; loopIndex++) {\t\t\t\n                    if (i >= maxI) {\n                        ${B("boundaryLeft")}  = max(minX, max(dyLeftBound, dxLeftBound));\n                        i = floor(boundaryLeft);\n\n                        ${B("boundaryRight")}  = min(maxX, min(dyRightBound, dxRightBound));\n                        maxI = ceil(boundaryRight);\n                        \n                        dyLeftBound += deltaDDy;\n                        dxLeftBound += deltaDDx;\n                        dyRightBound += deltaDDy;\n                        dxRightBound += deltaDDx;\n                    }\n\n                    ${L("seed")} = ${b("getSeed","i",[h("i"),h("j")])};\n                    for (${L("cell")}  = 0; cell < FLAKES_PER_CELL; cell++) {\n                        ${k("fPos")} ;\n                        ${O("fRefl")} ;\n                        ${A("fOpaque")} ;\n                        ${b("generateFlakes",null,[d("i","seed"),T("V"),T("N"),_("fPos"),C("fRefl"),d("b","fOpaque")])};\n                        if (fOpaque) {\n                            ${k("flakeUV")}  = nodeSize * (${k()}(i, j) + fPos);\n                            if (${b("midFlakeInFootPrint","b",[S("flakeUV")])}) {\n                                ${B("val")}  = step(0.0, dot(fRefl,L) - limit);\n                                flakesInFootPrint += 1.0;\n                                ${n.dspbrWithFlipFlopColor?"totalRefl += val * fRefl;":s}\n                                contributing += val;\n                            }\n                        }\n                    }\n\n                    i += 1.0;\n                    if (i >= maxI) { \n                        j += 1.0;\n                    }\n                    if (j >= jEnd) {\n                        break;\n                    }\n                }\n                ${B("coeff")}  = contributing / max(1.0,flakesInFootPrint);\n\n                ${n.dspbrWithFlipFlopColor?`                \n                    ${O("flakesN")}  = normalize(${rn("totalRefl")} + V);    \n                    return ${k()}(coeff, dot(V, flakesN));\n                    `:`return ${k()}(coeff, 0.0);`}\n            }\n        `},a=function(n){return`\n\n            ${N("contributingStochasticHemisphereFlakes","v3",[T("V"),T("N")])} {\n                ${O("stochasticFlakesOrientation")}  = ${O()}(0.0);\n                ${B("deltaDDx")}  = rasterizedGridData.deltaDDx;\n                ${B("deltaDDy")}  = rasterizedGridData.deltaDDy;\n                ${B("minX")}  = rasterizedGridData.minX;\n                ${B("maxX")}  = rasterizedGridData.maxX;\n                ${B("minY")}  = rasterizedGridData.minY;\n                ${B("maxY")}  = rasterizedGridData.maxY;\n                ${B("dyLeftBound")}  =  rasterizedGridData.dyLeftBound;\n                ${B("dxLeftBound")}  =  rasterizedGridData.dxLeftBound;\t\t\t\n                ${B("dyRightBound")}  = rasterizedGridData.dyRightBound;\n                ${B("dxRightBound")}  = rasterizedGridData.dxRightBound;\n\n                ${B("i")}  = 0.0;\n                ${B("maxI")}  = -1.0;\n                ${B("j")}  = minY;\n                ${B("jEnd")}  = maxY;\n                \n                ${B("nodeSize")}  = 1.0 / flakesData.seedRes;\n                for (${L("loopIndex")} = 0; loopIndex < 150; loopIndex++) {\t\t\t\n                    if (i >= maxI) {\n                        ${B("boundaryLeft")}  = max(minX, max(dyLeftBound, dxLeftBound));\n                        i = floor(boundaryLeft);\n\n                        ${B("boundaryRight")}  = min(maxX, min(dyRightBound, dxRightBound));\n                        maxI = ceil(boundaryRight);\n                        \n                        dyLeftBound += deltaDDy;\n                        dxLeftBound += deltaDDx;\n                        dyRightBound += deltaDDy;\n                        dxRightBound += deltaDDx;\n                    }\n\n                    ${L("seed")}= ${b("getSeed","i",[h("i"),h("j")])};\n                    for (${L("cell")} = 0; cell < FLAKES_PER_CELL; cell++) {\n                        ${k("fPos")};\n                        ${O("fRefl")};\n                        ${A("fOpaque")};\n                        ${b("generateFlakes",null,[d("i","seed"),T("V"),T("N"),_("fPos"),C("fRefl"),d("b","fOpaque")])};\n                        ${B("val")}  = dot(fRefl,N);\n                        stochasticFlakesOrientation += step(0.1, val) * fRefl;\n                    }\n\n                    i += 1.0;\n                    if (i >= maxI) { \n                        j += 1.0;\n                    }\n                    if (j >= jEnd) {\n                        break;\n                    }\n                }\n                ${B("len")}  = length(stochasticFlakesOrientation);\n                if (len > 1e-6) {\n                    return stochasticFlakesOrientation / len;\n                }\n                return reflect(V , N);\n            }\n        `},i=function(n){return`\n            ${N("contributingCloseFlakes","v3",[T("V"),T("N")])} {\n                ${B("deltaDDx")}  = rasterizedGridDataClose.deltaDDx;\n                ${B("deltaDDy")}   = rasterizedGridDataClose.deltaDDy;\n                ${B("minX")}   = rasterizedGridDataClose.minX;\n                ${B("maxX")}   = rasterizedGridDataClose.maxX;\n                ${B("minY")}   = rasterizedGridDataClose.minY;\n                ${B("maxY")}   = rasterizedGridDataClose.maxY;\n                ${B("dyLeftBound")}   =  rasterizedGridDataClose.dyLeftBound;\n                ${B("dxLeftBound")}   =  rasterizedGridDataClose.dxLeftBound;\t\t\t\n                ${B("dyRightBound")}   = rasterizedGridDataClose.dyRightBound;\n                ${B("dxRightBound")}   = rasterizedGridDataClose.dxRightBound;\n\n                ${B("i")}   = 0.0;\n                ${B("maxI")}   = -1.0;\n                ${B("j")}   = minY;\n                ${B("jEnd")}   = maxY;\n                \n                ${B("nodeSize")}   = 1.0 / flakesData.seedRes;\n                ${B("bestDistance")}   = 1e10;\n                ${O("res")}  = ${O()}(0.0);\n                for (${L("loopIndex")}= 0; loopIndex < 150; loopIndex++) {\t\t\n                    if (i >= maxI) {\n                        ${B("boundaryLeft")}   = max(minX, max(dyLeftBound, dxLeftBound));\n                        i = floor(boundaryLeft);\n\n                        ${B("boundaryRight")}   = min(maxX, min(dyRightBound, dxRightBound));\n                        maxI = ceil(boundaryRight);\n                        \n                        dyLeftBound += deltaDDy;\n                        dxLeftBound += deltaDDx;\n                        dyRightBound += deltaDDy;\n                        dxRightBound += deltaDDx;\n                    }\n\n                    ${L("seed")} = ${b("getSeed","i",[h("i"),h("j")])};\n                    for (${L("cell")} = 0; cell < FLAKES_PER_CELL; cell++) {\n                        ${k("fPos")};\n                        ${O("fRefl")};\n                        ${A("fOpaque")};\n                        ${b("generateFlakes",null,[d("i","seed"),T("V"),T("N"),_("fPos"),C("fRefl"),d("b","fOpaque")])};\n                        ${k("flakeUV")}  = nodeSize * (${k()}(i, j)  + fPos);\n                        \n                        ${k("prel")}  = flakesData.footprintPos + 0.5* (flakesData.footprintDx + flakesData.footprintDy) - flakeUV;\n                        ${B("curDistance")}   = dot(prel, prel);\n                        if (curDistance < bestDistance) {\n                            bestDistance = curDistance;\n                            if (fOpaque) {\n                                res = fRefl;\n                            } else {\n                                res = ${O()}(0.0);\n                            }\n                        }\n                    }\n\n                    i += 1.0;\n                    if (i >= maxI) { \n                        j += 1.0;\n                    }\n                    if (j >= jEnd) {\n                        break;\n                    }\n                }\n\n                return ${rn("res")};\n            }\n        `},u=function(n){return`   \n            ${n.dspbrWithFlipFlopColor?`\n                ${N("computeFlakesTint","v3",[h("NoV")])} {\n                    ${B("coeff")}  = pow(${q("NoV")}, flakesData.flipFlop);\n                    return mix(flakesData.flakesColor, flakesData.flipFlopColor, coeff);\n                }\n\n                ${N("computeFlakesTint","v3",[T("V"),T("N")])} {\n                    return ${b("computeFlakesTint","v3",[h("dot(N,V)")])};\n                }\n                `:`\n                ${N("computeFlakesTint","v3",[])} {\n                    return flakesData.flakesColor;\n                }\n                `}\n\n            ${N("initFlakesWeights",null,[T("V"),T("N")])} {\n                flakesData.closeupFlakesReflect = ${O()}(0.0);\n                ${B("flakesHit")}  = 0.0;\n                ${n.dspbrFlakesThreeLayers||n.dspbrFlakesTwoLayers?`          \n                    if (${b("checkFlakesPrecision","b",[])}) {\n                        ${n.dspbrFlakesThreeLayers?`\t\t\n                            ${B("closeupStochasticTransition")}  = log(DSPBRFLAKES_CLOSE_STO_TRANSITION);\n                            ${B("closeupSmoothTransition")}  = log(DSPBRFLAKES_CLOSE_SMOOTH_TRANSITION);\n                            ${B("stochasticSmoothTransition")}  = log(DSPBRFLAKES_STO_SMOOTH_TRANSITION);\n\n                            ${B("logCellsInFootPrint")}  = log(flakesData.cellsInFootPrint);\n                            if (logCellsInFootPrint < closeupSmoothTransition) {\t\n                                flakesData.closeupFlakesReflect = ${b("contributingCloseFlakes","v3",[T("V"),T("N")])};\n                                if (dot(flakesData.closeupFlakesReflect, flakesData.closeupFlakesReflect) > 0.0 ) {\n                                    flakesHit = 1.0;\n                                }\n                                if (logCellsInFootPrint < closeupStochasticTransition) {\n                                    flakesData.closeupWeight = flakesHit;\n                                    flakesData.stochasticWeight = 0.0;\n                                    flakesData.baseWeight = 1.0 - flakesHit;\n                                } else {\n                                    flakesData.stochasticWeight = smoothstep(closeupStochasticTransition, closeupSmoothTransition, logCellsInFootPrint);\n                                    flakesData.closeupWeight = flakesHit * (1.0 - flakesData.stochasticWeight);\n                                    flakesData.baseWeight = (1.0 - flakesHit) * (1.0 - flakesData.stochasticWeight) + (1.0 - flakesData.flakesCoverage) * flakesData.stochasticWeight;\n                                }\n                                flakesData.smoothWeight = 0.0;\n                            } else {\n                                flakesData.closeupWeight = 0.0;\n                                if (logCellsInFootPrint < stochasticSmoothTransition) {\t\n                                    flakesData.smoothWeight = smoothstep(closeupSmoothTransition, stochasticSmoothTransition, logCellsInFootPrint);\n                                    flakesData.stochasticWeight = 1.0 - flakesData.smoothWeight;\n                                } else {\n                                    flakesData.smoothWeight = 1.0;\n                                    flakesData.stochasticWeight = 0.0;\n                                }\n                                flakesData.baseWeight = 1.0 - flakesData.flakesCoverage;\n                            }\t\t\n                            `:`\t\n                            flakesData.stochasticWeight = 0.0;\n\n                            ${B("fullCloseUp")}  = log(DSPBRFLAKES_CLOSE_STO_TRANSITION);\n                            ${B("fullSmooth")}  = log(DSPBRFLAKES_CLOSE_SMOOTH_TRANSITION);\n\n                            ${B("logCellsInFootPrint")}  = log(flakesData.cellsInFootPrint);\n                            flakesData.smoothWeight = smoothstep(fullCloseUp,fullSmooth, logCellsInFootPrint);\t\n                            flakesData.closeupWeight = 0.0;\n                            flakesData.baseWeight = 1.0 - flakesData.flakesCoverage;\n                            if (logCellsInFootPrint < fullSmooth) {\t\t\t\n                                flakesData.closeupFlakesReflect = ${b("contributingCloseFlakes","v3",[T("V"),T("N")])};\n                                if (dot(flakesData.closeupFlakesReflect, flakesData.closeupFlakesReflect) > 0.0) {\n                                    flakesHit = 1.0;\n                                }\n                                if (logCellsInFootPrint < fullCloseUp) {\n                                    flakesData.closeupWeight = flakesHit;\n                                    flakesData.baseWeight = 1.0 - flakesHit;\n                                } else {\n                                    flakesData.closeupWeight = flakesHit * (1.0 - flakesData.smoothWeight);\n                                    flakesData.baseWeight = (1.0 - flakesHit) * (1.0 - flakesData.smoothWeight) + (1.0 - flakesData.flakesCoverage) * flakesData.smoothWeight;\n                                }\t\n                            }\t\t\t\n                            `}\n                    } else {\n                        // emulate layer\n                        flakesData.stochasticWeight = 0.0;\n                        flakesData.closeupWeight = 0.0;\t\n                        flakesData.smoothWeight = 1.0;\n                        flakesData.baseWeight = (1.0 - flakesData.flakesCoverage);\n                    }\n                    `:"\n                    flakesData.stochasticWeight = 0.0;\n                    flakesData.closeupWeight = 0.0;\t\n                    flakesData.smoothWeight = 1.0;\n                    flakesData.baseWeight = (1.0 - flakesData.flakesCoverage);\n                    "}\n                \n\n                ${n.dspbrHemiFlakes?`\n                    flakesData.stochasticHemisphereFlakesNormal = N;\n                    flakesData.stochasticHemisphereFlakesReflect = reflect(V, N);\n                    ${n.dspbrFlakesThreeLayers?`\n                        if (flakesData.stochasticWeight > 0.0) {\n                            flakesData.stochasticHemisphereFlakesReflect = ${b("contributingStochasticHemisphereFlakes","v3",[T("V"),T("N")])};\n                            flakesData.stochasticHemisphereFlakesNormal = normalize(V + flakesData.stochasticHemisphereFlakesReflect);\n                        }                \n                        `:s}\n                    \n                    `:s}\n                if (dot(flakesData.closeupFlakesReflect, N) < 0.0) {\n                    flakesData.closeupFlakesReflect = flakesData.closeupFlakesReflect - 2.0 * dot(flakesData.closeupFlakesReflect, N) * N;\n                }\n                flakesData.closeupFlakesNormal = normalize(V + flakesData.closeupFlakesReflect);\n\n                flakesData.stochasticWeight *= flakesData.flakesCoverage;\n                flakesData.smoothWeight *= flakesData.flakesCoverage;\n\n                ${n.dspbrWithFlipFlopColor?`\n                    flakesData.smoothFlakesColor = flakesData.smoothWeight * ${b("computeFlakesTint","v3",[T("V"),T("N")])};\n                    ${n.dspbrFlakesOneLayer?s:`\n                        flakesData.closeupFlakesColor = flakesData.closeupWeight * ${b("computeFlakesTint","v3",[T("V"),T("flakesData.closeupFlakesNormal")])};    \n                        `}\n                                       \n                    ${n.dspbrHemiFlakes&&n.dspbrFlakesThreeLayers?`flakesData.stochasticHemisphereFlakesColor = flakesData.stochasticWeight * ${b("computeFlakesTint","v3",[T("V"),T("flakesData.stochasticHemisphereFlakesNormal")])};`:s}\n                    `:`\n                    flakesData.smoothFlakesColor = flakesData.smoothWeight * ${b("computeFlakesTint","v3",[])};\n                    ${n.dspbrFlakesOneLayer?s:`\n                        flakesData.closeupFlakesColor = flakesData.closeupWeight * ${b("computeFlakesTint","v3",[])};    \n                        `}                  \n                    ${n.dspbrHemiFlakes&&n.dspbrFlakesThreeLayers?`flakesData.stochasticHemisphereFlakesColor = flakesData.stochasticWeight * ${b("computeFlakesTint","v3",[])};`:s}\n                    `}\n            }\n        `},v=function(o){return`\n            ${e.addTexturableVec3Uniform("flakesColor",o.flakesColorMap)}\n            ${o.flakesColorAddCoef&&o.flakesColorMulCoef?`\n                ${e.addVec3MADs("flakesColor")}\n                `:s}\n            ${e.addTexturableFloatUniform("flakesCoverage",o.flakesCoverageMap)}\n            ${o.flakesCoverageAddCoef&&o.flakesCoverageMulCoef?`\n                ${e.addFloatMADs("flakesCoverage")}\n                `:s}\n            ${e.addTexturableFloatUniform("flakesRoughness",o.flakesRoughnessMap)}\n            ${o.flakesRoughnessAddCoef&&o.flakesRoughnessMulCoef?`\n                ${e.addFloatMADs("flakesRoughness")}\n                `:s}\n            ${e.addTexturableFloatUniform("flakesSize",o.flakesSizeMap)}\n            ${o.flakesSizeAddCoef&&o.flakesSizeMulCoef?`\n                ${e.addFloatMADs("flakesSize")}\n                `:s}\n            ${o.dspbrWithFlipFlopColor?`\n                ${e.addTexturableVec3Uniform("flipFlopColor",o.flipFlopColorMap)}\n                ${o.flipFlopColorAddCoef&&o.flipFlopColorMulCoef?`\n                    ${e.addVec3MADs("flipFlopColor")}\n                    `:s}\n                ${e.addTexturableFloatUniform("flipFlop",o.flipFlopMap)}\n                ${o.flipFlopAddCoef&&o.flipFlopMulCoef?`\n                    ${e.addFloatMADs("flipFlop")}\n                    `:s}\n                `:s}\n            \n            ${n(o)}\n            ${t(o)}\n            ${r(o)}\n            ${i(o)}\n            ${o.dspbrHemiFlakes?a(o):s}\n            ${u(o)}\n        `};Sn=function(n){if(!n.dspbrFlakes)return[s,s,s];const t=e.addPDSFX("INTERNAL_backup_flakesCoverage","flakesCoverageV","ComputeFlakeCoverage",n),r=e.addColorPDSFX("INTERNAL_backup_flakesColor","flakesColorV","ComputeFlakeColor",n.dspbr&&n.gammaInput,n),a=e.addPDSFX("INTERNAL_backup_flakesRoughness","flakesRoughnessV","ComputeFlakeRoughness",n),o=e.addPDSFX("INTERNAL_backup_flakesSize","flakesSizeV","ComputeFlakeSize",n),i=e.addPDSFX("INTERNAL_backup_flipFlop","flipFlopV","ComputeFlipFlop",n),l=e.addColorPDSFX("INTERNAL_backup_flipFlopColor","flipFlopColorV","ComputeFlipFlopColor",n.dspbr&&n.gammaInput,n);let u=`\n                ${e.addFloatParameterResolution("flakesCoverageV","flakesCoverage",n.flakesCoverageMap,n.flakesCoverageAddCoef&&n.flakesCoverageMulCoef,!0,n)} \n                ${t.backup}\n                ${e.addColorParameterResolution("flakesColorV","flakesColor",n.flakesColorMap,n.flakesColorAddCoef&&n.flakesColorMulCoef,n.gammaInput&&!n.flakesColorMapLinear,!0,n)} \n                ${r.backup}\n                ${e.addFloatParameterResolution("flakesRoughnessV","flakesRoughness",n.flakesRoughnessMap,n.flakesRoughnessAddCoef&&n.flakesRoughnessMulCoef,!0,n)}\n                ${a.backup}\n                ${e.addFloatParameterResolution("flakesSizeV","flakesSize",n.flakesSizeMap,n.flakesSizeMulCoef&&n.flakesSizeAddCoef,!0,n)}\n                ${o.backup}\n                ${n.dspbrWithFlipFlopColor?`\n                    ${e.addColorParameterResolution("flipFlopColorV","flipFlopColor",n.flipFlopColorMap,n.flipFlopColorAddCoef&&n.flipFlopColorMulCoef,n.gammaInput&&!n.flipFlopColorMapLinear,!0,n)} \n                    ${l.backup}\n                    ${e.addFloatParameterResolution("flipFlopV","flipFlop",n.flipFlopMap,n.flipFlopAddCoef&&n.flipFlopMulCoef,!0,n)}\n                    ${i.backup}\n                    `:s}            \n            `,c=`\n                ${t.solve}\n                ${r.solve}\n                ${a.solve}\n                flakesRoughnessV = clamp(flakesRoughnessV, 0.036, 0.986);\n                ${o.solve}\n                ${!n.WebGPU&&n.flakesSizeOverriden?`\n                    // hack to stop the compiler from getting rid of flakesSize uniform, it seems to be causing unexpected behavior\n                    flakesSizeV = mix(flakesSizeV, ${V("flakesSize")}, 1e-12);\n                    `:s}\n                ${n.isDecal?`\n                    ${O("oPx")} = ${m.dpdx("dObjectSpacePosition")};\n                    ${O("oPy")} = ${m.dpdy("dObjectSpacePosition")};\n                    `:`\n                    ${O("oPx")} = ${m.dpdx(M("vObjectSpacePosition"))};\n                    ${O("oPy")} = ${m.dpdy(M("vObjectSpacePosition"))};\n                    `}\n                ${n.dspbrWithFlipFlopColor?`\n                    ${l.solve}\n                    ${i.solve}\n                    flipFlopV = max(flipFlopV, 1e-12);\n                    ${b("initFlakesData",null,[T("surfaceData.objectSpacePosition"),T("oPx"),T("oPy"),T("normalize(surfaceData.objectSpaceNormal)"),h("flakesSizeV"),h("flakesCoverageV"),T("flakesColorV"),h("flakesRoughnessV"),h("flipFlopV"),T("flipFlopColorV")])};                \n                    `:`\n                    ${b("initFlakesData",null,[T("surfaceData.objectSpacePosition"),T("oPx"),T("oPy"),T("normalize(surfaceData.objectSpaceNormal)"),h("flakesSizeV"),h("flakesCoverageV"),T("flakesColorV"),h("flakesRoughnessV")])};                \n                    `}\n                ${b("initFlakesWeights",null,[T("surfaceData.view"),T("surfaceData.viewNormal")])};\n            \n            `;return[v(n),c,u]}}{let n=function(n){return`\n\n\n            ${N("Rotate3DForFlakes","v3",[T("iVec"),h("iAngle"),T("iAxe")])}{\n                ${B("s")} = sin(iAngle);\n                ${B("c")} = cos(iAngle);\n                ${B("x")} = iAxe.x;\n                ${B("y")} = iAxe.y;\n                ${B("z")} = iAxe.z;\n    \n                ${H("rot")} = ${H()}(${b("pow2","f",[h("x")])} * (1.0 - c) + c, x * y * (1.0 - c) - z * s, x * z * (1.0 - c) + y * s,\n                                                 x * y * (1.0 - c) + z * s, ${b("pow2","f",[h("y")])} * (1.0 - c) + c, y * z * (1.0 - c) - x * s,\n                                                 x * z * (1.0 - c) - y * s, y * z * (1.0 - c) + x * s, ${b("pow2","f",[h("z")])} * (1.0 - c) + c);\n    \n                return rot * iVec;\n            }   \n\n            ${N("computeMetallicFlakes",null,[v("metallicFlakesPresence"),D("metallicFlakesBaseColor"),h("presenceNoise"),h("presenceNoise2"),h("noisePositive"),h("noiseNegative"),T("T"),T("B")])} {\n                if (length(${V("flakesColorMulCoef")}) < kEpsilon) {\n                    return;\n                }\n                ${B("mfp")} = ${c("metallicFlakesPresence")};\n                mfp = ${en("presenceNoise")};\n                ${B("aux")} = ${en("presenceNoise2")};\n                mfp += mix( - aux, aux, ${V("flakesDensity")});\n\n                mfp *= 5.0;\n                mfp = ${Z("mfp")};\n\n                ${c("metallicFlakesPresence")} = mfp;\n                ${c("metallicFlakesBaseColor")} = mix(2.0 * ${V("flakesColor")}, ${O()}(0.0), ${an("noiseNegative","0.5","1.0")});\n                \n                ${B("theta")}  = mfp * noisePositive* PI * 0.125;\n                ${B("phi")}  =  mfp * noiseNegative * PI * 0.125;\n                metalFlakes.flakesWorldNormal =  ${b("Rotate3DForFlakes","v3",[T("metalFlakes.flakesWorldNormal"),h("theta"),T("B")])};\n                metalFlakes.flakesWorldNormal =  ${b("Rotate3DForFlakes","v3",[T("metalFlakes.flakesWorldNormal"),h("phi"),T("T")])};\n            }\n\n            ${N("blendMetalFlakes",null,[T("currentWorldNormal"),h("flakesMask"),h("metallicFlakesBlending"),h("metallicFlakesPresence"),T("metallicFlakesBaseColor")])}{\n                if (length(${V("flakesColorMulCoef")}) < kEpsilon) {\n                    return;\n                }\n                ${B("metallicFlakesStrength")}  = flakesMask * metallicFlakesPresence;\n\n                ${n.flakesNormalPerturbation?`${B("metalPerturbateNormal")}  = 0.1 * ${V("flakesBump")};`:`${B("metalPerturbateNormal")}  = 0.0;`}\n\n                metalFlakes.flakesRoughness = 1.0 - mix(0.75,0.55,${V("flakesRoughness")});\n                metal.flakesRoughness = metalFlakes.flakesRoughness + metalPerturbateNormal;\n\n                metal.flakesSR0Color = ${V("flakesColorMulCoef")} * metallicFlakesBlending * ${V("flakesColor")};\n                metalFlakes.flakesSR0Color = ${V("flakesColorMulCoef")} * metallicFlakesBaseColor * metallicFlakesStrength;\n\n                metalPerturbateNormal *= 10.0 * flakesMask;\n                metalFlakes.flakesWorldNormal = normalize(currentWorldNormal + metalPerturbateNormal * metalFlakes.flakesWorldNormal);\n\n            }\n        `},e=function(n){return`\n            ${N("computePearlFlakes",null,[v("pearlFlakesPresence"),D("pearlFlakesBaseColor"),h("presenceNoise"),h("presenceNoise2"),h("noisePositive"),h("noiseNegative"),T("T"),T("B")])} {\n                if (length(${V("pearlFlakesColorMulCoef")}) < kEpsilon) {\n                    return;\n                }\n                ${B("pfp")} = ${c("pearlFlakesPresence")};\n                pfp = ${nn(`${tn("presenceNoise2")}`)};\n                ${B("aux")}  = ${nn(`${tn("presenceNoise")}`)};\n                pfp += mix( - aux, aux, ${V("pearlFlakesDensity")});\n\n                pfp *= 6.0;\n                pfp = ${Z("pfp")};\n\n                ${c("pearlFlakesPresence")} = pfp;\n                ${c("pearlFlakesBaseColor")} = mix(2.0 * ${V("pearlFlakesColor")}, ${O()}(0.0), ${an("noisePositive","0.5","1.0")});\n                \n                ${B("theta")}  = pfp * noisePositive * PI * 0.25;\n                ${B("phi")}  =  pfp * noiseNegative * PI * 0.25;\n                pearlFlakes.flakesWorldNormal =  ${b("Rotate3DForFlakes","v3",[T("pearlFlakes.flakesWorldNormal"),h("theta"),T("B")])};\n                pearlFlakes.flakesWorldNormal =  ${b("Rotate3DForFlakes","v3",[T("pearlFlakes.flakesWorldNormal"),h("phi"),T("T")])};\n            }\n\n            ${N("blendPearlFlakes",null,[T("currentWorldNormal"),h("flakesMask"),h("pearlFlakesPresence"),T("pearlFlakesBaseColor")])}{\n                if (length(${V("pearlFlakesColorMulCoef")}) < kEpsilon) {\n                    return;\n                }\n                ${B("pearlFlakesStrength")}  = flakesMask * pearlFlakesPresence;\n                ${n.flakesNormalPerturbation?`${B("pearlPerturbateNormal")}  = 0.05 * ${V("pearlFlakesBump")};`:`${B("pearlPerturbateNormal")} = 0.0;`}\n\n                pearlFlakes.flakesRoughness = 0.25;\n\n                pearlFlakes.flakesSR0Color = ${V("pearlFlakesColorMulCoef")} * pearlFlakesBaseColor * pearlFlakesStrength;\n\n                pearlPerturbateNormal *= 10.0 * sqrt(flakesMask);\n                pearlFlakes.flakesWorldNormal = normalize(currentWorldNormal + pearlPerturbateNormal * pearlFlakes.flakesWorldNormal);\n            }\n        `},t=function(n){return`\n            ${N("flakesVisibility",null,[v("flakesLODLevel"),v("metallicFlakesBlending"),v("flakesMask"),h("scaling")])}{\n                ${n.defaultInstancing?`\n                    ${H("mat")}  = ${b("transposeMatrix","m3",[$("m4","(modelMatrix * multipliedDefaultInstancingMatrix)")])};\n                    `:`\n                    ${H("mat")}  = ${b("transposeMatrix","m3",[$("m4","(modelMatrix)")])};\n                    `}   \n                ${O("worldScaling")}  = 1.0/${O()}(length(mat[0]),length(mat[1]),length(mat[2]));\n                ${B("dist")}  = length(worldScaling * surfaceData.viewPosition);\n                ${B("NdotV")}  = dot(surfaceData.viewNormal, surfaceData.view);\n                if (NdotV <= 0.0) {\n                    ${c("flakesLODLevel")} = 0.0;\n                    ${c("metallicFlakesBlending")} = 0.0;\n                    ${c("flakesMask")} = 0.0;\n                    return;\n                }\n                ${B("normDist")}  = ${Z("scaling * dist * 0.00125")};\n                ${B("shortDist")}  = 1.0 - normDist;\n                ${c("flakesLODLevel")} = scaling * dist;\n                ${n.advancedFlakesBlending?`${c("metallicFlakesBlending")} = normDist * (0.5 * ${V("flakesDensity")} + 0.25);`:`${c("metallicFlakesBlending")} = normDist * 0.5;`}\n                ${c("flakesMask")} = shortDist;\n            }\n        \n            ${N("doFlakes",null,[])}{\n                ${O("currentWorldNormal")}  = surfaceData.worldNormal;\n                ${B("flakesMask")}  = 0.0;\n                ${B("flakesLODLevel")}  = 0.0;\n                ${B("scaling")}  = mix(0.0, 0.9, atan(PI*${V("flakesScale")})*2.0*INV_PI);\n                ${O("T")}  = ${b("getGeomT","v3",[T("currentWorldNormal")])};\n                ${O("B")}  = ${b("getGeomB","v3",[T("currentWorldNormal"),T("T")])};\n\n                ${B("metallicFlakesBlending")}  = 0.0;\n                ${B("metallicFlakesPresence")}  = 0.0;\n                ${O("metallicFlakesBaseColor")}  = ${O()}(0.0);\n\n                metal.flakesRoughness = 0.0;\n                metal.flakesSR0Color = ${O()}(0.0);\n                metal.flakesWorldNormal = currentWorldNormal;\n\n                metalFlakes.flakesRoughness = 0.0;\n                metalFlakes.flakesSR0Color = ${O()}(0.0);\n                metalFlakes.flakesWorldNormal = currentWorldNormal;\n\n                ${B("pearlFlakesPresence")}  = 0.0;\n                ${O("pearlFlakesBaseColor")}  = ${O()}(0.0);\n\n                ${n.pearlFlakesActivated?`\n                    pearlFlakes.flakesRoughness = 0.0;\n                    pearlFlakes.flakesSR0Color = ${O()}(0.0);\n                    pearlFlakes.flakesWorldNormal = currentWorldNormal;\n                    `:s}\n\n                ${b("flakesVisibility",null,[g("flakesLODLevel"),g("metallicFlakesBlending"),g("flakesMask"),h("scaling")])};\n\n                if (length(${V("pearlFlakesColorMulCoef")}) < kEpsilon && length(${V("flakesColorMulCoef")}) < kEpsilon) {\n                    return;\n                }\n\n                if (flakesMask < kEpsilon) {\n                    ${b("blendMetalFlakes",null,[T("currentWorldNormal"),h("flakesMask"),h("metallicFlakesBlending"),h("metallicFlakesPresence"),T("metallicFlakesBaseColor")])};\n                    ${n.pearlFlakesActivated?`\n                        ${b("blendPearlFlakes",null,[T("currentWorldNormal"),h("flakesMask"),h("pearlFlakesPresence"),T("pearlFlakesBaseColor")])};\n                        `:s}\n                    return;\n                }\n\n                ${O("tex")}  = scaling * surfaceData.objectSpacePosition;\n                tex.y = -abs(tex.y);\n                tex.x = -abs(tex.x);\n\n                ${n.flakesNormalPerturbation?`\n                    ${B("noisePositive")}  = ${on("0.85 * tex","flakesLODLevel","FLAKES_FREQUENCY","1.0","2.0")};\n                    ${B("noiseNegative")}  = ${on("0.85 * tex.yxz","flakesLODLevel","FLAKES_FREQUENCY","1.0","2.0")};\n                    `:`\n                    ${B("noisePositive")} = 0.0;\n                    ${B("noiseNegative")} = 0.0;\n                    `}\n                ${B("fbm1")}  = ${on("tex","flakesLODLevel","FLAKES_FREQUENCY","1.0","3.0")};\n                ${B("presenceNoise")}  = ${an("fbm1","0.5","1.0")};\n\n                ${n.advancedPresenceNoise?`\n                    ${B("fbm2")}  = ${on("tex.yxz","flakesLODLevel","FLAKES_FREQUENCY","1.0","3.0")};\n                    ${B("presenceNoise2")}  = ${an("fbm2","0.5","1.0")};\n                    `:`${B("presenceNoise2")}  = 0.0;`}\n\n                ${b("computeMetallicFlakes",null,[g("metallicFlakesPresence"),C("metallicFlakesBaseColor"),h("presenceNoise"),h("presenceNoise2"),h("noisePositive"),h("noiseNegative"),T("T"),T("B")])};\n                ${b("blendMetalFlakes",null,[T("currentWorldNormal"),h("flakesMask"),h("metallicFlakesBlending"),h("metallicFlakesPresence"),T("metallicFlakesBaseColor")])};\n                ${n.pearlFlakesActivated?`\n                    ${b("computePearlFlakes",null,[g("pearlFlakesPresence"),C("pearlFlakesBaseColor"),h("presenceNoise"),h("presenceNoise2"),h("noisePositive"),h("noiseNegative"),T("T"),T("B")])};\n                    ${b("blendPearlFlakes",null,[T("currentWorldNormal"),h("flakesMask"),h("pearlFlakesPresence"),T("pearlFlakesBaseColor")])};\n                    `:s}\n            }\n        `},r=function(r){return`\n            ${w({uniformName:"flakesColor",uniformType:"v3"})}\n            ${w({uniformName:"flakesDensity",uniformType:"f"})}\n            ${w({uniformName:"flakesBump",uniformType:"f"})}\n            ${w({uniformName:"flakesColorMulCoef",uniformType:"v3"})}\n            ${w({uniformName:"flakesColorAddCoef",uniformType:"v3"})}\n            ${w({uniformName:"pearlFlakesColor",uniformType:"v3"})}\n            ${w({uniformName:"pearlFlakesDensity",uniformType:"f"})}\n            ${w({uniformName:"pearlFlakesBump",uniformType:"f"})}\n            ${w({uniformName:"pearlFlakesColorMulCoef",uniformType:"v3"})}\n            ${w({uniformName:"pearlFlakesColorAddCoef",uniformType:"v3"})}\n            ${w({uniformName:"flakesRoughness",uniformType:"f"})}\n            ${w({uniformName:"flakesScale",uniformType:"f"})}\n         \n            ${W("FLAKES_FREQUENCY")} = 0.6;\n\n            \n            ${o.createStruct({structName:"flakes",attributes:[{type:"f",name:"flakesRoughness"},{type:"v3",name:"flakesSR0Color"},{type:"v3",name:"flakesWorldNormal"},{type:"v3",name:"flakesNormal"}]})}\n            ${o.struct({name:"metal",structName:"flakes",addressSpace:"private"})};\n            ${o.struct({name:"metalFlakes",structName:"flakes",addressSpace:"private"})};\n            ${o.struct({name:"pearlFlakes",structName:"flakes",addressSpace:"private"})};\n            \n            ${n(r)}\n            ${e(r)}\n            ${t(r)}\n        `},a=function(n){return`      \n            ${b("doFlakes",null,[])};\n            metalFlakes.flakesNormal = normalize((${F("viewMatrix")}* (${G()}(metalFlakes.flakesWorldNormal, 0.0))).xyz);\n            metal.flakesNormal = surfaceData.viewNormal;\n            ${n.pearlFlakesActivated?`pearlFlakes.flakesNormal = normalize((${F("viewMatrix")} * (${G()}(pearlFlakes.flakesWorldNormal, 0.0))).xyz);`:s}\n        `};yn=function(n){return n.specGlossFlakes?[r(n),a(n),s]:[s,s,s]}}return _n=function(n){if(!n.thickness)return[s,s,s];const t=`\n                ${e.addTexturableFloatUniform("thickness",n.thicknessMap)}\n                ${n.thicknessAddCoef&&n.thicknessMulCoef?e.addFloatMADs("thickness"):s}\n            `,r=e.addPDSFX("INTERNAL_backup_thickness","surfaceData.thickness","ComputeThickness",n),a=`\n                ${e.addFloatParameterResolution("surfaceData.thickness","thickness",n.thicknessMap,n.thicknessAddCoef&&n.thicknessMulCoef,!1,n)}   \n                ${r.backup}\n            `;return[t,`\n                ${r.solve}\n                if (materialData.ior <= 1.0 + 1e-6 || surfaceData.thickness <= 1e-6) {\n                    materialData.adjustedIoR = 1.0;\n                } else {\n                    ${O("dummyT")}  = ${b("getGeomT","v3",[T("surfaceData.worldNormal")])};\n                    ${O("dummyB")}  = ${b("getGeomB","v3",[T("surfaceData.worldNormal"),T("dummyT")])};\n                    ${O("dummyVector")}  = normalize(surfaceData.worldNormal + dummyB + dummyT);\n                    ${O("refractVec")}  = refract(-dummyVector, surfaceData.worldNormal, 1.0/materialData.ior);\n                    ${B("sin1")}  = sqrt(1.0 - ${Q("dot(-dummyVector, surfaceData.worldNormal)")});\n                    refractVec = normalize(-dummyVector + (refractVec * surfaceData.thickness));\n                    ${B("sin2")}  = sqrt(1.0 - ${Q("dot(refractVec, surfaceData.worldNormal)")});\n                    materialData.adjustedIoR = max(abs(sin1), 1e-12) / max(abs(sin2), 1e-12);\n                }\n            `,a]},Tn=function(n){if(!n.iridescence)return[s,s,s];const t=`\n                ${w({uniformName:"iridescenceIoR",uniformType:"f"})}\n                ${e.addTexturableFloatUniform("iridescence",n.iridescenceMap)}\n                ${n.iridescenceAddCoef&&n.iridescenceMulCoef?e.addFloatMADs("iridescence"):s}\n                ${e.addTexturableFloatUniform("iridescenceThickness",n.iridescenceThicknessMap)}\n                ${n.iridescenceThicknessAddCoef&&n.iridescenceThicknessMulCoef?e.addFloatMADs("iridescenceThickness"):s}\n            `,r=e.addPDSFX("INTERNAL_backup_iridescence","materialData.iridescence","ComputeIridescence",n),a=e.addPDSFX("INTERNAL_backup_iridescenceThickness","materialData.iridescenceThickness","ComputeIridescenceThickness",n),o=`\n                materialData.iridescenceIoR = ${V("iridescenceIoR")};\n                ${e.addFloatParameterResolution("materialData.iridescence","iridescence",n.iridescenceMap,n.iridescenceAddCoef&&n.iridescenceMulCoef,!1,n)}\n                ${r.backup}\n                ${e.addFloatParameterResolution("materialData.iridescenceThickness","iridescenceThickness",n.iridescenceThicknessMap,n.iridescenceThicknessAddCoef&&n.iridescenceThicknessMulCoef,!1,n)}\n                ${a.backup}\n            `;return[t,`\n                ${r.solve}\n                ${a.solve}\n                if (materialData.iridescenceThickness < 1e-12) {\n                    materialData.iridescence = 0.0;\n                }\n                materialData.iridescenceSR0Color = materialData.sr0Color;\n                ${B("iridescenceEnergyCorrection")} = 0.0;\n                if (materialData.iridescence > 0.0) {\n                    // multiply materialData.iridescenceSR0Color by specFactor to make thin film depend on specular\n                    //${B("specFactor")} = mix(materialData.specularContribution, 1.0, materialData.metalness);\n                    // We omit the coloration, to add back color, use materialData.specularBlendingSR0 as baseSr0Color\n                    ${O("baseSr0Color")} = ${O()}(1.0) * mix(materialData.F0, dot(albedo, luminanceVector), materialData.metalness);\n                    ${O("baseSr90Color")} = ${O()}(1.0);\n                    ${G("fresnelIridescence")}  = ${b("ComputeIridescenceFresnel","v4",[h("1.0"),h("materialData.iridescenceIoR"),T("baseSr0Color"),h("materialData.iridescenceThickness * 1e3"),h("NoV")])};\n                    materialData.iridescenceSR0Color =  ${b("F0FromFresnelSchlick","v3",[T("fresnelIridescence.xyz"),T("baseSr90Color"),h("NoV")])};\n                    // Blending\n                    materialData.sr0Color = mix(materialData.sr0Color, materialData.iridescenceSR0Color, materialData.iridescence);\n                    materialData.sr90Color = mix(materialData.sr90Color, baseSr90Color, materialData.iridescence);\n                    materialData.specularBlendingSR0 = mix(materialData.specularBlendingSR0, materialData.iridescenceSR0Color, materialData.iridescence);\n                    // Energy\n                    ${B("iridescenceF0")} = ${Q("(materialData.iridescenceIoR - 1.0)/(materialData.iridescenceIoR + 1.0)")};\n                    iridescenceEnergyCorrection = 1.0 - mix(fresnelIridescence.w, ${b("AverageMultipleFresnel","f",[h("iridescenceF0")])}, 1.0 - ${en("1.0 - materialData.roughness * materialData.roughness")});\n                    iridescenceEnergyCorrection *= (1.0 - ${Z("materialData.iridescenceIoR - 1.5")} * 0.15);\n                }\n            `,o]},{getUniformShaders:function(n,e){let t=un(e),r=mn(e,n),a=$n(e),o=pn(e),i=dn(e),l=fn(e),u=hn(e),m=vn(e),c=gn(e),p=xn(e),d=Sn(e),f=yn(e),v=_n(e),g=Tn(e),x=cn(e),y=`\n                ${r[0]}\n                ${t[0]}\n                ${o[0]}\n                ${i[0]}\n                ${x[0]}\n                ${l[0]} \n                ${u[0]}   \n                ${m[0]}   \n                ${a[0]}  \n                ${c[0]}\n                ${p[0]}\n                ${d[0]}\n                ${f[0]}\n                ${v[0]}\n                ${g[0]}\n                ${w({uniformName:"ior",uniformType:"f"})}\n            `,_=s;e.dspbr&&n&&(_=e.vrDevice?`\n                    materialData.specularEnergyConservationConstant =  ${O()}(0.0);\n                    materialData.diffuseEnergyConservationConstant = 1.0;    \n                    `:`\n                    // Specular\n                    ${B("averageDirectionalMultipleAlbedo")} = ${b("AverageDirectionalMultipleAlbedo","f",[h("materialData.roughness")])};\n                    ${O("averageMultipleFresnel")} = ${b("AverageMultipleFresnel","v3",[T("materialData.sr0Color"),T("materialData.sr90Color")])};\n                    ${B("multipleScatteringGGX")} = ${Q(`1.0 - ${b("DirectionalMultipleAlbedo","f",[h("NoV"),h("materialData.roughness")])}`)}/max(1.0 - averageDirectionalMultipleAlbedo, 1e-6);\n                    ${O("multipleScatteringFresnel")} = (averageMultipleFresnel * averageMultipleFresnel * averageDirectionalMultipleAlbedo)/max(1.0 - averageMultipleFresnel * (1.0 - averageDirectionalMultipleAlbedo), ${O()}(1e-6));\n                    materialData.specularEnergyConservationConstant =  multipleScatteringGGX * multipleScatteringFresnel;\n                    // Diffuse\n                    ${B("directionalAlbedo")} = ${b("DirectionalAlbedo","f",[h("materialData.F0"),T("materialData.specularTint"),h("NoV"),h("materialData.roughness")])};\n                    ${B("averageDirectionalAlbedo")} = ${b("AverageDirectionalAlbedo","f",[h("materialData.F0"),T("materialData.specularTint"),h("materialData.roughness")])};\n                    materialData.diffuseEnergyConservationConstant = ${Q("1.0 - directionalAlbedo")} / max(1.0 - averageDirectionalAlbedo, 1e-6);   \n                    materialData.diffuseEnergyConservationConstant = mix(1.0, materialData.diffuseEnergyConservationConstant, materialData.specularContribution); \n                    ${e.iridescence?`\n                        //${B("directionalIridescenceAlbedo")} = ${b("DirectionalAlbedo","f",[T("materialData.iridescenceSR0Color"),h("NoV"),h("materialData.roughness")])};\n                        //${B("averageDirectionalIridescenceAlbedo")} = ${b("AverageDirectionalAlbedo","f",[T("materialData.iridescenceSR0Color"),h("materialData.roughness")])};\n                        //materialData.diffuseEnergyConservationConstant = mix(materialData.diffuseEnergyConservationConstant, ${Q("1.0 - directionalIridescenceAlbedo")} / max(1.0 - averageDirectionalIridescenceAlbedo, 1e-6), materialData.iridescence);\n                        materialData.diffuseEnergyConservationConstant = mix(materialData.diffuseEnergyConservationConstant, iridescenceEnergyCorrection, materialData.iridescence); \n                        `:s}\n                    // Use this one if thin film must depend on specular\n                    //materialData.diffuseEnergyConservationConstant = mix(1.0, materialData.diffuseEnergyConservationConstant, materialData.specularContribution);\n                 `);const D=e.PDSFX?"INTERNAL_computed_viewPosition":M("vViewPosition");let C=`\n                materialData.ior = ${V("ior")};\n                ${e.PDSFX?`\n                    INTERNAL_IOR = ${e.specgloss?"1e12":"materialData.ior"};\n                    `:s}\n                materialData.adjustedIoR = materialData.ior;\n                ${v[2]}\n                ${t[2]}\n                ${o[2]}\n                ${c[2]}\n                ${i[2]}\n                ${x[2]}\n                ${l[2]} \n                ${u[2]}   \n                ${m[2]}   \n                ${p[2]}\n                ${d[2]}\n                ${f[2]}\n                ${g[2]}\n                ${a[2]}\n            `;return[y,`\n                \n                if (${F("projectionMatrix")}[3][3] > 0.5) {\n                    surfaceData.view = ${O()}(0.0,0.0,1.0);\n                } else {\n                    ${e.isDecal?"surfaceData.view = normalize( dViewPosition);":`surfaceData.view = normalize( ${D} );`}\n                }\n\n                ${e.isDecal?"\n                    surfaceData.worldPosition = dWorldPosition;\n                    surfaceData.viewPosition = dViewPosition;\n                    ":`\n                    surfaceData.viewPosition = ${D};\n                    surfaceData.worldPosition = ${M("vWorldPosition")};\n                    `}\n                ${O("vPos")}  = surfaceData.viewPosition;\n\n                ${e.needObjectSpaceData?`\n                    surfaceData.objectSpacePosition = ${M("vObjectSpacePosition")};\n                    surfaceData.objectSpaceNormal = ${M("vObjectSpaceNormal")} ;\n                    ${e.isDecal?"\n                        surfaceData.objectSpacePosition = dObjectSpacePosition;\n                        surfaceData.objectSpaceNormal = dObjectNormal;\n                        ":""}\n                    `:""}\n\n                ${r[1]}\n                ${v[1]}\n                ${t[1]}\n                ${o[1]}\n                ${c[1]}\n                ${i[1]}\n                ${x[1]}\n                ${l[1]}\n                ${u[1]}\n                ${m[1]}\n                ${p[1]}\n                ${d[1]}\n                ${f[1]}\n                ${e.useSpecularAA?`             \n                    surfaceData.TForSpecularAA = ${b("getGeomT","v3",[T("viewNormal")])};\n                    surfaceData.BForSpecularAA = ${b("getGeomB","v3",[T("viewNormal"),T("surfaceData.TForSpecularAA")])};\n                    //surfaceData.TBNMatrixForSpecularAA = ${b("transposeMatrix","m3",[$("m3",`${H()}(surfaceData.TForSpecularAA, surfaceData.BForSpecularAA, viewNormal)`)])};\n                    `:s}\n\n                ${e.shadowMapDebugMaterial?`\n\t\t\t\t\talbedo = ${O()}(1.0);\n\t\t\t\t\tmaterialData.specularContribution = 0.0;\n\t\t\t\t\tmaterialData.metalness = 0.0;\n\t\t\t\t\t`:s}\n  \n                ${e.specgloss?`\n                    materialData.F0 = 1.0;\n                    materialData.specularBlendingSR0 = materialData.specularTint;\n                    materialData.sr0Color = materialData.specularBlendingSR0;\n                    materialData.sr90Color = ${O()}(1.0);\n                    `:`\n                    materialData.F0 = ${Q("(materialData.ior - 1.0)/(materialData.ior + 1.0)")};\n                    materialData.specularBlendingSR0 = materialData.F0 * materialData.specularTint;\n                    materialData.sr0Color = mix(materialData.specularBlendingSR0 * materialData.specularContribution, albedo, materialData.metalness);\n                    materialData.sr90Color = ${O()}(1.0) * ((1.0-materialData.metalness)*materialData.specularContribution + materialData.metalness);\n                    `}\n                ${g[1]}\n                ${a[1]}           \n                ${e.specgloss?"\n                    materialData.diffuseColor = albedo;\n                    materialData.transparentColor = albedo;\n                    ":"\n                    materialData.diffuseColor = albedo * (1.0 - materialData.metalness) * (1.0 - materialData.transparency);\t\n                    materialData.transparentColor = albedo * (1.0 - materialData.metalness) * materialData.transparency;\n                    "}\n                ${e.dspbrWithTranslucency?e.dspbrWithTranslucencyColor?"materialData.translucencyColor *= (1.0 - materialData.metalness) * (1.0 - materialData.transparency);":"materialData.translucencyColor = materialData.diffuseColor;":s}\n\n                ${e.useSpecularAA?`\n                    //${H("TBNRough")} = surfaceData.TBNMatrixForSpecularAA;\n                    ${O("HtbnRough")}  = reflect(surfaceData.view, surfaceData.viewNormal);\n                    ${k("roughnesses")} = ${k()}(materialData.roughness, materialData.roughness);\n                    roughnesses = ${b("AxisAlignedNDFFiltering","v2",[T("HtbnRough"),S("roughnesses")])};\n                    materialData.roughnessAACorrected = length(roughnesses);\n                    `:s}\n                \n                ${e.clearCoat&&e.useSpecularAA?`\n                    //${H("TBNRoughCC")} = surfaceData.TBNMatrixForSpecularAA;\n                    ${O("HtbnRoughCC")}  = reflect(surfaceData.view, surfaceData.clearCoatNormal);\n                    ${k("ccRoughnesses")} = ${k()}(materialData.clearCoatRoughness, materialData.clearCoatRoughness);\n                    ccRoughnesses = ${b("AxisAlignedNDFFiltering","v2",[T("HtbnRoughCC"),S("ccRoughnesses")])};\n                    materialData.clearCoatRoughnessAACorrected = length(ccRoughnesses);\n                    `:s}\n\n                ${_}\n            `,C]}}})),define("DS/ShaderBuilders/PBRUtils/PBRFragmentShaderBuilderUtils",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PBRUtils/PBRFragmentAnalyticalLightsShaderBuilderUtils","DS/ShaderBuilders/PBRUtils/PBRFragmentIBLShaderBuilderUtils","DS/ShaderBuilders/PBRUtils/PBRFragmentEquationsShaderBuilderUtils","DS/ShaderBuilders/PBRUtils/PBRFragmentUniformsShaderBuilderUtils","DS/ShaderBuilders/ShaderUtils/AttributeUtils","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a,o,i,s,l,u){"use strict";const m="",c=l.ParameterUtils,$=l.FunctionHandler,p=l.BridgeFunctions,d=n=>u.dereference(n),f=(n,e)=>c.parameter(n,e),h=n=>c.parameterF(n),v=n=>c.parameterI(n),g=n=>c.parameterV2(n),x=n=>c.parameterV3(n),S=n=>c.parameterInOutV3(n),y=n=>c.parameterRefV3(n),_=n=>c.parameterV4(n),T=(n,e,t)=>$.declareFunction(n,e,t),D=(n,e,t)=>$.callFunction(n,e,t),C=(n,e)=>e.mappingFromMatApp?(n=>{var e={uniformName:n};return i.getHighFrequencyUniform(e)})(n):(n=>{var e={uniformName:n};return i.getUniform(e)})(n),P=n=>i.addGlobalUniform(n),N=n=>{var e={uniformName:n};return i.getGlobalUniform(e)},b=n=>{var e={uniformName:n};return i.getGlobalTextureUniform(e)},M=n=>i.addObjectUniform(n),U=n=>{var e={uniformName:n};return i.getObjectUniform(e)},w=n=>{var e={uniformName:n};return i.getShadowUniform(e)},V=n=>s.addVarying(n),z=n=>s.getVarying(n,s.ShaderStages.in),F=(n=null)=>{var e={name:n};return u.int(e)},I=(n=null,e="")=>{var t={name:n,addressSpace:e};return u.float(t)},R=(n=null,e="")=>{var t={name:n,addressSpace:e};return u.vec2(t)},A=(n=null,e=0)=>{var t={name:n,size:e};return u.vec3(t)},L=(n=null,e=0)=>{var t={name:n,size:e};return u.vec4(t)},B=(n=null)=>{var e={name:n};return u.mat3(e)},E=n=>{var e={name:n,constant:!0};return u.float(e)},k=(n,e)=>p.sample2DTexture(n,e),O=(n,e)=>p.atan2(n,e);let G=function(e){return`\n                ${P({uniformName:"currentNormalStencilDepth",uniformType:"t2"})}    \n                ${P({uniformName:"currentTexCoord",uniformType:"t2"})} \n                ${e.renderToFloatTexture?m:P({uniformName:"currentRGBADepth",uniformType:"t2"})}\n                ${M({uniformName:"decalExplicitUv",uniformType:"i"})} \n                ${M({uniformName:"decalDepthOffset",uniformType:"f"})} \n                ${M({uniformName:"modelViewInvMatrix",uniformType:"m4"})} \n                ${P({uniformName:"viewInfo",uniformType:"v2"})}    \n                ${M({uniformName:"decalStencilValue",uniformType:"f"})}    \n\n                ${V({varyingName:"decalPositionVS",varyingType:"v4"})}\n                ${V({varyingName:"decalPositionCS",varyingType:"v4"})}\n\n                ${((n=null)=>I(n,"private"))("_decalDepth")};\n                \n                ${T("getEyeDepthPers","f",[h("iZClipSpace")])}{\n                    ${R("nearFar")}  = ${N("viewInfo")};\n                    return (2.0 *nearFar.x * nearFar.y) / (nearFar.y + nearFar.x - iZClipSpace * (nearFar.y - nearFar.x));\n                }\n\n                ${T("getEyeDepthOrtho","f",[h("iZClipSpace")])}{\n                    ${R("nearFar")}  = ${N("viewInfo")};\n                    return 0.5 * ((nearFar.y - nearFar.x) * iZClipSpace + nearFar.y + nearFar.x);\n                }\n\n                ${T("noBoxTest","v3",[h("depth"),(a="dUv",c.parameterInOutV2(a)),S("dObjectSpacePosition"),_("decalPosition")])} {\n                    ${L("nMVPosition")} ;\n                    if (${N("projectionMatrix")}[3][3] > 0.5) {\n                        ${I("viewDepth")}  = ${D("getEyeDepthOrtho","f",[h("2.0*depth-1.0")])};\n                        ${A("viewRay")}  = ${A()}(0.0, 0.0, -1.0);\n                        ${A("origin")}  = ${A()}(decalPosition.xy, 0.0);\n                        nMVPosition = ${L()}(origin + viewRay * viewDepth,1.0);\n                    } else {\n                        ${I("viewDepth")} = ${D("getEyeDepthPers","f",[h("2.0*depth-1.0")])};\n                        ${A("viewRay")} = (decalPosition.xyz  / -decalPosition.z);\n                        nMVPosition = ${L()}(viewRay * viewDepth,1.0);\n                    }\n                    ${L("pos")}  = (${U("modelViewInvMatrix")} * nMVPosition);\n                    ${d("dObjectSpacePosition")} = pos.xyz;\n                    pos.x /= pos.w;\n                    pos.y /= pos.w;\n                    pos.z /= pos.w;\n                    ${d("dUv")} = pos.xy;\n                    ${I("depthToUse")}  = depth;\n                    ${I("dDecalx")}  = ${p.dpdx("depth")};\n                    ${I("dDecaly")}  = ${p.dpdy("depth")};\n                    ${I("slope")} = sqrt(dDecalx*dDecalx + dDecaly*dDecaly);\n                    ${I("factor")} = ${U("decalDepthOffset")};\n                    ${e.mobileDevice?`\n                        ${I("depthDelta")} = (4.0 + factor) * (slope + DEPTH_PRECISION);\n                        `:`\n                        ${I("depthDelta")} = (2.0 + factor) * (min(slope, 5.0 * DEPTH_PRECISION) + DEPTH_PRECISION);\n                        `}\n                    ${e.materialToUse===n.MaterialToUse.transparentShadowMaterial||e.materialToUse===n.MaterialToUse.shadowMaterial?"depthToUse += depthDelta;":"depthToUse -= depthDelta;"}\n                    \n                    if (any(${t="abs(pos.xyz)",r=`${A()}(.5)`,p.greaterThan(t,r)})){\n                         discard;\n                    }\n                    ${e.shadowMapEnabled?`\n                        for( ${F("i")} = 0; i < ${e.maxShadows}; i ++ ) {\n                            gShadowCoord[ i ] = ${D("computeShadowCoord","v4",[x("pos.xyz"),f("m4",`${w("shadowMatrix")}[i]`),x(`${w("shadowCameraPosition")}[i].xyz`),x(`${w("lowPartShadowCameraPosition")}[i].xyz`)])};\n                        }\n                        `:m}\n                    _decalDepth = depthToUse;\n                    return -nMVPosition.xyz;\n                }\n        `;var t,r,a},H=function(n){return`\n            ${R("screenPos")}  = ${z("decalPositionCS")}.xy/${z("decalPositionCS")}.w;\n            ${R("decalFetchUv")}  = 0.5*${R()}(screenPos.x, screenPos.y) + 0.5;\n            ${p.uvConvention("decalFetchUv")}\n            ${L("normalStencilDepthValue")}  = ${k(b("currentNormalStencilDepth"),"decalFetchUv")};\n            if (floor(normalStencilDepthValue.z + 0.5) - ${U("decalStencilValue")}  < 0.0) {\n                discard;\n            }\n            ${A("decalNormal")}  = ${D("decodeOct22Normal","v3",[g("normalStencilDepthValue.xy")])};\n            ${A("dObjectNormal")}  = normalize((${U("modelViewInvMatrix")}  * ${L()}(decalNormal, 0.0)).xyz);\n            ${R("dUv")} ;\n            ${A("dObjectSpacePosition")} ;\t\t\n            ${n.renderToFloatTexture?`              \n                ${I("decalDepth")}  = normalStencilDepthValue.w;\n                `:`\n                ${I("decalDepth")} = ${D("unpackRGBA","f",[_(`${k(b("currentRGBADepth"),"decalFetchUv")}`)])};\n                `}\n            ${A("dViewPosition")}  = ${D("noBoxTest","v3",[h("decalDepth"),(e="dUv",c.parameterRefV2(e)),y("dObjectSpacePosition"),_(z("decalPositionVS"))])};        \n            ${2===n.WebGLVersion||n.WebGPU?`${(n=>s.getShaderOutput(n))("fragDepth")} = _decalDepth;`:n.extFragDepth?"gl_FragDepthEXT = _decalDepth;":m}\n            ${R("dUv2")}  = dUv;\n            if (${U("decalExplicitUv")} > 0) {\n                ${L("currentTexCoordsFetch")}  = ${k(b("currentTexCoord"),"decalFetchUv")};\n                dUv = currentTexCoordsFetch.xy;\n                dUv2 = currentTexCoordsFetch.zw;\n            }\n            ${A("dWorldPosition")}  =  ${D("getModelTransformation","v4",[_(`${L()}(dObjectSpacePosition, 1.0)`)])}.xyz;\n            ${n.shadowMapCubeEnabled?"decalShadowCubeWorldPosition = dWorldPosition;":m}\n    `;var e},X=function(n){return`   \n            ${n.useUV?`\n                ${n.isDecal?"\n                    uvToUse = dUv;\n                    uv2ToUse = dUv2;\n                    ":`\n                    uvToUse = ${z("vUv")}.xy;\n                    ${o._useUv2(n)?`uv2ToUse = ${z("vUv2")}.xy`:m};\n                    `}\n                ${n.lightMap?`\n                    ${R("lightMapUV")} = uvToUse;\n                    if (${U("lightMapUvSlot")} != 1) {\n                        lightMapUV = uv2ToUse;\n                    }   \n                    ${n.lightMapMappingType>-1?`\n                        ${n.isDecal?`\n                            lightMapUV = ${D("applyMappingOperator","v2",[g("lightMapUV"),x("dObjectSpacePosition"),x("dObjectNormal"),v(`${U("lightMapMappingType")}`)])};\n                            `:`\n                            lightMapUV = ${D("applyMappingOperator","v2",[g("lightMapUV"),x(z("localPosition")),x(z("localNormal")),v(`${U("lightMapMappingType")}`)])};\n                            `}\n                        `:m}\n                    lightMapUV = ${D("applyLightMapUVCombination","v2",[g("lightMapUV"),f("m3",`${U("lightMapUvTransform")}`)])};\n                    `:m}\n                ${n.mappingType>-1&&n.mappingUseFragment?`\n                    ${n.isDecal?`\n                        if (${U("decalExplicitUv")} == 0) {\n                            ${n.needTangentBinormal?`\n                                {\n                                    ${A("tmpTangent")} = tangent;\n                                    ${A("tmpBinormal")} = binormal;\n                                    uvToUse = ${D("applyMappingOperator","v2",[g("uvToUse"),x("dObjectSpacePosition"),x("dObjectNormal"),y("tmpTangent"),y("tmpBinormal")])};\n                                    tangent = tmpTangent;\n                                    binormal = tmpBinormal;\n                                }\n                                `:`uvToUse = ${D("applyMappingOperator","v2",[g("uvToUse"),x("dObjectSpacePosition"),x("dObjectNormal")])};`}  \n                            uv2ToUse = ${D("applyMappingOperator","v2",[g("uv2ToUse"),x("dObjectSpacePosition"),x("dObjectNormal")])};\n                        } else {\n                            ${n.needTangentBinormal?`\n                                {\n                                    ${A("tmpTangent")} = tangent;\n                                    ${A("tmpBinormal")} = binormal;\n                                    uvToUse = ${D("applyMappingOperator","v2",[g("uvToUse"),x("dObjectSpacePosition"),x("dObjectNormal"),v("0"),y("tmpTangent"),y("tmpBinormal")])};\n                                    tangent = tmpTangent;\n                                    binormal = tmpBinormal;\n                                }\n                                `:`uvToUse = ${D("applyMappingOperator","v2",[g("uvToUse"),x("dObjectSpacePosition"),x("dObjectNormal"),v("0")])};`}  \n                            uv2ToUse = ${D("applyMappingOperator","v2",[g("uv2ToUse"),x("dObjectSpacePosition"),x("dObjectNormal"),v("0")])};\n                        }\n                        `:`\n                        ${n.needTangentBinormal?`\n                                {\n                                    ${A("tmpTangent")} = tangent;\n                                    ${A("tmpBinormal")} = binormal;\n                                    uvToUse = ${D("applyMappingOperator","v2",[g("uvToUse"),x(z("localPosition")),x(z("localNormal")),y("tmpTangent"),y("tmpBinormal")])};\n                                    tangent = tmpTangent;\n                                    binormal = tmpBinormal;\n                                }\n                            `:`uvToUse = ${D("applyMappingOperator","v2",[g("uvToUse"),x(z("localPosition")),x(z("localNormal"))])};`}\n                        uv2ToUse = ${D("applyMappingOperator","v2",[g("uv2ToUse"),x(z("localPosition")),x(z("localNormal"))])};\n                        `}\n                    `:m}\n                `:`${n.needTangentBinormal&&n.mappingType>-1&&n.mappingUseFragment?`\n               \t\tif (${C("mappingType",n)}>0){\n                        ${A("tmpTangent")} = tangent;\n                        ${A("tmpBinormal")} = binormal;\n                    \t${R("bogusUV")}  = ${D("applyMappingOperator","v2",[g(`${R()}(0.0)`),x(z("localPosition")),x(z("localNormal")),y("tmpTangent"),y("tmpBinormal")])};\n                        tangent = tmpTangent;\n                        binormal = tmpBinormal;\n                \t}\n                \t`:m}`}\n        `},W=function(n){return`\n\n            ${T("gaussian","f",[h("x"),h("mean"),h("variance")])}{\n                ${I("value")}  = x - mean;\n                value *= value;\n                value /= 2.0 * variance;\n                return exp(-value);\n            }\n\n            ${T("mod289","v4",[_("x")])}{\n              return x - floor(x * (1.0 / 289.0)) * 289.0;\n            }\n\n            ${T("mod289","v3",[x("x")])}{\n              return x - floor(x * (1.0 / 289.0)) * 289.0;\n            }\n\n            ${T("mod289","v2",[g("x")])} {\n              return x - floor(x * (1.0 / 289.0)) * 289.0;\n            }\n\n            ${T("permute","v3",[x("x")])}{\n                ${A("value")}  = ((x*34.0)+1.0)*x;\n            \treturn ${D("mod289","v3",[x("value")])};\n            }\n\n            ${T("permute","v4",[_("x")])}{\n                ${L("value")}  = ((x*34.0)+1.0)*x;\n            \treturn ${D("mod289","v4",[_("value")])};\n            }\n\n            ${T("taylorInvSqrt","v4",[_("r")])}{\n            \treturn 1.79284291400159 - 0.85373472095314 * r;\n            }\n\n            ${T("snoise","f",[x("v")])}{\n\n                ${e="C",t={name:e,constant:!0},u.vec2(t)} = ${R()}(1.0/6.0, 1.0/3.0);\n                ${(n=>{var e={name:n,constant:!0};return u.vec4(e)})("D")} = ${L()}(0.0, 0.5, 1.0, 2.0);\n\n                ${A("i")}   = floor(v + dot(v, C.yyy) );\n                ${A("x0")}  =   v - i + dot(i, C.xxx) ;\n\n                ${A("g")}  = step(x0.yzx, x0.xyz);\n                ${A("l")}  = 1.0 - g;\n                ${A("i1")}  = min( g.xyz, l.zxy );\n                ${A("i2")}  = max( g.xyz, l.zxy );\n\n                ${A("x1")}  = x0 - i1 + C.xxx;\n                // 2.0*C.x = 1/3 = C.y\n                ${A("x2")}  = x0 - i2 + C.yyy; \n                // -1.0+3.0*C.x = -0.5 = -D.y\n                ${A("x3")}  = x0 - D.yyy;      \n\n                i = ${D("mod289","v3",[x("i")])};\n                ${L("permutationAux")}  = i.z + ${L()}(0.0, i1.z, i2.z, 1.0 );\n                permutationAux = ${D("permute","v4",[_("permutationAux")])} + i.y + ${L()}(0.0, i1.y, i2.y, 1.0 );\n                permutationAux = ${D("permute","v4",[_("permutationAux")])} + i.x + ${L()}(0.0, i1.x, i2.x, 1.0 );\n                ${L("permutation")}  = ${D("permute","v4",[_("permutationAux")])};\n\n                // 1.0/7.0\n                ${I("n_")}  = 0.142857142857;\n                ${A("ns")} = n_ * D.wyz - D.xzx;\n                //  mod(permutation,7*7)\n                ${L("j")} = permutation - 49.0 * floor(permutation * ns.z * ns.z);  \n\n                ${L("x_")}  = floor(j * ns.z);\n                // mod(j,N)\n                ${L("y_")}  = floor(j - 7.0 * x_ );    \n\n                ${L("x")}  = x_ *ns.x + ns.yyyy;\n                ${L("y")}  = y_ *ns.x + ns.yyyy;\n                ${L("h")}  = 1.0 - abs(x) - abs(y);\n\n                ${L("b0")}  = vec4( x.xy, y.xy );\n                ${L("b1")}  = vec4( x.zw, y.zw );\n\n                ${L("s0")}  = floor(b0)*2.0 + 1.0;\n                ${L("s1")}  = floor(b1)*2.0 + 1.0;\n                ${L("sh")}  = -step(h, vec4(0.0));\n\n                ${L("a0")}  = b0.xzyw + s0.xzyw*sh.xxyy;\n                ${L("a1")}  = b1.xzyw + s1.xzyw*sh.zzww;\n\n                ${A("p0")}  = ${A()}(a0.xy,h.x);\n                ${A("p1")}  = ${A()}(a0.zw,h.y);\n                ${A("p2")}  = ${A()}(a1.xy,h.z);\n                ${A("p3")}  = ${A()}(a1.zw,h.w);\n\n                ${L("r")} = ${L()}(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3));\n                ${L("norm")}  = ${D("taylorInvSqrt","v4",[_("r")])};\n                p0 *= norm.x;\n                p1 *= norm.y;\n                p2 *= norm.z;\n                p3 *= norm.w;\n\n                ${L("m")}  = max(0.6 - ${L()}(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), ${L()}(0.0));\n                m = m * m;\n                return 42.0 * dot( m*m, ${L()}( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );\n            }\n\n\n\n            ${(n=>{var e={name:n,constant:!0};return u.int(e)})("NBOCTAVES")}  = 10;\n\n            ${T("getMean","f",[h("LODLevel")])}{\n                ${I("mult")}  = 1.8;\n                ${I("LOD")}  = 3.0;\n                ${I("oldLOD")}  = 0.0;\n                for (${F("i")} = NBOCTAVES - 1 ; i >=0; i--) {\n                    ${I("pente")}  = 1.0 / (LOD - oldLOD);\n                    ${I("origine")}  = ${I()}(i) + 1.0 + oldLOD * pente;\n                    if (LODLevel <= LOD) {\n                        return origine - pente * LODLevel;\n                    }\n                    oldLOD = LOD;\n                    LOD *= mult;\n                }\n                return 0.0;\n            }\n\n            ${T("FBM","f",[x("iVector")])}{\n                ${A("vector")}  = iVector;\n                ${I("res")}  = 0.0;\n                ${I("amplitude")}  = 1.0;\n                ${I("sum")}  = 0.0;\n                for (${F("octave")}  = 0; octave < 1; octave++) {\n                    if (amplitude < 10.0 * kEpsilon) {\n                        break;\n                    }\n                    vector = vector * 2.0;\n                    sum += amplitude;\n                    res += ${D("snoise","f",[x("vector")])} * amplitude;\n                    amplitude *= 0.5;\n                }\n                return clamp(res/sum,-1.0,1.0);\n            }\n\n            ${T("arrayFBMMixer","f",[x("iVector"),h("LODLevel"),h("frequency"),h("low"),h("up")])}{\n                ${A("vector")}  = iVector;\n                ${I("res")}  = 0.0;\n                ${I("sum")}  = 0.0;\n                ${I("variance")}  = 1.5;\n                ${I("mean")}  = ${D("getMean","f",[h("LODLevel")])};\n                ${I("amplitude")} ;\n                ${F("minIndex")}  = ${F()}(max(0.0, mean - low));\n                ${F("maxIndex")}  = ${F()}(min(${I()}(NBOCTAVES), mean + up));\n                ${I("nFrequency")} = frequency * pow(1.8, ${I()}(minIndex));\n                ${F("octave")}  = minIndex;\n                for (${F("i")} = 0; i < 10 ; i++) {\n                    if (octave >= maxIndex) {break;}\n                    ${A("vec")}  = vector * nFrequency;\n                    nFrequency *= 1.8;\n                    amplitude = ${D("gaussian","f",[h(`${I()}(octave)`),h("mean"),h("variance")])};\n                    sum += amplitude;\n                    res += ${D("snoise","f",[x("vec")])} * amplitude;\n                    octave++;\n                }\n                return clamp(res/sum,-1.0,1.0);\n            }\n    `;var e,t},j={getDecalShaders:function(n){return n.isDecal?[G(n),H(n)]:[m,m]},getNoiseShader:function(n){return n.specGlossFlakes||n.orangePeel?W():m},getUtilityShader:function(e,t){let r=`\n                \n        ${E("kEpsilon")}  = 0.00001;\n\n        ${T("myAtan2","f",[h("y"),h("x")])}{\n\n            ${I("absx")};\n            ${I("absy")};\n            ${I("val")};\n\t\t\t${I("ret")};\n\t\t\tif (x == 0.0 && y == 0.0) { return 0.0; }\n\t\t\tif (y < 0.0) { absy = -y; } else { absy = y; }\n            if (x < 0.0) { absx = -x; } else { absx = x; }\n\t\t\tif (absy - absx == absy) {\n                if (y < 0.0) { return -PI*0.5; }\n                return PI*0.5;\n            }\n\t\t\tif (absx - absy == absx) {\n                val = 0.0;\n            } else {\n                // JBN10: WebGPU was specifically using atan2(y, x) while WebGL was on atan(y/x). TBC\n                val = atan(y/x);\n            }\n\t\t\tif (x > 0.0) { return val; }\n\t\t\tif (y < 0.0) { return val - PI; }\n            return val + PI;\n\t\t}\n\n        ${T("vOrthoProjectionOnLine","v3",[x("P"),x("A"),x("B")])}{\n            ${A("v")}  = normalize(B - A);\n            ${A("AP")}  = P - A;\n            return A + dot(AP,v) * v;\n        }\n\n        ${T("vSmoothstep","f",[h("lower"),h("upper"),h("factor")])}{\n\t\t\tif (upper <= lower) {\n\t\t\t\treturn 0.0;\n\t\t\t}\n\t\t\treturn smoothstep(lower, upper, factor);\n\t\t}\n        \n        ${T("vLerp","f",[h("a"),h("b"),h("w")])}{\n            return a + w * (b-a);\n        }\n\t\t\n        ${T("vLerp","v3",[x("a"),x("b"),h("w")])}{\n            return a + w * (b-a);\n        }\n\n        ${T("TangentToWorldGeom","v3",[x("Vec"),x("TangentZ")])}{\n\n            ${A("TangentX")}  = ${D("getGeomT","v3",[x("TangentZ")])};\n            ${A("TangentY")}  = ${D("getGeomB","v3",[x("TangentZ"),x("TangentX")])};\n\n            return TangentX * Vec.x + TangentY * Vec.y + TangentZ * Vec.z;\n        }\n\n        \n\n        ${T("modI","f",[h("a"),h("b")])}{\n\t\t\t${I("m")}  = a - floor((a+0.5)/b)*b;\n\t\t\treturn floor(m+0.5);\n\t\t}\n\n        ${T("modI","i",[v("a"),v("b")])}{\n            ${I("fA")}  = ${I()}(a);\n            ${I("fB")}  = ${I()}(b);\n\t\t\treturn ${F()}(${D("modI","f",[h("fA"),h("fB")])});\n\t\t}\n\n        ${T("vRound","f",[h("a")])}{\n\t\t\treturn floor(a + 0.5);\n\t\t}\n\n        ${T("vMax","f",[g("v")])}{\n\t\t\treturn max(v.x,v.y);\n\t\t}\n\n        ${T("vMax","f",[x("v")])}{\n\t\t\treturn max(${D("vMax","f",[g("v.xy")])},v.z);\n\t\t}\n\n        ${T("vMax","f",[_("v")])}{\n\t\t\treturn max(${D("vMax","f",[g("v.xy")])},${D("vMax","f",[g("v.zw")])});\n\t\t}\n\n        ${T("vMin","f",[g("v")])}{\n\t\t\treturn min(v.x,v.y);\n\t\t}\n\n        ${T("vMin","f",[x("v")])}{\n\t\t\treturn min(${D("vMin","f",[g("v.xy")])},v.z);\n\t\t}\n\n        ${T("vMin","f",[_("v")])}{\n\t\t\treturn min(${D("vMin","f",[g("v.xy")])},${D("vMin","f",[g("v.zw")])});\n\t\t}\n\n        ${T("affine","f",[h("value"),h("value0"),h("value1")])}{\n            return value * (value1 - value0) + value0;\n        }\n\n        ${T("toTexCoord","f",[h("x"),h("minValue"),h("maxValue")])}{\n            return clamp((clamp(x, minValue, maxValue) - minValue) / (maxValue - minValue),0.0,1.0);\n        }\n\n        ${T("toTexCoord","v2",[g("x"),g("minValue"),g("maxValue")])}{\n            return clamp((clamp(x, minValue, maxValue) - minValue) / (maxValue - minValue), ${R()}(0.0), ${R()}(1.0));\n        }\n\n        ${T("toTexCoord","v3",[x("x"),x("minValue"),x("maxValue")])}{\n            return clamp((clamp(x, minValue, maxValue) - minValue) / (maxValue - minValue), ${A()}(0.0), ${A()}(1.0));\n        }\n\n        ${T("toTexCoord","v4",[_("x"),_("minValue"),_("maxValue")])}{\n            return clamp((clamp(x, minValue, maxValue) - minValue) / (maxValue - minValue), ${L()}(0.0), ${L()}(1.0));\n        }\n\n        ${T("vIsnan","b",[h("val")])}{\n\t\t  return !( val < 0.0 || 0.0 < val || val == 0.0 );\n\t\t}\n\n        ${T("transposeMatrix","m3",[f("m3","m")])}{\n            ${B("mT")} = ${B()}(\n                ${A()}(m[0].x, m[1].x, m[2].x),\n                ${A()}(m[0].y, m[1].y, m[2].y),\n                ${A()}(m[0].z, m[1].z, m[2].z)    \n            );\n            return mT;\n        }\n\n        ${T("transposeMatrix","m3",[f("m4","m")])}{\n            ${B("mm")} = ${B()}(\n                m[0].xyz, \n                m[1].xyz, \n                m[2].xyz\n            );\n            return ${D("transposeMatrix","m3",[f("m3","mm")])};\n        }\n\n        ${T("saturate","f",[h("iValue")])}{\n            return clamp(iValue, 0.0, 1.0);\n        }\n\n        ${T("saturate","v2",[g("iValue")])}{\n            return clamp(iValue, ${R()}(0.0), ${R()}(1.0));\n        }\n\n        ${T("saturate","v3",[x("iValue")])}{\n            return clamp(iValue, ${A()}(0.0), ${A()}(1.0));\n        }\n\n        ${T("saturate","v4",[_("iValue")])}{\n            return clamp(iValue, ${L()}(0.0), ${L()}(1.0));\n        }\n\n        ${T("fma","f",[h("x"),h("y"),h("z")])}{\n            return x*y + z;\n        }\n\n        ${T("fma","v2",[g("x"),g("y"),g("z")])}{\n            return x*y + z;\n        }\n\n        ${T("fma","v3",[x("x"),x("y"),x("z")])}{\n            return x*y + z;\n        }\n\n        ${T("fma","v4",[_("x"),_("y"),_("z")])}{\n            return x*y + z;\n        } \n\n        ${T("FresnelSchlick","v3",[x("iSr0Color"),h("ctheta")])}{\n            ${I("Fc")}  = ${D("pow5","f",[h("1.0 - ctheta")])};\n            return Fc + (1.0 - Fc) * iSr0Color;\n        }\n\n        ${T("FresnelSchlick","v3",[x("iSr0Color"),x("iSr90Color"),h("ctheta")])}{\n            ${I("power")}  =  ${D("pow5","f",[h("1.0 - ctheta")])};\n            return  mix(iSr0Color, iSr90Color, power);\n        }\n\n        \n        ${T("FresnelSchlick","f",[h("iSr0Color"),h("iSr90Color"),h("ctheta")])}{\n            ${I("power")} =  ${D("pow5","f",[h("1.0 - ctheta")])};\n            return  mix(iSr0Color, iSr90Color, power);\n        }\n        \n        ${T("FresnelSchlick","v2",[h("ctheta")])}{\n            ${I("power")} =  ${D("pow5","f",[h("1.0 - ctheta")])};\n            return vec2((1.0-power),power);\n        }\n\n        ${T("F0FromFresnelSchlick","v3",[x("iFresnel"),x("iSr90Color"),h("ctheta")])}{\n            ${I("power")} =  ${D("pow5","f",[h("1.0 - ctheta")])};\n            power = clamp(power, 0.0, 1.0 - 1e-6);\n            return (iFresnel - iSr90Color * power) / (1.0 - power);\n        }\n    \n            `;return e&&(r=`\n                    ${r}\n                    ${function(e){return`       \n            ${T("SpecGlossEnergyConservationTerm","f",[h("NoL"),h("NoV"),x("iSr0Color"),x("iSr90Color")])} {\n                ${A("fresnelNoL")}  = ${D("FresnelSchlick","v3",[x("iSr0Color"),x("iSr90Color"),h("NoL")])};\n                ${e.specglossNRE?"return 1.0 - dot(fresnelNoL, luminanceVector);":`${A("fresnelNoV")} = ${D("FresnelSchlick","v3",[x("iSr0Color"),x("iSr90Color"),h("NoV")])};\n                    return 1.0 - ${D("vMax","f",[x("max(fresnelNoL, fresnelNoV)")])};\n                    `}\n            }\n\n            ${T("SpecGlossEnergyConservationTerm","f",[x("fresnel")])} {\n                return 1.0 - dot(fresnel, luminanceVector);\n            }\n            \n            ${e.mobileDevice?` \n\n                ${T("GeometricLambda","f",[h("a"),h("cosTheta")])} {\n                    return 1.0 - a + a/max(cosTheta, 1e-6);\n                }\n                \n                ${T("GeometricSchlick","f",[h("roughness"),h("NoV"),h("NoL")])} {\n                    ${I("a")}  = roughness * roughness;\n                    ${I("GLNoL")}  = ${D("GeometricLambda","f",[h("a"),h("NoL")])};\n                    ${I("GLNoV")}  = ${D("GeometricLambda","f",[h("a"),h("NoV")])};\n                    return 2.0 / (GLNoL + GLNoV);\n                }\n                `:` \n                ${T("GeometricLambda","f",[h("a2"),h("cosTheta")])} {\n                    return sqrt(1.0 - a2 + a2/max(cosTheta * cosTheta, 1e-6));\n                }\n                \n                ${T("GeometricSchlick","f",[h("roughness"),h("NoV"),h("NoL")])} {              \n                    ${I("a")}  = roughness * roughness;\n                    ${I("a2")}  = a * a;\n                    ${I("GLNoL")}  = ${D("GeometricLambda","f",[h("a2"),h("NoL")])};\n                    ${I("GLNoV")}  = ${D("GeometricLambda","f",[h("a2"),h("NoV")])};\n                    return 2.0 / (GLNoL + GLNoV);\n                }\n                `} \n            \n            ${T("GGXVisibility","f",[h("roughness"),h("NoV"),h("NoL")])} {\n                ${I("factor")}  = 0.25 / max(abs(NoL * NoV), 1e-3);\n                return factor * ${D("GeometricSchlick","f",[h("roughness"),h("NoV"),h("NoL")])};\n            }\n            \n            ${T("DistributionGGX","f",[h("roughness"),h("NoH")])} {\n                ${I("alpha")}  = roughness * roughness;\n                ${I("alpha2")}  = alpha * alpha;\n                ${I("NoH2")}  = NoH * NoH;\n                ${I("d")} = max((alpha2 - 1.0) * NoH2 + 1.0, 1e-6);\n                return alpha2* INV_PI / (d * d);\n            }\n\n            ${e.sheen?`\n                ${T("SheenVisGeometricSchlick","f",[h("NoV"),h("NoL")])} {\n                    ${I("div")}  = 4.0 * max(NoL + NoV - NoL*NoV, 1e-6);\n                    return 1.0 / div;\n                }\n\n                ${T("SheenDistribution","f",[h("NoH"),h("sheenValue")])} {\n                    ${I("cosine2")}  = max(NoH * NoH,kEpsilon);\n                    ${I("sine2")}  = max(1.0-cosine2,kEpsilon);\n                    ${I("D")}  = 1.0;\n                    ${I("normalisationTerm")}  = 0.31830988618379;\n                    ${e.sheenMode===n.SheenMode.VELVET?`\n                        ${I("a2")}  = sheenValue * sheenValue;\n                        normalisationTerm *= 1.0/(4.0*a2+1.0);\n                        ${I("sine4")}  = max(sine2 * sine2,kEpsilon);\n                        ${I("cotan2")}  = cosine2/sine2;\n                        ${I("value")}  = -cotan2 / a2;\n                        D = 1.0+4.0 * exp(value)/ sine4;\n                        `:m}\n                    ${e.sheenMode===n.SheenMode.VELVET_SOFT?`\n                        ${e.dspbrWithSquaredEstevezKullaRoughness?`${I("a")} = sheenValue * sheenValue;`:`${I("a")} = sheenValue;`}\n                        a = max(a, 1e-3);\n                        normalisationTerm *= 0.5;\n                        ${I("sine")}  = sqrt(sine2);\n                        D = (2.0 + 1.0 /a ) * pow(sine, 1.0 / a);\n                        `:m}\n                    ${e.sheenMode===n.SheenMode.SATIN?`\n                        ${I("a2")} = 0.0081;\n                        normalisationTerm *= 1.0/(8.0*a2);\n                        ${I("cosine4")}  = max(cosine2 * cosine2,kEpsilon);\n                        ${I("tan2")}  = sine2/cosine2;\n                        ${I("value")}  = -tan2/( a2*8.0);\n                        D = exp(value) / cosine4 ;\n                        `:m}\n                    return D * normalisationTerm;\n                }\n                \n                `:m}\n        `}(t)}\n                `,t.dspbr&&(r=`\n                        ${r}\n                        ${function(n){return`\n         \n            ${T("DirectionalMultipleAlbedo","f",[h("cosTheta"),h("roughness")])} {\n                ${I("a2")}  = ${D("pow4","f",[h("roughness")])};\n                ${I("res")}  = 3.09507 + cosTheta * (-9.11369 + cosTheta * (15.8884 + cosTheta * (-13.70343 + 4.51786 * cosTheta)));\n                res *= (-0.20277 + a2 * (2.772 + a2 * (-2.6175 + 0.73343*a2)));\n                res *= 1.4594 * a2 * cosTheta;\n                return 1.0  - res;\n            } \n\n            ${T("AverageDirectionalMultipleAlbedo","f",[h("roughness")])} {\n                ${I("a2")} = ${D("pow4","f",[h("roughness")])};\n                return 1.0 + a2 * (-0.133 + a2 * (-1.8695 + a2 * (2.2268 - 0.83397*a2)));\n            }\n\n            ${T("AverageMultipleFresnel","f",[h("F0")])} {\n                return mix(1.0, F0, 0.95238095238);\n            }\n            \n            ${T("AverageMultipleFresnel","v3",[x("iSr0Color"),x("iSr90Color")])} {\n                return mix(iSr90Color, iSr0Color, 0.95238095238);\n            }\n\n            \n            ${T("DirectionalAlbedo","f",[x("specularSr0"),h("cosTheta"),h("roughness")])} {       \n                ${I("a2")}  = ${D("pow4","f",[h("roughness")])};\n                ${I("E0")}  = ${D("vMax","f",[x("specularSr0")])};\n                ${I("a")}  = E0 + (1.0 - E0) * ${D("pow5","f",[h("1.0 - cosTheta")])};\n                ${I("b")}  = 0.04762 + 0.95238*E0;\n                ${I("w")}  = 1.0 - ${D("pow5","f",[h("1.0 - a2")])};\n                return ${D("vLerp","f",[h("a"),h("b"),h("w")])};\n            }\n\n            ${T("DirectionalAlbedo","f",[h("F0"),x("specularTint"),h("cosTheta"),h("roughness")])} {      \n                return ${D("DirectionalAlbedo","f",[x("F0 * specularTint"),h("cosTheta"),h("roughness")])};\n            }\n\n            ${T("AverageDirectionalAlbedo","f",[x("specularSr0"),h("roughness")])} {\n                ${I("a2")}  = ${D("pow4","f",[h("roughness")])};\n                ${I("E0")}  = ${D("vMax","f",[x("specularSr0")])};\n                return E0 + (-0.33263 * a2 - 0.072359) * (1.0 - E0) * E0;\n            }\n\n            ${T("AverageDirectionalAlbedo","f",[h("F0"),x("specularTint"),h("roughness")])} {\n                return ${D("AverageDirectionalAlbedo","f",[x("F0 * specularTint"),h("roughness")])};\n            }\n\n            \n            ${n.dspbrWithSheenColorRoughness?`\n                ${T("DirectionalSheenAlbedo","f",[h("cosTheta"),h("roughness")])} {\n                    ${n.dspbrWithSquaredEstevezKullaRoughness?`${I("a")} = roughness * roughness;`:`${I("a")} = roughness;`}\n                    return 0.04495972 + 0.47479907 * (sqrt(1.0 - cosTheta) + (1.0 - cosTheta) * sqrt(1.0 - sqrt(a)));\n                }\n                `:m}\n        `}(t)}\n                    `),(t.anisotropy||t.useSpecularAA)&&(r=`\n                        ${r}  \n                             \n\n        ${T("AnisotropicGeometricSchlick","f",[h("roughnessX"),h("roughnessY"),h("NoV"),h("NoL"),h("iAnisotropyAngle")])} {        \n            ${I("ax")}  = roughnessX * roughnessX;\n            ${I("ay")}  = roughnessY * roughnessY;\n            ${I("a2")}  = ${D("pow2","f",[h("cos(iAnisotropyAngle)*ax")])} + ${D("pow2","f",[h("sin(iAnisotropyAngle)*ay")])};\n            ${I("G1")}  = sqrt(1.0-a2+a2/max(NoL*NoL,1e-6));\n            ${I("G2")}  = sqrt(1.0-a2+a2/max(NoV*NoV,1e-6));\n            return 2.0 / (G1+G2);\n        }\n\n        ${T("AnisotropicGGXVisibility","f",[h("roughnessX"),h("roughnessY"),h("NoV"),h("NoL"),h("iAnisotropyAngle")])} {\n            ${I("factor")}  = 0.25 / max(abs(NoL * NoV), 1e-3);\n            return factor *  ${D("AnisotropicGeometricSchlick","f",[h("roughnessX"),h("roughnessY"),h("NoV"),h("NoL"),h("iAnisotropyAngle")])};\n        }\n\n        ${T("AnisotropicDistributionGGX","f",[x("T"),x("B"),x("N"),x("H"),h("NoH"),h("iRoughnessX"),h("iRoughnessY"),h("iAnisotropyAngle")])} {\n            ${A("rot_X")}  = cos(2.0 * PI * iAnisotropyAngle) * T + sin(2.0 * PI * iAnisotropyAngle) * B;\n            ${A("rot_Y")}  = cross(N, rot_X);\n\n            ${I("dot_t_h")}  = dot(rot_X, H);\n            ${I("dot_b_h")}  = dot(rot_Y, H);\n            ${I("alpha_T")}  = iRoughnessX;\n            ${I("alpha_B")}  = iRoughnessY;\n\n            alpha_T = max(alpha_T * alpha_T, 1e-3);\n            alpha_B = max(alpha_B * alpha_B, 1e-3);\n\n            ${I("a")}  = dot_t_h / alpha_T;\n            ${I("b")}  = dot_b_h / alpha_B;\n\n            ${I("D")}  = a * a + b * b + NoH * NoH;\n            D = PI * alpha_T * alpha_B * D * D;\n            D = 1.0 / max(D, kEpsilon);\n\n            return D;\n        }\n\n        ${T("ComputeAnisotropicRoughness","f",[x("T"),x("B"),x("N"),x("H"),h("iRoughness"),h("anisotropy"),h("anisotropyAngle")])} {\n            ${A("rot_X")}  = cos(2.0 * PI * anisotropyAngle) * T + sin(2.0 * PI * anisotropyAngle) * B;\n            ${A("rot_Y")}  = cross(N, rot_X);\n\n            ${I("dot_t_h")}  = dot(rot_X, H);\n            ${I("dot_b_h")}  = dot(rot_Y, H);\n            ${I("alpha_T")} = iRoughness;\n            ${I("alpha_B")} = iRoughness * (1.0 - anisotropy) ;\n\n            alpha_T = max(alpha_T * alpha_T, kEpsilon);\n            alpha_B = max(alpha_B * alpha_B, kEpsilon);\n\n            ${I("tmp")}  =  sign(dot_b_h) * sign(dot_t_h);\n\n            dot_t_h = max(abs(dot_t_h),0.05) * tmp;\n            dot_b_h = max(abs(dot_b_h),0.05);\n\n            ${I("phi")}  = ${O("dot_t_h","dot_b_h")};\n            ${I("a")}  = ${D("pow2","f",[h("cos(phi) / alpha_T")])};\n            ${I("b")}  = ${D("pow2","f",[h("sin(phi) / alpha_B")])};\n            ${I("a2")}  = 1.0/ (a+b);\n\n            ${I("roughness")}  = ${D("saturate","f",[h("sqrt(sqrt(a2))")])};\n            return clamp(roughness, ROUGHNESS_CLAMP_MIN, ROUGHNESS_CLAMP_MAX) ;\n        }\n       \n                    `)),r},getMappingShaders:function(e){return[`\n                ${n._ShaderChunk.map_pars_varying_declare_vertex_fragment(e)}\n                ${n._DefaultShaderChunk.map_pars_vertex_fragment(e)}\n            `,X(e)]}};return Object.assign(j,e),Object.assign(j,t),Object.assign(j,r),Object.assign(j,a),j})),define("DS/ShaderBuilders/PBRShaderBuilder",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/PBRUtils/PBRShaderBuilderUtils","DS/ShaderBuilders/PBRUtils/PBRVertexShaderBuilderUtils","DS/ShaderBuilders/PBRUtils/PBRFragmentShaderBuilderUtils","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(n,e,t,r,a,o,i,s,l){"use strict";const u="",m=(s.ParameterUtils,n=>{var e={uniformName:n};return o.getLightUniform(e)}),c=n=>i.getShaderOutput(n),$=(n,e)=>e.mappingFromMatApp?(n=>o.addHighFrequencyUniform(n))(n):(n=>o.addUniform(n))(n),p=n=>i.addVarying(n),d=n=>i.getVarying(n,i.ShaderStages.out),f=(n=null)=>{var e={name:n};return l.vec2(e)},h=n=>{var e={name:n,constant:!0};return l.float(e)};let v=function(e,t,a){let[o,i]=r.getDisplacementShaders(e),[l,m]=r.getDecalShaders(e),[c,f]=r.getMappingShaders(e),h=n._ShaderChunk,v=n._DeferredShaderChunk,g=`\n\n            ${n._DefaultShaderChunk.normal_viewposition_pars_vertex(e)}\n            ${h.color_pars_vertex(e)}\n\n            ${h.clip_pars_vertex(e)}\n            ${e.needsUvSlot?$({uniformName:"uvSlot",uniformType:"i"},e):u}\n            ${c}\n            ${o}\n\n            ${p({varyingName:"vWorldPosition",varyingType:"v3"})}\n\n            ${e.needObjectSpaceData?`\n                ${p({varyingName:"vObjectSpacePosition",varyingType:"v3"})}\n                ${p({varyingName:"vObjectSpaceNormal",varyingType:"v3"})}\n                `:u}\n\n            ${t?h.shadowmap_pars_vertex(e):u}\n            ${h.tangent_Binormal_pars(e)}\n            ${h.skinning_pars_vertex(e)}\n            ${h.fog_pars_vertex(e)}\n            ${v.oit_pars_vertex(e)}\n            ${a?v.depth_pars_vertex(e):u}\n            ${a?v.picking_pars_vertex(e):u}\n            ${a?v.picking_instancing_pars_vertex(e):u}\n            ${a?v.highlight_pars_vertex(e):u}\n            ${a?v.texcoord_pars_vertex(e):u}\n            ${a?v.gpupos_pars_vertex(e):u}\n            ${l}\n\n            ${(n=>s.FunctionHandler.getMainVertexStart(n))(e)}\n\n                ${h.PDSFX_start_vertex(e)}\n                ${h.color_vertex(e)}\n                ${h.skinbase_vertex(e)}\n                ${h.skinnormal_vertex(e)}\n                ${h.skinning_vertex(e)}\n                ${f}\n                ${h.tangent_Binormal_vertex(e)}\n                ${i}\n                ${h.position_vertex(e)}\n                ${h.default_vertex_with_normal(e)}\n                ${h.defaultnormal_vertex(e)}\n                ${m}\n\n                ${h.clip_vertex(e)}\n                ${h.fog_vertex(e)}\n\n                ${n._DefaultShaderChunk.normal_viewposition_vertex(e)}\n\n                ${h._worldpos_vertex(e)}\n                ${d("vWorldPosition")} = worldPosition.xyz;\n\n                ${e.needObjectSpaceData?`\n                    ${d("vObjectSpacePosition")} = position_.xyz;\n                    ${d("vObjectSpaceNormal")} = objectNormal.xyz;\n                    `:u}\n                ${t?h.shadowmap_vertex(e):u}\n                ${v.oit_vertex(e)}\n                ${a?v.depth_vertex(e):u}\n                ${a?v.picking_vertex(e):u}\n                ${a?v.picking_instancing_vertex(e):u}\n                ${a?v.highlight_vertex(e):u}\n                ${a?v.texcoord_vertex(e):u}\n                ${a?v.gpupos_vertex(e):u}\n\n                ${h.PDSFX_end_vertex(e)}\n\n            ${(n=>s.FunctionHandler.getMainVertexEnd(n))(e)}\n        `;return g},g=function(e,t,r){const[o,i]=a.getDecalShaders(e),[d,v]=a.getMappingShaders(e),[g,x,S]=a.getAnalyticalLightShaders(t,e),[y,_]=a.getIndirectLightShaders(t,e),[T,D,C]=a.getUniformShaders(t,e),[P,N]=a.getEquationsShaders(t,e),b=n._ShaderChunk,M=n._DeferredShaderChunk,U=[{type:"f",name:"roughness"},{type:"f",name:"transparency"},{type:"f",name:"metalness"},{type:"v3",name:"diffuseColor"},{type:"v3",name:"transparentColor"},{type:"f",name:"specularContribution"},{type:"v3",name:"specularTint"},{type:"v3",name:"specularBlendingSR0"},{type:"v3",name:"sr0Color"},{type:"v3",name:"sr90Color"},{type:"f",name:"ior"},{type:"f",name:"adjustedIoR"},{type:"f",name:"F0"}];e.useSpecularAA&&U.push({type:"f",name:"roughnessAACorrected"}),e.useEmission&&(U.push({type:"v3",name:"emissionColor"}),U.push({type:"f",name:"emissionValue"})),e.dspbrWithTranslucency&&(U.push({type:"f",name:"translucency"}),U.push({type:"v3",name:"translucencyColor"})),t&&(e.anisotropy&&(U.push({type:"f",name:"anisotropy"}),U.push({type:"f",name:"anisotropyAngle"})),e.sheen&&(U.push({type:"f",name:"sheen"}),U.push({type:"f",name:"sheenRoughness"}),U.push({type:"v3",name:"sheenColor"}),U.push({type:"f",name:"sheenEnergyConservationConstant"})),e.clearCoat&&(U.push({type:"f",name:"clearCoat"}),U.push({type:"f",name:"clearCoatRoughness"}),U.push({type:"v3",name:"clearCoatSR0Color"}),U.push({type:"v3",name:"clearCoatSR90Color"}),e.useSpecularAA&&U.push({type:"f",name:"clearCoatRoughnessAACorrected"})),e.iridescence&&(U.push({type:"f",name:"iridescence"}),U.push({type:"f",name:"iridescenceIoR"}),U.push({type:"f",name:"iridescenceThickness"}),U.push({type:"v3",name:"iridescenceSR0Color"}))),e.subsurface&&(U.push({type:"v3",name:"scatteringColor"}),e.thickness&&U.push({type:"v3",name:"transmittanceColor"})),e.dspbr&&(U.push({type:"v3",name:"specularEnergyConservationConstant"}),U.push({type:"f",name:"diffuseEnergyConservationConstant"}));const w=[{type:"v3",name:"viewNormal"},{type:"v3",name:"view"},{type:"v3",name:"worldPosition"},{type:"v3",name:"viewPosition"}];(t&&(e.envMap||e.useIBLColor||e.reflectivityEnvMap||e.specGlossFlakes)||e.thickness||e.subsurface)&&w.push({type:"v3",name:"worldNormal"}),e.needObjectSpaceData&&(w.push({type:"v3",name:"objectSpacePosition"}),w.push({type:"v3",name:"objectSpaceNormal"})),e.anisotropy&&(w.push({type:"v3",name:"tangent"}),w.push({type:"v3",name:"binormal"})),e.clearCoat&&(w.push({type:"v3",name:"clearCoatNormal"}),w.push({type:"v3",name:"clearCoatWorldNormal"})),e.subsurface&&w.push({type:"f",name:"curvature"}),e.useSpecularAA&&(w.push({type:"v3",name:"TForSpecularAA"}),w.push({type:"v3",name:"BForSpecularAA"})),e.thickness&&w.push({type:"f",name:"thickness"});let V=`\n            \n            ${l.createStruct({structName:"matData",attributes:U})}\n\n            ${l.createStruct({structName:"surfData",attributes:w})}\n            \n            ${e.needObjectSpaceData?`\n                ${p({varyingName:"vObjectSpacePosition",varyingType:"v3"})}\n                ${p({varyingName:"vObjectSpaceNormal",varyingType:"v3"})}\n                `:u}\n            \n            ${l.struct({name:"materialData",structName:"matData",addressSpace:"private"})};\n            ${l.struct({name:"surfaceData",structName:"surfData",addressSpace:"private"})};\n\n            ${h("ROUGHNESS_CLAMP_MIN")}  = 0.025;\n            ${h("ROUGHNESS_CLAMP_MAX")}  = 0.975;\n\n            ${h("PI")}  = 3.14159265359;\n            ${h("INV_PI")}  = 0.31830988618;\n\n            ${((n=null,e=0)=>{var t={name:n,constant:!0,size:e};return l.vec3(t)})("luminanceVector")}  = ${((n=null,e="",t=0)=>{var r={name:n,addressSpace:e,size:t};return l.vec3(r)})()}(0.299, 0.587, 0.114);\n            \n            ${M._debug_common_pars_fragment(e)}\n     \n            ${p({varyingName:"vWorldPosition",varyingType:"v3"})}\n            ${n._DefaultShaderChunk.normal_viewposition_pars_fragment(e)}\n\n            ${b.color_pars_fragment(e)}\n            ${b.clip_pars_fragment(e)}\n            \n            ${e.needsUvSlot?$({uniformName:"uvSlot",uniformType:"i"},e):u}\n            ${d}\n            ${b.tangent_Binormal_pars_fragment(e)}\n            ${t?n._ShaderChunk.shadowmap_pars_fragment(e):u}\n            ${a.getUtilityShader(t,e)}\n            ${a.getNoiseShader(e)}\n\n            ${g}\n            ${y}\n            ${T}\n            ${P}\n            ${S}\n         \n            ${M.oit_pars_fragment(e)}\n\t\t\t${r?M.picking_pars_fragment(e):u}\n\t\t\t${r?M.picking_instancing_pars_fragment(e):u}\n\t\t\t${r?M.depth_pars_fragment(e):u}\n\t\t\t${r?M.decal_normal_depth_pars_fragment(e):u}\n\t\t\t${r?M.shadowmap_pars_fragment(e):u}\n\t\t\t${r?M.highlight_pars_fragment(e):u}\n            ${r?M.texcoord_pars_fragment(e):u}\n            ${r?M.gpupos_pars_fragment(e):u}\n            ${o}\n            ${b.postprocess_pars_fragment(e)}\n            ${b.fog_pars_fragment(e)}\n        `,z=`\n            ${(n=>s.FunctionHandler.getMainFragmentStart(n))(e)}\n                ${t&&e.envMapHDR?`\n                    hdrSize = ${f()}(${m("envMapHDRSize")});\n                    hdrTexelSize = ${f()}(1.0 / ${m("envMapHDRSize")});\n                    mipsSize = ${e.reflectionProbes?"1.0":m("envMapHDRToMipsRatio")} * ${f()}(1.0, 2.0) * hdrSize;\n                    mipsTexelSize = ${f()}(1.0 / mipsSize);\n                    `:u}\n\n                ${i}  \n                ${e.PDSFX?`\n                    ${b.PDSFX_start_fragment(e)}\n                    ${b.PDSFX_uv_fragment(e)}\n                    ${b.PDSFX_mapping_uv_transform_fragment(e)}\n                    `:u}  \n                ${v}\n                ${C}\n\n                ${e.PDSFX?`\n                    ${F="ComputeCommonValues",I=null,R=[],s.FunctionHandler.callFunction(F,I,R)};\n                    ${b.PDSFX_discard_fragment(e)}\n                    ${b.PDSFX_viewNormal_fragment(e)}\n                    ${b.PDSFX_viewPosition_fragment(e)}\n                    `:u}\n                \n                ${c("out0")} = ${((n=null,e=0)=>{var t={name:n,size:e};return l.vec4(t)})()}( 1.0 );\n              \n                ${b.tangent_Binormal_fragment(e)}\n                ${D}  \n                ${b.clip_fragment(e)} \n\n                ${t?b.shadowmap_fragment(e):u}  \n                ${x}  \n                ${_}                \n                ${e.useLighting?`\n                    ${e.shadowMapDebugMaterial||!e.dspbrWithTranslucency&&!e.subsurface?u:`\n                        ${c("out0")}.x += totalTransmissive.x;\n                        ${c("out0")}.y += totalTransmissive.y;\n                        ${c("out0")}.z += totalTransmissive.z ;\n                        `}\n                    ${e.shadowMapDebugMaterial||!e.useEmission?u:`\n                        ${c("out0")}.x += totalEmission.x;\n                        ${c("out0")}.y += totalEmission.y;\n                        ${c("out0")}.z += totalEmission.z;\n                        `}\n                    `:`\n                    ${c("out0")}.x = albedo.x;\n                    ${c("out0")}.y = albedo.y;\n                    ${c("out0")}.z = albedo.z;\n                    ${e.subsurface?`\n                        ${c("out0")}.x *= materialData.scatteringColor.x;\n                        ${c("out0")}.y *= materialData.scatteringColor.y;\n                        ${c("out0")}.z *= materialData.scatteringColor.z;\n                        `:u}\n                    ${e.invisiblePlaneMaterial?`\n                        ${c("out0")}.x = 1.0;\n                        ${c("out0")}.y = 1.0;\n                        ${c("out0")}.z = 1.0;\n                        `:u}\n                    `} \n                ${e.dspbr&&e.useTransparency&&!e.shadowMapDebugMaterial?`\n                    ${c("out0")}.x /= transToDivide;\n                    ${c("out0")}.y /= transToDivide;\n                    ${c("out0")}.z /= transToDivide;\n                    `:u}\n                \n                ${e.useSSAO?`\n                    if (${c("out0")}.a > 1.0 - 1e-3 && materialData.transparency < 1e-3) {\n                        ${b._ao_fragment(e)}\n                    }\n                    `:u}\n                ${b.postprocess_fragment(e)}\n                ${b.linear_to_gamma_fragment(e)}\n                ${b.PDSFX_end_fragment(e)}\n                ${b.fog_fragment(e)}\n                ${b.backgroundviewmode_lowlight_fragment(e)}\n                ${M._debug_common_face_fragment(e)}\n                ${M.oit_fragment(e)}\n\t\t\t\t${r?M.picking_fragment(e):u}\n\t\t\t\t${r?M.picking_instancing_fragment(e):u}\n\t\t\t\t${r?M.depth_fragment_face(e):u}\n\t\t\t\t${r?M.normal_fragment(e):u}\n\t\t\t\t${r?M.normal_depth_fragment(e):u}\n\t\t\t\t${r?M.shadowmap_fragment(e):u}\n                ${r?M.highlight_fragment_face(e):u}\n                ${r?M.texcoord_fragment(e):u}\n                ${r?M.gpupos_fragment(e):u}\n\n            ${(n=>s.FunctionHandler.getMainFragmentEnd(n))(e)}\n        `;var F,I,R;return`\n            ${V}\n            ${z}\n        `};return new e((function(n,e){let t=e.isDeferredMaterial;n=n&&e.useLighting;let r=g(e,n,t);return{vertexShader:v(e,n,t),fragmentShader:r}}))}));