this.GAUSSIAN_SPLATTING_PARSING_INCLUDE=!0,define("DS/Mesh/GaussianSplattingParsing",["DS/Mesh/ThreeJS_Base"],(function(t){"use strict";class e{constructor(){this.splatCount=0,this.scale_0=[],this.scale_1=[],this.scale_2=[],this.rot_0=[],this.rot_1=[],this.rot_2=[],this.rot_3=[],this.x=[],this.y=[],this.z=[],this.f_dc_0=[],this.f_dc_1=[],this.f_dc_2=[],this.opacity=[]}addSplat(t,e,o,a,r,s,n,c,l,i,_,f,d,p){this.x.push(t),this.y.push(e),this.z.push(o),this.scale_0.push(a),this.scale_1.push(r),this.scale_2.push(s),this.rot_0.push(n),this.rot_1.push(c),this.rot_2.push(l),this.rot_3.push(i),this.f_dc_0.push(_),this.f_dc_1.push(f),this.f_dc_2.push(d),this.opacity.push(p),this.splatCount++}}let o=function(e,o){const r=e.splatCount;o<10&&(o=10);let s="",n=["opacity","scale_0","scale_1","scale_2","rot_0","rot_1","rot_2","rot_3","x","y","z","f_dc_0","f_dc_1","f_dc_2"];for(let t of n)e[t].length!==r&&(s+=`${t}, `);if(""!==s)return console.error(`Cannot generate SplatBuffer, properties ${s} do not have data for all splats`),null;const c=12*r,l=12*r,i=4*r,_=16*r,f=new ArrayBuffer(c,{maxByteLength:c}),d=new ArrayBuffer(l,{maxByteLength:l}),p=new ArrayBuffer(i,{maxByteLength:i}),h=new ArrayBuffer(_,{maxByteLength:_}),y=new Float32Array(f),u=new Float32Array(d),g=new Uint8ClampedArray(p),x=new Float32Array(h);let w=0;for(let a=0;a<e.splatCount;a++){const r=e.opacity[a];if(r>=o){const o=new t.Quaternion(e.rot_1[a],e.rot_2[a],e.rot_3[a],e.rot_0[a]);o.normalize(),y.set([e.x[a],e.y[a],e.z[a]],3*w),u.set([e.scale_0[a],e.scale_1[a],e.scale_2[a]],3*w),g.set([e.f_dc_0[a],e.f_dc_1[a],e.f_dc_2[a],r],4*w),x.set([o.w,o.x,o.y,o.z],4*w),w+=1}}const F=12*w,P=12*w,m=4*w,S=16*w;f.resize(F),d.resize(P),p.resize(m),h.resize(S);const U=f.byteLength+d.byteLength+p.byteLength+h.byteLength,A=new ArrayBuffer(U);new Uint8Array(A,0,f.byteLength).set(new Uint8Array(f)),new Uint8Array(A,f.byteLength,d.byteLength).set(new Uint8Array(d)),new Uint8Array(A,f.byteLength+d.byteLength,p.byteLength).set(new Uint8Array(p)),new Uint8Array(A,f.byteLength+d.byteLength+p.byteLength,h.byteLength).set(new Uint8Array(h));return new a(y,u,g,x,w)};class a{constructor(t,e,o,a,r){this.splatCount=r,this.bytesPerCenter=12,this.bytesPerScale=12,this.bytesPerColor=4,this.bytesPerRotation=16,this.centerArray=t,this.scaleArray=e,this.colorArray=o,this.rotationArray=a}}a.CenterComponentCount=3,a.ScaleComponentCount=3,a.RotationComponentCount=4,a.ColorComponentCount=4,a.CovarianceSizeFloats=6;let r=function(t){return 255*(.5+.28209479177387814*t)},s=function(t){return(t/255-.5)/.15},n=function(t){return 1/(1+Math.exp(-t))};class c{constructor(){}static decodeHeader(t){const e=new TextDecoder;let o=0,a="";console.log(".PLY size: "+t.byteLength+" bytes");const r=100;for(;;){if(o+r>=t.byteLength)throw new Error("End of file reached while searching for end of header");const s=new Uint8Array(t,o,r);a+=e.decode(s),o+=r;const n=new Uint8Array(t,Math.max(0,o-200),200);if(e.decode(n).includes("end_header"))break}const s=a.split("\n");let n=0,c={};for(let t=0;t<s.length;t++){const e=s[t].trim();if(e.startsWith("element vertex")){const t=e.match(/\d+/);t&&(n=parseInt(t[0]))}else if(e.startsWith("property")){const t=e.match(/(\w+)\s+(\w+)\s+(\w+)/);if(t){const e=t[2];c[t[3]]=e}}else if("end_header"===e)break}const l=a.indexOf("end_header")+10+1;return{splatCount:n,propertyTypes:c,vertexData:new DataView(t,l),headerOffset:o}}static readRawVertexFast(t,e,o,a,r,s){let n=s||{};for(let s of a){const a=r[s];"float"===a?n[s]=t.getFloat32(e+o[s],!0):"uchar"===a&&(n[s]=t.getUint8(e+o[s])/255)}}static parseToSplatBuffer(t,a){const s=performance.now();console.log("Parsing PLY to SPLAT...");const{splatCount:l,propertyTypes:i,vertexData:_}=c.decodeHeader(t);let f=0;for(const t in i)t.startsWith("f_rest_")&&(f+=1);const d=f/3,p=[];for(let t=0;t<3;++t)p.push(`f_dc_${t}`);for(let t=0;t<d;++t)for(let e=0;e<3;++e)p.push(`f_rest_${e*d+t}`);let h=0,y={};const u={double:8,int:4,uint:4,float:4,short:2,ushort:2,uchar:1};for(let t in i)if(i.hasOwnProperty(t)){const e=i[t];y[t]=h,h+=u[e]}let g={};const x=["scale_0","scale_1","scale_2","rot_0","rot_1","rot_2","rot_3","x","y","z","f_dc_0","f_dc_1","f_dc_2","opacity"],w=new e;for(let t=0;t<l;t++)c.readRawVertexFast(_,t*h,y,x,i,g),void 0!==g.scale_0?(w.scale_0[t]=Math.exp(g.scale_0),w.scale_1[t]=Math.exp(g.scale_1),w.scale_2[t]=Math.exp(g.scale_2)):(w.scale_0[t]=.01,w.scale_1[t]=.01,w.scale_2[t]=.01),void 0!==g.f_dc_0?(w.f_dc_0[t]=r(g.f_dc_0),w.f_dc_1[t]=r(g.f_dc_1),w.f_dc_2[t]=r(g.f_dc_2)):(w.f_dc_0[t]=0,w.f_dc_1[t]=0,w.f_dc_2[t]=0),void 0!==g.opacity&&(w.opacity[t]=255*n(g.opacity)),w.rot_0[t]=g.rot_0,w.rot_1[t]=g.rot_1,w.rot_2[t]=g.rot_2,w.rot_3[t]=g.rot_3,w.x[t]=g.x,w.y[t]=g.y,w.z[t]=g.z,w.splatCount++;const F=o(w,a),P=performance.now();return console.log("Parsing PLY to SPLAT complete!"),console.log("Total time: ",(P-s).toFixed(2)+" ms"),F}static convertToSTPM(t){console.log("Converting PLY to STPM...");const{splatCount:e,propertyTypes:o,vertexData:a}=c.decodeHeader(t);let s=0;for(const t in o)t.startsWith("f_rest_")&&(s+=1);const l=s/3,i=[];for(let t=0;t<3;++t)i.push(`f_dc_${t}`);for(let t=0;t<l;++t)for(let e=0;e<3;++e)i.push(`f_rest_${e*l+t}`);let _=0,f={};const d={double:8,int:4,uint:4,float:4,short:2,ushort:2,uchar:1};for(let t in o)if(o.hasOwnProperty(t)){const e=o[t];f[t]=_,_+=d[e]}let p={};const h=["scale_0","scale_1","scale_2","rot_0","rot_1","rot_2","rot_3","x","y","z","f_dc_0","f_dc_1","f_dc_2","opacity"];var y="#mandatory centroid x/y/z\n";y+="#supported types: float\n",y+="metadata centroid_x float\n",y+="metadata centroid_y float\n",y+="metadata centroid_z float\n",y+="metadata rot_0 float\n",y+="metadata rot_1 float\n",y+="metadata rot_2 float\n",y+="metadata rot_3 float\n",y+="metadata scale_0 float\n",y+="metadata scale_1 float\n",y+="metadata scale_2 float\n",y+="metadata f_dc_0 float\n",y+="metadata f_dc_1 float\n",y+="metadata f_dc_2 float\n",y+="metadata opacity float\n";for(let t=0;t<e;t++){if(c.readRawVertexFast(a,t*_,f,h,o,p),y+=p.x.toFixed(4),y+=" "+p.y.toFixed(4),y+=" "+p.z.toFixed(4),y+=" "+p.rot_0.toFixed(4),y+=" "+p.rot_1.toFixed(4),y+=" "+p.rot_2.toFixed(4),y+=" "+p.rot_3.toFixed(4),void 0===p.scale_0)return void console.error("Invalid ply file to convert. Missing Scale");if(y+=" "+p.scale_0.toFixed(4),y+=" "+p.scale_1.toFixed(4),y+=" "+p.scale_2.toFixed(4),void 0===p.f_dc_0)return void console.error("Invalid ply file to convert. Missing 1st order color harmonics");y+=" "+r(p.f_dc_0).toFixed(4),y+=" "+r(p.f_dc_1).toFixed(4),y+=" "+r(p.f_dc_2).toFixed(4),void 0!==p.opacity&&(y+=" "+(255*n(p.opacity)).toFixed(4)),y+="\n"}return y}}class l{constructor(){}static readVertexLine(t){const e=t.split(" ");let o={};return o.positions_x=parseFloat(e[0]),o.positions_y=parseFloat(e[1]),o.positions_z=parseFloat(e[2]),o.rotation_x=parseFloat(e[3]),o.rotation_y=parseFloat(e[4]),o.rotation_z=parseFloat(e[5]),o.rotation_w=parseFloat(e[6]),o.scale_x=parseFloat(e[7]),o.scale_y=parseFloat(e[8]),o.scale_z=parseFloat(e[9]),o.color_r=parseFloat(e[10]),o.color_g=parseFloat(e[11]),o.color_b=parseFloat(e[12]),o.color_a=parseFloat(e[13]),o}static parseToSplatBuffer(t,a){const r=performance.now();console.log("Parsing STPM data to SPLAT...");let s=new TextDecoder("utf-8").decode(t).split("\n"),n=0;for(;"#"===s[n][0];)n+=1;for(;"metadata"===s[n].substring(0,8);)n+=1;const c=new e;for(var i=0;n<s.length;){const t=l.readVertexLine(s[n]);c.scale_0[i]=Math.exp(t.scale_x),c.scale_1[i]=Math.exp(t.scale_y),c.scale_2[i]=Math.exp(t.scale_z),c.f_dc_0[i]=t.color_r,c.f_dc_1[i]=t.color_g,c.f_dc_2[i]=t.color_b,c.opacity[i]=t.color_a,c.rot_0[i]=t.rotation_x,c.rot_1[i]=t.rotation_y,c.rot_2[i]=t.rotation_z,c.rot_3[i]=t.rotation_w,c.x[i]=t.positions_x,c.y[i]=t.positions_y,c.z[i]=t.positions_z,c.splatCount++,n+=1,i+=1}const _=o(c,a),f=performance.now();return console.log("Parsing STPM Data to SPLAT complete!"),console.log("Total time: ",(f-r).toFixed(2)+" ms"),_}}class i{static getFixed24(t,e,o){let a=t.getUint8(9*e+3*o+0,!0);return a|=t.getUint8(9*e+3*o+1,!0)<<8,a|=t.getUint8(9*e+3*o+2,!0)<<16,a|=8388608&a?4278190080:0,a}static parseToSplatBuffer(a,n){const c=new Uint8Array(a,0,4);if("NGSP"!==String.fromCharCode(c[0],c[1],c[2],c[3]))return 31==c[0]&&139==c[1]?console.error("SPZ is still gzipped. It should be decompressed before feeding to the Parser !"):console.error("SPZ Magic not recognized ! Unknown file"),null;const l=16,_=new DataView(a,0,l);if(2!==_.getUint32(4,!0))return console.error("SPZ version not supported !"),null;const f=_.getUint32(8,!0),d=(_.getUint8(12,!0),_.getUint8(13,!0)),p=(_.getUint8(14,!0),3*f*3),h=f,y=3*f,u=3*f,g=3*f,x=new DataView(a,l,p),w=new DataView(a,l+p,h),F=new DataView(a,l+p+h,y),P=new DataView(a,l+p+h+y,u),m=new DataView(a,l+p+h+y+u,g),S=1/(1<<d),U=new e;let A=0;for(;A<f;){U.scale_0[A]=Math.exp(P.getUint8(3*A+0,!0)/16-10),U.scale_1[A]=Math.exp(P.getUint8(3*A+1,!0)/16-10),U.scale_2[A]=Math.exp(P.getUint8(3*A+2,!0)/16-10),U.f_dc_0[A]=r(s(F.getUint8(3*A+0,!0))),U.f_dc_1[A]=r(s(F.getUint8(3*A+1,!0))),U.f_dc_2[A]=r(s(F.getUint8(3*A+2,!0))),U.opacity[A]=w.getUint8(A,!0);let e=new t.Vector3(1*m.getUint8(3*A+0,!0)/127.5-1,1*m.getUint8(3*A+1,!0)/127.5-1,1*m.getUint8(3*A+2,!0)/127.5-1);U.rot_0[A]=Math.sqrt(Math.max(0,1-e.dot(e))),U.rot_1[A]=e.x,U.rot_2[A]=e.y,U.rot_3[A]=e.z,U.x[A]=i.getFixed24(x,A,0)*S,U.y[A]=i.getFixed24(x,A,1)*S,U.z[A]=i.getFixed24(x,A,2)*S,U.splatCount++,A+=1}const C=o(U,n);return console.log("Parsing SPZ Data to SPLAT complete!"),C}}class _{constructor(){}}return _.CGR_TYPE_UNKNOWN=0,_.CGR_TYPE_PLY=1,_.createSplatBufferFromCGR=function(t){if(console.log("Reading CGR file..."),1==t.version){if(t.type==_.CGR_TYPE_PLY){return _.PlyParser.parseToSplatBuffer(t.bufferData.buffer,1)}console.warn(`Unsupported CGR Gaussian Type ${t.type} on version 1`)}else console.warn(`Gaussian splat CGR version ${t.version} is not yet supported`);return null},_.SplatBuffer=a,_.PlyParser=c,_.PlainDataParser=class{constructor(){}static parseToSplatBuffer(t,a){const r=performance.now();console.log("Parsing Plain data to SPLAT...");const s=t.nbPoints,n=new e;t.colors.length>0&&!(t.colors[0]instanceof Array)&&console.error("Splat data colors is not the right type");for(let e=0;e<s;e++)n.scale_0[e]=Math.exp(t.scales[e].x),n.scale_1[e]=Math.exp(t.scales[e].y),n.scale_2[e]=Math.exp(t.scales[e].z),n.f_dc_0[e]=t.colors[e][0],n.f_dc_1[e]=t.colors[e][1],n.f_dc_2[e]=t.colors[e][2],n.opacity[e]=t.colors[e][3],n.rot_0[e]=t.rotations[e].x,n.rot_1[e]=t.rotations[e].y,n.rot_2[e]=t.rotations[e].z,n.rot_3[e]=t.rotations[e].w,n.x[e]=t.positions[e].x,n.y[e]=t.positions[e].y,n.z[e]=t.positions[e].z,n.splatCount++;const c=o(n,a),l=performance.now();return console.log("Parsing Plain Data to SPLAT complete!"),console.log("Total time: ",(l-r).toFixed(2)+" ms"),c}},_.StpmDataParser=l,_.ResponseDataParser=class{static parseToSplatBuffer(t,a){let r=new DataView(t);const s=new Uint8Array(t);let n=0;if(2!==r.getUint32(n,!0))return console.error("Response data version is not 2"),null;n+=4;let c=r.getUint32(n,!0);n+=4;const l=new TextDecoder("utf-8"),i=JSON.parse(l.decode(s.subarray(n,n+c)));n+=c;let _=r.getUint32(n,!0);n+=4;r.getFloat32(n,!0);n+=4;let f,d=0,p={};for(let t of i)d+=t.size,p[t.name]=t.offset;f=n%4==0?s.subarray(n,n+_*d):new Uint8Array(t.slice(n,n+_*d));let h=new DataView(f.buffer);const y=new e;for(var u=0;u<_;){const t=u*d,e=1;y.scale_0[u]=Math.exp(h.getFloat32(p.scale_0+t,!0))*e,y.scale_1[u]=Math.exp(h.getFloat32(p.scale_1+t,!0))*e,y.scale_2[u]=Math.exp(h.getFloat32(p.scale_2+t,!0))*e,y.f_dc_0[u]=h.getFloat32(p.f_dc_0+t,!0),y.f_dc_1[u]=h.getFloat32(p.f_dc_1+t,!0),y.f_dc_2[u]=h.getFloat32(p.f_dc_2+t,!0),y.opacity[u]=h.getFloat32(p.opacity+t,!0),y.rot_0[u]=h.getFloat32(p.rot_0+t,!0),y.rot_1[u]=h.getFloat32(p.rot_1+t,!0),y.rot_2[u]=h.getFloat32(p.rot_2+t,!0),y.rot_3[u]=h.getFloat32(p.rot_3+t,!0),y.x[u]=h.getFloat32(p.DEF_POSITION+t,!0),y.y[u]=h.getFloat32(p.DEF_POSITION+4+t,!0),y.z[u]=h.getFloat32(p.DEF_POSITION+8+t,!0),y.splatCount++,u+=1}const g=o(y,a);return console.log("Parsing Response Data to SPLAT complete!"),g}},_.SPZParser=i,_}));