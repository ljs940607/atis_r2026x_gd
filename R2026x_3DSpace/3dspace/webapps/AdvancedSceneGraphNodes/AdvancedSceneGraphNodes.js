define("DS/AdvancedSceneGraphNodes/InstancedSphereImpostorsNode",["DS/Visualization/ThreeJS_DS","DS/Visualization/Node3D","DS/Visualization/Mesh3D","DS/Mesh/MeshUtils"],(function(t,n,e,r){"use strict";var i=n.extend({init:function(n){this._isIE11=null!=new RegExp("Trident/.*rv:([0-9]{1,}[.0-9]{0,})").exec(navigator.userAgent),this._name=n.name||"sphereImpostors",this._parent(this._name);var r=n.material?n.material:t.MaterialUtils.createShinyFaceMaterial({force:!0});r.transparent=!0;var i=this._createMaterial(r),a=n.nbInstances||1,o=null;o=this._isIE11?this._createCoarseImpostor(8,i):this._createFlatImpostor(6,i);for(var s=new e(o,""),c=n.positions,l=n.radii,d=n.colors,v=new t.Vector3(1/0,1/0,1/0),u=new t.Vector3(-1/0,-1/0,-1/0),$=new Float32Array(4*a),y=new Float32Array(2*a),_=0;_<a;_++)$[4*_]=c[3*_],$[4*_+1]=c[3*_+1],$[4*_+2]=c[3*_+2],$[4*_+3]=l[_],y[2*_]=Math.floor(255*d[4*_])+256*Math.floor(255*d[4*_+1])+65536*Math.floor(255*d[4*_+2]),y[2*_+1]=d[4*_+3],v.x=Math.min(v.x,c[3*_]-l[_]),v.y=Math.min(v.y,c[3*_+1]-l[_]),v.z=Math.min(v.z,c[3*_+2]-l[_]),u.x=Math.max(u.x,c[3*_]+l[_]),u.y=Math.max(u.y,c[3*_+1]+l[_]),u.z=Math.max(u.z,c[3*_+2]+l[_]);var h=(new t.Vector3).addVectors(v,u).multiplyScalar(.5),f=(new t.Vector3).addVectors(h,(new t.Vector3).subVectors(v,h).multiplyScalar(1.05)),p=(new t.Vector3).addVectors(h,(new t.Vector3).subVectors(u,h).multiplyScalar(1.05)),C=new t.Box3(f,p),m={data:$,type:"v4",isFlattened:!0,attribName:"instancePositionAndRadius"},w={data:y,type:"v2",isFlattened:!0,attribName:"instanceColor"};return s.setMaterial(i),s.setInstancingParameters(a,[m,w],"instance"),s.forceBoundingBox(C),this.addChild(s),this},_createFlatImpostor:function(n,e){var i=[],a=new t.BufferGeometryDS;a.drawingGroups=[];var o=3*n,s=new r.DrawingGroup(e,e,4,0,o);s.geometry=a,a.drawingGroups.push(s);var c,l=new Float32Array(3*(n+1)),d=0;l[d++]=0,l[d++]=0,l[d++]=0;for(var v=0;v<n;v++)c=v/n,l[d++]=Math.cos(2*c*Math.PI),l[d++]=Math.sin(2*c*Math.PI),l[d++]=0;a.vertexPositionArray=l;var u=new Uint16Array(o),$=0;for(v=0;v<n;v++)u[$++]=0,u[$++]=v+1,u[$++]=v+2>6?(v+2)%n:v+2;a.vertexIndexArray=u,i.push(a);var y=new t.Mesh(i,e);return y.matrixAutoUpdate=!1,y},_createCoarseImpostor:function(n,e){var i=[],a=new t.BufferGeometryDS;a.drawingGroups=[];var o=6*n*(n-1),s=new r.DrawingGroup(e,e,4,0,o);s.geometry=a,a.drawingGroups.push(s);var c=2+(n-1)*n,l=new Float32Array(3*c),d=0,v=0;l[d++]=0,l[d++]=0,l[d++]=-1;for(var u=0,$=0,y=0;y<n;y++)for(var _=-n/2+1;_<=n/2-1;_++)v=_/n,u=2*(y/n)*Math.PI,$=v*Math.PI,l[d++]=Math.cos(u)*Math.cos($),l[d++]=Math.sin(u)*Math.cos($),l[d++]=Math.sin($);l[d++]=0,l[d++]=0,l[d++]=1,a.vertexPositionArray=l;var h=new Uint16Array(o);d=0;var f=0;for(y=0;y<n;y++){f=y===n-1?c-2:c-1,h[d++]=0,h[d++]=((y+1)*(n-1)+1)%f,h[d++]=y*(n-1)+1;for(_=1;_<n-1;_++)h[d++]=((y+1)*(n-1)+_)%f,h[d++]=y*(n-1)+_+1,h[d++]=y*(n-1)+_,h[d++]=((y+1)*(n-1)+_)%f,h[d++]=((y+1)*(n-1)+_+1)%f,h[d++]=y*(n-1)+_+1;h[d++]=((y+1)*(n-1)+n-1)%f,h[d++]=c-1,h[d++]=y*(n-1)+n-1}a.vertexIndexArray=h,i.push(a);var p=new t.Mesh(i,e);return p.matrixAutoUpdate=!1,p},_createMaterial:function(t){var n=t;n.activatePDSFX("PDSFXSphereImpostor"),n.setPDSFXVaryings({viewCenterPos:{type:"v3"},radius:{type:"f"},radius2:{type:"f"},vaColor:{type:"v4"},rightAndLeft:{type:"v2"}}),n.setPDSFXGlobalShaderCode((function(t){const n=t.variableHandler,e=t=>n.floatG(t);return`\n                        ${e("_radius")} ;\n                        ${e("_radius2")} ;\n                        ${r="instancePosition",n.vec4G(r)} ;            \n                        `;var r}),(function(t){const n=t.variableHandler,e=t.functionHandler,r=n=>t.getVarying(n),i=t=>n.float(t),a=t=>n.boolG(t),o=t=>n.vec3(t);return`\n                        ${s="newViewPosition",n.vec3G(s)} ;\n                        ${a("toDiscard")} ;\n                        ${a("isPerspective")} ;\n                        ${(t=>n.vec2G(t))("viewport")} ;\n                        \n                        ${e.dF("intersectionWithSpherePERSP","v3",[e.prmV3("ray")])} {\n                        \n                            ${o("cameraToCenter")}  = ${r("viewCenterPos")};\n                            ${i("adjacentInTriangle")}  = dot(cameraToCenter, ray);\n                            ${i("distRayToCenter2")}  = dot(cameraToCenter, cameraToCenter) - adjacentInTriangle * adjacentInTriangle;\n                            if (distRayToCenter2 > (${r("radius")}*${r("radius")})) {\n                                toDiscard = true;\n                                return ${o()}(0.0,0.0,0.0);\n                            }\n                            //distance from orthoProj of center on ray, to the intersection\n                            ${i("projToIntersection")}  = sqrt(${r("radius")}*${r("radius")} - distRayToCenter2);\n                            ${i("cameraToIntersection")}  = adjacentInTriangle - projToIntersection;\n                            return cameraToIntersection * ray;\n                            \n                        }\n    \n                        ${e.dF("intersectionWithSphereORTHO","v3",[e.prmV3("ray")])} {\t\n                            \n                            ${o("viewRayBase")}  = ${o()}((2.0*(${t.vGetFragCoord()}.xy/viewport.xy) - 1.0)*${r("rightAndLeft")}.xy, 0.0);\t\t\t\t\t\n                            ${(t=>n.vec2(t))("projToCenter")}  = ${r("viewCenterPos")}.xy - viewRayBase.xy;\n                            ${i("distRayToCenter2")}  = dot(projToCenter,projToCenter);\n                            if (distRayToCenter2 > ${r("radius2")}) {\n                                toDiscard = true;\n                                return ${o()}(0.0,0.0,0.0);\n                            }\n                            ${i("projToIntersection")}  = sqrt(${r("radius2")} - distRayToCenter2);\n                            ${o("projRayOnImpostor")}  = ${o()}(viewRayBase.xy, ${r("viewCenterPos")}.z);\n                            return projRayOnImpostor - projToIntersection*ray;\n                            \n                        }\n                        \n                        `;var s}));var e={ComputeCommonValues:function(t,n){return`\n                            //radius\n                            _radius = instancePositionAndRadius.w;\n                            //radius2\n                            _radius2 = _radius * _radius;\t\t\t\t\t\n                            //instancePosition\n                            instancePosition = ${t.variableHandler.vec4(e)}(instancePositionAndRadius.xyz, 0.0);\n                        `;var e},ComputeVaryingValues:function(t,n){const e=t.variableHandler,r=t.pdsfxDefines,i=n=>t.getVarying(n),a=t=>e.vec4(t);return`\n                            //radius\n                            ${i("radius")} = _radius;\n                            //radius2\n                            ${i("radius2")} = _radius2;\n                            //vaColor\n                            ${a("color")} ;\n                            color.a = instanceColor.y;\n                            color.b = floor(instanceColor.x / 65536.0);\n                            ${o="tmp",e.float(o)}  = instanceColor.x - color.b * 65536.0;\n                            color.g = floor(tmp / 256.0);\n                            color.r = floor(tmp - color.g * 256.0);\n                            color.x /= 255.0;\n                            color.y /= 255.0;\n                            color.z /= 255.0;\n                            ${r.gammaInput?`\n                                vaColor = ${a()}(color.rgb * color.rgb, color.a);\n                                `:"\n                                vaColor = color;\n                                "}\n                            ${(t=>e.mat4(t))("pMatrix")}  = ${t.vGetProjectionMatrix()};\n                            ${i("rightAndLeft")} = ${(t=>e.vec2(t))()}(1.0/pMatrix[0][0],${r.WebGPU?"-":""}1.0/pMatrix[1][1]);\n                        `;var o},ProcessViewTangentSpace:function(t,n){const e=t.variableHandler,r=n=>t.getVarying(n),i=t=>e.float(t),a=t=>e.vec2(t),o=t=>e.vec3(t),s=e.dereference(n[0]);return`\n                        ${o("localPos")}  = ${t.vGetAttribPosition()};\n                        ///////\n                        ${c="pMatrix",e.mat4(c)} = ${t.vGetProjectionMatrix()};\n                        ${(t=>e.bool(t))("isPersp")} = pMatrix[3][3] < 0.5;\n                        ${i("minScale")} ;\n                        //center in view space\n                        ${r("viewCenterPos")} = (${t.vGetViewMatrix()}*${(t=>e.vec4(t))()}(instancePosition.xyz,1.0)).xyz;\n                        if (isPersp) {\n                            ${o("CR")}  = - ${r("viewCenterPos")};\n                            ${i("CR_L")}  = length(CR);\n                            ${i("CR_L_2")}  = CR_L*CR_L;\n                            ${i("d")} = sqrt(CR_L_2 - _radius2);\n                            ${o("CP")}  = localPos;\n                            ${i("dotCRCP")}  = dot(CR,CP);\n                            ${o("CR_y")}  = CR - dotCRCP*CP;\n                            //camera in the new basis coordinates\n                            ${a("_R")} = ${a()}(dotCRCP, length(CR_y));\n                            ${i("_Y1")}  = _radius*(_radius*_R.y + d*_R.x)/CR_L_2;\n                            ${i("_X1")}  = (_radius2 - _Y1*_R.y)/_R.x;\n\n                            ${i("_Y2")}  = _radius*(_radius*_R.y - d*_R.x)/CR_L_2;\n                            ${i("_X2")}  = (_radius2 - _Y2*_R.y)/_R.x;\n\n                            ${i("minScale1")}  = abs(_radius2/_X1);\n                            ${i("minScale2")}  = abs(_radius2/_X2);\n\n                            minScale = max(minScale1, minScale2);\n                            ${i("bonusCoeff")}  = (minScale - _radius)*0.1547005/(0.4*_radius) + 1.0;\n                            minScale = minScale*1.1547005*bonusCoeff;\n                            minScale = min(_radius*1.8, minScale);\n                            //special case\n                            if (abs(dotCRCP) < 0.0001) {\n                                minScale = _radius*1.1547;\n                            }\n                        } else {\n                            minScale = _radius*1.1547;\n                        }\n\n                        ${s}.Position = ${o()}( ${r("viewCenterPos")} + minScale * localPos);\n                    `;var c}},r={ComputeCommonValues:function(t,n){const e=t.variableHandler,r=t.functionHandler,i=t=>e.vec3(t);return`\n                            toDiscard = false;\n\t\t\t\t\t\t\t${a="pMatrix",e.mat4(a)}  = ${t.vGetProjectionMatrix()};\n\t\t\t\t\t\t\tviewport = ${(t=>e.vec2(t))()}(${t.vGetViewportSize()});\n\t\t\t\t\t\t\tisPerspective = pMatrix[3][3] < 0.5;\n\t\t\t\t\t\t\tif(isPerspective) {\n\t\t\t\t\t\t\t\t${i("ray")}  = normalize(${t.vGetViewPosition()});\n\t\t\t\t\t\t\t\tnewViewPosition = ${r.cF("intersectionWithSpherePERSP","v3",[r.prmV3("ray")])};\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t${i("ray")}  = ${i()}(0.0, 0.0, -1.0);\n\t\t\t\t\t\t\t\tnewViewPosition = ${r.cF("intersectionWithSphereORTHO","v3",[r.prmV3("ray")])};\n\t\t\t\t\t\t\t}\n                        `;var a},ComputeDiscard:function(t,n){return"\n                            return toDiscard;\n                        "},ComputeAlbedo:function(t,n){return"\n                            return vaColor.xyz;\n                        "},ComputeViewNormal:function(t,n){return`\n                            return normalize(newViewPosition - ${e="viewCenterPos",t.getVarying(e)});\n                        `;var e},ComputeViewPosition:function(t,n){const e=t.variableHandler,r=t=>e.float(t);return`               \n                        ${r("linearDepth")}  = -newViewPosition.z;\n                        ${i="near_far",e.vec3(i)} = ${t.vGetNearFarLogFactor()};\n                        ${r("near")}  = near_far.x;\n                        ${r("far")}  = near_far.y;\n                        ${r("fragDepth")} ;\n                        if (isPerspective) {\n                            fragDepth = (1.0/linearDepth - 1.0/near)/(1.0/far - 1.0/near);\n                        } else {\n                            fragDepth = (linearDepth - near)/(far - near);\n                        }\n                        ${t.vSetFragDepth("fragDepth")};\n                        return newViewPosition;\n                    `;var i}};return n.setPDSFXOverridableFunctions(e,r),n},setName:function(t){this._name=t}});return UWA.namespace("THREEDS/Nodes/InstancedSphereImpostorsNode",i)})),define("DS/AdvancedSceneGraphNodes/InstancedCylinderImpostorsNode",["DS/Visualization/ThreeJS_DS","DS/Visualization/Node3D","DS/Visualization/Mesh3D","DS/Mesh/MeshUtils"],(function(t,n,e,r){"use strict";var i=n.extend({init:function(n){this._isIE11=null!=new RegExp("Trident/.*rv:([0-9]{1,}[.0-9]{0,})").exec(navigator.userAgent),this._name=n.name||"cylinderImpostors",this._parent(this._name);var r=n.material?n.material:t.MaterialUtils.createShinyFaceMaterial({force:!0});r.transparent=!0;var i=this._createMaterial(r),a=n.nbInstances||1,o=null;o=this._isIE11?this._createCoarseImpostor(6,i):this._createFlatImpostor(0,i);for(var s=new e(o,""),c=n.positions,l=n.radii,d=n.axes,v=n.colors,u=function(n,e,r,i){var a=r.dot(r),o=new t.Vector3(i*Math.sqrt(1-r.x*r.x/a),i*Math.sqrt(1-r.y*r.y/a),i*Math.sqrt(1-r.z*r.z/a)),s=(new t.Vector3).subVectors(n,o);s.min((new t.Vector3).subVectors(e,o));var c=(new t.Vector3).addVectors(n,o);return c.max((new t.Vector3).addVectors(e,o)),new t.Box3(s,c)},$=new t.Vector3(1/0,1/0,1/0),y=new t.Vector3(-1/0,-1/0,-1/0),_=new Float32Array(4*a),h=new Float32Array(2*a),f=new Float32Array(3*a),p=new t.Vector3,C=new t.Vector3,m=new t.Vector3,w=0;w<a;w++)_[4*w]=c[3*w],_[4*w+1]=c[3*w+1],_[4*w+2]=c[3*w+2],_[4*w+3]=l[w],f[3*w]=d[3*w],f[3*w+1]=d[3*w+1],f[3*w+2]=d[3*w+2],p.set(f[3*w],f[3*w+1],f[3*w+2]),m.addVectors(new t.Vector3(c[3*w],c[3*w+1],c[3*w+2]),new t.Vector3(.5*d[3*w],.5*d[3*w+1],.5*d[3*w+2])),C.subVectors(new t.Vector3(c[3*w],c[3*w+1],c[3*w+2]),new t.Vector3(.5*d[3*w],.5*d[3*w+1],.5*d[3*w+2])),D=u(C,m,p,l[w]),$.min(D.min),y.max(D.max),h[2*w]=Math.floor(255*v[4*w])+256*Math.floor(255*v[4*w+1])+65536*Math.floor(255*v[4*w+2]),h[2*w+1]=v[4*w+3];var x=(new t.Vector3).addVectors($,y).multiplyScalar(.5),P=(new t.Vector3).addVectors(x,(new t.Vector3).subVectors($,x).multiplyScalar(1.05)),g=(new t.Vector3).addVectors(x,(new t.Vector3).subVectors(y,x).multiplyScalar(1.05)),D=new t.Box3(P,g),A={data:_,type:"v4",isFlattened:!0,attribName:"instancePositionAndRadius"},V={data:f,type:"v3",isFlattened:!0,attribName:"cylinderAxis"},M={data:h,type:"v2",isFlattened:!0,attribName:"instanceColor"};return s.setMaterial(i),s.setInstancingParameters(a,[A,V,M],"instance"),s.forceBoundingBox(D),this.addChild(s),this},_createFlatImpostor:function(n){var e=[],i=new t.BufferGeometryDS;i.drawingGroups=[];var a=new r.DrawingGroup(n,n,4,0,6);a.geometry=i,i.drawingGroups.push(a);var o=new Float32Array([0,0,0,1,0,0,1,1,0,0,1,0]);i.vertexPositionArray=o;var s=new Uint16Array([0,1,2,0,2,3]);i.vertexIndexArray=s,e.push(i);var c=new t.Mesh(e,n);return c.matrixAutoUpdate=!1,c},_createCoarseImpostor:function(n,e){var i=[],a=new t.BufferGeometryDS;a.drawingGroups=[];var o=12*n,s=new r.DrawingGroup(e,e,4,0,o);s.geometry=a,a.drawingGroups.push(s);var c=2*n+2,l=new Float32Array(3*c),d=0,v=0;l[d++]=0,l[d++]=0,l[d++]=-1;for(var u=0;u<n;u++)v=u/n,l[d++]=Math.cos(2*v*Math.PI),l[d++]=Math.sin(2*v*Math.PI),l[d++]=-1,l[d++]=Math.cos(2*v*Math.PI),l[d++]=Math.sin(2*v*Math.PI),l[d++]=1;l[d++]=0,l[d++]=0,l[d++]=1,a.vertexPositionArray=l;var $=new Uint16Array(o),y=0;for(u=0;u<2*n;u+=2){var _=c-1;10===u&&(_=c-2),$[y++]=0,$[y++]=(u+3)%_,$[y++]=u+1,$[y++]=u+1,$[y++]=(u+3)%_,$[y++]=u+2,$[y++]=(u+3)%_,$[y++]=(u+4)%_,$[y++]=u+2,$[y++]=c-1,$[y++]=u+2,$[y++]=(u+4)%_}a.vertexIndexArray=$,i.push(a);var h=new t.Mesh(i,e);return h.matrixAutoUpdate=!1,h},_createMaterial:function(t){var n=t;n.activatePDSFX("PDSFXCylinderImpostor"),n.setPDSFXVaryings({viewCenterPos:{type:"v3"},radius:{type:"f"},radius2:{type:"f"},vaColor:{type:"v4"},_viewAxis:{type:"v3"},half_height:{type:"f"},rightAndLeft:{type:"v2"}}),n.setPDSFXGlobalShaderCode((function(t){const n=t.variableHandler;return`\n                            ${e="_viewCenterPos",n.vec3G(e)};\n                        `;var e}),(function(t){const n=t.variableHandler,e=t.functionHandler,r=n=>t.getVarying(n),i=t=>n.boolG(t),a=t=>n.float(t),o=t=>n.vec3(t),s=t=>n.vec3G(t);return`\n                            ${s("viewPositionOnCylinder")};\n                            ${s("viewNormalOnCylinder")};\n                            ${i("toDiscard")};\n                            ${i("isPerspective")};\n                            ${c="viewport",n.vec2G(c)};\n\n                            ${e.dF("intersectionWithCylinderPERSP",null,[])}{\n                                //smallest distance between the ray and the axis\n                                ${a("minDistance")} ;\n                                // minDistance^2\n                                ${a("minDistance2")} ;\n                                \n                                //ray from camera to position \n                                ${o("viewPos")}  = ${t.vGetViewPosition()};\n                                ${o("ray")}  = normalize(viewPos);\n                                ${o("cameraToCenter")}  = ${r("viewCenterPos")};\t\t\n                                ${o("viewAxis")} = ${r("_viewAxis")};\t\t\t\t\n                                \n                                //direction of the closest path between ray and cylinder axis\n                                //(common orthogonal)\n                                ${o("D")} = cross(ray, viewAxis);\n                                \n                                //if the ray is parallel to the cylinder axis\n                                ${a("lengthD")}  = length(D);\n                                if (lengthD == 0.0) {\n                                    ${a("adjacentInTriangle")}  = dot(ray, cameraToCenter);\n                                    minDistance2 = dot(cameraToCenter, cameraToCenter) - adjacentInTriangle*adjacentInTriangle;\n                                    if (minDistance2 > ${r("radius2")}) {\n                                    \ttoDiscard = true;\n                                    \treturn;\n                                    }\t\t\t\t\t\n                                    viewNormalOnCylinder = -ray;\n                                    viewPositionOnCylinder = adjacentInTriangle*ray;\n                                    return;\t\t\t\t\t\t\t\t\n                                }\n                                \n                                // if not\n                                D = normalize(D);\n                                minDistance = abs(dot(-cameraToCenter, D));\n                                if (minDistance > radius) {\n                                \ttoDiscard = true;\n                                \treturn;\n                                }\n                                \n                                ${a("t")} = -dot(cross(-cameraToCenter, viewAxis), D)/lengthD;\n                                ${o("O")} = normalize(cross(D, viewAxis));\n                                ${a("s")} = abs(sqrt(${r("radius2")} - minDistance*minDistance)/dot(ray, O));\n                                //first intersection\n                                ${o("intersection_in")}  = (t-s)*ray;\t\t\t\t\t\t\t\t\n                                //second intersection\n                                ${o("intersection_out")}  = (t+s)*ray;\n                                \n                                //checking if the intersection is on the closed cylinder\n                                ${o("intersectionToCenter_in")}  = cameraToCenter - intersection_in;\n                                ${o("intersectionToCenter_out")}  = cameraToCenter - intersection_out;\n                                \n                                ${a("dot_in_axis")}  = abs(dot(intersectionToCenter_in, viewAxis));\n                                \n                                //the first intersection isn't on the closed cylinder\n                                if (dot_in_axis > ${r("half_height")}) {\n                                    // we exclude rays that don't go through the closed cylinder\n                                    if (abs(dot(intersectionToCenter_out, viewAxis)) > ${r("half_height")} && \n                                        dot(intersectionToCenter_in, viewAxis)*dot(intersectionToCenter_out, viewAxis) > 0.0) {\n                                            toDiscard = true;\n                                            return;\n                                    }\n                                    \n                                    ${a("diff")}  = dot_in_axis - ${r("half_height")};\n                                    ${a("_dot")}  = dot(ray, viewAxis);\n                                    \n                                    viewNormalOnCylinder = - sign(_dot) * viewAxis;\n                                    //distance along the ray from intersection_in to the real intersection on cap\n                                    ${a("x")};\n                                    x = diff/abs(_dot);\n                                    viewPositionOnCylinder = intersection_in + x*ray;\t\t\t\t\t\t\t\t\t\n                                    \n                                    return;\n                                \n                                }\n\n                                //projection of the intersection on the axis\n                                ${o("intersectionProj")};\n                                intersectionProj = ${r("viewCenterPos")} + dot(-intersectionToCenter_in, viewAxis)*viewAxis;\n                                \n                                viewNormalOnCylinder = normalize(intersection_in - intersectionProj);\n                                viewPositionOnCylinder = intersection_in;\n\n                            }\n\n                            ${e.dF("intersectionWithCylinderORTHO",null,[])} {\n                                //smallest distance between the ray and the axis\n                                ${a("minDistance")} ;\n                                //ray from camera to position \n                                ${o("ray")}  = ${o()}(0.0,0.0, -1.0);\n                                ${o("viewRayBase")}  = ${o()}((2.0*(${t.vGetFragCoord()}.xy/viewport.xy) - 1.0)*${r("rightAndLeft")}.xy, 0.0);\n                                ${o("cameraToCenter")}  = ${o()}(0.0,0.0,${r("viewCenterPos")}.z);\t\n                                ${o("viewAxis")} = ${r("_viewAxis")};\t\t\t\n                                \n                                //direction of the closest path between ray and cylinder axis\n                                //(common orthogonal)\n                                ${o("D")} = cross(ray, viewAxis);\n                                \n                                //if the ray is parallel to the cylinder axis\n                                ${a("lengthD")}  = length(D);\n                                if (lengthD == 0.0) {\t\t\t\t\t\t\t\n                                    minDistance = length(viewRayBase.xy - ${r("viewCenterPos")}.xy);\n                                    if (minDistance > radius) {\n                                    \ttoDiscard = true;\n                                    \treturn;\n                                    }\n                                    viewNormalOnCylinder = -ray;\n                                    viewPositionOnCylinder = viewRayBase + cameraToCenter + vec3(0.0,0.0,${r("half_height")});\n                                    return;\t\t\t\t\t\t\t\t\n                                }\n                                \n                                // if not\n                                D = normalize(D);\n                                minDistance = abs(dot(${r("viewCenterPos")} - viewRayBase, D));\n                                //skip pixels beyond cylinder radius\n                                if (minDistance > radius) {\n                                \ttoDiscard = true;\n                                \treturn;\n                                }\n                                \n                                ${a("t")} = -dot(cross(viewRayBase - ${r("viewCenterPos")}, viewAxis), D)/lengthD;\n                                ${o("O")} = normalize(cross(D, viewAxis));\n                                ${a("s")} = abs(sqrt(${r("radius2")} - minDistance*minDistance)/dot(ray, O));\n                                // // first intersection\n                                ${o("intersection_in")}  = viewRayBase + (t-s)*ray;\n                                // second intersection\n                                ${o("intersection_out")}  = viewRayBase + (t+s)*ray;\n                                \n                                // checking if the intersection is on the closed cylinder\n                                ${o("intersectionToCenter_in")}  = ${r("viewCenterPos")} - intersection_in;\n                                ${o("intersectionToCenter_out")}  = ${r("viewCenterPos")} - intersection_out;\n                                \n                                ${a("dot_in_axis")}  = abs(dot(intersectionToCenter_in, viewAxis));\n                                //the first intersection isn't on the closed cylinder\n                                if (dot_in_axis > ${r("half_height")}) {\n                                    // we exclude rays that don't go through the closed cylinder\n                                    if (abs(dot(intersectionToCenter_out, viewAxis)) > ${r("half_height")} && \n                                        dot(intersectionToCenter_in, viewAxis)*dot(intersectionToCenter_out, viewAxis) > 0.0) {\n                                            toDiscard = true;\n                                            return;\n                                    }\n                                    \n                                    ${a("diff")}  = dot_in_axis - ${r("half_height")};\n                                    ${a("_dot")}  = dot(ray, viewAxis);\n                                    \n                                    viewNormalOnCylinder = - sign(_dot) * viewAxis;\n                                    //distance along the ray from intersection_in to the real intersection on cap\n                                    ${a("x")};\n                                    x = diff/abs(_dot);\n                                    viewPositionOnCylinder = intersection_in + x*ray;\t\t\t\t\t\t\t\t\t\n                                    \n                                    return;\n                                \n                                }\n                                //projection of the intersection on the axis\n                                ${o("intersectionProj")} ;\n                                intersectionProj = ${r("viewCenterPos")} + dot(-intersectionToCenter_in, viewAxis)*viewAxis;\n                                \n                                viewNormalOnCylinder = normalize(intersection_in - intersectionProj);\n                                viewPositionOnCylinder = intersection_in;\n                            }\n                        `;var c}));var e={ComputeCommonValues:function(t,n){const e=t.variableHandler,r=n=>t.getVarying(n),i=t=>e.vec4(t);return`\n                        //radius (varying)\n                        ${r("radius")} = instancePositionAndRadius.w;\n                        //radius2 (varying)\n                        ${r("radius2")} = ${r("radius")} * ${r("radius")};\t\t\t\t\t\n                        //viewAxis (varying)\n                        ${r("_viewAxis")} = normalize((${t.vGetViewMatrix()}*${i()}(cylinderAxis, 0.0)).xyz);\n                        //half_height\n                        ${r("half_height")} = length(cylinderAxis)/2.0;\n                        //viewCenterPos (varying)\n                        ${r("viewCenterPos")} = (vGetViewMatrix() * ${i()}(instancePositionAndRadius.xyz, 1.0)).xyz;\n                        `},ComputeVaryingValues:function(t,n){const e=t.variableHandler,r=t.pdsfxDefines,i=n=>t.getVarying(n),a=t=>e.vec4(t);return`         \n\t\t\t\t\t\t\t//vaColor\n\t\t\t\t\t\t\t${a("color")} ;\n\t\t\t\t\t\t\tcolor.a = instanceColor.y;\n\t\t\t\t\t\t    color.b = floor(instanceColor.x / 65536.0);\n\t\t\t\t\t\t\t${o="tmp",e.float(o)}  = instanceColor.x - color.b * 65536.0;\n\t\t\t\t\t\t\tcolor.g = floor(tmp / 256.0);\n\t\t\t\t\t\t\tcolor.r = floor(tmp - color.g * 256.0);\n\t\t\t\t\t\t\tcolor.x /= 255.0;\n\t\t\t\t\t\t\tcolor.y /= 255.0;\n\t\t\t\t\t\t\tcolor.z /= 255.0;\n                            ${r.gammaInput?`\n                                ${i("vaColor")} = ${a()}(color.rgb * color.rgb, color.a);\n                                `:`\n                                ${i("vaColor")} = color;\n                                `}\n\t\t\t\t\t\t\t${(t=>e.mat4(t))("pMatrix")}  = ${t.vGetProjectionMatrix()};\n\t\t\t\t\t\t\t${i("rightAndLeft")} = ${(t=>e.vec2(t))()}(1.0/pMatrix[0][0], ${r.WebGPU?"-":""}1.0/pMatrix[1][1]);\n                        `;var o},ProcessViewTangentSpace:function(t,n){const e=t.variableHandler,r=n=>t.getVarying(n),i=t=>e.bool(t),a=t=>e.float(t),o=t=>e.vec3(t),s=e.dereference(n[0]);return`\n                            ${o("localPosition")}  = ${t.vGetAttribPosition()} - ${o()}(0.5, 0.5, 0.0);\n                            ${c="pMatrix",e.mat4(c)}  = ${t.vGetProjectionMatrix()};\n                            ${i("isPersp")}  = pMatrix[3][3] < 0.5;\n                            ${o("viewAxis")} = ${r("_viewAxis")};\t\t\n                            ${o("_z")}  = -sign(dot( -${r("viewCenterPos")}, viewAxis))*viewAxis;\n                            \n                            ${o("C0")}  = ${r("viewCenterPos")} - ${r("half_height")}*_z;\t\t\t\t\n                            ${o("C1")}  = ${r("viewCenterPos")} + ${r("half_height")}*_z;\n                            if (isPersp) {\n                                                                \n                                ${o("v")}  =  - C0;\n                                ${o("_x")}  = normalize(cross(v, _z));\n                                ${o("_y")}  = normalize(cross(_z, _x));\t\t\t\t\t\t\n                                \n                                ${o("y_1")} ;\n                                ${o("x_2")} ;\n                                ${a("cos_alpha")} ;\n                                ${a("sin_alpha")} ;\n                                ${a("tan_alpha")} ;\n                                ${o("O_1")}  = C0 + dot(-C0, _y)*_y;\n                                ${a("OC_L")}  = length(C0 - O_1);\n                                \n                                sin_alpha = ${r("radius")}/OC_L;\n                                \n                                ${i("rectBillboard")}  = true;\n                                if (sin_alpha <= 0.5) {\n                                    cos_alpha = sqrt(1.0 - sin_alpha*sin_alpha);\n                                    tan_alpha = sin_alpha/cos_alpha;\n                                    y_1 = ${r("radius")}*_y;\n                                    x_2 = (OC_L -${r("radius")})*tan_alpha*_x;\n                                    rectBillboard = false;\n                                }\n                                //coeff in case no cap is visible on the cylinder because of perspective\n                                ${a("flatCylCoeff")}  = -1.0;\n                                \n                                ${o("C0Plus_y")}  = C0+${r("radius")}*_y;\n                                ${a("z_plane")}  = ${r("viewCenterPos")}.z;\n                                ${o("C0_n")}  = normalize(C0);\n                                ${o("C0_plane")}  = (z_plane/C0_n.z) * C0_n;\n                                ${o("C1_n")}  = normalize(C1);\n                                ${o("C1_plane")}  = (z_plane/C1_n.z) * C1_n;\n                                ${o("Y_y_n")}  = normalize(C0Plus_y);\n                                ${o("Y_plane")}  = (z_plane/Y_y_n.z) * Y_y_n;\n                                \n                                ${a("dot_C0_C1_y")}  = dot(C1_plane - C0_plane, Y_plane - C0_plane);\n                                if (dot_C0_C1_y*_y.z < 0.0) {\n                                    if (dot_C0_C1_y < 0.0) {\n                                        flatCylCoeff = 1.0;\n                                    }\n                                }\n                                \n                                ${o("newMvPosition")} ;\n\n                                ${a("sgn")}  = sign(localPosition.y);\n                                \n                                //margin to prevent black dots on the limits of the billboards\n                                ${a("inc_coeff")}  = 1.03;\n                                _x*=inc_coeff;\n                                _y*=inc_coeff;\n                                y_1*=inc_coeff;\n                                x_2*=inc_coeff;\n                                \n                                if (localPosition.x < 0.0) {\n                                    //cylinder seen from the top\n                                    if (rectBillboard) {\n                                        newMvPosition = C0 - ${r("radius")}*_y + sgn* ${r("radius")}*_x;\n                                    } else {\n                                        newMvPosition = C0 + flatCylCoeff * ${r("radius")}*_y + sgn* tan_alpha*(${r("radius")}+OC_L)*_x;\n                                    }\n                                } else {                                 \n                                    ${o("point")} ;\n                                    if (rectBillboard) {\n                                        ${o("ray")}  = normalize(C1 + ${r("radius")}*_y);\n                                        //the intersection point must be on the front facing cap's plane (and not at the C0.z level)\n                                        ${a("len")}  = dot(viewAxis, C0)/dot(viewAxis, ray);\n                                        ${o("intsc")}  = len*ray;\n                                        if (dot(intsc, _y) > dot(C0Plus_y, _y)) {\n                                            point = intsc;\n                                        } else {\n                                            point = C0Plus_y;\n                                        }\n                                        newMvPosition = point + sgn* ${r("radius")}*_x;\n                                    } else {\n                                        newMvPosition = C1 + y_1 + sgn* x_2;\n                                    }\n                                    \n                                }\t\t\t\n                                ${s}.Position = newMvPosition;\n                            } else {\n                                //axis projected on the impostor\n                                ${o("_y")}  = normalize(${o()}(C1.xy-C0.xy,0.0));\n                                ${o("_x")}  = ${o()}(-_y.y, _y.x, 0.0);\n                                \n                                ${a("medZ")}  = 0.5*(C0.z+C1.z);\n                                C0.z = medZ;\n                                C1.z = medZ;\n                                ${a("coeff")}  = 1.03;\n                                \n                                ${a("y_radius")}  = 0.0;\n                                if (viewAxis.z != 0.0) {\n                                    ${o("orthAxis")}  = normalize(${o()}(viewAxis.xy, -dot(viewAxis.xy,viewAxis.xy)/viewAxis.z));\n                                    y_radius = ${r("radius")}*abs(dot(orthAxis, _y));\n                                }\n                                \n                                if (localPosition.x < 0.0) {\n                                    ${s}.Position = C0 +coeff*(sign(localPosition.y) *_x*${r("radius")} - _y*y_radius);\n                                } else {\n                                    ${s}.Position = C1 + coeff*(sign(localPosition.y) *_x*${r("radius")} + _y*y_radius);\n                                }\n                            }\n                        \n                        `;var c}},r={ComputeCommonValues:function(t,n){const e=t.variableHandler,r=t.functionHandler;return`\n                        \n\t\t\t\t\t\t\t${i="pMatrix",e.mat4(i)}  = ${t.vGetProjectionMatrix()};\n\t\t\t\t\t\t\tisPerspective = pMatrix[3][3] < 0.5;\n\t\t\t\t\t\t\ttoDiscard = false;\n\t\t\t\t\t\t\tviewport = ${(t=>e.vec2(t))()}(${t.vGetViewportSize()});\n\t\t\t\t\t\t\tif (isPerspective) {\n                                ${r.cF("intersectionWithCylinderPERSP",null,[])};\n                            } else {\n                                ${r.cF("intersectionWithCylinderORTHO",null,[])};\n                            }\n                        `;var i},ComputeDiscard:function(t,n){return"\n                            return toDiscard;\n                        "},ComputeAlbedo:function(t,n){return`\n                            return ${e="vaColor",t.getVarying(e)}.xyz;\n                        `;var e},ComputeViewNormal:function(t,n){return"\n                            return viewNormalOnCylinder;\n                        "},ComputeViewPosition:function(t,n){const e=t.variableHandler,r=t=>e.float(t);return`\n                            ${r("linearDepth")} = -viewPositionOnCylinder.z;\n\t\t\t\t\t\t\t${i="near_far",e.vec3(i)}  = ${t.vGetNearFarLogFactor()};\n\t\t\t\t\t\t\t${r("near")}  = near_far.x;\n\t\t\t\t\t\t\t${r("far")} = near_far.y;\n\t\t\t\t\t\t\t${r("fragDepth")} ;\n\t\t\t\t\t\t\tif (isPerspective) {\n\t\t\t\t\t\t\t\tfragDepth = (1.0/linearDepth - 1.0/near)/(1.0/far - 1.0/near);\t\t\t\t\t\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfragDepth = (linearDepth - near)/(far - near);\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t${t.vSetFragDepth("fragDepth")};\n\t\t\t\t\t\t\treturn viewPositionOnCylinder;\n                        `;var i}};return n.setPDSFXOverridableFunctions(e,r),n},setName:function(t){this._name=t}});return UWA.namespace("THREEDS/Nodes/InstancedCylinderImpostorsNode",i)}));