define("DS/SVGLoader/SVGLineMaterial",["DS/Visualization/ThreeJS_DS","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],(function(t,n,e,i,r,a){const s="",o=r.ParameterUtils,l=r.FunctionHandler,c=r.BridgeFunctions,d=t=>o.parameterF(t),u=t=>o.parameterRefF(t),h=t=>o.parameter("b",t),f=t=>o.parameterV2(t),p=t=>o.parameterV4(t),g=(t,n,e)=>r.FunctionHandler.declareFunction(t,n,e),$=(t,n,e)=>r.FunctionHandler.callFunction(t,n,e),m=t=>e.addUniform(t),S=t=>{var n={uniformName:t};return e.getUniform(n)},v=t=>{var n={uniformName:t};return e.getGlobalUniform(n)},x=(t,n)=>n.highFrequencyColors?(t=>{var n={uniformName:t};return e.getHighFrequencyUniform(n)})(t):S(t),y=(t=null)=>{var n={name:t};return a.bool(n)},A=(t=null)=>{var n={name:t};return a.int(n)},b=(t=null)=>{var n={name:t};return a.float(n)},D=(t=null,n="")=>{var e={name:t,addressSpace:n};return a.vec2(e)},_=(t=null,n=0)=>{var e={name:t,size:n};return a.vec3(e)},P=(t=null,n=0)=>{var e={name:t,size:n};return a.vec4(e)},C=t=>i.addVarying(t),V=t=>i.getVarying(t,i.ShaderStages.in),w=t=>i.getVarying(t,i.ShaderStages.out),M=t=>i.getShaderOutput(t),F=(t,n)=>c.modulo(t,n),N=(t,n)=>c.lessThan(t,n);var L=function(n){return`\n                    ${r={uniformName:"pixelSize",uniformType:"v2"},e.addGlobalUniform(r)} \n                    ${g("computeWorldSizeToPixel","f",[p("pos")])}{\n\t\t\t\t\t   return abs(${v("projectionMatrix")}[0][0]/pos.w)/${v("pixelSize")}.x;\n\t\t\t\t\t}\n\n                    ${C({varyingName:"vPointCurrFadeAway",varyingType:"v3"})}\n\n\t\t\t\t\t${n.dashedLine?`\n                        ${C({varyingName:"vLineDistance",varyingType:"v2"})}\n\t\t\t\t\t\t${n.wideLine?`\n                            ${C({varyingName:"vPointNextPrec",varyingType:"v4"})}\n                            ${C({varyingName:"vLineDistanceAltResetSecondDist",varyingType:"v2"})}\n                            ${C({varyingName:"vConstantNextPrec",varyingType:"v4"})}\n\t\t\t\t\t\t\t`:s}\n\t\t\t\t\t\t`:s}\n\t\t\t\t\t${n.wideLine?`\n\t\t\t\t\t\t${t._ShaderChunk.PDSFX_halfWidth_pars_vertex_fragment(n)}\n                        ${m({uniformName:"miterLimit",uniformType:"f"})} \n                        ${C({varyingName:"vConstantCurr",varyingType:"v2"})}\n\n                        ${g("isNull","b",[d("x")])}{\n\t\t\t\t\t\t\treturn abs(x) < 1e-6;\n\t\t\t\t\t\t}\n\n                        ${g("cNormalize","v2",[f("v")])}{\n\t\t\t\t\t\t\t${b("len")}  = length(v);\n\t\t\t\t\t\t\tif (!${$("isNull","b",[d("len")])}) {\n\t\t\t\t\t\t\t\treturn v/len;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn ${D()}(0.0);\n\t\t\t\t\t\t}\n\n                        ${g("cNormalize","v3",[(i="v",o.parameterV3(i))])}{\n\t\t\t\t\t\t\t${b("len")}  = length(v);\n\t\t\t\t\t\t\tif (!${$("isNull","b",[d("len")])}) {\n\t\t\t\t\t\t\t\treturn v/len;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn ${_()}(0.0);\n\t\t\t\t\t\t}\n\n                        ${g("cNormalize","v4",[p("v")])}{\n\t\t\t\t\t\t\t${b("len")}  = length(v);\n\t\t\t\t\t\t\tif (!${$("isNull","b",[d("len")])}) {\n\t\t\t\t\t\t\t\treturn v/len;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn ${P()}(0.0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t`:s}\n\t\t\t\t\t${"round"===n.linecap?`\n                        ${C({varyingName:"infosCenterCap",varyingType:"v4"})}\n                        ${C({varyingName:"centerLeftRight",varyingType:"v4"})}\n\t\t\t\t\t\t`:s}\n\t\t\t\t\t${"round"===n.linejoin?`\n                        ${C({varyingName:"centerJoin",varyingType:"v4"})}\n                        ${C({varyingName:"centerRightJoin",varyingType:"v4"})}\n                        ${C({varyingName:"centerLeftJoin",varyingType:"v4"})}\n\t\t\t\t\t\t`:s}\n\t\t\t\t`;var i,r},G=function(n){return`\n\t\t\t\t\t${n.dashedLine?`\n\t\t\t\t\t\t${b("modelMatrixScaleX")}  = length(modelMatrix[0]);\n                        ${n.defaultInstancing?"\n                            modelMatrixScaleX *= length(multipliedDefaultInstancingMatrix[0]);\n                            ":s}\n\t\t\t\t\t\t${n.fixedSize?"modelMatrixScaleX *= simpleNodeData.fixedSizeScale;":s}\n\t\t\t\t\t\t${w("vLineDistance")} = modelMatrixScaleX* lineDistance;\n\t\t\t\t\t\t`:s}\n\t\t\t\t\t${w("vPointCurrFadeAway")}.x = position_.x;\n\t\t\t\t\t${w("vPointCurrFadeAway")}.y = position_.y;\n\t\t\t\t\t${n.wideLine?`\n\t\t\t\t\t\t${D("eps")}  = ${D()}(1e-6);\n\t\t\t\t\t\t${y("bPrecCurr")}  = !all(${N("abs(position_.xy - previousPos.xy)","eps")});\n\t\t\t\t\t\t${y("bCurrNext")}  = !all(${N("abs(followingPos.xy - position_.xy)","eps")});\n\t\t\t\t\t\t${b("offset")}   = ${$("getHalfWidth","f",[])};\n\t\t\t\t\t\t${D("pos")} ;\n                        ${D("posPrecCurr")} ;\n                        ${D("posCurrNext")} ;\n\t\t\t\t\t\t${D("dirPrecCurr")} ;\n                        ${D("dirCurrNext")} ;\n\t\t\t\t\t\t${b("orientation")}   = sign(sideExtrusion);\n\t\t\t\t\t\t${y("parity")}  = abs(${F("sideExtrusion","2.0")}) < 0.5;\n\t\t\t\t\t\t${w("vConstantCurr")} = position_.xy;\n\t\t\t\t\t\t${b("worldSizeToPixel")}   = ${$("computeWorldSizeToPixel","f",[p(M("position"))])};\n\t\t\t\t\t\t${b("pixelToWorld")}   = 1.0/worldSizeToPixel;\n\t\t\t\t\t\t${b("distValue")}  = (0.5*pixelToWorld - ${$("getHalfWidth","f",[])})/(0.5*pixelToWorld);\n\t\t\t\t\t\tif (distValue > 0.0) {\n\t\t\t\t\t\t\toffset = 0.5*pixelToWorld;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t${w("vPointCurrFadeAway")}.z = 1.0-smoothstep(0.65,1.0,distValue);\n\t\t\t\t\t\tif (bPrecCurr){\n\t\t\t\t\t\t\tdirPrecCurr = position_.xy - previousPos.xy;\n\t\t\t\t\t\t\tdirPrecCurr = ${$("cNormalize","v2",[f("dirPrecCurr")])};\n\t\t\t\t\t\t\tposPrecCurr = position_.xy + offset * orientation * ${D()}(-dirPrecCurr.y, dirPrecCurr.x);\n\t\t\t\t\t\t} else if (bCurrNext) {\n\t\t\t\t\t\t\tdirPrecCurr = position_.xy - followingPos.xy;\n\t\t\t\t\t\t\tdirPrecCurr = ${$("cNormalize","v2",[f("dirPrecCurr")])};\n\t\t\t\t\t\t\tposPrecCurr = position_.xy + offset * dirPrecCurr.xy;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (bCurrNext){\n\t\t\t\t\t\t\tdirCurrNext = followingPos.xy - position_.xy;\n\t\t\t\t\t\t\tdirCurrNext = ${$("cNormalize","v2",[f("dirCurrNext")])};\n\t\t\t\t\t\t\tposCurrNext = position_.xy + offset * orientation * ${D()}(-dirCurrNext.y, dirCurrNext.x);\n\t\t\t\t\t\t} else if (bPrecCurr) {\n\t\t\t\t\t\t\tdirCurrNext = position_.xy - previousPos.xy;\n\t\t\t\t\t\t\tdirCurrNext = ${$("cNormalize","v2",[f("dirCurrNext")])};\n\t\t\t\t\t\t\tposCurrNext = position_.xy + offset * dirCurrNext.xy;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t${D("dir")}  = ${$("cNormalize","v2",[f("dirCurrNext - dirPrecCurr")])};\n\t\t\t\t\t\t${D("nDir")} = ${D()}(-dir.y, dir.x);\n\t\t\t\t\t\tif ( bPrecCurr && bCurrNext){\n\t\t\t\t\t\t\tif (${$("isNull","b",[d("length(dir)")])}){\n\t\t\t\t\t\t\t\tdir = ${D()}(-dirCurrNext.y, dirCurrNext.x);\n\t\t\t\t\t\t\t\tnDir = ${D()}(-dir.y, dir.x);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t${b("sinAlpha")}  = dir.y * dirPrecCurr.x - dir.x * dirPrecCurr.y;\n\t\t\t\t\t\t\t${b("alpha")}  = asin(abs(sinAlpha));\n\t\t\t\t\t\t\t${"round"===n.linejoin?`${y("angleTest")}  = alpha < radians(45.0);`:`${y("angleTest")} = true;`}\n\t\t\t\t\t\t\tif (sign(sinAlpha) == -orientation) {\n\t\t\t\t\t\t\t\tif (angleTest) {\n\t\t\t\t\t\t\t\t\t${b("axisCorrection")}  = 1.0 / abs(cos(alpha));\n\t\t\t\t\t\t\t\t\t${"bevel"===n.linejoin?"\n\t\t\t\t\t\t\t\t\t\tif (parity){\n\t\t\t\t\t\t\t\t\t\t\tpos = position_.xy - sign(sinAlpha) * offset*axisCorrection * nDir;\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tpos = position_.xy + sign(sinAlpha) *offset*axisCorrection * nDir;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t":`\n\t\t\t\t\t\t\t\t\t\t${"miter"===n.linejoin?`\n\t\t\t\t\t\t\t\t\t\t\t${b("ratio")}  = 1.0/abs(sinAlpha);\n\t\t\t\t\t\t\t\t\t\t\tif (${S("miterLimit")} < 1.0 || ratio < ${S("miterLimit")}) {\n\t\t\t\t\t\t\t\t\t\t\t\tpos = position_.xy - offset * ratio * dir;\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tif (parity){\n\t\t\t\t\t\t\t\t\t\t\t\t\tpos = position_.xy - sign(sinAlpha) * offset*axisCorrection * nDir;\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpos = position_.xy + sign(sinAlpha) *offset*axisCorrection * nDir;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t`:`\n\t\t\t\t\t\t\t\t\t\t\t${"miterclip"===n.linejoin?`\n\t\t\t\t\t\t\t\t\t\t\t\t${b("ratio")}  = 1.0/abs(sinAlpha);\n\t\t\t\t\t\t\t\t\t\t\t\tif (${S("miterLimit")} < 1.0 || ratio < ${S("miterLimit")}) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpos = position_.xy - offset * ratio * dir;\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\t${b("dist")}  = offset * ${S("miterLimit")};\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (parity){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpos = position_.xy - sign(sinAlpha) * offset*axisCorrection * nDir;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpos -= dist * dirCurrNext;\n\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpos = position_.xy + sign(sinAlpha) *offset*axisCorrection * nDir;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpos += dist * dirPrecCurr;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t`:`\n\t\t\t\t\t\t\t\t\t\t\t\t${"round"===n.linejoin?`\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (parity){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpos = position_.xy - sign(sinAlpha) * offset * ${D()}(-dirCurrNext.y,dirCurrNext.x);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpos -= offset * dirCurrNext;\n\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpos = position_.xy - sign(sinAlpha) *offset * ${D()}(-dirPrecCurr.y,dirPrecCurr.x);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpos += offset * dirPrecCurr;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t`:s}\n\t\t\t\t\t\t\t\t\t\t\t\t`}\n\t\t\t\t\t\t\t\t\t\t\t`}\n\t\t\t\t\t\t\t\t\t\t`}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t${b("dist")}  = offset/ sinAlpha;\n\t\t\t\t\t\t\t\t\tpos = position_.xy - dir * abs(dist) ;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t${b("distPoints")}  = min(distance(position_.xy, previousPos.xy), distance(position_.xy, followingPos.xy)) + offset;\n\t\t\t\t\t\t\t\t${b("dist")}  = offset/ sinAlpha;\n\t\t\t\t\t\t\t\tif (max(distPoints, offset) < abs(dist)){\n\t\t\t\t\t\t\t\t\tdist = max(distPoints - offset, offset)*sign(sinAlpha);\n\t\t\t\t\t\t\t\t\tif (alpha < radians(22.5)){\n\t\t\t\t\t\t\t\t\t\tif (parity){\n\t\t\t\t\t\t\t\t\t\t\tpos = posCurrNext + dist * dirCurrNext*orientation;\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tpos = posPrecCurr - dist * dirPrecCurr *orientation;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tpos = position_.xy + dir * max(distPoints, offset);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tpos = position_.xy + dir * abs(dist) ;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if(bPrecCurr || bCurrNext) {\n\t\t\t\t\t\t\t${"butt"===n.linecap?`pos = position_.xy + offset * ${D()}(-dirCurrNext.y, dirCurrNext.x)*orientation;`:"pos = (posCurrNext - position_.xy)  + posPrecCurr;"}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpos = position_.xy + offset;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t${w("vPointCurrFadeAway")}.x = pos.x;\n\t\t\t\t\t\t${w("vPointCurrFadeAway")}.y = pos.y;\n\n\t\t\t\t\t\t${"round"===n.linecap?`\n\t\t\t\t\t\t\tif (!bPrecCurr) {\n\t\t\t\t\t\t\t\t${w("centerLeftRight")}.x = position_.x;\n\t\t\t\t\t\t\t\t${w("centerLeftRight")}.y = position_.y;\n\t\t\t\t\t\t\t\t${w("infosCenterCap")}.z = position_.x;\n\t\t\t\t\t\t\t\t${w("infosCenterCap")}.w = position_.y;\n\t\t\t\t\t\t\t\t${w("centerLeftRight")}.z = followingPos.x;\n\t\t\t\t\t\t\t\t${w("centerLeftRight")}.w = followingPos.y;\n\t\t\t\t\t\t\t\t${w("infosCenterCap")}.x = -${$("getHalfWidth","f",[])};\n\t\t\t\t\t\t\t\t${w("infosCenterCap")}.y = 1.0;\n\t\t\t\t\t\t\t} else if (!bCurrNext) {\n\t\t\t\t\t\t\t\t${w("centerLeftRight")}.x = previousPos.x;\n\t\t\t\t\t\t\t\t${w("centerLeftRight")}.y = previousPos.y;\n\t\t\t\t\t\t\t\t${w("infosCenterCap")}.z = previousPos.x;\n\t\t\t\t\t\t\t\t${w("infosCenterCap")}.w = previousPos.y;\n\t\t\t\t\t\t\t\t${w("centerLeftRight")}.z = position_.x;\n\t\t\t\t\t\t\t\t${w("centerLeftRight")}.w = position_.y;\n\t\t\t\t\t\t\t\t${w("infosCenterCap")}.x = length(position_.xy-previousPos.xy) + ${$("getHalfWidth","f",[])};\n\t\t\t\t\t\t\t\t${w("infosCenterCap")}.y = 1.0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t${w("centerLeftRight")}.x = previousPos.x;\n\t\t\t\t\t\t\t\t${w("centerLeftRight")}.y = previousPos.y;\n\t\t\t\t\t\t\t\t${w("infosCenterCap")}.z = position_.x;\n\t\t\t\t\t\t\t\t${w("infosCenterCap")}.w = position_.y;\n\t\t\t\t\t\t\t\t${w("centerLeftRight")}.z = followingPos.x;\n\t\t\t\t\t\t\t\t${w("centerLeftRight")}.w = followingPos.y;\n\t\t\t\t\t\t\t\tif (parity) {\n\t\t\t\t\t\t\t\t\t${w("infosCenterCap")}.x = dot(pos.xy - position_.xy, dirCurrNext);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t${w("infosCenterCap")}.x = length(position_.xy - previousPos.xy) + dot(pos.xy - position_.xy, dirPrecCurr);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t${w("infosCenterCap")}.y = 0.0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t`:s}\n\n\t\t\t\t\t\t${"round"===n.linejoin?`\n\t\t\t\t\t\t\t${w("centerLeftJoin")} = ${P()}(0.0);\n\t\t\t\t\t\t\t${w("centerRightJoin")} = ${P()}(0.0);\n\t\t\t\t\t\t\t${w("centerJoin")} = ${P()}(0.0);\n\t\t\t\t\t\t\tif (!bPrecCurr) {\n\t\t\t\t\t\t\t\t${w("centerLeftJoin")}.x = followingPos.x;\n\t\t\t\t\t\t\t\t${w("centerLeftJoin")}.y = followingPos.y;\n\t\t\t\t\t\t\t\t${w("centerJoin")}.x = position_.x;\n\t\t\t\t\t\t\t\t${w("centerJoin")}.y = position_.y;\n\t\t\t\t\t\t\t\t${w("centerRightJoin")}.x = followingPos.x;\n\t\t\t\t\t\t\t\t${w("centerRightJoin")}.y = followingPos.y;\n\t\t\t\t\t\t\t\t${w("centerRightJoin")}.z = dirCurrNext.x;\n\t\t\t\t\t\t\t\t${w("centerRightJoin")}.w = dirCurrNext.y;\n\t\t\t\t\t\t\t} else if (!bCurrNext) {\n\t\t\t\t\t\t\t\t${w("centerLeftJoin")}.x = previousPos.x;\n\t\t\t\t\t\t\t\t${w("centerLeftJoin")}.y = previousPos.y;\n\t\t\t\t\t\t\t\t${w("centerJoin")}.x = position_.x;\n\t\t\t\t\t\t\t\t${w("centerJoin")}.y = position_.y;\n\t\t\t\t\t\t\t\t${w("centerRightJoin")}.x = previousPos.x;\n\t\t\t\t\t\t\t\t${w("centerRightJoin")}.y = previousPos.y;\n\t\t\t\t\t\t\t\t${w("centerLeftJoin")}.z = -dirPrecCurr.x;\n\t\t\t\t\t\t\t\t${w("centerLeftJoin")}.w = -dirPrecCurr.y;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (parity) {\n\t\t\t\t\t\t\t\t\t${w("centerLeftJoin")}.x = position_.x;\n\t\t\t\t\t\t\t\t\t${w("centerLeftJoin")}.y = position_.y;\n\t\t\t\t\t\t\t\t\t${w("centerJoin")}.x = position_.x;\n\t\t\t\t\t\t\t\t\t${w("centerJoin")}.y = position_.y;\n\t\t\t\t\t\t\t\t\t${w("centerRightJoin")}.x = followingPos.x;\n\t\t\t\t\t\t\t\t\t${w("centerRightJoin")}.y = followingPos.y;\n\t\t\t\t\t\t\t\t\t${w("centerLeftJoin")}.z = -dirCurrNext.x;\n\t\t\t\t\t\t\t\t\t${w("centerLeftJoin")}.w = -dirCurrNext.y;\n\t\t\t\t\t\t\t\t\t${w("centerRightJoin")}.z = dirCurrNext.x;\n\t\t\t\t\t\t\t\t\t${w("centerRightJoin")}.w = dirCurrNext.y;\n\t\t\t\t\t\t\t\t\t${w("centerJoin")}.z = -dir.x;\n\t\t\t\t\t\t\t\t\t${w("centerJoin")}.w = -dir.y;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t${w("centerLeftJoin")}.x = previousPos.x;\n\t\t\t\t\t\t\t\t\t${w("centerLeftJoin")}.y = previousPos.y;\n\t\t\t\t\t\t\t\t\t${w("centerJoin")}.x = position_.x;\n\t\t\t\t\t\t\t\t\t${w("centerJoin")}.y = position_.y;\n\t\t\t\t\t\t\t\t\t${w("centerRightJoin")}.x = position_.x;\n\t\t\t\t\t\t\t\t\t${w("centerRightJoin")}.y = position_.y;\n\t\t\t\t\t\t\t\t\t${w("centerLeftJoin")}.z = -dirPrecCurr.x;\n\t\t\t\t\t\t\t\t\t${w("centerLeftJoin")}.w = -dirPrecCurr.y;\n\t\t\t\t\t\t\t\t\t${w("centerRightJoin")}.z = dirPrecCurr.x;\n\t\t\t\t\t\t\t\t\t${w("centerRightJoin")}.w = dirPrecCurr.y;\n\t\t\t\t\t\t\t\t\t${w("centerJoin")}.z = -dir.x;\n\t\t\t\t\t\t\t\t\t${w("centerJoin")}.w = -dir.y;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t`:s}\n\n\t\t\t\t\t\t${n.dashedLine?`\n\t\t\t\t\t\t\t${w("vLineDistanceAltResetSecondDist")}.x = ${w("vLineDistance")}.x;\n\t\t\t\t\t\t\t${w("vConstantNextPrec")}.x = followingPos.x;\n\t\t\t\t\t\t\t${w("vConstantNextPrec")}.y = followingPos.y;\n\t\t\t\t\t\t\t${w("vConstantNextPrec")}.z = previousPos.x;\n\t\t\t\t\t\t\t${w("vConstantNextPrec")}.w = previousPos.y;\n\n\t\t\t\t\t\t\t${w("vLineDistanceAltResetSecondDist")}.y = 0.0;\n\t\t\t\t\t\t\tif (!parity){\n\t\t\t\t\t\t\t\t${w("vLineDistanceAltResetSecondDist")}.x = ${w("vLineDistance")}.y;\n\t\t\t\t\t\t\t\t${w("vPointNextPrec")}.z = previousPos.x;\n\t\t\t\t\t\t\t\t${w("vPointNextPrec")}.w = previousPos.y;\n\t\t\t\t\t\t\t\t${w("vPointNextPrec")}.x = position_.x;\n\t\t\t\t\t\t\t\t${w("vPointNextPrec")}.y = position_.y;\n\t\t\t\t\t\t\t\t${w("vLineDistance")}.x = lineDistance.x* modelMatrixScaleX;\n\t\t\t\t\t\t\t\t${w("vLineDistance")}.y = lineDistance.y* modelMatrixScaleX;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t${w("vLineDistanceAltResetSecondDist")}.x = ${w("vLineDistance")}.x;\n\t\t\t\t\t\t\t\t${w("vPointNextPrec")}.z = position_.x;\n\t\t\t\t\t\t\t\t${w("vPointNextPrec")}.w = position_.y;\n\t\t\t\t\t\t\t\t${w("vPointNextPrec")}.x = followingPos.x;\n\t\t\t\t\t\t\t\t${w("vPointNextPrec")}.y = followingPos.y;\n\t\t\t\t\t\t\t\t${w("vLineDistance")}.x = lineDistance.x* modelMatrixScaleX;\n\t\t\t\t\t\t\t\t${w("vLineDistance")}.y = lineDistance.y* modelMatrixScaleX;\n\t\t\t\t\t\t\t\tif (abs(lineDistance.x - lineDistance.y) < 1e-6) {\n\t\t\t\t\t\t\t\t\t${w("vLineDistanceAltResetSecondDist")}.y = 1.0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t`:s}\n\n\t\t\t\t\t\t${t._DefaultShaderChunk.getModelViewTransformationChunk("mvPosition","vec4(pos.xy,position_.z,1.0)",n)}\n\t\t\t\t\t\t${M("position")} = ${v("projectionMatrix")} * mvPosition;\n\t\t\t\t\t\t`:s}\n\t\t\t\t`},I=function(n){return`\t\t\t\t\n\n                    ${C({varyingName:"vPointCurrFadeAway",varyingType:"v3"})}\n\n\t\t\t\t\t${t._ShaderChunk.PDSFX_Color_pars_fragment(n)}\n\t\t\t\t\t${n.wideLine?`\n\t\t\t\t\t\t${t._ShaderChunk.PDSFX_halfWidth_pars_vertex_fragment(n)}\t\n                        ${C({varyingName:"vConstantCurr",varyingType:"v2"})}\t\t\t\n\t\t\t\t\t\t`:s}\n\t\t\t\t\t${n.dashedLine?`\n                        ${m({uniformName:"scale",uniformType:"f"})} \n                        ${m({uniformName:"totalSize",uniformType:"f"})} \n                        ${m({uniformName:"patternOffset",uniformType:"f"})} \n\t\t\t\t\t\t${n.patternSize?m({uniformName:"dashPattern",uniformType:"fv4",size:n.patternSize}):s}\n                        ${C({varyingName:"vLineDistance",varyingType:"v2"})}\t\n\t\t\t\t\t\t${n.wideLine?`\n                            ${C({varyingName:"vPointNextPrec",varyingType:"v4"})}\t\n                            ${C({varyingName:"vLineDistanceAltResetSecondDist",varyingType:"v2"})}\n                            ${C({varyingName:"vConstantNextPrec",varyingType:"v4"})}\t\n\t\t\t\t\t\t\t`:s}\n\n                        ${g("getDistance","f",[f("cur"),f("next"),f("prev")])}{\n\t\t\t\t\t\t\t${b("res")} = 0.0;\n\t\t\t\t\t\t\t${D("direction")}  = next-prev;\n\t\t\t\t\t\t\tres = dot(cur - prev, normalize(direction));\n\t\t\t\t\t\t\treturn res;\n\t\t\t\t\t\t}\n\n                        ${g("getDistance","f",[f("cur"),f("next"),f("prev"),f("origin")])}{\n\t\t\t\t\t\t\t${b("res")}  = 0.0;\n\t\t\t\t\t\t\t${D("direction")} = next-prev;\n\t\t\t\t\t\t\tres = dot(cur - origin, normalize(direction));\n\t\t\t\t\t\t\treturn res;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t${n.patternSize?`\n                            ${g("getPatternInfo","v3",[d("dist")])}{\n\t\t\t\t\t\t\t\t${A("index")}  = 0;\n\t\t\t\t\t\t\t\t${b("prec")}  = 0.0;\n                                ${b("cur")}  = 0.0;\n\t\t\t\t\t\t\t\tfor (${A("i")}  = 0; i < ${n.patternSize}; i++) {\n                                    ${P("dashInfo")} = max(${S("scale")},1e-6)* ${S("dashPattern")}[i];\t\t\t\t\t\n\t\t\t\t\t\t\t\t    ${function(){let t=s,n=["x","y","z","w"];for(let e=0;e<4;e++)t=`\n                            ${t};\n                            cur = dashInfo.${n[e]};\n                            if (cur > dist) {\n                                break;\n                            }\n                            prec = cur;\n                            index++;\n                        `;return t}()}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn ${_()}(${b()}(index),prec,cur);\n\t\t\t\t\t\t\t}\n\n                            ${g("getPatternAlpha","f",[d("dist")])}{\n                                ${b("repeat")} = max(${S("scale")},1e-6) *${S("totalSize")};\n\t\t\t\t\t\t\t\t${"round"===n.linecap||"square"===n.linecap?`\n                                    ${b("distWithWidth")} = dist + ${$("getHalfWidth","f",[])};\n                                    ${b("mDist")}  = ${F("distWithWidth","repeat")};`:`${b("mDist")} = ${F("dist","repeat")};`}\n\t\t\t\t\t\t\t\t${_("patternInfo")}  = ${$("getPatternInfo","v3",[d("mDist")])};\n\t\t\t\t\t\t\t\t${n.invertedPattern?`\n\t\t\t\t\t\t\t\t\tif (abs(${F("patternInfo.x","2.0")}) < 0.5) {\n\t\t\t\t\t\t\t\t\t\treturn 1.0;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn 0.0;\n\t\t\t\t\t\t\t\t\t`:`\n\t\t\t\t\t\t\t\t\tif (abs(${F("patternInfo.x","2.0")}) < 0.5) {\n\t\t\t\t\t\t\t\t\t\treturn 0.0;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn 1.0;\n\t\t\t\t\t\t\t\t\t`}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t`:s}\n\t\t\t\t\t\t`:s}\n\t\t\t\t\t${"round"===n.linecap?`\n                        ${C({varyingName:"infosCenterCap",varyingType:"v4"})}\t\n                        ${C({varyingName:"centerLeftRight",varyingType:"v4"})}\t\n\n                        ${g("doLeftCap","b",[f("iInfos"),f("cur"),f("left"),h("leftSide")])}{\n\t\t\t\t\t\t\t${y("leftCap")}  = leftSide && iInfos.x < 0.0;\n\t\t\t\t\t\t\tif (!leftCap) {\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t${b("distanceL")}  = length(cur.xy - left) / ${$("getHalfWidth","f",[])};\n\t\t\t\t\t\t\tif (distanceL > 1.0) {\n\t\t\t\t\t\t\t\tdiscard;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n                        ${g("doRightCap","b",[f("iInfos"),f("cur"),f("center"),f("right"),h("rightSide")])}{\n\t\t\t\t\t\t\t${y("rightCap")}  = rightSide && iInfos.x > length(right - center);\n\t\t\t\t\t\t\tif (!rightCap) {\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t${b("distanceR")}  = length(cur.xy - right) / ${$("getHalfWidth","f",[])};\n\t\t\t\t\t\t\tif (distanceR > 1.0) {\n\t\t\t\t\t\t\t\tdiscard;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n                        ${g("doRoundCap",null,[f("iInfos"),f("cur"),f("center"),f("right"),f("left")])}{\n\t\t\t\t\t\t\t${y("centerSide")}  = abs(length(fwidth(center))) < 1e-3;\n\t\t\t\t\t\t\t${y("capToCap")}  = abs(fwidth(iInfos.y)) < 1e-3 && iInfos.y > 0.0;\n\t\t\t\t\t\t\t${y("leftSide")}  = abs(length(fwidth(left))) < 1e-3 ;\n\t\t\t\t\t\t\t${y("rightSide")}  = abs(length(fwidth(right))) < 1e-3 ;\n\t\t\t\t\t\t\t${y("toTreat")}  = ! (leftSide && rightSide && centerSide) || capToCap;\n\t\t\t\t\t\t\tif (!toTreat) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t${y("leftCap")}  = ${$("doLeftCap","b",[f("iInfos"),f("cur"),f("left"),h("leftSide")])};\n\t\t\t\t\t\t\t${y("rightCap")}  = ${$("doRightCap","b",[f("iInfos"),f("cur"),f("center"),f("right"),h("rightSide && centerSide")])};\n\t\t\t\t\t\t}\n\t\t\t\t\t\t`:s}\n\t\t\t\t\t${"round"===n.linejoin?`\n                        ${C({varyingName:"centerJoin",varyingType:"v4"})}\t\n                        ${C({varyingName:"centerRightJoin",varyingType:"v4"})}\t\n                        ${C({varyingName:"centerLeftJoin",varyingType:"v4"})}\t\n\n                        ${g("doCentralJoin",null,[f("cur"),p("center")])}{\n\t\t\t\t\t\t\t${b("distanceJoin")}  = 0.0;\n\t\t\t\t\t\t\t${b("varJoinC")}  = 0.0;\n\t\t\t\t\t\t\tif (dot(cur.xy - center.xy, center.zw) <= 0.0) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdistanceJoin = length(cur.xy - center.xy) / ${$("getHalfWidth","f",[])};\n\t\t\t\t\t\t\tif (distanceJoin > 1.0) {\n\t\t\t\t\t\t\t\tdiscard;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n                        ${g("doSideJoins",null,[f("cur"),p("right"),p("left")])}{\n\t\t\t\t\t\t\t${y("rightJoin")}  = abs(length(fwidth(right))) < 1e-3 && dot(cur.xy - right.xy, right.zw) > 0.0;\n\t\t\t\t\t\t\t${y("leftJoin")}  =  abs(length(fwidth(left))) < 1e-3 && dot(cur.xy - left.xy, left.zw) > 0.0;\n\t\t\t\t\t\t\t${b("distanceRight")}  = 0.0;\n\t\t\t\t\t\t\t${b("distanceLeft")}  = 0.0;\n\t\t\t\t\t\t\t${b("varJoinR")}  = 0.0;\n\t\t\t\t\t\t\t${b("varJoinL")}  = 0.0;\n\t\t\t\t\t\t\tif (rightJoin) {\n\t\t\t\t\t\t\t\tdistanceRight = length(cur.xy - right.xy) / ${$("getHalfWidth","f",[])};\n\t\t\t\t\t\t\t\tif (distanceRight > 1.0) {\n\t\t\t\t\t\t\t\t\tdiscard;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (leftJoin) {\n\t\t\t\t\t\t\t\tdistanceLeft = length(cur.xy - left.xy) / ${$("getHalfWidth","f",[])};\n\t\t\t\t\t\t\t\tif (distanceLeft > 1.0) {\n\t\t\t\t\t\t\t\t\tdiscard;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n                        ${g("doRoundJoins",null,[f("cur"),p("center"),p("right"),p("left")])}{\n\t\t\t\t\t\t\t${y("isOnJoin")}  = abs(length(fwidth(center))) < 1e-3;\n\t\t\t\t\t\t\tif (isOnJoin) {\n\t\t\t\t\t\t\t\t${$("doCentralJoin",null,[f("cur"),p("center")])};\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t${$("doSideJoins",null,[f("cur"),p("right"),p("left")])};\n\t\t\t\t\t\t}\n\t\t\t\t\t\t`:s}\n\t\t\t\t`},R=function(t){return`\n\t\t\t\t\t${t.wideLine?`\n                        ${y("isConnection")}  = length(fwidth(${V("vConstantCurr")})) < 1e-6;\n                        `:s}\n\t\t\t\t\t${t.dashedLine?`\n                            ${b("dist")}   = ${V("vLineDistance")}.x;\n                            ${b("dist2")}   = 0.0;\n\t\t\t\t\t\t\t${t.wideLine?`\n\t\t\t\t\t\t\t\t${y("resetDist2")}  = fwidth(${V("vLineDistanceAltResetSecondDist")}).y > 1e-6;\n\t\t\t\t\t\t\t\tif (!isConnection){\n\t\t\t\t\t\t\t\t\tdist += ${$("getDistance","f",[f(V("vPointCurrFadeAway.xy")),f(V("vPointNextPrec.xy")),f(V("vPointNextPrec.zw"))])};\n\t\t\t\t\t\t\t\t} else  {\n\t\t\t\t\t\t\t\t\tdist = ${V("vLineDistanceAltResetSecondDist")}.x + ${$("getDistance","f",[f(V("vPointCurrFadeAway.xy")),f(V("vConstantCurr")),f(V("vConstantNextPrec.zw")),f(V("vConstantCurr"))])};\n\t\t\t\t\t\t\t\t\tdist2 = ${$("getDistance","f",[f(V("vPointCurrFadeAway.xy")),f(V("vConstantNextPrec.xy")),f(V("vConstantCurr")),f(V("vConstantCurr"))])};\n                                    if (!resetDist2) {\n                                        dist2 += ${V("vLineDistanceAltResetSecondDist")}.x;\n                                    }\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t`:s}\n\t\t\t\t\t\t\t${t.patternSize?`\n                                ${b("offsetedDist")}  = dist + ${S("patternOffset")};\n\t\t\t\t\t\t\t\t${b("patternAlpha")}  = ${$("getPatternAlpha","f",[d("offsetedDist")])};\n\t\t\t\t\t\t\t\t${t.PDSFX?`${$("ProcessLinePattern",null,[u("patternAlpha"),d("offsetedDist")])};`:s}\n\t\t\t\t\t\t\t\tif (abs(dist2) > 1e-6) {\n                                    ${b("offsetedDist2")}  = dist2 + ${S("patternOffset")};\n\t\t\t\t\t\t\t\t\t${b("patternAlpha2")}  = ${$("getPatternAlpha","f",[d("offsetedDist2")])};\n\t\t\t\t\t\t\t\t\t${t.PDSFX?`${$("ProcessLinePattern",null,[u("patternAlpha2"),d("offsetedDist2")])};`:s}\n\t\t\t\t\t\t\t\t\tpatternAlpha = min(patternAlpha, patternAlpha2);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (patternAlpha > 0.5) {\n\t\t\t\t\t\t\t\t\tdiscard;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t`:s}\n\t\t\t\t\t   `:s}\n\t\t\t\t\t${"round"===t.linecap?`${$("doRoundCap",null,[f(V("infosCenterCap.xy")),f(V("vPointCurrFadeAway.xy")),f(V("infosCenterCap.zw")),f(V("centerLeftRight.zw")),f(V("centerLeftRight.xy"))])};`:s}\n\t\t\t\t\t${"round"===t.linejoin?`${$("doRoundJoins",null,[f(V("vPointCurrFadeAway.xy")),p(V("centerJoin")),p(V("centerRightJoin")),p(V("centerLeftJoin"))])};`:s}\n\t\t\t\t\t${M("out0")}.a *= ${V("vPointCurrFadeAway")}.z;\n\t\t\t\t\tif (${V("vPointCurrFadeAway")}.z < 1e-2) {\n\t\t\t\t\t\tdiscard;\n\t\t\t\t\t}\n\t\t\t\t`},T=function(n,e){var i=t._ShaderChunk,r=t._DeferredShaderChunk,a=`\n                ${r._debug_common_pars_fragment(n)}\n\t\t\t\t${I(n)}       \n\t\t\t\t${i.clip_pars_fragment(n)}\n\t\t\t\t${i.color_pars_fragment(n)}\n\t\t\t\t${i.fog_pars_fragment(n)}\t\t\t\n                ${i.map_pars_fragment(n)}\n\t\t\t\t${r.oit_pars_fragment(n)}\n\t\t\t\t${e?`\n\t\t\t\t\t${r.depth_pars_fragment(n)}\n\t\t\t\t\t${r.picking_pars_fragment(n)}\n\t\t\t\t\t${r.picking_instancing_pars_fragment(n)}\n\t\t\t\t\t${r.highlight_pars_fragment(n)}\n\t\t\t\t\t${r.gpupos_pars_fragment(n)}\n\t\t\t\t\t`:s}\n\t\t\t\t${i.postprocess_pars_fragment(n)}\n\t\t\t`,o=`\n                    ${_("diffuseToUse")}  = ${x("diffuse",n)}.rgb;\n                    ${b("opacityToUse")}  = ${x("opacity",n)};\n                    ${n.selectionMaterial?"opacityToUse = 1.0;":s}\n\t\t\t\t\t${i.color_fragment(n)}\n                    if(${x("diffuse",n)}.w > 0.5) {\n                        diffuseToUse = ${x("diffuse",n)}.rgb;\n                    }\n\t\t\t\t\t${n.PDSFX?`\n                        ${i.PDSFX_start_fragment(n)}\n\t\t\t\t\t\t${i.PDSFX_uv_fragment(n)}\n\t\t\t\t\t\t${i.PDSFX_mapping_uv_transform_fragment(n)}\n                        ${i.PDSFX_Color_backup_fragment(n)}\n                        ${i.PDSFX_halfWidth_backup_fragment_vertex(n)}\n\t\t\t\t\t\t${$("ComputeCommonValues",null,[])}; \n\t\t\t\t\t\t${i.PDSFX_discard_fragment(n)}\n\t\t\t\t\t\t${i.PDSFX_Color_fragment(n)}\n\t\t\t\t\t\t${i.PDSFX_halfWidth_fragment_vertex(n)}\n\t\t\t\t\t\t`:s}\n\t\t\t\t\t${M("out0")} = ${P()}( diffuseToUse, opacityToUse );\n\n\t\t\t\t\t${i.clip_fragment(n)}\n\t\t\t\t\t${i.alphatest_fragment(n)}\n\t\t\t\t\n                    ${R(n)}\n\t\t\t\t\t${i.postprocess_fragment(n)}\n\t\t\t\t\t${i.linear_to_gamma_fragment(n)}\n\n\t\t\t\t\t${i.PDSFX_end_fragment(n)}\n\t\t\t\t\t${i.fog_fragment(n)}\n\t\t\t\t\t${i.backgroundviewmode_lowlight_fragment(n)}\n                    ${r._debug_common_lineic_fragment(n)}\n\t\t\t\t\t${r.oit_fragment(n)}\n\t\t\t\t\t${e?`\n\t\t\t\t\t\t${r.depth_fragment(n)}\n\t\t\t\t\t\t${r.picking_fragment(n)}\n\t\t\t\t\t\t${r.picking_instancing_fragment(n)}\n\t\t\t\t\t\t${r.lineic_normal_fragment(n)}\n                        ${r.lineic_normal_depth_fragment(n)}\n\t\t\t\t\t\t${function(n){return n.materialToUse!==t.MaterialToUse.highlightMaterial?s:`\t\n\t\t\t\t\t${n.politeHighlight?`\n\t\t\t\t\t\t${n.mobileHL?`\n                            ${b("alphaValue")};\n                            if (${$("getDepthValue","f",[p(V("clipPos_Deferred"))])} > 0.5) {\n                                alphaValue = iHighlightIntensity.y;\n                            } else {\n                                alphaValue = iHighlightIntensity.x;\n                            }\n\t\t\t\t\t\t\t${M("out0")} = ${P()}( iHighlightColor.xyz, alphaValue);\n\t\t\t\t\t\t\t${M("out0")}.a = min(${M("out0")}.a, 1.0);\n\t\t\t\t\t\t\t`:`${M("out0")} = ${P()}( highlightID / 255.0, 1.0, ${$("getDepthValue","f",[p(V("clipPos_Deferred"))])} , 1.0 / 255.0 );`}\n\t\t\t\t\t\t`:`\n\t\t\t\t\t\t${n.mobileHL?`\n\t\t\t\t\t\t\t${M("out0")} = ${P()}( iHighlightColor.xyz, 0.8 * iHighlightIntensity.x );\n\t\t\t\t\t\t\t${M("out0")}.a = min(${M("out0")}.a, 1.0);\n\t\t\t\t\t\t\t`:`${M("out0")} = ${P()}( highlightID / 255.0, 1.0 , 0.0, 1.0 / 255.0 );`}\n\t\t\t\t\t\t`}\n\t\t\t`}(n)}\n\t\t\t\t\t\t${r.gpupos_fragment(n)}\n\t\t\t\t\t\t`:s}\n\t\t\t\n\t\t\t`;return`\n\t\t\t\t${a}\n\t\t\t\t${l.getMainFragmentStart(n)}\n\t\t\t\t\t${o}\n\t\t\t\t${l.getMainFragmentEnd(n)}\n\t\t\t`};t.ShaderLib.line2D=new n((function(n,e){var i=!n,r=T(e,i),a=function(n,e){var i=t._ShaderChunk,r=t._DeferredShaderChunk,a=`\n\n\t\t\t\t${i.clip_pars_vertex(n)}\n\t\t\t\t${i.map_pars_vertex(n)}\n\t\t\t\t${i.color_pars_vertex(n)}\n                ${i.morphtarget_pars_vertex(n)}\n                ${i.skinning_pars_vertex(n)}\n\t\t\t\t${L(n)}\n                ${i.map_pars_vertex(n)}\n\t\t\t\t${i.fog_pars_vertex(n)}\n\t\t\t\t${r.oit_pars_vertex(n)}\n\t\t\t\t${e?`\n\t\t\t\t\t${r.depth_pars_vertex(n)}\n\t\t\t\t\t${r.picking_pars_vertex(n)}\n\t\t\t\t\t${r.picking_instancing_pars_vertex(n)}\n\t\t\t\t\t${r.highlight_pars_vertex(n)}\n\t\t\t\t\t${r.gpupos_pars_vertex(n)}\n\t\t\t\t\t`:s}\n\t\t\t`,o=`\n                ${n.PDSFX?`\n                    ${i.PDSFX_halfWidth_backup_fragment_vertex(n)}\n                    `:s}\n\t\t\t\t${i.PDSFX_start_vertex(n)}\n\n\t\t\t\t${n.PDSFX?`\n\t\t\t\t\t${i.PDSFX_halfWidth_fragment_vertex(n)}\n\t\t\t\t\t`:s}\n\n                ${i.map_varying_set_vertex(n)}\n\t\t\t\t${i.map_vertex(n)}\n\t\t\t\t${i.color_vertex(n)}\n\t\t\t\t${i.skinbase_vertex(n)}\n\n\t\t\t\t${i.morphtarget_vertex(n)}\n\t\t\t\t${i.skinning_vertex(n)}\n\t\t\t\t${i.position_vertex(n)}\n\t\t\t\t${i.default_vertex(n)}\n\n\t\t\t\t${i.clip_vertex(n)}\n\t\t\t\t${i.fog_vertex(n)}\n\n\t\t\t\t${G(n)}\n\n\t\t\t\t${r.oit_vertex(n)}\n\t\t\t\t${e?`\n\t\t\t\t\t${r.depth_vertex(n)}\n\t\t\t\t\t${r.picking_vertex(n)}\n\t\t\t\t\t${r.picking_instancing_vertex(n)}\n\t\t\t\t\t${r.highlight_vertex(n)}\n\t\t\t\t\t${r.gpupos_vertex(n)}\n\t\t\t\t\t`:s}\n\t\t\t\t${i.PDSFX_end_vertex(n)}\n\t\t\t`;return`\n\t\t\t\t${a}\n\t\t\t\t${l.getMainVertexStart(n)}\n\t\t\t\t\t${o}\n\t\t\t\t${l.getMainVertexEnd(n)}\n\t\t\t`}(e,i);return{vertexShader:a,fragmentShader:r}}));class z extends t.LineDSMaterial{constructor(t){t=t||{};var n={};Object.assign(n,t),n.linecap||(n.linecap="butt"),n.scale||(n.scale=1),n.miterLimit||(n.miterLimit=4),super(n),this.miterLimit=n.miterLimit,this.transparent=!0,this.miterLimit<1&&(this.miterLimit=1),this.is2DLine=!0,this.isCPUPattern=!1}clone(){var t=new z;return super.clone(t),t.miterLimit=this.miterLimit>1?this.miterLimit:1,t}getType(){return"SVGLine"}setMiterLimit(t){this.miterLimit=t,this.miterLimit<1&&(this.miterLimit=1),this._revision++}loadUniforms(t,n,e,i,r,a){super.loadUniforms(t,n,e,i,r,a),e.halfWidth&&n.uniform1f(e.halfWidth,this.lineWidth?this.lineWidth/2:.5),e.miterLimit&&n.uniform1f(e.miterLimit,this.miterLimit?this.miterLimit:4),e.scale&&n.uniform1f(e.scale,this.scale?this.scale:1)}fillUBO(t,n){super.fillUBO(t,n);const e=t.layout;e.halfWidth&&t.setF(e.halfWidth,this.lineWidth?this.lineWidth/2:.5),e.miterLimit&&t.setF(e.miterLimit,this.miterLimit?this.miterLimit:4),e.scale&&t.setF(e.scale,this.scale?this.scale:1)}setLineWidth(t){Math.abs(this.lineWidth-t)>1e-6&&(this.lineWidth=t,this.needsUpdate=!0,this.updateDeferredMaterials())}_setMaterialShaderOptions(t,n,e,i,r,a){super._setMaterialShaderOptions(t,n,e,i,r,a);var s={};a||Object.assign(s,{worldSizePattern:!0,cpuPattern:!1}),Object.assign(t,s)}}z.prototype._shaderID="line2D",t.SVGLineMaterial=z})),define("DS/SVGLoader/SVGLoaderUtils",["DS/Visualization/ThreeJS_DS"],(function(t){"use strict";var n={parseCommands:function(t,n){var e,i,r,a=t.split(" "),s=[],o=[];for(e=0;e<a.length;e++)if(i=a[e])if(r=parseFloat(i),isNaN(r)){if(n.indexOf(i)<0)throw new Error("unknown command '"+i+"'");o.length&&s.push(o),o=[i]}else{if(!o.length)throw new Error("missing command");o.push(r)}return o.length&&s.push(o),s},parseTransformation:function(r){if(0===r.indexOf("rotate")){var a=r.indexOf("("),s=r.indexOf(")"),o=r.substring(a+1,s),l=(o=e(o=i(o,","," "))).split(" "),c=parseFloat(l[0]);n.lastAngle=c;var d=new t.Vector2;l.length>1&&(d.x=parseFloat(l[1]),d.y=parseFloat(l[2]));var u=new t.Matrix3;u.set(1,0,d.x,0,1,d.y,0,0,1);var h=new t.Matrix3;h.set(1,0,-d.x,0,1,-d.y,0,0,1);var f=new t.Matrix3,p=Math.PI*c/180;f.set(Math.cos(p),-Math.sin(p),0,Math.sin(p),Math.cos(p),0,0,0,1);var g=h;return g.multiplyMatrices(f,h),g.multiplyMatrices(u,g),{matrix:g,angle:p}}throw new Error("Unknown transformation")},parseColor:function(n){var e=i(n," ","");return new t.Color(e)},parseDashArray:function(t){var n,r=e(i(t,","," ")),a=r.split(" "),s={key:r,value:[]};for(n=0;n<a.length;n++)s.value.push(parseFloat(a[n]));return s}};function e(t){return t.replace(/\s+/g," ").replace(/^\s+|\s+$/,"")}function i(t,n,e){return t.replace(new RegExp(n,"g"),e)}return n})),define("DS/SVGLoader/SVGNode_abstract",["UWA/Class"],(function(t){"use strict";return t.extend({init:function(t){this.node=t,this.children=[]},fillRenderableBank:function(t,n){var e,i=n.buildChildGas(this.node),r=this.children.length;for(e=0;e<r;e++)this.children[e].fillRenderableBank(t,i);return[]}})})),define("DS/SVGLoader/SVGRenderable",["UWA/Class"],(function(t){"use strict";return t.extend({init:function(t,n){this.isAsync=!!t,this.context=n},createNode3D:function(t){}})})),define("DS/SVGLoader/MultiIndexTable",["DS/Visualization/ThreeJS_DS"],(function(t){"use strict";var n=function(t,n){var e;for(this.data={},this.attributesNames=t,this.mainAttributesNames=n,this.secondaryAttributesNames=[],e=0;e<this.attributesNames.length;e++)this.mainAttributesNames.indexOf(this.attributesNames[e])<0&&this.secondaryAttributesNames.push(this.attributesNames[e])};return n.prototype.getElement=function(n,e){var i,r,a,s,o=this.data;for(i=0;i<this.mainAttributesNames.length;i++)(s=n[r=this.mainAttributesNames[i]])instanceof t.Color&&(s=s.getHexString()),(a=o[s])||(a=i===this.mainAttributesNames.length-1?[]:{},o[s]=a),o=a;var l,c,d,u=null;for(i=0;i<o.length&&!u;i++){for(c=o[i].attributes,d=!0,l=0;l<this.secondaryAttributesNames.length&&d;l++)c[r=this.secondaryAttributesNames[l]]&&c[r].equals?n[r]&&c[r].equals(n[r])||(d=!1):c[r]!==n[r]&&(d=!1);d&&(u=o[i].element)}return u||(u=e(),o.push({attributes:n,element:u})),u},n.prototype.exportToArray=function(){var t=[];return function t(n,e){var i;if(n instanceof Array)for(i=0;i<n.length;i++)e.push(n[i].element);else for(i in n)t(n[i],e)}(this.data,t),t},n})),define("DS/SVGLoader/InstancedArcsUtils",["DS/Visualization/ThreeJS_R57","DS/Mesh/MeshUtils"],(function(t,n){"use strict";return{computeArcBBox:function(n,e,i,r,a,s,o){var l=.5*o,c=r+a,d=Math.cos(r),u=Math.sin(r),h=Math.cos(c),f=Math.sin(c),p=Math.sqrt(d*d/(e*e)+u*u/(i*i)),g=Math.sqrt(h*h/(e*e)+f*f/(i*i)),$=new t.Vector2(l*d/(e*p),l*u/(i*p)),m=new t.Vector2(l*h/(e*g),l*f/(i*g)),S=.5*Math.PI,v=(Math.PI,Math.PI,new t.Vector3(1/0,1/0,-1)),x=new t.Vector3(-1/0,-1/0,1),y=new t.Vector2(e*d-$.x,i*u-$.y),A=new t.Vector2(e*h-m.x,i*f-m.y),b=new t.Vector2(e*d+$.x,i*u+$.y),D=new t.Vector2(e*h+m.x,i*f+m.y),_=[y.x,A.x,b.x,D.x],P=[y.y,A.y,b.y,D.y],C=[Math.floor(r/S),Math.floor(c/S)];.5>=C[0]&&.5<=C[1]&&P.push(i+l),1.5>=C[0]&&1.5<=C[1]&&_.push(-e-l),2.5>=C[0]&&2.5<=C[1]&&P.push(-i-l),3.5>=C[0]&&3.5<=C[1]&&_.push(e+l),4.5>=C[0]&&4.5<=C[1]&&P.push(i+l),5.5>=C[0]&&5.5<=C[1]&&_.push(-e-l),6.5>=C[0]&&6.5<=C[1]&&P.push(-i-l);for(var V=0;V<_.length;V++)v.x=Math.min(v.x,_[V]),x.x=Math.max(x.x,_[V]);for(V=0;V<P.length;V++)v.y=Math.min(v.y,P[V]),x.y=Math.max(x.y,P[V]);var w=new t.Matrix4;return w.rotateZ(s),w.setPosition(new t.Vector3(n.x,n.y,n.z)),new t.Box3(v,x).applyMatrix4(w)},computeArcFillBBox:function(n,e,i,r,a,s){var o=r+a,l=Math.cos(r),c=Math.sin(r),d=Math.cos(o),u=Math.sin(o),h=.5*Math.PI,f=(Math.PI,Math.PI,new t.Vector3(1/0,1/0,-1)),p=new t.Vector3(-1/0,-1/0,1),g=new t.Vector2(0,0),$=new t.Vector2(e*l,i*c),m=new t.Vector2(e*d,i*u),S=[g.x,$.x,m.x],v=[g.y,$.y,m.y],x=[Math.floor(r/h),Math.floor(o/h)];.5>=x[0]&&.5<=x[1]&&v.push(i),1.5>=x[0]&&1.5<=x[1]&&S.push(-e),2.5>=x[0]&&2.5<=x[1]&&v.push(-i),3.5>=x[0]&&3.5<=x[1]&&S.push(e),4.5>=x[0]&&4.5<=x[1]&&v.push(i),5.5>=x[0]&&5.5<=x[1]&&S.push(-e),6.5>=x[0]&&6.5<=x[1]&&v.push(-i);for(var y=0;y<S.length;y++)f.x=Math.min(f.x,S[y]),p.x=Math.max(p.x,S[y]);for(y=0;y<v.length;y++)f.y=Math.min(f.y,v[y]),p.y=Math.max(p.y,v[y]);var A=new t.Matrix4;return A.rotateZ(s),A.setPosition(new t.Vector3(n.x,n.y,n.z)),new t.Box3(f,p).applyMatrix4(A)},createArcLoopMesh:function(e){var i=[],r=new t.BufferGeometryDS;r.drawingGroups=[];var a=new n.DrawingGroup(e,e,4,0,36);a.geometry=r,r.drawingGroups.push(a);for(var s,o=new Float32Array(42),l=0,c=0,d=0;d<7;d++)s=d/6,o[l++]=-1,o[l++]=s,o[l++]=1,o[l++]=1,o[l++]=s,o[l++]=0;r.vertexPositionArray=o;var u=new Uint16Array(36);c=0;for(d=0;d<6;d++)u[c++]=2*d,u[c++]=2*d+1,u[c++]=2*d+3,u[c++]=2*d,u[c++]=2*d+3,u[c++]=2*d+2;r.vertexIndexArray=u,i.push(r);var h=new t.Mesh(i,e);return h.matrixAutoUpdate=!1,h},createArcFillMesh:function(e){var i=[],r=new t.BufferGeometryDS;r.drawingGroups=[];var a=new n.DrawingGroup(e,e,4,0,18);a.geometry=r,r.drawingGroups.push(a);var s,o=new Float32Array(24),l=0,c=0;o[l++]=-1,o[l++]=0,o[l++]=0;for(var d=0;d<7;d++)s=d/6,o[l++]=1,o[l++]=s,o[l++]=0;r.vertexPositionArray=o;var u=new Uint16Array(18);c=0;for(d=0;d<6;d++)u[c++]=0,u[c++]=d+1,u[c++]=d+2;r.vertexIndexArray=u,i.push(r);var h=new t.Mesh(i,e);return h.matrixAutoUpdate=!1,h},createMaterial:function(n,e,i){var r=new t.MeshBasicMaterial({force:!0});r.activatePDSFX(n.uID);var a=n.get_pdsfx_uniforms();if(i){let t=new Float32Array(4*i.length);for(let n=0;n<i.length;n++)t[4*n]=i[n],t[4*n+1]=0,t[4*n+2]=0,t[4*n+3]=0;a.patternArray.value=t,a.patternArray.length=t.length/4}r.setPDSFXUniforms(a);var s=n.get_pdsfx_varyings();return r.setPDSFXVaryings(s),r.defines=r.defines||{},r.defines.CONSIDER_ARC=!!e,r.defines.PATTERN_SIZE=i?i.length:0,r.defines.ARC_PATTERN=!!i,r.setPDSFXGlobalShaderCode(n.VS_global,n.FS_global),r.setPDSFXOverridableFunctions(n.VS_ov,n.FS_ov),r.refreshPDSFXUniforms=function(){r.updatePDSFXUniform("cst",.5*t.glStates.currentHeight*t.getDevicePixelRatio())},r.transparent=!0,r}}})),define("SVGLoader/InstancedArcsUtils",["DS/SVGLoader/InstancedArcsUtils","DS/DSMigration/DSMigration"],(function(t,n){return n.deprecateModule("SVGLoader/InstancedArcsUtils"),t})),define("DS/SVGLoader/SVGMeshMaterial",["DS/Visualization/ThreeJS_DS"],(function(t){"use strict";class n extends t.MeshBasicMaterial{constructor(n){var e={viewBox:{type:"v4",value:new t.Vector4(-1/0,1/0,-1/0,1/0)}};super({side:t.FrontSide}),this.activatePDSFX("PDSFXSVGMeshMaterial"),this.setPDSFXUniforms(e),this.setPDSFXVaryings({pos2d:{type:"v2"}}),this.setPDSFXOverridableFunctions({ComputeVaryingValues:function(t,n){const e=t.variableHandler;var i;return`\n                        ${i="pos2d",t.getVarying(i)} = ${(t=>e.vec2(t))()}((modelMatrix * ${(t=>e.vec4(t))()}( ${t.vGetAttribPosition()}, 1.0 )).xy);\n                    `}},{ComputeDiscard:function(t,n){const e=(i="viewBox",t.getUniform(i));var i;const r=(n=>t.getVarying(n))("pos2d");return`\n                        return (${r}.x < ${e}.x || ${r}.x > ${e}.y || ${r}.y < ${e}.z || ${r}.y > ${e}.w);\n                    `}}),this.setValues(n)}clone(){var t=new n;return super.clone(t),t}getType(){return"SVGBasic"}}return n})),define("DS/SVGLoader/SVGRenderableContext",["UWA/Class"],(function(t){"use strict";return t.extend({init:function(){this._lastUsedGas=null,this._currentZIndex=0},computeZIndex:function(t){return this._lastUsedGas&&t&&t.isZCompatibleWithGas(this._lastUsedGas)||(this._currentZIndex++,this._lastUsedGas=t),this._currentZIndex},forceNewZ:function(){this._lastUsedGas=null},getZFromZIndex:function(t){return-this._currentZIndex+t-1},getBgZ:function(t){return-this._currentZIndex-2}})})),define("DS/SVGLoader/InstancedArcsShaders",["DS/Visualization/ThreeJS_R57"],(function(t){"use strict";var n=function(t){const n=t.variableHandler;return`\n            ${e="tolerance",n.float(e)} = max(0.1 * nbPixels, 1.0) / ratio;\n        `;var e},e=function(t){const n=t.variableHandler,e=t.functionHandler,i=t=>n.float(t);return`\n            ${e.dF("computeClampedAngle","f",[e.prmF("_cos"),e.prmF("_sin")])} {\n                ${i("currAngle")} ;\n                ${i("_asin")}  = asin(_sin);\n                if (_sin >= 0.0) {\n                    currAngle = acos(_cos);\n                }else {\n                    if (_cos >=0.0) {\n                        currAngle = _asin + PI2;\n                    } else {\n                        currAngle = -_asin + PI;\n                    }\n                }\t\t\t\t\t\t\t\n                currAngle = clamp(currAngle, 0.0, PI2);\n                return currAngle;\n            }\n        `},i=function(t){const n=t.variableHandler,e=t.functionHandler,i=t=>n.float(t),r=t=>n.vec2(t);return`\n                \n            //Method: A and B are the first and second outer points of a pair of the polygon, extruded half a width along their respective normals. We consider the (AB) line, find\n            // a point M0 on the ellipse whose tangent is parallel to (AB). Then we compute the distance from M0 to (AB). We know that the distance from M0 to the wanted polygon line \n            //which will be tangent to the outer shape of the constant width ellipse is halfWidth. With this information, we compute the new positions of A and B (using cos) to obtain \n            //the best polygon to contain the ellipse.\n            ${e.dF("_computeVertices",null,[e.prmIOV2("firstPoint"),e.prmIOV2("secondPoint"),e.prmV2("firstNormal"),e.prmV2("secondNormal")])} {\n                //first point of the pair on ellipse extruded along its normal\n                ${r("A")} = ${n.dereference("firstPoint")};\n                //second point of the pair on ellipse extruded along its normal\n                ${r("B")} = ${n.dereference("secondPoint")};\n                ${r("nA")} = firstNormal;\n                ${r("nB")} = secondNormal;\n                ${i("a")} = instanceRadiiAndWidth.x;\n                ${i("b")} = instanceRadiiAndWidth.y;\n                ${i("a2")} = a*a;\n                ${i("b2")} = b*b;\t\t\t\t\t\t\t\n                ${r("M0_1")} ;\n                ${r("M0_2")} ;\n                //compute the (AB) line's equation: -alpha*x + beta*y + gamma = 0\n                ${r("AB")}  = B-A;\n                ${i("alpha")}  = AB.y;\n                ${i("beta")}  = AB.x;\n                ${i("alpha2")}  = alpha*alpha;\n                ${i("beta2")}  = beta*beta;\n                ${i("a2alpha2")}  = a2*alpha2;\n                ${i("b2beta2")}  = b2*beta2;\n                ${i("L_alpha_beta")}  = sqrt(alpha2 + beta2);\n                \n                ${i("gamma")}  = 0.5*(alpha*(A.x + B.x) - beta*(A.y + B.y));\n                //normal to (AB)\n                ${r("nAB")}  = ${r()}(-alpha, beta)/L_alpha_beta;\n                if (alpha == 0.0) {\t\t\t\n                    M0_1.x = 0.0;\n                    M0_1.y = -abs(b);\n                    M0_2.x = 0.0;\n                    M0_2.y = -M0_1.y;\n                } else if (beta == 0.0) {\n                    M0_1.y = 0.0;\n                    M0_1.x = -abs(a);\n                    M0_2.y = 0.0;\n                    M0_2.x = -M0_1.x;\n                } else {\n                    // find point M0 on the ellipse whose tangent is parallel to (AB)\n                    ${i("denom")}  = a2alpha2 + b2beta2;\t\t\t\t\t\t\t\t\n                    M0_1.x = -sqrt((a2*a2alpha2)/denom);\n                    M0_1.y = -b2*beta*M0_1.x/(a2*alpha);\n                    M0_2.x = -M0_1.x;\n                    M0_2.y = -M0_1.y;\n                }\n                \n                //find the distance from M0 to (AB)\n                ${i("d1")}  =  abs(-alpha*M0_1.x + beta*M0_1.y + gamma)/L_alpha_beta;\n                ${i("d2")}  =  abs(-alpha*M0_2.x + beta*M0_2.y + gamma)/L_alpha_beta;\n                ${i("distM0_AB")}  = min(d1,d2);\n                //does (AB) intersect the ellipse?\n                ${i("intEllipse")}  = -1.0;\n                if (b2beta2 - gamma*gamma + a2alpha2 >= 0.0) {\n                    intEllipse = 1.0;\n                }\n                //compute totalDistance from (AB) to the end of the extruded ellipse)\n                ${i("totalDist")}  = intEllipse*distM0_AB + halfWidth;\n                //compute new position for A\n                ${i("dotA")}  = abs(dot(nA, nAB));\n                // float newExtA = min(totalDist/dotA, max(a,b));\n                ${i("newExtA")}  = totalDist/dotA;\n                ${n.dereference("firstPoint")} = A + newExtA*nA;\n                //compute new position for B\n                ${i("dotB")}  = abs(dot(nB, nAB));\n                // float newExtB = min(totalDist/dotB, max(a,b));\n                ${i("newExtB")}  = totalDist/dotB;\n                ${n.dereference("secondPoint")} = B + newExtB*nB;\n            }\n\n            ${e.dF("computeImpostorVertices",null,[e.prmV2("precExtruded"),e.prmIOV2("currExtruded"),e.prmV2("nextExtruded"),e.prmV2("precNormal"),e.prmV2("currNormal"),e.prmV2("nextNormal")])} {\n                ${r("curr")} = ${n.dereference("currExtruded")};\n                ${r("currSolution0")} = curr;\n                ${r("prec0")}  = precExtruded;\n                ${e.cF("_computeVertices",null,[e.prmRefV2("prec0"),e.prmRefV2("currSolution0"),e.prmV2("precNormal"),e.prmV2("currNormal")])};\n                \n                ${r("currSolution1")}  = curr;\n                ${r("next1")}  = nextExtruded;\n                ${e.cF("_computeVertices",null,[e.prmRefV2("currSolution1"),e.prmRefV2("next1"),e.prmV2("currNormal"),e.prmV2("nextNormal")])};\n                                        \n                ${n.dereference("currExtruded")} = currSolution1;\t\t\t\t\t\n                if (length(currSolution0 - curr) > length(currSolution1 - curr)) {\n                    ${n.dereference("currExtruded")} = currSolution0;\n                }\n            }\n            `},r=function(t){const n=t.variableHandler,i=t.functionHandler,r=t.bridgeFunctions,a=t=>n.int(t),s=(t,e=0)=>n.float(t,e),o=(t,e=0)=>n.floatC(t,e),l=t=>n.vec2(t),c=t=>n.vec3(t);let d="";var u;return t.userDefines.CONSIDER_ARC&&(d=`\n                ${i.dF("angularDistanceToArc","f",[i.prmF("startAngle"),i.prmF("endAngle"),i.prmF("iCos"),i.prmF("iSin")])} {\n                    // return 0.0;\n                    ${s("currAngle")} = ${i.cF("computeClampedAngle","f",[i.prmF("iCos"),i.prmF("iSin")])};\n                    \n                    ${s("dist")}  = 1e5;\n                    ${s("startDist")}  = ${r.modulo("abs(startAngle - currAngle)","PI2")};\n                    ${s("fendAngle")} = endAngle;\n                    if (fendAngle < PI2) {\n                        ${s("endDist")}  = ${r.modulo("abs(currAngle-fendAngle)","PI2")};\n                        if (currAngle < startAngle || currAngle > fendAngle) {\n                            dist = min(dist, min(startDist, endDist));\n                        } else {\n                            dist = 0.0;\n                        }\n                    } else if (fendAngle >= PI2){            \n                        fendAngle -= PI2;\n                        ${s("endDist")}  = ${r.modulo("abs(currAngle-fendAngle)","PI2")};\n                        if (currAngle > fendAngle && currAngle < startAngle) {\n                            dist = min(dist, min(startDist, endDist));\n                        } else {\n                            dist = 0.0;\n                        }\n                    }\n                    \n                    return dist;\n                }\n\n                //Method: http://equationsolver.intemodino.com/fr/resolution-des-equations-du-quatrieme-degre.html \n                // and http://equationsolver.intemodino.com/fr/resolution-des-equations-du-troisieme-degre.html\n                // The function was coded to minimize computations in order to minimize imprecisions.\n                // Returns the minimal distance and the projection on the ellipse\n                ${i.dF("distanceToArc","v3",[i.prmF("iStartAngle"),i.prmF("iEndAngle"),i.prmF("iA"),i.prmF("iB"),i.prmV2("point"),i.prmF("h")])} {\t\n                    ${s("a")} = iA;\n                    ${s("b")} = iB;\n                    ${l("pointToUse")} = point;\n                    if (b > a) {\n                        pointToUse = ${l()}(-point.y, point.x); \n                        a=iB; \n                        b=iA;\n                    }\t\t\t\n                    ${s("h2")} = h*h;\n                    ${s("a2")}  = a*a;\n                    ${s("b2")}  = b*b;\n                    ${s("b2_a2")}  = (b+a)*(b-a);\n                    ${s("x")}  = pointToUse.x;\n                    ${s("y")}  = pointToUse.y;\n                    \n                    ${s("startAngle")}  = iStartAngle;\n                    ${s("endAngle")}  = iEndAngle;\n                    \n                    ${s("cosSolutions",4)};\n                    \n                    ${s("m")}  = x*a/b2_a2;\n                    ${s("n")} = y*b/b2_a2;\n                    ${s("m2")} = m*m;\n                    ${s("n2")} = n*n;\n                    ${s("m2n2")}  = m2*n2;\n                    \n                    // equation: y^4 + p*y^2 + q*y + r = 0 with y = lambda + 0.5*m\n                    ${s("p")} = -0.5*m2 + n2 - 1.0;\n                    ${s("q")} = -m*(1.0 + n2);\n                    \n                \n                    //cubic equation; A*z^3 + B*z^2 + C*z + D = 0 of which we only want one real solution z0\n                    ${s("B")} = p;\n                    ${s("B_3")}  = B/3.0;\n                    \n                    // equation: v^3 + P*v + Q = 0 with v = z + B/3.0\n                    ${s("var1")} = m2+n2-1.0;\n                    ${s("var2")} = var1*var1;\n                    ${s("var3")}  = var2*var1;\n                    ${s("P")}  = -var2/12.0;\n                    ${s("Q")}  = -0.5*(m2n2 + var3*0.5/27.0);\n                                                    \n                    ${s("P_3")}  = P/3.0;\n                    ${s("Q_2")}  = 0.5*Q;\n                    \n                    ${s("v")} ;\n                    //delta = (P/3)^3 + (Q/2)^2\n                    ${s("delta")}  = (1.0/432.0)*m2n2*(var3 + 27.0*m2n2);\n                    ${s("dTerm0")}  = abs(m*n)/12.0;\n                    ${s("dTerm1")}  = var3/3.0 + 9.0*m2n2;\n                    ${s("_sqDelta")}  = dTerm0*sqrt(-dTerm1);\n                    ${s("sqDelta")}  = dTerm0*sqrt(dTerm1);\n                    if (delta < 0.0) {\n                        //we consider z = r*exp(i*theta) with alpha = pow(z, 1/3)\n                        ${l("complZ")}  = ${l()}(-Q_2, _sqDelta);\n                        ${s("modulo")}  = length(complZ);\n                        ${s("theta")}  = acos(clamp(-Q_2/modulo, -1.0, 1.0));\n                        v = 2.0*pow(modulo, 1.0/3.0)*cos(theta/3.0);\n                    } else {\n                        ${s("alpha")}  = pow(-Q_2 + sqDelta, 1.0/3.0);\n                        ${s("beta")}  = -P_3/alpha;\n                        v = alpha + beta;\n                    }\n                    ${s("z0")}  = v - B_3;\n                    \n                    //now we can express the solution to the inital equation\n                    ${s("z02")}  = max(2.0*z0, 0.0);\n                    ${s("sqz02")}  = sqrt(z02);\n                    ${s("term0")}  = 2.0*(p + z02);\n                    ${s("term1")}  = 2.0*q/sqz02;\n                    ${s("largeTerm0")}  = sqrt(z02 - (term0 + term1));\n                    ${s("largeTerm1")}  = sqrt(z02 - (term0 - term1));\n                    ${s("lambda1")}  = 0.5*(-m + (sqz02 - largeTerm0));\n                    ${s("lambda2")}  = 0.5*(-m + (sqz02 + largeTerm0));\n                    ${s("lambda3")}  = 0.5*(-m + (-sqz02 - largeTerm1));\n                    ${s("lambda4")}  = 0.5*(-m + (-sqz02 + largeTerm1));\t\t\t\t\t\t\t\n                    \n                    cosSolutions[0] = lambda1;\n                    cosSolutions[1] = lambda2;\n                    cosSolutions[2] = lambda3;\n                    cosSolutions[3] = lambda4;\n                    \n                    ${s("ax")}  = a*x;\n                    ${s("by")}  = b*y;\t\t\t\t\t\t\t\n                    ${s("sinSolution")} ;\n                    ${l("pointSolution")} ;\n                    ${s("minDistArc")}  = 1e5;\n                    ${s("minDistEllipse")}  = 1e5;\n                    //to find the solutions closest to the arc (and not on the arc, because it introduces imprecisions)\n                    ${s("minAngularDist")}  = 0.1*abs(endAngle - startAngle);\n                    // float minAngularDist = 0.000031415;\n                    \n                    ${l("closestOnEllipse")} ;\n                    ${l("closestOnArc")} ;\t\t\t\n                    \n                    ${u="foundOnArc",n.bool(u)}  = false;\n                    ${s("_cos2")} ;\n                    ${s("currLength")} ;\n                    ${s("tangentLength")} ;\n                    ${s("epsilon")} ;\n                    ${s("currAngularDist")} ;\n                    for (${a("i")} = 0; i < 4; i++) {\n                        cosSolutions[i] = clamp(cosSolutions[i], -1.0, 1.0);\n                        _cos2 = cosSolutions[i]*cosSolutions[i];\n                        //first sin\n                        sinSolution = clamp(sqrt(1.0 - _cos2), 0.0, 1.0);\n                        pointSolution = ${l()}(a*cosSolutions[i], b*sinSolution);\n                        currLength = length(pointToUse - pointSolution);\n                        tangentLength = length(${l()}(-a*sinSolution, b*cosSolutions[i]));\n                        epsilon = 0.8*(currLength*tangentLength);\n                        //is a solution\n                        // if (abs(b2_a2*sinSolution*cosSolutions[i] + ax*sinSolution - by*cosSolutions[i]) < epsilon) {\n                            //is smaller than the current minimal distance to ELLIPSE\n                            if (currLength < minDistEllipse) {\n                                minDistEllipse = currLength;\n                                closestOnEllipse = pointSolution;\n                            }\n                            currAngularDist = ${i.cF("angularDistanceToArc","f",[i.prmF("startAngle"),i.prmF("endAngle"),i.prmF("cosSolutions[i]"),i.prmF("sinSolution")])};\n                            //the closest point in on considered ARC\n                            if (currLength < minDistArc && currAngularDist <= minAngularDist) {\n                                minAngularDist = currAngularDist;\n                                minDistArc = currLength;\n                                foundOnArc = true;\n                                closestOnArc = pointSolution;\n                            } \n                        // }\n                        //second sin\n                        sinSolution = -sinSolution;\n                        pointSolution.y *= -1.0;\n                        currLength = length(pointToUse - pointSolution);\n                        tangentLength = length(vec2(-a*sinSolution, b*cosSolutions[i]));\n                        epsilon = 100.0*(currLength*tangentLength);\n                        //is a solution\n                        // if (abs(b2_a2*sinSolution*cosSolutions[i] + ax*sinSolution - by*cosSolutions[i]) < epsilon) {\n                            //is smaller than the current minimal distance to ELLIPSE\n                            if (currLength < minDistEllipse) {\n                                minDistEllipse = currLength;\n                                closestOnEllipse = pointSolution;\n                            }\n                            currAngularDist = ${i.cF("angularDistanceToArc","f",[i.prmF("startAngle"),i.prmF("endAngle"),i.prmF("cosSolutions[i]"),i.prmF("sinSolution")])};\n                            //the closest point in on considered ARC\n                            if (currLength < minDistArc && currAngularDist <= minAngularDist) {\n                                minAngularDist = currAngularDist;\n                                minDistArc = currLength;\n                                foundOnArc = true;\n                                closestOnArc = pointSolution;\n                            } \n                        // }\n                    }\n                    //minimal distance (x) + projection (y-z)\n                    ${c("results")}  = ${c()}(minDistArc, closestOnArc);\n                    if (x*x/a2 + y*y/b2 > 1.0 || !foundOnArc) {\n                        //outside the ellipse: distance to whole ellipse, to avoid imprecisions\t\n                        results = ${c()}(minDistEllipse, closestOnEllipse.x, closestOnEllipse.y);\t\n                    }\t\t\t\t\t\n                    if (iB > iA) {\n                        // swap z and y\n                        results = ${c()}(results.x, results.z, -results.y);\t\n                    }\t\t\t\t\n                    return results;\t\t\t\t\t\t\t\n                }\n                `),`\n            ${(t=>n.vec3G(t))("debug")};\n            ${o("PI")} = 3.1415926535897932384;\n            ${o("PI2")} = 6.283185307179586;\n            ${o("PI_2")} = 1.5707963267948966;\n\n            ${e(t)}\n\t\t\n            ${i.dF("ClosestPointOnEllipse","v2",[i.prmV2("p"),i.prmV2("ab")])}{\n\t\t\t\t//focal point of ellipse - either on x axis if a>b or y otherwise\n\t\t\t\t${s("c")} = sqrt(abs(ab.x*ab.x - ab.y*ab.y));\n\n\t\t\t\t${s("t")} = 0.;\n\t\t\t\tif (ab.y < ab.x && abs(p.x) < c)\n\t\t\t\t{\n                    if (p.y <= 0.0) {\n                        t = -PI_2;\n                    }\n\t\t\t\t}\n\t\t\t\telse if (ab.x < ab.y && abs(p.y) < c)\n\t\t\t\t{\n                    if (p.x <= 0.0) {\n                        t = -PI;\n                    }\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tt = ${r.atan2("ab.x*p.y","ab.y*p.x")};\n\t\t\t\t}\n\n\t\t\t\t${s("aa_bb")}  = ab.x * ab.x - ab.y * ab.y;\n\t\t\t\t${l("pab")}  = p*ab;\n\t\t\t\tfor (${a("i")} = 0; i < 4; i++)\n\t\t\t\t{\n\t\t\t\t\t${s("sint")}  = sin(t);\n\t\t\t\t\t${s("cost")}  = cos(t);\n\t\t\t\t\t${s("ft")}  = aa_bb * cost * sint - pab.x * sint + pab.y * cost;\n\t\t\t\t\t${s("dft")}  = aa_bb * (cost * cost - sint * sint) - pab.x * cost - pab.y * sint;\n\n\t\t\t\t\tt = t - ft/dft;\n\t\t\t\t}\n\t\t\t\treturn ${l()}(cos(t),sin(t))*ab;\n\t\t\t}\n\n            ${i.dF("distanceToEllipse","v3",[i.prmF("iStartAngle"),i.prmF("iEndAngle"),i.prmF("iA"),i.prmF("iB"),i.prmV2("p"),i.prmF("h")])}{\n\t\t\t\t${l("ab")}  = abs(${l()}(iA,iB));\n\t\t\t\t${l("origp")}  = p;\n\t\t\t\t${l("absMp")} = -abs(p);\n\t\t\t\t${l("closest")}  = ${i.cF("ClosestPointOnEllipse","v2",[i.prmV2("absMp"),i.prmV2("ab")])};\n\t\t\t\t${s("dist")}  = length(closest-absMp);\n\t\t\t\t\n\t\t\t\tclosest = abs(closest)*sign(origp);\t\t\t\t\n\t\t\t\t\n\t\t\t\treturn ${c()}(abs(dist), closest);\n\t\t\t}\n            ${d}\n            `},a=function(t){const n=t.variableHandler,e=t.functionHandler,i=(t,e=0)=>n.float(t,e);return`\n            ${e.dF("clampToOnePixelSize",null,[e.prmRefGF("iHalfWidth")])}{\n\t\t\t\tif ((2.0*${n.dereference("iHalfWidth")}* ratio) < 1.0) {\n\t\t\t\t\t${i("newHalfLineWidth")}  = 0.5/ratio;\n\t\t\t\t\t${i("linesRatio")}  = (newHalfLineWidth - ${n.dereference("iHalfWidth")})/newHalfLineWidth;\n\t\t\t\t\tfartheringAlpha = 1.0 - smoothstep(0.65, 1.0, linesRatio);\n\t\t\t\t\t${n.dereference("iHalfWidth")} = newHalfLineWidth;\n\t\t\t\t}\n\t\t\t}\n\t\t`},s=function(t){const n=t.variableHandler,e=t.functionHandler,i=t.bridgeFunctions,r=t.userDefines,a=t=>n.int(t),s=(t,e=0)=>n.float(t,e),o=t=>n.vec3(t);return`\n            ${e.dF("getPatternInfo","v3",[e.prmF("dist")])}{\n                ${a("index")}  = 0;\n                ${s("prec")}  = 0.0;\n                ${s("cur")} = 0.0;\n                for (${a("i")} = 0; i < ${r.PATTERN_SIZE}; i++) {\n                    cur = ${l="patternArray",t.getUniform(l)}[i].x;\n                    if (cur > dist) {\n                        break;\n                    }\n                    prec = cur;\n                    index++;\n                }\n                return ${o()}(${s()}(index),prec,cur);\n            }\n\n            ${e.dF("getPatternAlpha","f",[e.prmF("dist"),e.prmF("fTotalSize")])}{\n                ${r.USE_ROUNDCAP||r.USE_SQUARECAP?`\n                    ${s("mDist")}  = ${i.modulo("dist + halfWidth/scale","fTotalSize")};\n                    `:`\n                    ${s("mDist")}  = ${i.modulo("dist","fTotalSize")};\n                    `}\n                ${o("patternInfo")}  = ${e.cF("getPatternInfo","v3",[e.prmF("mDist")])};\n                if (abs(${i.modulo("patternInfo.x","2.0")}) < 1e-2) {\n                    return 0.0;\n                }\n                return 1.0;\n            }\n\n        `;var l},o=function(t){const n=t.functionHandler;return`      \n\t\t\t    alpha *= (1.0- ${n.cF("getPatternAlpha","f",[n.prmF("curvAbs"),n.prmF("vPatternSize")])});\n            `},l={transX:{type:"f"},transY:{type:"f"},vInstanceColor:{type:"v4"}},c={vRadiiAndHWidth:{type:"v3"},vStartAngle:{type:"f"},vEndAngle:{type:"f"}},d={vRadius:{type:"f"},vHalfWidth:{type:"f"}},u={vStartAngle:{type:"f"},vPatternOffset:{type:"f"}},h={patternOffset:{type:"f"},vIntegralFirstTerm:{type:"v4"}},f={cst:{type:"f",value:.5*t.glStates.currentHeight*t.getDevicePixelRatio()}},p={cst:{type:"f",value:.5*t.glStates.currentHeight*t.getDevicePixelRatio()},patternArray:{type:"fv4",value:[],length:-1}},g={uID:"PDSFXArcEllipse",get_pdsfx_uniforms:function(){return Object.create(f)},get_pdsfx_varyings:function(){return Object.assign({},l,c)},VS_global:function(t){const n=t.variableHandler,e=(t,e=0)=>n.floatG(t,e);return`\n\t\t\t${e("fartheringAlpha")} ;\n\t\t\t${r="viewTr",n.vec3G(r)} ;\n\t\t\t${e("halfWidth")} ;\n\t\t\t${e("ratio")} ;\n\t\t\t${(t=>n.vec2G(t))("myViewPos")} ;\n\t\t\t\n\t\t\t${i(t)}\n\t\t\t${a(t)}\n\t\t`;var r},FS_global:function(t){const n=t.variableHandler;return`\n\t\t\t${r(t)}\n\t\t\t${e="toDiscard",n.boolG(e)} ;\n\t\t\t${((t,e=0)=>n.floatG(t,e))("alpha")} ;\n            `;var e},VS_ov:{ComputeCommonValues:function(t,n){const e=t.variableHandler,i=t.functionHandler,r=t=>e.mat4(t);return`\n                \n\t\t\t\t\t${r("PM")} = ${t.vGetProjectionMatrix()};\n\t\t\t\t\tfartheringAlpha = 1.0;\n                    //symmetric camera\n\t\t\t\t\t${((t,n=0)=>e.float(t,n))("cameraTop")}  = 1.0/PM[1][1];\n\t\t\t\t\tratio = ${a="cst",t.getUniform(a)}/cameraTop;\n\t\t\t\t\thalfWidth = instanceRadiiAndWidth.z;\n\t\t\t\t\t${i.cF("clampToOnePixelSize",null,[i.prmRefGF("halfWidth")])};\t\t\t\t\n\t\t\t\t\t${r("viewM")}  = ${t.vGetViewMatrix()};\t\t\t\t\n\t\t\t\t\tviewTr = ${(t=>e.vec3(t))()}(viewM[3][0], viewM[3][1], viewM[3][2]);\n                `;var a},ProcessViewTangentSpace:function(t,e){const i=t.variableHandler,r=t.functionHandler,a=(t,n=0)=>i.float(t,n),s=t=>i.vec2(t),o=t=>i.vec3(t),l=t=>i.mat2(t),c=i.dereference(e[0]);return`\n\t\t\t\t\t\n                ${a("totalAngle")}  = instanceOffsetAndAngles.z;\n                ${a("startAngle")}  = instanceOffsetAndAngles.w;\n                \n                ${s("_localPosition")} ;\n                \n                ${o("infos")}  = ${t.vGetAttribPosition()};\n                ${a("inOrOut")}  = infos.x;\n                ${a("frac")}  = infos.y;\n                ${a("currAngle")}  = frac*totalAngle + startAngle;\n                ${a("cosCurr")}  = cos(currAngle);\n                ${a("sinCurr")}  = sin(currAngle);\n                //number of pixels of the half width of the circle\n                ${a("nbPixels")}  = halfWidth*ratio;\n                ${n(t)}\n                ${a("a")}  = instanceRadiiAndWidth.x;\n                ${a("b")}  = instanceRadiiAndWidth.y;\n                ${a("a2")}  = a*a;\n                ${a("b2")}  = b*b;\n                                    \n                ${s("localPt")}  = ${s()}(a*cosCurr, b*sinCurr);\n                ${s("localNormal")}  = normalize(${s()}(localPt.x/(a2), localPt.y/(b2)));\n                if (inOrOut < 0.0) {\n                    _localPosition = localPt - (halfWidth+tolerance)*localNormal;\n                    \n                } else {\n                    ${a("totalAngle_6")}  = totalAngle/6.0;\n                    //current point\n                    ${s("currPt")}  = localPt + halfWidth*localNormal;\n                    //next point\n                    ${s("nextPt")}  = ${s()}(a*cos(currAngle + totalAngle_6), b*sin(currAngle + totalAngle_6));\n                    ${s("nextNormal")}  = normalize(${s()}(nextPt.x/(a2), nextPt.y/(b2)));\n                    nextPt += halfWidth*nextNormal;\n                    //preceding point\n                    ${s("precPt")}  = ${s()}(a*cos(currAngle - totalAngle_6), b*sin(currAngle - totalAngle_6));\n                    ${s("precNormal")}  = normalize(${s()}(precPt.x/(a2), precPt.y/(b2)));\n                    precPt += halfWidth*precNormal;\n                    if (frac == 0.0) {\n                        ${s("next_")}  = nextPt;\n                        ${r.cF("_computeVertices",null,[r.prmRefV2("currPt"),r.prmRefV2("next_"),r.prmV2("localNormal"),r.prmV2("nextNormal")])};\t\t\t\t\t\t\t\t\n                    } else if (frac == 1.0) {\n                        ${s("prec_")}  = precPt;\n                        ${r.cF("_computeVertices",null,[r.prmRefV2("prec_"),r.prmRefV2("currPt"),r.prmV2("precNormal"),r.prmV2("localNormal")])};\n                    } else {\n                        ${r.cF("computeImpostorVertices",null,[r.prmV2("precPt"),r.prmRefV2("currPt"),r.prmV2("nextPt"),r.prmV2("precNormal"),r.prmV2("localNormal"),r.prmV2("nextNormal")])};\n                    }\n                    _localPosition = currPt;\n                    _localPosition += tolerance*localNormal;\n                \n                }\n                ${a("cosO")}  = instanceOffsetAndAngles.x;\n                ${a("sinO")}  = instanceOffsetAndAngles.y;\n                ${l("rotMatrix")}  = ${l()}(cosO, sinO, -sinO, cosO);\t\t\t\t\t\n\n                // for the vertex position\n                ${c}.Position = viewTr + ${o()}( rotMatrix*_localPosition + instancePosition.xy, instancePosition.z);\n                // for the ellipse equation\n                myViewPos = viewTr.xy + _localPosition + instancePosition.xy;\n                `},ComputeVaryingValues:function(t,n){const e=t.variableHandler,i=n=>t.getVarying(n),r=(t,n=0)=>e.float(t,n);return`\n                ${a="viewCenterPos",e.vec2(a)}  = viewTr.xy + instancePosition.xy;\n                ${i("vRadiiAndHWidth")} = ${(t=>e.vec3(t))()}(instanceRadiiAndWidth.xy, halfWidth);\n                ${i("transX")} = myViewPos.x - viewCenterPos.x;\n                ${i("transY")} = myViewPos.y - viewCenterPos.y;\n                ${i("vInstanceColor")} = instanceColor;\n                ${i("vInstanceColor")}.w *= fartheringAlpha;\n                \n                ${r("totalAngle")}  = instanceOffsetAndAngles.z;\n                ${r("startAngle")} = instanceOffsetAndAngles.w;\n                \n                ${i("vStartAngle")} = startAngle;\n                ${i("vEndAngle")} = startAngle+totalAngle;\n                `;var a}},FS_ov:{ComputeCommonValues:function(t,n){const e=t.variableHandler,i=t.functionHandler,r=t.userDefines,a=n=>t.getVarying(n),s=(t,n=0)=>e.float(t,n);return`\n                alpha = 1.0;\n                ${s("a")} = ${a("vRadiiAndHWidth")}.x;\n                ${s("b")} = ${a("vRadiiAndHWidth")}.y;\n                ${s("halfWidth")}  = ${a("vRadiiAndHWidth")}.z;\n                \n                ${s("startAngle")}  = ${a("vStartAngle")};\n                ${s("endAngle")}  = ${a("vEndAngle")};\n                if (b > a) {\t\n                    ${s("totalAngle")}  = endAngle - startAngle;\n                    startAngle += PI_2;\n                    if (startAngle >= PI2) {\n                        startAngle -= PI2;\n                    }\n                    endAngle = startAngle + totalAngle;\n                }\n                ${s("dist")} ;\n                ${o="inEllipse",e.bool(o)}  = ${a("transX")}*${a("transX")}/(a*a) + ${a("transY")}*${a("transY")}/(b*b) < 1.0;\n                ${(t=>e.vec2(t))("transXY")} = vec2(${a("transX")}, ${a("transY")});\n                ${r.CONSIDER_ARC?`\n                    if (inEllipse) {\n                        dist = (${i.cF("distanceToArc","v3",[i.prmF("startAngle"),i.prmF("endAngle"),i.prmF("a"),i.prmF("b"),i.prmV2("transXY"),i.prmF("halfWidth")])}).x;\n                    } else {\n                        dist = (${i.cF("distanceToEllipse","v3",[i.prmF("startAngle"),i.prmF("endAngle"),i.prmF("a"),i.prmF("b"),i.prmV2("transXY"),i.prmF("halfWidth")])}).x;\n                    }\n                    `:`\n                    dist = (${i.cF("distanceToEllipse","v3",[i.prmF("startAngle"),i.prmF("endAngle"),i.prmF("a"),i.prmF("b"),i.prmV2("transXY"),i.prmF("halfWidth")])}).x;\n                    `}\n                ${s("value")}  = dist/halfWidth;\n                \n            toDiscard = value > 1.0;\n                     \n                `;var o},ComputeDiscard:function(t,n){return"\n                    return toDiscard;\n                "},ProcessFinalColor:function(t,n){const e=t.variableHandler,i=n=>t.getVarying(n);return`\n                    ${e.dereference(n[0])} = ${e.vec4(r)}(${i("vInstanceColor")}.xyz, ${i("vInstanceColor")}.w*alpha);\n                `;var r}}},$={uID:"PDSFXArcCircle",get_pdsfx_uniforms:function(){return Object.assign({},f)},get_pdsfx_varyings:function(){return Object.assign({},l,d)},VS_global:function(t,n){const e=t.variableHandler,i=(t,n=0)=>e.floatG(t,n);return`\n\t\t\t${i("fartheringAlpha")} ;\n\t\t\t${r="viewTr",e.vec3G(r)} ;\n\t\t\t${i("halfWidth")} ;\n\t\t\t${i("ratio")} ;\n\t\t\t${(t=>e.vec2G(t))("myViewPos")} ;\n\t\t\t${a(t)}\n            `;var r},FS_global:function(t,n){const e=t.variableHandler;return`\n\t\t\t${i="toDiscard",e.boolG(i)} ;\n\t\t\t${((t,n=0)=>e.floatG(t,n))("alpha")} ;\n            `;var i},VS_ov:{ComputeCommonValues:function(t,n){const e=t.variableHandler,i=t.functionHandler,r=t=>e.mat4(t);return`\n                ${r("PM")}  = ${t.vGetProjectionMatrix()};\n                fartheringAlpha = 1.0;\n                //symmetric camera\n                ${((t,n=0)=>e.float(t,n))("cameraTop")}  = 1.0/PM[1][1];\n                ratio = ${a="cst",t.getUniform(a)}/cameraTop;\n                halfWidth = instanceRadiiAndAngles.y;\n                ${i.cF("clampToOnePixelSize",null,[i.prmRefGF("halfWidth")])};\t\t\t\t\n                ${r("viewM")}  = ${t.vGetViewMatrix()};\t\t\t\t\n                viewTr = ${((t,n=0)=>e.vec3(t,n))()}(viewM[3][0], viewM[3][1], viewM[3][2]);\n                `;var a},ProcessViewTangentSpace:function(t,e){const i=t.variableHandler,r=(t,n=0)=>i.float(t,n),a=t=>i.vec2(t),s=t=>i.vec3(t),o=i.dereference(e[0]);return`\n                //compute local position\n                ${a("_localPosition")} ;\n                ${r("totalAngle")}  = instanceRadiiAndAngles.z;\n                ${r("startAngle")}  = instanceRadiiAndAngles.w;\n                ${s("infos")}  = ${t.vGetAttribPosition()};\n                ${r("inOrOut")}  = infos.x;\n                ${r("frac")}  = infos.y;\n                ${r("currAngle")}  = frac*totalAngle + startAngle;\n                ${r("cosCurr")}  = cos(currAngle);\n                ${r("sinCurr")}  = sin(currAngle);\n                ${r("r")}  = instanceRadiiAndAngles.x;\n                ${r("coeff")}  = cos(totalAngle/12.0);\n                //number of pixels of the half width of the circle\n                ${r("nbPixels")}  = halfWidth*ratio;\n                ${n(t)}\n                if (inOrOut < 0.0) {\n                    _localPosition = (r-halfWidth-tolerance)*${a()}(cosCurr, sinCurr);\n                }else {\n                    _localPosition = (r+halfWidth+tolerance)*${a()}(cosCurr, sinCurr)/coeff;\n                }\n                ${s("mvPosition")}  = viewTr + ${s()}( _localPosition+instancePosition.xy, instancePosition.z);\n                myViewPos = mvPosition.xy;\n                ${o}.Position = mvPosition;\n                `},ComputeVaryingValues:function(t,n){const e=t.variableHandler,i=n=>t.getVarying(n);return`\n                ${r="viewCenterPos",e.vec2(r)}  = viewTr.xy + instancePosition.xy;\t\t\t\t\t\t\t\n                ${i("transX")} = myViewPos.x - viewCenterPos.x;\n                ${i("transY")} = myViewPos.y - viewCenterPos.y;\t\t\t\t\n                ${i("vRadius")} = instanceRadiiAndAngles.x;\n                ${i("vHalfWidth")} = halfWidth;\n                ${i("vInstanceColor")} = instanceColor;\n                ${i("vInstanceColor")}.w *= fartheringAlpha;\n                `;var r}},FS_ov:{ComputeCommonValues:function(t,n){const e=t.variableHandler,i=n=>t.getVarying(n),r=(t,n=0)=>e.float(t,n);return`\n                alpha = 1.0;\n                ${r("transX_2")}  = ${i("transX")}*${i("transX")};\n                ${r("transY_2")}  = ${i("transY")}*${i("transY")};\n                ${r("halfWidth")}  = ${i("vHalfWidth")};\n                \n                ${r("dist")}  = abs(${i("vRadius")} - length(${e.vec2(a)}(${i("transX")}, ${i("transY")})));\n                ${r("value")}  = dist/halfWidth;\n                \n            toDiscard = value > 1.0;\n        \n                `;var a},ComputeDiscard:function(t,n){return"\n                return toDiscard;  \n                "},ProcessFinalColor:function(t,n){const e=t.variableHandler,i=n=>t.getVarying(n);return`\n                ${e.dereference(n[0])} = ${e.vec4(r)}(${i("vInstanceColor")}.xyz, ${i("vInstanceColor")}.w*alpha);\n                `;var r}}};return{ArcEllipse:g,ArcEllipsePattern:{uID:"PDSFXArcEllipsePattern",get_pdsfx_uniforms:function(){return Object.assign({},p)},get_pdsfx_varyings:function(){return Object.assign({},l,c,h)},VS_global:function(t){const n=t.variableHandler,e=(t,e=0)=>n.floatG(t,e);return`\n                ${e("fartheringAlpha")} ;\n                ${r="viewTr",n.vec3G(r)} ;\n                ${e("halfWidth")} ;\n                ${e("ratio")} ;\n                ${(t=>n.vec2G(t))("myViewPos")} ;\n                ${i(t)}\n                ${a(t)}\n            `;var r},FS_global:function(t){const n=t.variableHandler;return`\n\t\t\t${r(t)}\n\t\t\t${s(t)}\n\t\t\t${e="toDiscard",n.boolG(e)} ;\n\t\t\t${((t,e=0)=>n.floatG(t,e))("alpha")} ;\n            `;var e},VS_ov:{ComputeCommonValues:g.VS_ov.ComputeCommonValues,ProcessViewTangentSpace:g.VS_ov.ProcessViewTangentSpace,ComputeVaryingValues:function(t){const n=t.variableHandler,e=n=>t.getVarying(n),i=(t,e=0)=>n.float(t,e);return`\n                ${r="viewCenterPos",n.vec2(r)}  = viewTr.xy + instancePosition.xy;\n                ${e("vRadiiAndHWidth")} = ${(t=>n.vec3(t))()}(instanceRadiiAndWidth.xy, halfWidth);\n                ${e("transX")} = myViewPos.x - viewCenterPos.x;\n                ${e("transY")} = myViewPos.y - viewCenterPos.y;\n                ${e("vInstanceColor")} = instanceColor;\n                ${e("vInstanceColor")}.w *= fartheringAlpha;\n                \n                ${i("totalAngle")}  = instanceOffsetAndAngles.z;\n                ${i("startAngle")}  = instanceOffsetAndAngles.w;\n                \n                ${e("vStartAngle")} = startAngle;\n                ${e("vEndAngle")} = startAngle+totalAngle;\n                \n                ${e("vIntegralFirstTerm")} = integralFirstTerms;\n                ${e("patternOffset")} = instancePatternOffset;\n                `;var r}},FS_ov:{ComputeCommonValues:function(t){const n=t.variableHandler,e=t.functionHandler,i=t.userDefines,r=n=>t.getVarying(n),a=(t,e=0)=>n.float(t,e),s=t=>n.vec2(t),l=t=>n.vec4(t);return`\n                alpha = 1.0;\n                ${a("a")} = ${r("vRadiiAndHWidth")}.x;\n                ${a("b")} = ${r("vRadiiAndHWidth")}.y;\n                ${a("a2")} = a*a;\n                ${a("b2")} = b*b;\n                ${a("halfWidth")}  = ${r("vRadiiAndHWidth")}.z;\n                \n                ${a("startAngle")}  = ${r("vStartAngle")};\n                ${a("endAngle")}  = ${r("vEndAngle")};\n                if (b > a) {\t\n                    ${a("totalAngle")}  = endAngle - startAngle;\n                    startAngle += PI_2;\n                    if (startAngle >= PI2) {\n                        startAngle -= PI2;\n                    }\n                    endAngle = startAngle + totalAngle;\n                }\n                ${c="results",n.vec3(c)} ;\n                ${(t=>n.bool(t))("inEllipse")}  = ${r("transX")}*${r("transX")}/(a*a) + ${r("transY")}*${r("transY")}/(b*b) < 1.0;\n                ${i.CONSIDER_ARC?`\n                    if (inEllipse) {\n                        results = ${e.cF("distanceToArc","v3",[e.prmF("startAngle"),e.prmF("endAngle"),e.prmF("a"),e.prmF("b"),e.prmV2(`${s()}(${r("transX")}, ${r("transY")})`),e.prmF("halfWidth")])};\n                    } else {\n                        results = ${e.cF("distanceToEllipse","v3",[e.prmF("startAngle"),e.prmF("endAngle"),e.prmF("a"),e.prmF("b"),e.prmV2(`${s()}(${r("transX")}, ${r("transY")})`),e.prmF("halfWidth")])};\n                    }\n                    `:`\n                    results = ${e.cF("distanceToEllipse","v3",[e.prmF("startAngle"),e.prmF("endAngle"),e.prmF("a"),e.prmF("b"),e.prmV2(`${s()}(${r("transX")}, ${r("transY")})`),e.prmF("halfWidth")])};\n                    `}\n                \n                ${a("dist")}  = results.x;\n                ${a("value")}  = dist/halfWidth;\n                \n            toDiscard = value > 1.0;\n        \n                \n                //PATTERNS: method cf http://www.les-mathematiques.net/phorum/file.php?4,file=43185,filename=longueur-arc-ellipse.pdf\t\t\t\t\t\t\t\n                //excentricity squared\n                ${a("e2")}  = (1.0 - a2/b2);\n                if (a > b ) {\n                    e2 = (1.0 - b2/a2);\n                }\n                ${a("e4")}  = e2*e2;\n                ${a("e6")}  = e4*e2;\n                ${a("e8")}  = e4*e4;\n                ${l("excentricities")}  = ${l()}(e2, e4, e6, e8);\n                ${l("taylorCoeffsTimesOtherCoeffs")}  =  ${l()}(-0.25, -0.00390625, -0.0003255208333333333, -0.000012715657552083334);\n                ${s("ptOnEllipse")}  = results.yz;\t\t\t\t\n                ${a("_cos")}  = ptOnEllipse.x/a;\n                ${a("_sin")}  = ptOnEllipse.y/b;\n                if (b > a) {\n                    _cos = -ptOnEllipse.y/b;\n                    _sin = ptOnEllipse.x/a;\n                }\t\t\t\t\t\t\t\n                                \n                ${a("currAngle")}  = ${e.cF("computeClampedAngle","f",[e.prmF("_cos"),e.prmF("_sin")])};\n                \n                ${a("angle2")}  = 2.0*currAngle;\n                ${a("sin_angle2")}  = sin(angle2);\n                ${a("angle4")}  = 4.0*currAngle;\n                ${a("sin_angle4")}  = sin(angle4);\n                ${a("angle6")}  = 6.0*currAngle;\n                ${a("sin_angle6")}  = sin(angle6);\n                ${a("angle8")}  = 8.0*currAngle;\n                ${a("sin_angle8")}  = sin(angle8);\n                ${l("integralSecondTerm")}  = ${l()}(\n                      currAngle + _sin*_cos,\n                      12.0*currAngle + 8.0*sin_angle2 + sin_angle4,\n                      60.0*currAngle + 45.0*sin_angle2 + 9.0*sin_angle4 + sin_angle6,\n                      840.0*currAngle + 672.0*sin_angle2 + 168.0*sin_angle4 + 32.0*sin_angle6 + 3.0*sin_angle8\n                );\n                \n                ${a("curvAbs")}  = currAngle - startAngle \n                                +  excentricities.x*taylorCoeffsTimesOtherCoeffs.x*(${r("vIntegralFirstTerm")}.x + integralSecondTerm.x) \n                                +  excentricities.y*taylorCoeffsTimesOtherCoeffs.y*(${r("vIntegralFirstTerm")}.y + integralSecondTerm.y) \n                                +  excentricities.z*taylorCoeffsTimesOtherCoeffs.z*(${r("vIntegralFirstTerm")}.z + integralSecondTerm.z) \n                                +  excentricities.w*taylorCoeffsTimesOtherCoeffs.w*(${r("vIntegralFirstTerm")}.w + integralSecondTerm.w); \n                                            \n                curvAbs *= max(a,b);\t\n                curvAbs += ${r("patternOffset")};\n                \n                ${a("vPatternSize")}  = ${(n=>t.getUniform(n))("patternArray")}[${i.PATTERN_SIZE}-1].x;\n                \n                ${o(t)}\n                `;var c},ComputeDiscard:function(t){return"\n                return toDiscard;\n                "},ProcessFinalColor:function(t,n){const e=t.variableHandler,i=n=>t.getVarying(n);return`\n                ${e.dereference(n[0])} = ${e.vec4(r)}(${i("vInstanceColor")}.xyz, ${i("vInstanceColor")}.w*alpha); \n                `;var r}}},ArcCircle:$,ArcCircleFill:{uID:"PDSFXArcCircleFill",get_pdsfx_uniforms:function(){return Object.assign({},f)},get_pdsfx_varyings:function(){return Object.assign({},l,{vRadius:{type:"f"}})},VS_global:function(t,n){const e=t.variableHandler,i=(t,n=0)=>e.floatG(t,n);return`\n\t\t\t${i("fartheringAlpha")} ;\n\t\t\t${r="viewTr",e.vec3G(r)} ;\n\t\t\t${i("radius")} ;\n\t\t\t${i("ratio")} ;\n\t\t\t${(t=>e.vec2G(t))("myViewPos")} ;\n\t\t\t${a(t)}\n            `;var r},FS_global:function(t,n){const e=t.variableHandler;return`\n\t\t\t${i="toDiscard",e.boolG(i)} ;\n\t\t\t${((t,n=0)=>e.floatG(t,n))("alpha")} ;\t\n            `;var i},VS_ov:{ComputeCommonValues:function(t,n){const e=t.variableHandler,i=t.functionHandler,r=t=>e.mat4(t);return`\n                ${r("PM")}  = ${t.vGetProjectionMatrix()};\n                fartheringAlpha = 1.0;\n                //symmetric camera\n                ${((t,n=0)=>e.float(t,n))("cameraTop")}  = 1.0/PM[1][1];\n                ratio = ${a="cst",t.getUniform(a)}/cameraTop;\n                radius = instanceRadiiAndAngles.x;\n                ${i.cF("clampToOnePixelSize",null,[i.prmRefGF("radius")])};\t\n                ${r("viewM")}  = ${t.vGetViewMatrix()};\t\t\t\t\n                viewTr = ${(t=>e.vec3(t))()}(viewM[3][0], viewM[3][1], viewM[3][2]);\n                `;var a},ProcessViewTangentSpace:function(t,e){const i=t.variableHandler,r=(t,n=0)=>i.float(t,n),a=t=>i.vec2(t),s=t=>i.vec3(t),o=i.dereference(e[0]);return`\n                ${a("_localPosition")} ;\n                ${r("totalAngle")}  = instanceRadiiAndAngles.y;\n                ${r("startAngle")}  = instanceRadiiAndAngles.z;\n                ${s("infos")}  = ${t.vGetAttribPosition()};\n                ${r("notCenter")}  = infos.x;\n                ${r("frac")}  = infos.y;\n                ${r("currAngle")}  = frac*totalAngle + startAngle;\n                ${r("cosCurr")}  = cos(currAngle);\n                ${r("sinCurr")}  = sin(currAngle);\n                ${r("coeff")}  = cos(totalAngle/12.0);\n                //number of pixels of the half width of the circle\n                ${r("nbPixels")}  = radius*ratio;\n                ${n(t)}\n                if (notCenter > 0.0) {\n                    _localPosition = (radius+tolerance)*${a()}(cosCurr, sinCurr)/coeff;\t\n                }else {\n                    _localPosition = ${a()}(0.0, 0.0);\n                }\t\n                \n                ${s("mvPosition")}  = viewTr + ${s()}( _localPosition+instancePosition.xy, instancePosition.z);\n                myViewPos = mvPosition.xy;\n                ${o}.Position = mvPosition;\n                `},ComputeVaryingValues:function(t,n){const e=t.variableHandler,i=n=>t.getVarying(n);return`\n                ${r="viewCenterPos",e.vec2(r)}  = viewTr.xy + instancePosition.xy;\t\t\t\t\t\t\t\n                ${i("transX")} = myViewPos.x - viewCenterPos.x;\n                ${i("transY")} = myViewPos.y - viewCenterPos.y;\t\t\t\t\n                ${i("vRadius")} = radius;\n                ${i("vInstanceColor")} = instanceColor;\n                ${i("vInstanceColor")}.w *= fartheringAlpha;\n                `;var r}},FS_ov:{ComputeCommonValues:function(t,n){const e=t.variableHandler,i=n=>t.getVarying(n),r=(t,n=0)=>e.float(t,n);return`\n                alpha = 1.0;\n                ${r("transX_2")}  = ${i("transX")}*${i("transX")};\n                ${r("transY_2")}  = ${i("transY")}*${i("transY")};\n                \n                ${r("normPoint")}  = length(${e.vec2(a)}(${i("transX")}, ${i("transY")}));\n                ${r("value")}  = normPoint/${i("vRadius")};\n                \n                \n            toDiscard = value > 1.0;\n        \t\n                `;var a},ComputeDiscard:function(t,n){return"\n                return toDiscard;\n                "},ProcessFinalColor:function(t,n){const e=t.variableHandler,i=n=>t.getVarying(n);return` \n                ${e.dereference(n[0])} = ${e.vec4(r)}(${i("vInstanceColor")}.xyz, ${i("vInstanceColor")}.w*alpha);\n                `;var r}}},ArcCirclePattern:{uID:"PDSFXArcCirclePattern",get_pdsfx_uniforms:function(){return Object.assign({},p)},get_pdsfx_varyings:function(){return Object.assign({},l,d,u)},VS_global:function(t,n){const e=t.variableHandler,i=(t,n=0)=>e.floatG(t,n);return`\n\t\t\t${i("fartheringAlpha")} ;\n\t\t\t${r="viewTr",e.vec3G(r)} ;\n\t\t\t${i("halfWidth")} ;\n\t\t\t${i("ratio")} ;\n\t\t\t${(t=>e.vec2G(t))("myViewPos")} ;\n\t\t\t${a(t)}\n            `;var r},FS_global:function(t,n){const i=t.variableHandler,r=(t,n=0)=>i.floatG(t,n);return`\n\t\t\t${r("PI")}  = 3.1415926535897932384;\n\t\t\t${r("PI2")} = 6.283185307179586;\n\t\t\t${r("PI_2")} = 1.5707963267948966;\t\t\t\n\t\t\t${e(t)}\n\t\t\t${s(t)}\n\t\t\t${a="toDiscard",i.boolG(a)} ;\n\t\t\t${r("alpha")} ;\n            `;var a},VS_ov:{ComputeCommonValues:$.VS_ov.ComputeCommonValues,ProcessViewTangentSpace:$.VS_ov.ProcessViewTangentSpace,ComputeVaryingValues:function(t,n){const e=t.variableHandler,i=n=>t.getVarying(n);return`\n                ${r="viewCenterPos",e.vec2(r)}  = viewTr.xy + instancePosition.xy;\t\t\t\t\t\t\t\n                ${i("transX")} = myViewPos.x - viewCenterPos.x;\n                ${i("transY")} = myViewPos.y - viewCenterPos.y;\t\t\t\t\n                ${i("vRadius")} = instanceRadiiAndAngles.x;\n                ${i("vHalfWidth")} = halfWidth;\n                ${i("vInstanceColor")} = instanceColor;\n                ${i("vInstanceColor")}.w *= fartheringAlpha;\n                ${((t,n=0)=>e.float(t,n))("startAngle")}  = instanceRadiiAndAngles.w;\n                \n                ${i("vStartAngle")} = startAngle;\n                ${i("vPatternOffset")} = instancePatternOffset;\n                `;var r}},FS_ov:{ComputeCommonValues:function(t,n){const e=t.variableHandler,i=t.functionHandler,r=t.userDefines,a=n=>t.getVarying(n),s=(t,n=0)=>e.float(t,n),l=t=>e.vec2(t);return`\n                alpha = 1.0;\n                ${s("transX_2")}  = ${a("transX")}*${a("transX")};\n                ${s("transY_2")}  = ${a("transY")}*${a("transY")};\n                ${s("halfWidth")}  = ${a("vHalfWidth")};\n                \n                ${s("dist")}  = abs(${a("vRadius")} - length(${l()}(${a("transX")}, ${a("transY")})));\n                ${s("value")}  = dist/halfWidth;\n                \n            toDiscard = value > 1.0;\n        \n                \n                //PATTERNS\n                ${l("normal")}  = normalize(${l()}(${a("transX")}, ${a("transY")}));\n                ${s("_cos")}  = normal.x;\n                ${s("_sin")}  = normal.y;\n                \n                ${s("currAngle")}  = ${i.cF("computeClampedAngle","f",[i.prmF("_cos"),i.prmF("_sin")])};\n                ${s("vPatternSize")}  = ${c="patternArray",t.getUniform(c)}[${r.PATTERN_SIZE}-1].x;\n                ${s("patternOffset")}  = ${a("vPatternOffset")};\n                ${s("curvAbs")}  = patternOffset + (currAngle - ${a("vStartAngle")})*${a("vRadius")};\n                \n                ${o(t)}\n                `;var c},ComputeDiscard:function(t,n){return"\n                return toDiscard; \n                "},ProcessFinalColor:function(t,n){const e=t.variableHandler,i=n=>t.getVarying(n);return`\n                ${e.dereference(n[0])} = ${e.vec4(r)}(${i("vInstanceColor")}.xyz, ${i("vInstanceColor")}.w*alpha);\n                `;var r}}}}})),define("SVGLoader/InstancedArcsShaders",["DS/SVGLoader/InstancedArcsShaders","DS/DSMigration/DSMigration"],(function(t,n){return n.deprecateModule("SVGLoader/InstancedArcsShaders"),t})),define("DS/SVGLoader/PolygonRenderer",["DS/Visualization/PolygonTessellator"],(function(t){"use strict";return t})),define("DS/SVGLoader/SVGRenderableStrokePolygonSet",["DS/Visualization/ThreeJS_DS","DS/SVGLoader/SVGRenderable","DS/Visualization/SceneGraphFactory","DS/Visualization/Node3D","DS/Mesh/MeshUtils","DS/SVGLoader/SVGMeshMaterial","DS/SVGLoader/SVGLineMaterial","DS/SVGLoader/PolygonRenderer"],(function(t,n,e,i,r,a,s,o){"use strict";return n.extend({init:function(t,n){this._parent(!1,n),this.gas=t,this.zIndex=this.context.computeZIndex(this.gas),this.polygonRenderer=new o},startNewPolygon:function(){this.polygonRenderer._startNewPolygon()},addPointToCurrentPolygon:function(t,n,e){this.polygonRenderer.addPointToCurrentPolygonLoop(t,n,{dashOffset:e})},closePolygon:function(){this.polygonRenderer.closeCurrentPolygonLoop()},endPolygonGroup:function(){this.polygonRenderer.endCurrentPolygon()},createNode3D:function(t){var n,e=new i;if(this.gas.attributes.strokeColor&&(n=this.createStrokeNode3D(t))&&e.addChild(n),this.gas.attributes.fillColor){var r=new a({color:this.gas.attributes.fillColor,force:!0,viewBox:t}),s=this.context.getZFromZIndex(this.zIndex);(n=this.polygonRenderer.createNode3D(r,s))&&e.addChild(n)}return e},createStrokeNode3D:function(n){var i=this.polygonRenderer;if(!i.polygons.length)return null;var a,s,o=this.gas.attributes.dashValue,l={color:this.gas.attributes.strokeColor,lineWidth:this.gas.attributes.strokeWidth,force:!0};if(this.gas.attributes.lineCap&&(l.linecap=this.gas.attributes.lineCap),this.gas.attributes.lineJoin&&(l.linejoin=this.gas.attributes.lineJoin),this.gas.attributes.miterLimit&&(l.miterLimit=this.gas.attributes.miterLimit),o){for(a=new Float32Array(o.length),s=0;s<o.length;s++)a[s]=o[s];l.dashPattern=a}var c,d,u,h,f=new t.SVGLineMaterial(l),p=[];for(h=this.context.getZFromZIndex(this.zIndex),d=0;d<i.polygons.length;d++)for(u=i.polygons[d].points,c=0;c<u.length;c+=2)p.push(new t.Vector3(u[c],-u[c+1],h));var g,$,m,S=[],v=0,x=[];for(d=0;d<i.polygons.length;d++){for($=v,g=(u=i.polygons[d].points).length/2,m=0;m<g-1;m++)S.push(v),S.push(v+1),0===m?x.push(i.polygons[d].userData.dashOffset):x.push(0),x.push(0),v++;i.polygons[d].closed&&(S.push(v),S.push($),x.push(0),x.push(0)),v++}var y=e.createLineNode({points:p,idx:S,patternOffsets:x,material:f,drawMode:r.ConnectivityTypeEnum.LINES});return y.setSSAO(!1),y.setFrustumCulled(!1),y}})})),define("DS/SVGLoader/Instanced2DArcEllipsePattern",["DS/Visualization/ThreeJS_DS","DS/Visualization/Node3D","DS/Visualization/Mesh3D","DS/Mesh/MeshUtils","DS/SVGLoader/InstancedArcsShaders","DS/SVGLoader/InstancedArcsUtils"],(function(t,n,e,i,r,a){"use strict";var s=n.extend({init:function(n){this._parent(n.name),this._name=n.name;for(var i,s=n.nbInstances||1,o=function(t,n){return{0:-n,1:.5*(-n-Math.sin(n)*Math.cos(n)),2:.03125*(-12*n-8*Math.sin(2*n)-Math.sin(4*n)),3:1/192*(-60*n-45*Math.sin(2*n)-9*Math.sin(4*n)-Math.sin(6*n)),4:(-840*n-672*Math.sin(2*n)-168*Math.sin(4*n)-32*Math.sin(6*n)-3*Math.sin(8*n))/3072}[t]},l={},c=0;c<s;c++){var d,u=n.xRadii[c],h=n.yRadii[c],f=.5*n.lineWidths[c],p=[];i=0;for(var g=0;g<n.patterns[c].length;g++)i+=n.patterns[c][g],p[g]=i;var $=f>h*h/u||f>u*u/h?1:0;l[p]&&l[p][$]?d=l[p][$]:(d={considerArc:$,nbInstances:0,pattern:p,bbox:null,positions:[],colors:[],radiiHalfWidth:[],patternOffsets:[],integralFirstTerms:[],offsets_and_angles:[],createMesh3D:function(){var t={data:this.positions,type:"v3",isFlattened:!0,attribName:"instancePosition"},n={data:this.colors,type:"v4",isFlattened:!0,attribName:"instanceColor"},i={data:this.radiiHalfWidth,type:"v3",isFlattened:!0,attribName:"instanceRadiiAndWidth"},s={data:this.patternOffsets,type:"f",isFlattened:!0,attribName:"instancePatternOffset"},o={data:this.integralFirstTerms,type:"v4",isFlattened:!0,attribName:"integralFirstTerms"},l={data:this.offsets_and_angles,type:"v4",isFlattened:!0,attribName:"instanceOffsetAndAngles"},c=a.createMaterial(r.ArcEllipsePattern,this.considerArc,this.pattern),d=a.createArcLoopMesh(c),u=new e(d,null);return u.setMaterial(c),u.setInstancingParameters(this.nbInstances,[t,n,i,s,o,l],"instance"),u.forceBoundingBox(this.bbox),u.setShadow(!1),u.setFrustumCulled(!1),u.setSSAO(!1),u}},l[p]||(l[p]=[null,null]),l[p][$]=d),d.nbInstances++;var m=a.computeArcBBox(new t.Vector3(n.positions[3*c],n.positions[3*c+1],n.positions[3*c+2]),u,h,n.startAngles[c],n.totalAngles[c],n.offsets[c],n.lineWidths[c]);d.bbox?d.bbox.mergeWithBox(m):d.bbox=m,d.positions.push(n.positions[3*c]),d.positions.push(n.positions[3*c+1]),d.positions.push(n.positions[3*c+2]),d.colors.push(n.colors[4*c]),d.colors.push(n.colors[4*c+1]),d.colors.push(n.colors[4*c+2]),d.colors.push(n.colors[4*c+3]),d.radiiHalfWidth.push(u),d.radiiHalfWidth.push(h),d.radiiHalfWidth.push(f),d.patternOffsets.push(n.patternOffsets[c]);var S=u>h?n.startAngles[c]:n.startAngles[c]+.5*Math.PI;d.integralFirstTerms.push(o(1,S)),d.integralFirstTerms.push(o(2,S)),d.integralFirstTerms.push(o(3,S)),d.integralFirstTerms.push(o(4,S)),d.offsets_and_angles.push(Math.cos(n.offsets[c])),d.offsets_and_angles.push(Math.sin(n.offsets[c])),d.offsets_and_angles.push(n.totalAngles[c]),d.offsets_and_angles.push(n.startAngles[c])}for(var v in l)l[v][0]&&this.addChild(l[v][0].createMesh3D()),l[v][1]&&this.addChild(l[v][1].createMesh3D());return this},setName:function(t){this._name=t},getNodeType:function(){return"Node3D"}});return UWA.namespace("THREEDS/Nodes/Instanced2DArcEllipsePattern",s)})),define("SVGLoader/Instanced2DArcEllipsePattern",["DS/SVGLoader/Instanced2DArcEllipsePattern","DS/DSMigration/DSMigration"],(function(t,n){return n.deprecateModule("SVGLoader/Instanced2DArcEllipsePattern"),t})),define("DS/SVGLoader/Instanced2DArcCirclePattern",["DS/Visualization/ThreeJS_DS","DS/Visualization/Node3D","DS/Visualization/Mesh3D","DS/Mesh/MeshUtils","DS/SVGLoader/InstancedArcsShaders","DS/SVGLoader/InstancedArcsUtils"],(function(t,n,e,i,r,a){"use strict";var s=n.extend({init:function(n){this._parent(n.name),this._name=n.name;for(var i,s=n.nbInstances||1,o={},l=0;l<s;l++){var c,d=[];i=0;for(var u=0;u<n.patterns[l].length;u++)i+=n.patterns[l][u],d[u]=i;o[d]?c=o[d]:(c={nbInstances:0,pattern:d,bbox:null,positions:[],colors:[],radiiHalfWidthAngles:[],patternOffsets:[],createMesh3D:function(){var t={data:this.positions,type:"v3",isFlattened:!0,attribName:"instancePosition"},n={data:this.colors,type:"v4",isFlattened:!0,attribName:"instanceColor"},i={data:this.radiiHalfWidthAngles,type:"v4",isFlattened:!0,attribName:"instanceRadiiAndAngles"},s={data:this.patternOffsets,type:"f",isFlattened:!0,attribName:"instancePatternOffset"},o=a.createMaterial(r.ArcCirclePattern,null,this.pattern),l=a.createArcLoopMesh(o),c=new e(l,null);return c.setMaterial(o),c.setInstancingParameters(this.nbInstances,[t,n,i,s],"instance"),c.forceBoundingBox(this.bbox),c.setShadow(!1),c.setFrustumCulled(!1),c.setSSAO(!1),c}},o[d]=c),c.nbInstances++;var h=a.computeArcBBox(new t.Vector3(n.positions[3*l],n.positions[3*l+1],n.positions[3*l+2]),n.radii[l],n.radii[l],n.startAngles[l],n.totalAngles[l],0,n.lineWidths[l]);c.bbox?c.bbox.mergeWithBox(h):c.bbox=h,c.positions.push(n.positions[3*l]),c.positions.push(n.positions[3*l+1]),c.positions.push(n.positions[3*l+2]),c.colors.push(n.colors[4*l]),c.colors.push(n.colors[4*l+1]),c.colors.push(n.colors[4*l+2]),c.colors.push(n.colors[4*l+3]),c.radiiHalfWidthAngles.push(n.radii[l]),c.radiiHalfWidthAngles.push(.5*n.lineWidths[l]),c.radiiHalfWidthAngles.push(n.totalAngles[l]),c.radiiHalfWidthAngles.push(n.startAngles[l]),c.patternOffsets.push(n.patternOffsets[l])}for(var f in o)this.addChild(o[f].createMesh3D());return this},setName:function(t){this._name=t},getNodeType:function(){return"Node3D"}});return UWA.namespace("THREEDS/Nodes/Instanced2DArcCirclePattern",s)})),define("SVGLoader/Instanced2DArcCirclePattern",["DS/SVGLoader/Instanced2DArcCirclePattern","DS/DSMigration/DSMigration"],(function(t,n){return n.deprecateModule("SVGLoader/Instanced2DArcCirclePattern"),t})),define("DS/SVGLoader/Instanced2DArcCircle",["DS/Visualization/ThreeJS_DS","DS/Visualization/Node3D","DS/Visualization/Mesh3D","DS/Mesh/MeshUtils","DS/SVGLoader/InstancedArcsShaders","DS/SVGLoader/InstancedArcsUtils"],(function(t,n,e,i,r,a){"use strict";var s=e.extend({init:function(n){this._name=n.name;var e=a.createMaterial(r.ArcCircle,!1,null),i=n.nbInstances||1,s=a.createArcLoopMesh(e);this._parent(s,n.name),this.setShadow(!1),this.setFrustumCulled(!1);for(var o,l=n.positions,c={data:l,type:"v3",isFlattened:!0,attribName:"instancePosition"},d=new t.Box3,u=0;u<i;u++)o=a.computeArcBBox(new t.Vector3(l[3*u],l[3*u+1],l[3*u+2]),n.radii[u],n.radii[u],n.startAngles[u],n.totalAngles[u],0,n.lineWidths[u]),d.mergeWithBox(o);for(var h={data:n.colors,type:"v4",isFlattened:!0,attribName:"instanceColor"},f=[],p=0;p<i;p++){var g=.5*n.lineWidths[p],$=n.radii[p];f.push($),f.push(g),f.push(n.totalAngles[p]),f.push(n.startAngles[p])}var m={data:f,type:"v4",isFlattened:!0,attribName:"instanceRadiiAndAngles"};return this.setMaterial(e),this.setInstancingParameters(i,[c,m,h],"instance"),this.forceBoundingBox(d),this.setSSAO(!1),this},setName:function(t){this._name=t},getNodeType:function(){return"Mesh3D"},setRatio:function(t){console.warn("setRatio is not supported for Instanced2DArcCircle")},setBillboardData:function(t,n,e){console.warn("setBillboardData is not supported for Instanced2DArcCircle")},setFixedSizeCameraName:function(t){console.warn("setFixedSizeCameraName is not supported for Instanced2DArcCircle")},setFixedSizeCenter:function(t){console.warn("setFixedSizeCenter is not supported for Instanced2DArcCircle")}});return UWA.namespace("THREEDS/Nodes/Instanced2DArcCircle",s)})),define("SVGLoader/Instanced2DArcCircle",["DS/SVGLoader/Instanced2DArcCircle","DS/DSMigration/DSMigration"],(function(t,n){return n.deprecateModule("SVGLoader/Instanced2DArcCircle"),t})),define("DS/SVGLoader/Instanced2DArcCircleFill",["DS/Visualization/ThreeJS_DS","DS/Visualization/Node3D","DS/Visualization/Mesh3D","DS/Mesh/MeshUtils","DS/SVGLoader/InstancedArcsShaders","DS/SVGLoader/InstancedArcsUtils"],(function(t,n,e,i,r,a){"use strict";var s=e.extend({init:function(n){this._name=n.name;var e=a.createMaterial(r.ArcCircleFill,!1,null),i=n.nbInstances||1,s=a.createArcFillMesh(e);this._parent(s,n.name),this.setShadow(!1),this.setFrustumCulled(!1);for(var o,l=n.positions,c={data:l,type:"v3",isFlattened:!0,attribName:"instancePosition"},d=new t.Box3,u=0;u<i;u++)o=a.computeArcFillBBox(new t.Vector3(l[3*u],l[3*u+1],l[3*u+2]),n.radii[u],n.radii[u],n.startAngles[u],n.totalAngles[u],0),d.mergeWithBox(o);for(var h={data:n.colors,type:"v4",isFlattened:!0,attribName:"instanceColor"},f=[],p=0;p<i;p++){var g=n.radii[p];f.push(g),f.push(n.totalAngles[p]),f.push(n.startAngles[p])}var $={data:f,type:"v3",isFlattened:!0,attribName:"instanceRadiiAndAngles"};return this.setMaterial(e),this.setInstancingParameters(i,[c,$,h],"mesh"),this.forceBoundingBox(d),this.setSSAO(!1),this},setName:function(t){this._name=t},getNodeType:function(){return"Mesh3D"},setRatio:function(t){console.warn("setRatio is not supported for Instanced2DArcCircleFill")},setBillboardData:function(t,n,e){console.warn("setBillboardData is not supported for Instanced2DArcCircleFill")},setFixedSizeCameraName:function(t){console.warn("setFixedSizeCameraName is not supported for Instanced2DArcCircleFill")},setFixedSizeCenter:function(t){console.warn("setFixedSizeCenter is not supported for Instanced2DArcCircleFill")}});return UWA.namespace("THREEDS/Nodes/Instanced2DArcCircleFill",s)})),define("SVGLoader/Instanced2DArcCircleFill",["DS/SVGLoader/Instanced2DArcCircleFill","DS/DSMigration/DSMigration"],(function(t,n){return n.deprecateModule("SVGLoader/Instanced2DArcCircleFill"),t})),define("DS/SVGLoader/Instanced2DArcEllipse",["DS/Visualization/ThreeJS_DS","DS/Visualization/Node3D","DS/Visualization/Mesh3D","DS/Mesh/MeshUtils","DS/SVGLoader/InstancedArcsShaders","DS/SVGLoader/InstancedArcsUtils"],(function(t,n,e,i,r,a){"use strict";var s=n.extend({init:function(n){this._parent(n.name),this._name=n.name;for(var i=n.nbInstances||1,s={},o=0;o<i;o++){var l,c=n.xRadii[o],d=n.yRadii[o],u=.5*n.lineWidths[o],h=c*c,f=u*u,p=d*d,g=(Math.cos(n.startAngles[o]),Math.cos(n.startAngles[o]+n.totalAngles[o]),Math.sin(n.startAngles[o]),Math.sin(n.startAngles[o]+n.totalAngles[o]),c>d?Math.sqrt((f-p)/(p-h)):Math.sqrt((f-h)/(h-p)),u>d*d/c||u>c*c/d?1:0);s[g]?l=s[g]:(l={considerArc:g,nbInstances:0,bbox:null,positions:[],colors:[],radiiHalfWidth:[],offsets_and_angles:[],createMesh3D:function(){var t={data:this.positions,type:"v3",isFlattened:!0,attribName:"instancePosition"},n={data:this.colors,type:"v4",isFlattened:!0,attribName:"instanceColor"},i={data:this.radiiHalfWidth,type:"v3",isFlattened:!0,attribName:"instanceRadiiAndWidth"},s={data:this.offsets_and_angles,type:"v4",isFlattened:!0,attribName:"instanceOffsetAndAngles"},o=a.createMaterial(r.ArcEllipse,this.considerArc,null),l=a.createArcLoopMesh(o),c=new e(l,null);return c.setMaterial(o),c.setInstancingParameters(this.nbInstances,[t,n,i,s],"instance"),c.forceBoundingBox(this.bbox),c.setShadow(!1),c.setFrustumCulled(!1),c.setSSAO(!1),c}},s[g]=l),l.nbInstances++;var $=a.computeArcBBox(new t.Vector3(n.positions[3*o],n.positions[3*o+1],n.positions[3*o+2]),c,d,n.startAngles[o],n.totalAngles[o],n.offsets[o],n.lineWidths[o]);l.bbox?l.bbox.mergeWithBox($):l.bbox=$,l.positions.push(n.positions[3*o]),l.positions.push(n.positions[3*o+1]),l.positions.push(n.positions[3*o+2]),l.colors.push(n.colors[4*o]),l.colors.push(n.colors[4*o+1]),l.colors.push(n.colors[4*o+2]),l.colors.push(n.colors[4*o+3]),l.radiiHalfWidth.push(c),l.radiiHalfWidth.push(d),l.radiiHalfWidth.push(u),l.offsets_and_angles.push(Math.cos(n.offsets[o])),l.offsets_and_angles.push(Math.sin(n.offsets[o])),l.offsets_and_angles.push(n.totalAngles[o]),l.offsets_and_angles.push(n.startAngles[o])}for(var m in s)s[m]&&this.addChild(s[m].createMesh3D());return this},setName:function(t){this._name=t},getNodeType:function(){return"Node3D"}});return UWA.namespace("THREEDS/Nodes/Instanced2DArcEllipse",s)})),define("SVGLoader/Instanced2DArcEllipse",["DS/SVGLoader/Instanced2DArcEllipse","DS/DSMigration/DSMigration"],(function(t,n){return n.deprecateModule("SVGLoader/Instanced2DArcEllipse"),t})),define("DS/SVGLoader/SVGRenderableStrokeArcSet",["DS/SVGLoader/SVGRenderable","DS/Visualization/ThreeJS_DS","DS/SVGLoader/Instanced2DArcEllipse","DS/SVGLoader/Instanced2DArcCircle","DS/Visualization/Node3D","DS/Visualization/SceneGraphFactory","DS/SVGLoader/Instanced2DArcEllipsePattern","DS/SVGLoader/Instanced2DArcCirclePattern"],(function(t,n,e,i,r,a,s,o){"use strict";return t.extend({init:function(t,n){this._parent(!1,n),this.arcDataArray=[],this.activatePatterns=t},isEmpty:function(){return!this.arcDataArray.length},addArcData:function(t){t&&t.gas&&t.gas.getStrokeColor()&&(t.zIndex=this.context.computeZIndex(t.gas),this.arcDataArray.push(t))},createNode3D:function(t){if(!this.arcDataArray.length)return null;var n,a,l,c,d,u,h,f,p={totalAngles:[],startAngles:[],positions:[],xRadii:[],yRadii:[],offsets:[],lineWidths:[],colors:[],patterns:this.activatePatterns?[]:null,patternOffsets:this.activatePatterns?[]:null,nbInstances:0},g={totalAngles:[],startAngles:[],positions:[],radii:[],offsets:[],lineWidths:[],colors:[],patterns:this.activatePatterns?[]:null,patternOffsets:this.activatePatterns?[]:null,nbInstances:0};for(n=0;n<this.arcDataArray.length;n++)(l=this.arcDataArray[n])&&(l.xRadius===l.yRadius?(g.radii.push(l.xRadius),a=g):(p.xRadii.push(l.xRadius),p.yRadii.push(l.yRadius),a=p),a.totalAngles.push(l.totalAngle),a.startAngles.push(l.startAngle),a.positions.push(l.position.x),a.positions.push(l.position.y),a.positions.push(this.context.getZFromZIndex(l.zIndex)),a.offsets.push(l.offset),a.lineWidths.push(l.gas.getStrokeLineWidth()),c=l.gas.getStrokeColor(),a.colors.push(c.r),a.colors.push(c.g),a.colors.push(c.b),this.activatePatterns&&(d=this.computeDashData(l),a.patterns.push(d.dashArray),a.patternOffsets.push(d.dashOffset)),a.colors.push(1),a.nbInstances++);return(p.nbInstances||g.nbInstances)&&(f=new r),p.nbInstances&&(u=this.activatePatterns?new s(p):new e(p),f.addChild(u)),g.nbInstances&&(h=this.activatePatterns?new o(g):new i(g),f.addChild(h)),f},computeDashData:function(t){var n;if(t.invert){var e,i=t.gas.getDashArray(),r=[];for(e=0;e<i.length;e++)r.push(i[i.length-e-1]);r.splice(0,0,r[r.length-1]),r.pop();var a=0;for(e=0;e<r.length;e++)a+=r[e];n={dashArray:r,dashOffset:a-(t.length+t.dashOffset-r[0])%a}}else n={dashArray:t.gas.getDashArray(),dashOffset:t.dashOffset};return n}})})),define("DS/SVGLoader/SVGNode_unknown",["DS/SVGLoader/SVGNode_abstract"],(function(t){"use strict";return t.extend({init:function(t){this._parent(t),this.unknown=!0,console.log("SVGLoader: unknown node '"+this.node.nodeName+"'")}})})),define("DS/SVGLoader/SVGRenderableFilledCircleSet",["DS/SVGLoader/SVGRenderable","DS/Visualization/ThreeJS_DS","DS/SVGLoader/Instanced2DArcCircleFill"],(function(t,n,e){"use strict";return t.extend({init:function(t){this._parent(!1,t),this.circleDataArray=[]},isEmpty:function(){return!this.circleDataArray},addFilledCircle:function(t,n,e,i){var r=this.context.computeZIndex(i);this.circleDataArray.push({cx:t,cy:n,r:e,gas:i,zIndex:r})},createNode3D:function(t){if(!this.circleDataArray.length)return null;var n,i,r,a,s={totalAngles:[],startAngles:[],positions:[],radii:[],colors:[],nbInstances:0};for(n=0;n<this.circleDataArray.length;n++)i=this.circleDataArray[n],s.totalAngles.push(2*Math.PI),s.startAngles.push(0),s.positions.push(i.cx),s.positions.push(-i.cy),s.positions.push(this.context.getZFromZIndex(i.zIndex)),s.radii.push(i.r),r=i.gas.getFillColor(),s.colors.push(r.r),s.colors.push(r.g),s.colors.push(r.b),s.colors.push(1),s.nbInstances++;return s.nbInstances>0&&(a=new e(s)),a}})})),define("DS/SVGLoader/SVGNode_image",["DS/SVGLoader/SVGNode_abstract","DS/SVGLoader/SVGLoaderUtils","DS/Visualization/ThreeJS_DS"],(function(t,n,e){"use strict";return t.extend({init:function(t){this._parent(t)},fillRenderableBank:function(t,n){var e,i,r,a,s=this.node.getAttributeNS("http://www.w3.org/1999/xlink","href");s&&s.startsWith("data:")&&(e=parseFloat(this.node.getAttribute("x")),i=parseFloat(this.node.getAttribute("y")),r=parseFloat(this.node.getAttribute("width")),a=parseFloat(this.node.getAttribute("height")),t.getImageRenderable(e,i,r,a,s))}})})),define("DS/SVGLoader/SVGRenderableImage",["DS/SVGLoader/SVGRenderable","DS/Visualization/ThreeJS_DS","DS/Visualization/Node3D","DS/Visualization/SceneGraphFactory","DS/SVGLoader/SVGMeshMaterial"],(function(t,n,e,i,r){"use strict";return t.extend({init:function(t,e,i,r,a,s,o){this._parent(!0,o),this.isImageReady=!1,this.x=t,this.y=e,this.width=i,this.height=r,this.zIndex=this.context.computeZIndex(null);var l=this;this.texture=n.ImageUtils.loadTexture(a,void 0,(function(){l.isImageReady=!0,s(l)}),(function(){l.isImageReady=!0,l.texture=null,s(l)}),void 0,!0)},createNode3D:function(t){if(!this.isImageReady||!this.texture)return null;var e=new r({map:this.texture,force:!0,transparent:!0,viewBox:t}),a=i.createRectangleNode({width:this.width,height:this.height,fill:!0,noEdge:!0,fillColor:null,material:e}),s=new n.Matrix4,o=new n.Vector3(this.x,-this.y-this.height,this.context.getZFromZIndex(this.zIndex));return s.setPosition(o),a.setMatrix(s),a.setSSAO(!1),a}})})),define("DS/SVGLoader/SVGNode_ellipse",["DS/SVGLoader/SVGNode_abstract","DS/Visualization/ThreeJS_DS","DS/SVGLoader/SVGLoaderUtils","DS/SVGLoader/SVGRenderableStrokeArcSet"],(function(t,n,e,i){"use strict";return t.extend({init:function(t){this._parent(t)},fillRenderableBank:function(t,i){var r=i.buildChildGas(this.node),a=t.getStrokeArcSetRenderable(r),s=parseFloat(this.node.getAttributeNS(null,"cx")),o=parseFloat(this.node.getAttributeNS(null,"cy")),l=parseFloat(this.node.getAttributeNS(null,"rx")),c=parseFloat(this.node.getAttributeNS(null,"ry")),d=this.node.getAttributeNS(null,"transform"),u=d?e.parseTransformation(d):{matrix:new n.Matrix3,angle:0},h=u.matrix,f=u.angle,p=new n.Vector3(s,o,1);p.applyMatrix3(h),r.getStrokeColor()&&a.addArcData({xRadius:l,yRadius:c,totalAngle:2*Math.PI,startAngle:0,position:new n.Vector2(p.x,-p.y),offset:-f,gas:r})}})})),define("DS/SVGLoader/SVGGas",["UWA/Class","DS/SVGLoader/SVGLoaderUtils"],(function(t,n){"use strict";window.linecaps=[],window.linejoins=[],window.miterLimits=[];var e=t.extend({init:function(t){var n;if(this.attributes={strokeWidth:1},t)for(n in t.attributes)this.attributes[n]=t.attributes[n]},setFromSVGNode:function(t){var e=t.getAttributeNS(null,"stroke");e&&("none"!==e?this.attributes.strokeColor=n.parseColor(e):delete this.attributes.strokeColor);var i=t.getAttributeNS(null,"fill");i&&"none"!==i&&(this.attributes.fillColor=n.parseColor(i));var r=t.getAttributeNS(null,"stroke-width");r&&(this.attributes.strokeWidth=parseFloat(r));var a,s,o=t.getAttributeNS(null,"stroke-dasharray");o&&(a=n.parseDashArray(o),this.attributes.dash=a.key,(s=a.value).length%2!=0&&(s=s.concat(s)),this.attributes.dashValue=s);var l=t.getAttributeNS(null,"stroke-linejoin");l&&(this.attributes.lineJoin=l);var c=t.getAttributeNS(null,"stroke-linecap");c&&(this.attributes.lineCap=c);var d=t.getAttributeNS(null,"stroke-miterlimit");d&&(this.attributes.miterLimit=parseFloat(d))},getStrokeLineWidth:function(){return this.attributes.strokeWidth},getStrokeColor:function(){return this.attributes.strokeColor},getFillColor:function(){return this.attributes.fillColor},getDashArray:function(){return this.attributes.dashValue},getLineCap:function(){return this.attributes.lineCap},getLineJoin:function(){return this.attributes.lineJoin},getMiterLimit:function(){return this.attributes.miterLimit},buildChildGas:function(t){var n=new e(this);return n.setFromSVGNode(t),n},isValid:function(){return!isNaN(this.attributes.strokeWidth)&&!(!this.attributes.fillColor&&!this.attributes.strokeColor)},isZCompatibleWithGas:function(t){return this.hasSameColorAs(t,"strokeColor")&&this.hasSameColorAs(t,"fillColor")},hasSameColorAs:function(t,n){var e=this.attributes[n],i=t.attributes[n];return!e&&!i||!(!e||!i)&&e.equals(i)}});return e})),define("DS/SVGLoader/SVGRenderableBank",["UWA/Class","DS/SVGLoader/SVGRenderableStrokePolygonSet","DS/SVGLoader/SVGRenderableStrokeArcSet","DS/SVGLoader/MultiIndexTable","DS/SVGLoader/SVGRenderableImage","DS/SVGLoader/SVGRenderableContext","DS/SVGLoader/SVGRenderableFilledCircleSet"],(function(t,n,e,i,r,a,s){"use strict";return t.extend({init:function(){this.polygonSetRenderableTable=new i(["strokeWidth","strokeColor","fillColor","dash","lineCap","lineJoin","miterLimit"],["strokeWidth","strokeColor"]),this.arcSetRenderable=null,this.arcSetWithPatternRenderable=null,this.filledCircleSetRenderable=null,this.imageRenderables=[],this.nbImagesToLoad=0,this.destinationNode=null,this.onEnded=null,this.context=new a},setOnEndedCB:function(t){this.onEnded=t},hasImagesToLoad:function(){return this.nbImagesToLoad>0},getStrokePolygonSetRenderable:function(t){t.attributes.strokeWidth;var e=this.context;return this.polygonSetRenderableTable.getElement(t.attributes,(function(){return new n(t,e)}))},getStrokeArcSetRenderable:function(t){return t.attributes.dash?(this.arcSetWithPatternRenderable||(this.arcSetWithPatternRenderable=new e(!0,this.context)),this.arcSetWithPatternRenderable):(this.arcSetRenderable||(this.arcSetRenderable=new e(!1,this.context)),this.arcSetRenderable)},getFilledCircleSetRenderable:function(t){return this.filledCircleSetRenderable||(this.filledCircleSetRenderable=new s(this.context)),this.filledCircleSetRenderable},getImageRenderable:function(t,n,e,i,a){this.nbImagesToLoad++;var s=new r(t,n,e,i,a,this.onImageLoaded.bind(this),this.context);return this.imageRenderables.push(s),s},onImageLoaded:function(t,n){var e=t.createNode3D(this.viewBox);e&&this.destinationNode.addChild(e),this.nbImagesToLoad--,!this.nbImagesToLoad&&this.onEnded&&this.onEnded()},buildNodes:function(t,n,e){this.viewBox=n;var i,r,a=this.polygonSetRenderableTable.exportToArray();for(this.arcSetRenderable&&a.push(this.arcSetRenderable),this.arcSetWithPatternRenderable&&a.push(this.arcSetWithPatternRenderable),this.filledCircleSetRenderable&&a.push(this.filledCircleSetRenderable),i=0;i<a.length;i++)(r=a[i].createNode3D(n))&&(e&&r.exludeFromBounding(!0),t.addChild(r));this.destinationNode=t}})})),define("DS/SVGLoader/SVGNode_g",["DS/SVGLoader/SVGNode_abstract"],(function(t){"use strict";return t.extend({init:function(t){this._parent(t)}})})),define("DS/SVGLoader/SVGNode_svg",["DS/SVGLoader/SVGNode_abstract","DS/Visualization/Node3D","DS/SVGLoader/SVGRenderableBank","DS/SVGLoader/SVGGas","DS/Visualization/ThreeJS_DS","DS/Visualization/SceneGraphFactory","DS/Mesh/Mesh","DS/SVGLoader/SVGLoaderUtils"],(function(t,n,e,i,r,a,s,o){"use strict";return t.extend({init:function(t){this._parent(t)},buildNode3D:function(t,r){var a,s,o,l,c,d=this.getViewBox(),u=new n,h=1;function f(){0===--h&&r&&r()}for(s=0;s<this.children.length;s++)(o=this.children[s]).buildNode3D?(h++,a=o.buildNode3D(t+1,f),s>0&&a.setVisibility(!1),u.addChild(a)):(l||(c=new i,l=new e),o.fillRenderableBank(l,c));var p=u;if(l){0===t&&(p=new n,u.addChild(p));var g=null;if(d){u.getBoundingSphere();g=this.buildBgNode(d,l.context.getBgZ())}l.buildNodes(p,d,!!g),g&&p.addChild(g),l.hasImagesToLoad()&&(l.setOnEndedCB(f),h++)}return f(),u},buildBgNode:function(t,n){var e=new r.Color(16777215),i=this.node.style&&this.node.style.background;i&&(i=function(t){var n=t.indexOf("rgb");if(-1===n)return t;var e=t.substring(n),i=e.indexOf(")");if(-1===i)return t;return e=e.substring(0,i+1)}(i),e=o.parseColor(i));var s=new r.MeshBasicMaterial({color:e,force:!0}),l=a.createRectangleNode({width:t.width,height:t.height,fill:!0,material:s}),c=new r.Matrix4,d=new r.Vector3(t.x,t.y,n);return c.setPosition(d),l.setMatrix(c),l.setSSAO(!1),l},buildMaskNode:function(t,n){},getViewBox:function(){var t=this.node.getAttributeNS(null,"viewBox");if(!t)return null;var n=t.split(" "),e={x:parseFloat(n[0]),y:parseFloat(n[1]),width:parseFloat(n[2]),height:parseFloat(n[3])};return{x:e.x,y:-e.y-e.height,width:e.width,height:e.height}}})})),define("DS/SVGLoader/SVGNode_path",["DS/SVGLoader/SVGNode_abstract","DS/SVGLoader/SVGLoaderUtils","DS/SVGLoader/SVGRenderableStrokePolygonSet","DS/SVGLoader/SVGRenderableStrokeArcSet","DS/Visualization/ThreeJS_DS"],(function(t,n,e,i,r){"use strict";var a=["M","m","A","a","L","l","Z","z"];function s(t,n,e,i){var r=Math.sqrt(t*t+n*n),a=Math.sqrt(e*e+i*i),s=Math.acos((t*e+n*i)/(r*a));return t*i-n*e<0&&(s*=-1),s}function o(t){if(0===t)return 1;var n,e=1,i=1;for(n=1;n<=t;n++)e*=n,i*=2;var r=e*i;n=0;var a=1;if(t>2)for(n=0;n<=t-2;n++)a*=2*n+1;return-a/r}function l(t,n,e){return{0:e-n,1:.5*(e+Math.sin(e)*Math.cos(e)-n-Math.sin(n)*Math.cos(n)),2:.03125*(12*e+8*Math.sin(2*e)+Math.sin(4*e)-12*n-8*Math.sin(2*n)-Math.sin(4*n)),3:1/192*(60*e+45*Math.sin(2*e)+9*Math.sin(4*e)+Math.sin(6*e)-60*n-45*Math.sin(2*n)-9*Math.sin(4*n)-Math.sin(6*n)),4:(840*e+672*Math.sin(2*e)+168*Math.sin(4*e)+32*Math.sin(6*e)+3*Math.sin(8*e)-840*n-672*Math.sin(2*n)-168*Math.sin(4*n)-32*Math.sin(6*n)-3*Math.sin(8*n))/3072}[t]}return t.extend({init:function(t){this._parent(t)},fillRenderableBank:function(t,e){var i,r,s,o,l,c=e.buildChildGas(this.node),d=t.getStrokePolygonSetRenderable(c),u=t.getStrokeArcSetRenderable(c),h=this.node.getAttributeNS(null,"d"),f=n.parseCommands(h,a),p=0,g=0,$=!1,m=!1,S=null,v=0;for(s=0;s<f.length;s++)switch((o=f[s])[0]){case"M":d.startNewPolygon(),v=0,S=[p=o[1],g=o[2]],d.addPointToCurrentPolygon(p,g,v);break;case"m":d.startNewPolygon(),v=0,S=[p+=o[1],g+=o[2]],d.addPointToCurrentPolygon(p,g,v);break;case"A":if(0===o[1]||0===o[2]){p=o[6],g=o[7],d.addPointToCurrentPolygon(p,g,v);break}$||($=!0,m=!0),i=o[6],r=o[7],(l=this.buildArcData(p,g,i,r,o[1],o[2],o[3],o[4],o[5],c))&&(l.dashOffset=v),u.addArcData(l),l&&(v+=l.length),p=i,g=r,d.startNewPolygon(),d.addPointToCurrentPolygon(p,g,v);break;case"a":if(0===o[1]||0===o[2]){p+=o[6],g+=o[7],d.addPointToCurrentPolygon(p,g,v);break}$||($=!0,m=!0),i=p+o[6],r=g+o[7],(l=this.buildArcData(p,g,i,r,o[1],o[2],o[3],o[4],o[5],c))&&(l.dashOffset=v),u.addArcData(l),l&&(v+=l.length),p=i,g=r,$=!0,m=!0,d.startNewPolygon(),d.addPointToCurrentPolygon(p,g,v);break;case"L":i=o[1],r=o[2],d.addPointToCurrentPolygon(i,r,v),v+=Math.sqrt((i-p)*(i-p)+(r-g)*(r-g)),p=i,g=r;break;case"l":i=p+o[1],r=g+o[2],d.addPointToCurrentPolygon(i,r,v),v+=Math.sqrt((i-p)*(i-p)+(r-g)*(r-g)),p=i,g=r;break;case"z":case"Z":$?(d.addPointToCurrentPolygon(S[0],S[1],v),d.startNewPolygon()):d.closePolygon(),$=!1,v=0}if(m&&c.attributes.fillColor)throw new Error("broken filled polygon!!");d.startNewPolygon(),d.endPolygonGroup()},buildArcData:function(t,n,e,i,r,a,o,l,c,d){if(o=Math.PI*o/180,t===e&&n===i)return null;var u=l?1:0,h=c?1:0,f=(t-e)/2,p=(n-i)/2,g=Math.cos(o)*f+Math.sin(o)*p,$=-Math.sin(o)*f+Math.cos(o)*p,m=g*g/((r=Math.abs(r))*r)+$*$/((a=Math.abs(a))*a);m>1&&(r*=1.001*Math.sqrt(m),a*=1.001*Math.sqrt(m));var S=Math.sqrt((r*r*a*a-r*r*$*$-a*a*g*g)/(r*r*$*$+a*a*g*g));u===h&&(S*=-1);var v=S*r*$/a,x=-S*a*g/r,y=Math.cos(o)*v-Math.sin(o)*x+(t+e)/2,A=Math.sin(o)*v+Math.cos(o)*x+(n+i)/2,b=(g-v)/r,D=($-x)/a,_=(-g-v)/r,P=(-$-x)/a,C=s(1,0,b,D),V=s(b,D,_,P)%(2*Math.PI);return 0===h&&V>0&&(V-=2*Math.PI),1===h&&V<0&&(V+=2*Math.PI),this.buildArcDataFinal(y,A,r,a,C,V,o,d)},buildArcDataFinal:function(t,n,e,i,a,s,o,l){e===i&&(a+=o,o=0),a*=-1;var c=!1;(s*=-1)<0&&(a+=s,s*=-1,c=!0);var d={totalAngle:s,startAngle:a=function(t){var n=t%(2*Math.PI);n<0&&(n+=2*Math.PI);return n}(a),position:new r.Vector2(t,-n),xRadius:e,yRadius:i,offset:-o,gas:l,invert:c};return d.length=this.computeArcLength(d),d},computeArcLength:function(t){if(!t)return 0;var n=t.startAngle+t.offset,e=n+t.totalAngle,i=function(t,n,e,i,r){var a,s,c,d;t>n?(d=1-n*n/(t*t),a=t,n,s=e,c=i):(d=1-t*t/(n*n),a=n,t,s=e+.5*Math.PI,c=i+.5*Math.PI);for(var u=0,h=0;h<=r;h++)u+=Math.pow(d,h)*o(h)*l(h,s,c);return a*u}(t.xRadius,t.yRadius,n,e,4);return i}})})),define("DS/SVGLoader/SVGNode_circle",["DS/SVGLoader/SVGNode_abstract","DS/SVGLoader/SVGLoaderUtils","DS/Visualization/ThreeJS_DS"],(function(t,n,e){"use strict";return t.extend({init:function(t){this._parent(t)},fillRenderableBank:function(t,n){var i=n.buildChildGas(this.node),r=t.getStrokeArcSetRenderable(i),a=parseFloat(this.node.getAttributeNS(null,"cx")),s=parseFloat(this.node.getAttributeNS(null,"cy")),o=parseFloat(this.node.getAttributeNS(null,"r")),l=t.getFilledCircleSetRenderable(i);i.getFillColor()&&l.addFilledCircle(a,s,o,i),i.getStrokeColor()&&r.addArcData({xRadius:o,yRadius:o,totalAngle:2*Math.PI,startAngle:0,position:new e.Vector2(a,-s),offset:0,gas:i})}})})),define("DS/SVGLoader/SVGNodeTreeBuilder",["UWA/Class","DS/SVGLoader/SVGNode_svg","DS/SVGLoader/SVGNode_g","DS/SVGLoader/SVGNode_circle","DS/SVGLoader/SVGNode_ellipse","DS/SVGLoader/SVGNode_unknown","DS/SVGLoader/SVGNode_path","DS/SVGLoader/SVGNode_image"],(function(t,n,e,i,r,a,s,o){"use strict";var l={svg:n,g:e,circle:i,ellipse:r,path:s,image:o};return t.extend({init:function(t){this.svgRoot=t},buildTree:function(){return this.buildNodeTree(this.svgRoot)},buildNodeTree:function(t){var n,e,i=new(l[t.nodeName]||a)(t);for(n=0;n<t.childNodes.length;n++)1===t.childNodes[n].nodeType&&(e=this.buildNodeTree(t.childNodes[n]),i.children.push(e));return i}})})),define("DS/SVGLoader/SVGToNode3D",["UWA/Class","DS/SVGLoader/SVGNodeTreeBuilder"],(function(t,n){"use strict";return t.extend({init:function(t){this.svgRootElement=t},buildNode3D:function(t){return new n(this.svgRootElement).buildTree().buildNode3D(0,t)}})})),define("DS/SVGLoader/SVGNode",["DS/Visualization/ThreeJS_DS","DS/Visualization/Node3D","DS/Mesh/MeshUtils","DS/SVGLoader/SVGToNode3D","DS/Visualization/GetSVGMode"],(function(t,n,e,i,r){"use strict";return n.extend({init:function(t,n){this._parent(n);var e=new i(t).buildNode3D();this.addChild(e)}})})),define("DS/SVGLoader/SVGLoader",["UWA/Class","DS/SVGLoader/SVGToNode3D"],(function(t,n){"use strict";return t.extend({init:function(t){t=t||{},this.renderCB=t.renderCB,this.onProgressCB=t.onProgressCB,this.onLoadedCB=t.onLoadedCB,this.onErrorCB=t.onErrorCB},load:function(t,e){var i=this.onLoadedCB,r=new XMLHttpRequest;r.onload=function(){var t,a,s=new DOMParser,o=r.response,l=s.parseFromString(o,"image/svg+xml"),c=l.rootElement;if(!c)for(t=0;t<l.childNodes.length&&!c;t++)1===(a=l.childNodes[t]).nodeType&&"svg"===a.nodeName&&(c=a);if(c){var d=new n(c);e.addChild(d.buildNode3D((()=>{i&&setTimeout(i,0)})))}else this.onErrorCB&&this.onErrorCB()};var a=t.serverurl+t.filename;r.open("GET",a,!0),r.send(null)}})}));