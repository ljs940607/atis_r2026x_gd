define("DS/WAfrHandlers/mod_Handler",[],(function(){"use strict";function e(e,t){if(!e)throw new Error("clients must be defined");if(void 0===t)throw new Error("value must be defined.");for(const n in e)e[n](t)}let t=Object.create(null);return t.Handler=class{constructor(e){if(this._private||(this._private=Object.create(null)),this._private._currentAvailability=!0,this._private._isEnabled=!0,this._private._isEnabledChangeClients={},this._private._isEnabledNextClientUid=0,!e)throw new Error("Missing parameters. Please see the Handler documentation to see the required parameters.");if(!e.id)throw new Error("Missing parameter. id has to be defined.");this._private._id=e.id,e.i18n&&(this._private._i18n=e.i18n),e.accelerator&&(this._private._accelerator=e.accelerator)}getAccelerator(){return this._private._accelerator}getId(){return this._private._id}setI18n(e){if(!(e&&e.title&&e.shortHelpImage&&e.shortHelpImage.uri&&e.longHelpImage&&e.longHelpImage.uri))throw new Error("One or many parameters are missing.");e&&(this._private._i18n=e)}getI18n(){return this._private._i18n}beingInitialized(){let e=!1;return this.getHandlerComponent()&&(e=!0),e}getHandlerComponent(){throw new Error("getHandlerComponent has to be implemented on subclasses.")}onAvailabilityChanged(){throw new Error("onAvailabilityChanged has to be implemented on subclasses")}onAvailabilityEvent(e){if(!e||"function"!=typeof e)throw new Error("cb has to be a function",e);const t=this.getHandlerComponent();if(!t)throw new Error("There is no HandlerComponent related to this Handler",this);const n=t.getEventChannel();if(!n)throw new Error("Retrieved eventChannel is undefined");const r=this.getId();if(!r)throw new Error("handlerIdentifier has to be a non empty string.");return n.subscribe({event:r+"/AVAILABILITY"},e)}removeAvailabilityEventSubscription(e){if(void 0===e)throw new Error("token has to be defined");const t=this.getHandlerComponent();if(!t)throw new Error("There is no HandlerComponent related to this Handler",this);const n=t.getEventChannel();if(!n)throw new Error("Retrieved eventChannel is undefined");if(!this.getId())throw new Error("handlerIdentifier has to be a non empty string.");return n.unsubscribe(e)}isAvailable(){return this._private._currentAvailability}isEnabled(){return this._private._isEnabled}disable(){this._private._isEnabled&&(this._private._isEnabled=!1,e(this._private._isEnabledChangeClients,!1))}enable(){this._private._isEnabled||(this._private._isEnabled=!0,e(this._private._isEnabledChangeClients,!0))}isExecutable(){return this.isAvailable()&&this.isEnabled()}onIsEnabledChangeEvent(e){if(!e||"function"!=typeof e)throw new TypeError("cb must be a function.");const t=this._private._isEnabledNextClientUid++;return this._private._isEnabledChangeClients[t]=e,t}removeIsEnabledChangeEventSubscription(e){const t=this._private._isEnabledChangeClients;if(!t.hasOwnProperty(e))throw new Error("No element registered with this token",e);delete t[e]}onIconChanged(){throw new Error("onIconChanged has to be implemented on subclasses")}destroy(){this._private._isEnabledChangeClients&&delete this._private._isEnabledChangeClients}},t})),define("DS/WAfrHandlers/private/private_Utilities",[],(function(){"use strict";let e=Object.create(null);return e.enums=Object.create(null),e.enums.HandlerType={},e.executeHandlerFunctions=[],e.registerLeafHandler=function(t,n){const r=e.enums.HandlerType;if(r.hasOwnProperty(t))throw new Error("There already are a handler registered using the same handlerId",t);if(!n||!n.executeFunc)throw new Error("Missing parameters");let a=-1;for(let e in r)r.hasOwnProperty(e)&&(a=a>r[e]?a:r[e]);++a,r[t]=a,e.executeHandlerFunctions[a]=n.executeFunc},e.publishHandlerAvailability=function(e){const t=e.getHandlerComponent();if(!t)throw new Error("There is no HandlerComponent related to this Handler",e);const n=t.getEventChannel();if(!n)throw new Error("Retrieved eventChannel is undefined");const r=e.getId();if(!r)throw new Error("handlerIdentfier has to be a non empty string.");setTimeout((function(){n.publish({event:r+"/AVAILABILITY",data:{newValue:e.isAvailable()}})}),0)},e.computeArgs=function(e,t){const n=e.getArgs();if(t&&n)for(let e in n)n.hasOwnProperty(e)&&!t.hasOwnProperty(e)&&(t[e]=n[e]);else n&&(t=n);return t},e})),define("DS/WAfrHandlers/private/private_CheckHandlerUtilities",["DS/CoreUtilities/ErrorManagement","DS/WAfrHandlers/private/private_Utilities"],(function(e,t){"use strict";let n=Object.create(null);return n.executeCheckHandler=function(n,r){if(!n)throw new Error("checkHandler has to be defined and cannot be null");const a=n.getHandlerComponent();if(!a)throw new Error("handlerComponent must be defined.");if(!a.getExecutionContext())throw new Error("Execution Context not found.");if(!r||void 0===r.action||"boolean"!=typeof r.action)throw new Error("Wrong parameters");let i=!0;(n.beingInitialized()||n._private._isChecked!==r.action)&&(n._private._isChecked=r.action,function(e){const t=e.getHandlerComponent();if(!t)throw new Error("There is no HandlerComponent related to this CheckHandler",e);const n=t.getEventChannel();if(!n)throw new Error("Retrieved eventChannel is undefined");const r=e.getId();if(!r)throw new Error("handlerIdentfier has to be a non empty string.");const a=e._private._isChecked?"/CHECK":"/UNCHECK";n.publish({event:r+a})}(n),n._private._isChecked?n._private._check&&void 0!==n._private._check._private._type&&(i=!1,t.executeHandlerFunctions[n._private._check._private._type]({handler:n._private._check,cb:r.cb,args:r.args})):n._private._uncheck&&void 0!==n._private._uncheck._private._type&&(i=!1,t.executeHandlerFunctions[n._private._uncheck._private._type]({handler:n._private._uncheck,cb:r.cb,args:r.args}))),i&&r.cb&&setTimeout((function(){const t=e.getErrorManager(),n=e.createReturnObject(t.SUCCEEDED);r.cb(n)}),0)},n})),define("DS/WAfrHandlers/mod_HandlerComponent",["DS/CoreUtilities/ErrorManagement","DS/CoreEvents/ModelEvents","DS/WAfrHandlers/private/private_Utilities","DS/WAfrUtils/mod_Performances"],(function(e,t,n,r){"use strict";var a=r.Performances,i="[DS/WAfrHandlers/mod_HandlerComponent]",o=Object.create(null);function s(t){if(!(this&&this.resolve&&this.reject&&t))throw new Error;e.hasSucceeded(t)?this.resolve(t):this.reject(t)}o.DEFAULT_COMPONENT_NAME="AFR_HandlerComponent";var d=Object.create(null);function l(e,t,n){if(!(e&&t&&n&&e._private.hasOwnProperty(t)))throw new Error;const r=e._private[t],a=n.getId();if(!r||!a)throw new Error;if(!n.setHandlerComponent(e))throw new Error;r[a]=n}function c(e,t,n){if(!(e&&t&&n&&e._private.hasOwnProperty(t)))throw new Error;const r=e._private[t],a=n.getId();if(!r||!a)throw new Error;if(!n.setHandlerComponent(null))throw new Error;delete r[a]}function h(){return Promise.resolve()}function p(e,t){const n=e._perf.start([i,"cleanUpHandlers"].join(" ")),r=d.HandlerMap;for(var a in r)if(r.hasOwnProperty(a)){const n=r[a],i=e._private[n];for(let e in i)i.hasOwnProperty(e)&&i[e].destroy();delete e._private[n],t&&(e._private[n]={})}e._perf.stop(n)}function u(e,t){let n={};if(void 0!==t&&e&&e._private&&e._private._hdlrMap){const a=e._private._hdlrMap;for(var r in a)if(a.hasOwnProperty(r)){const i=a[r]._private._type;e.hasHandler(r)&&i===t&&(n[r]=e._private._hdlrMap[r])}}return n}d.HandlerMap={HANDLER:"_hdlrMap",CHECK_HANDLER:"_chkHdlrMap",RADIO_HANDLER:"_radioHdlrMap"};class m{constructor(){this._perf=new a,this._private={};var e=d.HandlerMap;for(var n in e)if(e.hasOwnProperty(n)){var r=e[n];this._private[r]={}}this._private._eventChannel=new t}getExposedComponentCtor(){const e=this;function t(){}return t.prototype.initialize=h,t.prototype.clean=h,t.prototype.destroy=h,t.prototype.hasHandler=e.hasHandler.bind(e),t.prototype.executeHandler=e.executeHandler.bind(e),t.prototype.hasCheckHandler=e.hasCheckHandler.bind(e),t.prototype.toggleCheck=e.toggleCheck.bind(e),t.prototype.setCheckState=e.setCheckState.bind(e),t.prototype.getCheckState=e.getCheckState.bind(e),t.prototype.hasRadioHandler=e.hasRadioHandler.bind(e),t.prototype.toggleRadioItemState=e.toggleRadioItemState.bind(e),t.prototype.setRadioItemState=e.setRadioItemState.bind(e),t.prototype.getRadioItemState=e.getRadioItemState.bind(e),t.prototype.enableHandler=e.enableHandler.bind(e),t.prototype.disableHandler=e.disableHandler.bind(e),t.prototype.isHandlerExecutable=e.isHandlerExecutable.bind(e),t.prototype.enableCheck=e.enableCheck.bind(e),t.prototype.disableCheck=e.disableCheck.bind(e),t.prototype.isCheckExecutable=e.isCheckExecutable.bind(e),t.prototype.enableRadio=e.enableRadio.bind(e),t.prototype.disableRadio=e.disableRadio.bind(e),t.prototype.isRadioExecutable=e.isRadioExecutable.bind(e),t}initialize(){return Promise.resolve()}async configure(){const e={ActionHandler:"executeHandler",CommandHandler:"executeHandler",CheckHandler:"setCheckState",RadioHandler:"setRadioItemState"},t=this._private._initializationData||[];for(let n=0;n<t.length;++n){const r=t[n],a=e[r.type];try{r&&void 0!==r.wait&&!0!==r.wait?this[a](r):await this[a](r)}catch(e){if(!e||!e.getError||"NOT_EXECUTABLE"!==e.getReturnValue().internalValue)throw e}}return function(e){if(!e)throw new Error("handlerComponent has to be defined");const t=e._perf,n=t.start([i,"manageDefaultCommand"].join(" ")),r=e._private._defaultCommandIdentifier;return new Promise((function(a,i){if(r){const o=e.getExecutionContext();o?require(["DS/WAfrCommandsArchitecture/mod_CommandsManagerComponent"],(function(s){const d=o.getComponent(s.CommandsManagerComponent.DEFAULT_COMPONENT_NAME);d?(d.subscribeOnceToCmdState(r,"begin",(function(){return t.stop(n),a()})),d.setDefaultCommand(r),delete e._private._defaultCommandIdentifier):(t.stop(n),i(new Error("No commandsManagerComponent found using this executionContext",o)))}),(function(){t.stop(n),i(new Error("Require failed (DS/WAfrCommandsArchitecture/mod_CommandsManagerComponent)"))})):(t.stop(n),i(new Error("executionContext is undefined")))}else t.stop(n),a()}))}(this)}async configureHandlerbyId(e){if(!this._private._initializationData){const t=this._private._initializationData.indexOf(e);if(-1!=t){await this.configureHandler(this._private._initializationData[t]);const e={ActionHandler:"executeHandler",CommandHandler:"executeHandler",CheckHandler:"setCheckState",RadioHandler:"setRadioItemState"},n=this._private._initializationData[t],r=e[n.type];try{n&&void 0!==n.wait&&!0!==n.wait?this[r](n):await this[r](n)}catch(e){if(!e||!e.getError||"NOT_EXECUTABLE"!==e.getReturnValue().internalValue)throw e}}}}async configureHandler(e){const t={ActionHandler:"executeHandler",CommandHandler:"executeHandler",CheckHandler:"setCheckState",RadioHandler:"setRadioItemState"}[e.type];try{e&&void 0!==e.wait&&!0!==e.wait?this[t](e):await this[t](e)}catch(e){if(!e||!e.getError||"NOT_EXECUTABLE"!==e.getReturnValue().internalValue)throw e}}clean(){return p(this,!0),this._private._eventChannel.unsubscribeAll(),this._private._availabilityModesComponent=null,this._private._defaultCommandIdentifier=void 0,Promise.resolve()}destroy(){return p(this,!1),this._private._eventChannel.destroy(),delete this._private._eventChannel,delete this._private._availabilityModesComponent,Promise.resolve()}getEventChannel(){return this._private._eventChannel}setInitializationDefaultCommand(e){if(!e||"string"!=typeof e)throw new Error("commandIdentifier has to be a string");this._private._defaultCommandIdentifier=e}setInitializationData(e){if(!Array.isArray(e))throw new Error("data has to be an array");this._private._initializationData=e}addInitializationData(e){if(!Array.isArray(e))throw new Error("data has to be an array");this._private._initializationData?this._private._initializationData=this._private._initializationData.concat(e):this._private._initializationData=e}setAvailabilityModesComponent(e){if(void 0===e)throw new Error("component has to be defined");if(null!==e&&this._private._availabilityModesComponent)throw new Error("There is already one AvailabilityModesComponent attached to this HandlerComponent");this._private._availabilityModesComponent=e}getAvailabilityModesComponent(){return this._private._availabilityModesComponent}hasHandler(e){return Object.hasOwn(this._private._hdlrMap,e)}addHandler(e){l(this,d.HandlerMap.HANDLER,e)}removeHandler(e){c(this,d.HandlerMap.HANDLER,e)}hasCheckHandler(e){return Object.hasOwn(this._private._chkHdlrMap,e)}addCheckHandler(e){l(this,d.HandlerMap.CHECK_HANDLER,e)}removeCheckHandler(e){c(this,d.HandlerMap.CHECK_HANDLER,e)}hasRadioHandler(e){return Object.hasOwn(this._private._radioHdlrMap,e)}addRadioHandler(e){l(this,d.HandlerMap.RADIO_HANDLER,e)}removeRadioHandler(e){c(this,d.HandlerMap.RADIO_HANDLER,e)}executeHandler(t){if(t&&t.cb)throw new Error;const n=this;return new Promise((function(r,a){var i=e.getErrorManager();t||a(e.createReturnObject(i.MISSING_PARAMETERS,{description:"parameters has to be defined"}));const o=t.id;o&&"string"==typeof o||a(e.createReturnObject(i.MISSING_PARAMETERS,{description:"parameters.id has to be defined"})),n.hasHandler(o)?n._private._hdlrMap[o].execute({cb:s.bind({resolve:r,reject:a}),args:t.args}):a(e.createReturnObject(i.FAILED,{description:"No Handler corresponding to the following id: "+o}))}))}toggleCheck(t){if(t&&t.cb)throw new Error;const n=this;return new Promise((function(r,a){const i=e.getErrorManager();t||a(e.createReturnObject(i.MISSING_PARAMETERS,{description:"parameters has to be defined"}));const o=t.id,d=t.args;if(o&&"string"==typeof o||a(e.createReturnObject(i.MISSING_PARAMETERS,{description:"parameters.id has to be defined"})),n.hasCheckHandler(o)){const e=n._private._chkHdlrMap[o],t=e.getState();e.setState({state:!t,cb:s.bind({resolve:r,reject:a}),args:d})}else a(e.createReturnObject(i.FAILED,{description:"No CheckHandler corresponding to the following id: "+o}))}))}setCheckState(t){if(t&&t.cb)throw new Error;const n=this;return new Promise((function(r,a){const i=e.getErrorManager();t||a(e.createReturnObject(i.MISSING_PARAMETERS,{description:"parameters has to be defined"}));const o=t.id,d=t.state,l=t.args;o&&"string"==typeof o||a(e.createReturnObject(i.MISSING_PARAMETERS,{description:"parameters.id has to be defined"})),void 0!==d&&"boolean"==typeof d||a(new Error),n.hasCheckHandler(o)?n._private._chkHdlrMap[o].setState({state:d,cb:s.bind({resolve:r,reject:a}),args:l}):a(e.createReturnObject(i.FAILED,{description:"No CheckHandler corresponding to the following id: "+o}))}))}getCheckState(e){if(!e)throw new Error;const t=e.id;if(!t||"string"!=typeof t)throw new Error;if(!this.hasCheckHandler(t))throw new Error;return this._private._chkHdlrMap[t].getState()}toggleRadioItemState(t){if(t&&t.cb)throw new Error;const n=this;return new Promise((function(r,a){const i=e.getErrorManager();t||a(e.createReturnObject(i.MISSING_PARAMETERS,{description:"parameters has to be defined"}));const o=t.id,d=t.radioId,l=t.args;o&&"string"==typeof o||a(e.createReturnObject(i.MISSING_PARAMETERS,{description:"parameters.id has to be defined"})),d&&"string"==typeof d||a(e.createReturnObject(i.MISSING_PARAMETERS,{description:"parameters.radioId has to be defined"}));const c=n._private._radioHdlrMap;if(n.hasRadioHandler(d)){const e=!c[d].getRadioItemState(o);c[d].setRadioItemState({radioHdlrItemId:o,state:e,cb:s.bind({resolve:r,reject:a}),args:l})}else a(e.createReturnObject(i.FAILED,{description:"No item corresponding to the following id: "+d}))}))}setRadioItemState(t){if(t&&t.cb)throw new Error;const n=this;return new Promise((function(r,a){var i=e.getErrorManager();t||a(e.createReturnObject(i.MISSING_PARAMETERS,{description:"parameters has to be defined"}));const o=t.id,d=t.radioId,l=t.state,c=t.args;o&&"string"==typeof o||a(new Error),d&&"string"==typeof d||a(e.createReturnObject(i.MISSING_PARAMETERS,{description:"parameters.id has to be defined"})),void 0!==l&&"boolean"==typeof l||a(e.createReturnObject(i.MISSING_PARAMETERS,{description:"parameters.state has to be defined"}));var h=n._private._radioHdlrMap;n.hasRadioHandler(d)?h[d].setRadioItemState({radioHdlrItemId:o,state:l,cb:s.bind({resolve:r,reject:a}),args:c}):a(e.createReturnObject(i.MISSING_PARAMETERS,{description:"No CheckHandler corresponding to the following id: "+o}))}))}getRadioItemState(e){if(!e)throw new Error;const t=e.id,n=e.radioId;if(!t||"string"!=typeof t)throw new Error;if(!n||"string"!=typeof n)throw new Error;const r=this._private._radioHdlrMap;if(!this.hasRadioHandler(n))throw new Error;return r[n].getRadioItemState(t)}enableHandler(e){if(!e||"string"!=typeof e)throw new TypeError("[HandlerComponent] enableHandler - id has to be defined.");const t=this._private._hdlrMap;if(!this.hasHandler(e))throw new Error(`[HandlerComponent] enableHandler - Handler not found: ${e}`);t[e].enable()}disableHandler(e){if(!e||"string"!=typeof e)throw new TypeError("[HandlerComponent] disableHandler - id has to be defined.");const t=this._private._hdlrMap;if(!this.hasHandler(e))throw new Error(`[HandlerComponent] disableHandler - Handler not found: ${e}`);t[e].disable()}isHandlerExecutable(e){if(!e||"string"!=typeof e)throw new TypeError("[HandlerComponent] isHandlerExecutable - id has to be defined.");const t=this._private._hdlrMap;if(!this.hasHandler(e))throw new Error(`[HandlerComponent] isHandlerExecutable - Handler not found: ${e}`);return t[e].isExecutable()}enableCheck(e){if(!e||"string"!=typeof e)throw new TypeError("[HandlerComponent] enableCheck - id has to be defined.");const t=this._private._chkHdlrMap;if(!this.hasCheckHandler(e))throw new Error(`[HandlerComponent] enableCheck - Handler not found: ${e}`);t[e].enable()}disableCheck(e){if(!e||"string"!=typeof e)throw new TypeError("[HandlerComponent] disableCheck - id has to be defined.");const t=this._private._chkHdlrMap;if(!this.hasCheckHandler(e))throw new Error(`[HandlerComponent] disableCheck - Handler not found: ${e}`);t[e].disable()}isCheckExecutable(e){if(!e||"string"!=typeof e)throw new TypeError("[HandlerComponent] isCheckExecutable - id has to be defined.");const t=this._private._chkHdlrMap;if(!this.hasCheckHandler(e))throw new Error(`[HandlerComponent] isCheckExecutable - Handler not found: ${e}`);return t[e].isExecutable()}enableRadio(e){if(!e||"string"!=typeof e)throw new TypeError("[HandlerComponent] enableRadio - id has to be defined.");const t=this._private._radioHdlrMap;if(!this.hasRadioHandler(e))throw new Error(`[HandlerComponent] enableRadio - Handler not found: ${e}`);t[e].enable()}disableRadio(e){if(!e||"string"!=typeof e)throw new TypeError("[HandlerComponent] disableRadio - id has to be defined.");const t=this._private._radioHdlrMap;if(!this.hasRadioHandler(e))throw new Error(`[HandlerComponent] disableRadio - Handler not found: ${e}`);t[e].disable()}isRadioExecutable(e){if(!e||"string"!=typeof e)throw new TypeError("[HandlerComponent] isRadioExecutable - id has to be defined.");const t=this._private._radioHdlrMap;if(!this.hasRadioHandler(e))throw new Error(`[HandlerComponent] isRadioExecutable - Handler not found: ${e}`);return t[e].isExecutable()}getActionHandlerMap(){return u(this,n.enums.HandlerType.ACTION_HANDLER)}getCommandHandlerMap(){return u(this,n.enums.HandlerType.COMMAND_HANDLER)}getLeafHandlerMaps(){let e=Object.create(null);if(e.actionHandlers={},e.commandHandlers={},this._private&&this._private._hdlrMap){const r=this._private._hdlrMap;for(var t in r)if(r.hasOwnProperty(t)){const a=r[t]._private._type;a===n.enums.HandlerType.ACTION_HANDLER?e.actionHandlers[t]=r[t]:a===n.enums.HandlerType.COMMAND_HANDLER?e.commandHandlers[t]=r[t]:console.warn("Unknown LeafHandler type",r[t]._private._type)}}return e}getCheckHandlerMap(){return this._private[d.HandlerMap.CHECK_HANDLER]}getRadioHandlerMap(){return this._private[d.HandlerMap.RADIO_HANDLER]}}return m.DEFAULT_COMPONENT_NAME=o.DEFAULT_COMPONENT_NAME,o.HandlerComponent=m,o})),define("DS/WAfrHandlers/mod_LeafHandler",["DS/WAfrHandlers/mod_Handler","DS/CoreUtilities/ErrorManagement"],(function(e,t){"use strict";const n=e.Handler;class r{constructor(e,t){if(!e||!t)throw new Error("handler and manager have to be defined");this._handler=e,this._manager=t}execute(e){return this._manager.handleExecute({cb:e.cb,manageable:this._handler,args:e.args})}setHandlerComponent(){return console.warn("Impossible to set a HandlerComponent to a LeafHandler which is managed."),!1}getHandlerComponent(){return this._manager.getHandlerComponent()}onAvailabilityChanged(e,t){const n=this._handler;return this._manager.handleOnAvailabilityChanged({manageable:n,args:{newValue:e,info:t}})}isExecutable(){return this._manager.handleIsExecutable({manageable:this._handler})}disable(){throw new Error("Impossible to disable a Managed Handler")}enable(){throw new Error("Impossible to enable a Managed Handler")}onIsEnabledChangeEvent(){throw new Error("Impossible to subscribe to isEnabledChangeEvent from a Managed Handler")}removeIsEnabledChangeEventSubscription(){throw new Error("Impossible to unsubscribe to isEnabledChangeEvent from a Managed Handler")}onIconChangedEvent(){throw new Error("Impossible to subscribe to onIconChangedEvent from a Managed Handler")}removeIconChangedEventSubscription(){throw new Error("Impossible to unsubscribe to removeIconChangedEventSubscription from a Managed Handler")}onIconChanged(e,t){const n=this._handler;return this._manager.handleOnIconChanged({manageable:n,args:{newValue:e,info:t}})}onI18nChangedEvent(){throw new Error("Impossible to subscribe to onI18nChangedEvent from a Managed Handler")}removeI18nEventSubscription(){throw new Error("Impossible to unsubscribe to removeI18nEventSubscription from a Managed Handler")}}let a=Object.create(null);return a.LeafHandler=class extends n{constructor(e){if(super(e),!e)throw new Error("Missing parameters. Please see the LeafHandler documentation to see the required parameters.");e.availabilityMode&&(this._private._availabilityMode=e.availabilityMode),this._private._currentAvailability=!0,e.icon&&(e.icon.uri||e.icon.fonticon)&&(this._private._icon=e.icon)}initAvailabilityModesSubscription(){const e=this.getHandlerComponent();if(!e)throw new Error("Impossible to retrieve the HandlerComponent.");const t=e.getAvailabilityModesComponent();if(!t)throw new Error("Impossible to retrieve the AvailabilityModesComponent.");return t.subscribe(this,!0).then(function(e){this._private._availabilityModesSubscriptionToken=e}.bind(this))}destroy(){super.destroy();const e=this.getHandlerComponent();if(!e)throw new Error("Impossible to retrieve the HandlerComponent.");const t=e.getAvailabilityModesComponent();t&&t.unsubscribe(this._private._availabilityModesSubscriptionToken)}getAvailabilityModesInfo(){return{modes:this._private._availabilityMode,currentAvailability:this._private._currentAvailability}}onAvailabilityChanged(e,t){return this._private._currentAvailability=e,this._private._handlerState.onAvailabilityChanged(e,t)}getIcon(){return this._private._icon}makeManaged(e){if(this._private._handlerState instanceof r)throw new Error("Call makeManaged method on an LeafHandler which is already managed");this._private._handlerState=new r(this,e)}isExecutable(){return this._private._handlerState.isExecutable()}disable(){return this._private._handlerState.disable()}enable(){return this._private._handlerState.enable()}onIsEnabledChangeEvent(e){return this._private._handlerState.onIsEnabledChangeEvent(e)}removeIsEnabledChangeEventSubscription(e){return this._private._handlerState.removeIsEnabledChangeEventSubscription(e)}onIconChangedEvent(e){}removeIconChangedEventSubscription(e){}onI18nChangedEvent(){}removeI18nEventSubscription(){}execute(e){if(e&&"object"!=typeof e)throw new Error("parameters has to be an object if defined");if(this.isExecutable())return this._private._handlerState.execute(e);e&&e.cb?setTimeout((function(){const n=t.getErrorManager(),r=t.createReturnObject(n.NOT_EXECUTABLE,{description:"This LeafHandler is not executable"});e.cb(r)}),0):console.warn("This LeafHandler is not executable",this.getId())}setArgs(e){if("object"!=typeof e)throw new Error("args has to be an object");this._private._args=e}getArgs(){return this._private._args}},a.StandaloneLeafHandlerState=class{constructor(e){if(!e)throw new Error("handler has to be defined");this._handler=e}execute(){throw new Error("execute has to be implemented on subclasses")}setHandlerComponent(e){if(void 0===e)throw new Error("component has to be defined");return this._handler._private._handlerComponent=e,!0}getHandlerComponent(){return this._handler._private._handlerComponent}onAvailabilityChanged(e){const t=this._handler;t._private._currentAvailability=e;const n=t.getHandlerComponent();if(!n)throw new Error("There is no HandlerComponent related to this LeafHandler",t);const r=n.getEventChannel();if(!r)throw new Error("Retrieved eventChannel is undefined");const a=t.getId();if(!a)throw new Error("handlerIdentfier has to be a non empty string.");r.publish({event:a+"/AVAILABILITY",data:{newValue:e}})}isExecutable(){return n.prototype.isExecutable.call(this._handler)}disable(...e){return n.prototype.disable.call(this._handler,...e)}enable(...e){return n.prototype.enable.call(this._handler,...e)}onIsEnabledChangeEvent(...e){return n.prototype.onIsEnabledChangeEvent.call(this._handler,...e)}removeIsEnabledChangeEventSubscription(...e){return n.prototype.removeIsEnabledChangeEventSubscription.call(this._handler,...e)}onIconChangedEvent(e){if(!e||"function"!=typeof e)throw new Error("cb has to be a function",e);const t=this.getHandlerComponent();if(!t)throw new Error("There is no HandlerComponent related to this Handler",this);const n=t.getEventChannel();if(!n)throw new Error("Retrieved eventChannel is undefined");const r=this.getId();if(!r)throw new Error("handlerIdentifier has to be a non empty string.");return n.subscribe({event:r+"/ICON",data:{newValue:newValue}})}removeIconChangedEventSubscription(e){if(void 0===e)throw new Error("token has to be defined");const t=this.getHandlerComponent();if(!t)throw new Error("There is no HandlerComponent related to this Handler",this);const n=t.getEventChannel();if(!n)throw new Error("Retrieved eventChannel is undefined");if(!this.getId())throw new Error("handlerIdentifier has to be a non empty string.");return n.unsubscribe(e)}onI18nChangedEvent(e){if(!e||"function"!=typeof e)throw new Error("cb has to be a function",e);const t=this.getHandlerComponent();if(!t)throw new Error("There is no HandlerComponent related to this Handler",this);const n=t.getEventChannel();if(!n)throw new Error("Retrieved eventChannel is undefined");const r=this.getId();if(!r)throw new Error("handlerIdentifier has to be a non empty string.");return n.subscribe({event:r+"/TITLE"},e)}removeI18nEventSubscription(e){if(void 0===e)throw new Error("token has to be defined");const t=this.getHandlerComponent();if(!t)throw new Error("There is no HandlerComponent related to this Handler",this);const n=t.getEventChannel();if(!n)throw new Error("Retrieved eventChannel is undefined");if(!this.getId())throw new Error("handlerIdentifier has to be a non empty string.");return n.unsubscribe(e)}},a.ManagedLeafHandlerState=r,a})),define("DS/WAfrHandlers/private/private_RadioHandlerUtilities",["DS/CoreUtilities/ErrorManagement","DS/WAfrHandlers/private/private_CheckHandlerUtilities"],(function(e,t){"use strict";let n=Object.create(null);return n.fireEvent=function(e,t,n){if(!e||!t||void 0===n)throw new Error("radioHandler, itemIdentifier and state has to be defined");const r=e.getHandlerComponent();if(!r)throw new Error("There is no HandlerComponent related to this RadioHandler",e);const a=r.getEventChannel();if(!a)throw new Error("Retrieved eventChannel is undefined");const i=e.getId();if(!i)throw new Error("radioHandlerIdentifier has to be a non empty string.");const o="/"+t,s=n?"/SELECT":"/UNSELECT";a.publish({event:i+o+s})},n.checkOnUncheck=function(r){if(!(this&&this.manager&&this.manageable&&r))throw new Error("Internal error. Manageable has to be defined");if(e.hasSucceeded(r))n.fireEvent(this.manager,this.manageable.getId(),!0),t.executeCheckHandler(this.manageable,{cb:this.cb,action:!0,args:this.args});else{if(!this.cb)throw r.getError();this.cb(r)}},n.isManagedByRadioHandler=function(e,t){let n=!1,r=0;const a=t._private._elements.length;for(;!n&&r<a;)t._private._elements[r]===e&&(n=!0),++r;return n},n})),define("DS/WAfrHandlers/private/private_CommandHandlerUtilities",["DS/CoreUtilities/ErrorManagement","DS/WAfrHandlers/private/private_Utilities"],(function(e,t){"use strict";let n=Object.create(null);function r(t){if(!this)throw new Error("this (commandHandler) is undefined.");if(this.getState()!==n.HandlerState.ENDED)throw new Error("The command ended with the status Stated");if(!t||!t.notStarted)for(let n=0;n<this._private._appCB.length;n++)if(this._private._appCB[n]&&"function"==typeof this._private._appCB[n]){if(!t){const n=e.getErrorManager();t=e.createReturnObject(n.SUCCEEDED)}this._private._appCB[n](t)}}return n.CmdMode={EXCLUSIVE:0,NESTED:1},n.RepeatMode={NEVER:0,STANDARD:1,ALWAYS:2},n.LifeCycleEvents={BEGIN:"BEGIN",PAUSE:"PAUSE",RESUME:"RESUME",CANCEL:"CANCEL",COMPUTE:"COMPUTE",END:"END"},n.HandlerState={EXECUTING:"EXECUTING",PAUSED:"PAUSED",CANCELED:"CANCELED",ENDING:"ENDING",COMPUTING:"COMPUTING",ENDED:"ENDED"},n.isValidHandlerState=function(e){return Boolean(e)&&this.HandlerState.hasOwnProperty(e)},n.executeCommandHandler=function(e){if(!e||!e.handler)throw new Error("parameters.handler has to be defined");e.args=t.computeArgs(e.handler,e.args),e.handler._private._cmdsManager.stackCommandExecutionRequest(r.bind(e.handler),e)},n})),define("DS/WAfrHandlers/mod_CommandHandler",["DS/WAfrHandlers/private/private_Utilities","DS/WAfrHandlers/private/private_CommandHandlerUtilities","DS/WAfrHandlers/mod_LeafHandler"],(function(e,t,n){"use strict";const r=n.LeafHandler,a=n.StandaloneLeafHandlerState,i="COMMAND_HANDLER";e.registerLeafHandler(i,{executeFunc:t.executeCommandHandler});let o=Object.create(null);function s(e){return Boolean(e)&&o.LifeCycleEvents.hasOwnProperty(e)}o.CmdMode={EXCLUSIVE:t.CmdMode.EXCLUSIVE,NESTED:t.CmdMode.NESTED},o.RepeatMode={NEVER:t.RepeatMode.NEVER,STANDARD:t.RepeatMode.STANDARD,ALWAYS:t.RepeatMode.ALWAYS},o.LifeCycleEvents={BEGIN:t.LifeCycleEvents.BEGIN,PAUSE:t.LifeCycleEvents.PAUSE,RESUME:t.LifeCycleEvents.RESUME,CANCEL:t.LifeCycleEvents.CANCEL,COMPUTE:t.LifeCycleEvents.COMPUTE,END:t.LifeCycleEvents.END};class d extends a{constructor(e){super(e)}execute(e){const n=e?e.cb:void 0,r=e?e.args:void 0;return t.executeCommandHandler({handler:this._handler,cb:n,args:r})}}return o.CommandHandler=class extends r{constructor(t){if(super(t),!t)throw new Error("DS/WAfrHandlers/mod_CommandHandler.CommandHandler: parameters has to be defined");if(!t.module||"string"!=typeof t.module)throw new Error("DS/WAfrHandlers/mod_CommandHandler.CommandHandler: parameters.module has to be defined and to be a non empty string");if(!t.cmdsManager||"object"!=typeof t.cmdsManager)throw new Error("DS/WAfrHandlers/mod_CommandHandler.CommandHandler: parameters.cmdsManager has to be defined and to be Object of type DS/WAfrCommandsArchitecture/mod_CommandsManagerComponent");if(t.dynamicModeModule||t.dynamicModeFunction){if(!t.dynamicModeModule)throw new Error("DS/WAfrHandlers/mod_CommandHandler.CommandHandler: the handler has a compute mode function field but no compute mode module");if(!t.dynamicModeFunction)throw new Error("DS/WAfrHandlers/mod_CommandHandler.CommandHandler: the handler has a compute mode module field but no compute mode function");if(void 0!==t.cmdMode)throw new Error("DS/WAfrHandlers/mod_CommandHandler.CommandHandler: the command handler has a mode declared although it shall compute its mode. Either remove the computed mode fields or the mode field from the wafrac.")}this._private||(this._private=Object.create(null)),this._private._type=e.enums.HandlerType[i],this._private._command=Object.create(null),this._private._command._module=t.module,this._private._command._instance=null,this._private._command._mode=t.cmdMode?t.cmdMode:o.CmdMode.EXCLUSIVE,this._private._command._dynamicModeModule=t.dynamicModeModule?t.dynamicModeModule:null,this._private._command._dynamicModeFunction=t.dynamicModeFunction?t.dynamicModeFunction:null,this._private._repeatMode=t.repeatMode?t.repeatMode:o.RepeatMode.NEVER,this._private._cmdsManager=t.cmdsManager,this._private._useComputeServer=!!t.computeServer&&t.computeServer,this._private._cb=null,this._private._cbIfCommandNotStarted=null,this._private._handlerState=new d(this)}makeStandalone(){if(this._private._handlerState instanceof d)throw new Error("Call makeStandalone method on an CommandHandler which is already a standalone item");this._private._handlerState=new d(this)}execute(e){super.execute(e)}getMode(){return this._private._command._mode}isDynamic(){return null!==this._private._command._dynamicModeModule&&null!==this._private._command._dynamicModeFunction}setMode(e){if("string"!=typeof e&&"number"!=typeof e||!t.CmdMode.hasOwnProperty(e)&&(e<0||e>t.CmdMode.NESTED))throw new Error("CommandHandler.setMode : command mode value illegal. The command mode must be defined on mod_CommandHandler.CmdMode");if(this._private._command._instance)throw new Error("CommandHandler.setMode : command mode cannot be changed during command execution");this._private._command._mode=e}getRepeatMode(){return this._private._repeatMode}setRepeatMode(e){if("number"!=typeof e||e<0||e>t.RepeatMode.ALWAYS)throw new Error("CommandHandler.setRepeatMode : command repeat mode value illegal. The command repeat mode must be defined on mod_CommandHandler.RepeatMode");this._private._repeatMode=e}getCSIdentifier(){return this._private._command._instance}isUsingComputeServer(){return this._private._useComputeServer}setHandlerComponent(e){return this._private._handlerState.setHandlerComponent(e)}getHandlerComponent(){return this._private._handlerState.getHandlerComponent()}setStateAndSendEvent(e){if(!e||!e.state)throw new Error("parameters has to be defined with a non empty and valid state property (mod_CommandHandler.HandlerState) ");const n=e.state.toUpperCase();if(!t.isValidHandlerState(e.state))throw new Error("There is no state corresponding to the event "+e.state+" for a CommandHandler");if(this._private._command._state=t.HandlerState[n],e.event){const n=e.event.toUpperCase();if(s(n)){const r=this.getHandlerComponent();if(!r)throw new Error("There is no HandlerComponent related to this CommandHandler",this);const a=r.getEventChannel();if(!a)throw new Error("Retrieved eventChannel is undefined");const i=this.getId();if(!i)throw new Error("handlerIdentifier has to be a non empty string.");a.publish({event:i+"/"+t.LifeCycleEvents[n],data:{repeated:e.repeated,canceled:e.canceled,notStarted:e.notStarted}})}}}getState(){return this._private._command._state}onLifeCycleEvent(e,t){if(!e||"string"!=typeof e)throw new Error("identifier has to be a non empty string");const n=e.toUpperCase();if(!s(n))throw new Error("The given identifier is not supported by an CommandHandler",e);if(!t||"function"!=typeof t)throw new Error("cb has to be a function",t);const r=this.getHandlerComponent();if(!r)throw new Error("There is no HandlerComponent related to this CommandHandler",this);const a=r.getEventChannel();if(!a)throw new Error("Retrieved eventChannel is undefined");const i=this.getId();if(!i)throw new Error("handlerIdentifier has to be a non empty string.");return a.subscribe({event:i+"/"+n},t)}removeLifeCycleEventSubscription(e){if(void 0===e)throw new Error("token has to be defined");const t=this.getHandlerComponent();if(!t)throw new Error("There is no HandlerComponent related to this CommandHandler",this);const n=t.getEventChannel();if(!n)throw new Error("Retrieved eventChannel is undefined");if(!this.getId())throw new Error("handlerIdentifier has to be a non empty string.");return n.unsubscribe(e)}},o})),define("DS/WAfrHandlers/private/private_ActionHandlerUtilities",["DS/CoreUtilities/ErrorManagement","DS/WAfrHandlers/private/private_Utilities","DS/Utilities/UUID","DS/WAfrModelEvents/mod_ModelEvents"],(function(e,t,n,r){"use strict";const a=r.DEFAULT_COMPONENT_NAME;let i=Object.create(null);function o(e){const t=e.getI18n()?e.getI18n():null;return{pd1:e._private._cmdUUID,pd2:t?t.title:"",pd3:e._private._handlerTrigger}}function s(t){if(!this.actionHandler)throw new Error("this.action is undefined. A problem occurred when calling this function.");const n=this.actionHandler,r=n.getHandlerComponent();if(!r)throw new Error("There is no HandlerComponent related to this ActionHandler",n);const i=r.getEventChannel();if(!i)throw new Error("Retrieved eventChannel is undefined");const s=n.getId();if(!s)throw new Error("handlerIdentfier has to be a non empty string.");i.publish({event:s+"/END"});const d=r.getExecutionContext?.()?r.getExecutionContext():null,l=d.getSourceApp?.()?d.getSourceApp():null,c=l?.getId?.()||"",h=o(n);h.pd4="Validated";const p={pv1:Date.now()-n._private._startTimeCmd};if("Internal"!==n._private._handlerTrigger){const e={id:s,appID:c,pds:h,pvs:p},t=d.getComponent(a);t?t.publish({event:"command_end",data:e}):console.error("Model events is undefined")}if(!t){const n=e.getErrorManager();t=e.createReturnObject(n.SUCCEEDED)}if(this.cb&&"function"==typeof this.cb)this.cb(t);else if(t&&!e.hasSucceeded(t))throw t.getError()}return i.ImplementationTypes={EXPORTED_FUNCTION:"EXPORTED_FUNCTION",COMPONENT_METHOD:"COMPONENT_METHOD"},i.executeActionHandler=function(r){const d=r.handler;let l=r.cb;if(!d)throw new Error("actionHandler has to be defined and cannot be null");var c=d.getHandlerComponent();if(!c)throw console.warn("NO HANDLER COMPONENT SET"),new Error;if(!c.getExecutionContext())throw console.warn("NO EXECUTION CONTEXT SET"),new Error;null!==l&&"function"==typeof l||(l=void 0);const h=r.args?r.args:null;d._private._cmdUUID=n.createUUID(),d._private._handlerTrigger=h?h.handlerTrigger:"Internal",d._private._startTimeCmd=Date.now();const p=o(d),u=c.getExecutionContext?.()?c.getExecutionContext():null,m=u.getSourceApp?.()?u.getSourceApp():null,f=m?.getId?.()||"";if("Internal"!==d._private._handlerTrigger){const e={id:r.handler.getId?.()?r.handler.getId():"",appID:f,pds:p},t=u.getComponent(a);t?t.publish({event:"command_launch",data:e}):console.error("Model events is undefined")}let _=null;_=d._private._implementationType===i.ImplementationTypes.EXPORTED_FUNCTION?new Promise(((t,n)=>{require([d._private._action._module],(function(r){const a=e.getErrorManager();let i;if(r){const o=r[d._private._action._func];return o&&"function"==typeof o?t(o):(i=e.createReturnObject(a.FAILED,{description:`Unknown function ${d._private._action._func} in ${d._private._action._module}`}),n(i))}return i=e.createReturnObject(a.WRONG_VALUE,{description:"Module require return undefined"}),n(i)}),(function(){const t=e.getErrorManager(),r=e.createReturnObject(t.FAILED,{description:`Require failed (${d._private._action._module})`});return n(r)}))})):new Promise(((t,n)=>{if(!(c=d.getHandlerComponent()))throw new Error("There is no HandlerComponent related to this ActionHandler",d);const r=c.getExecutionContext().exposedApi,a=d._private._action._component,i=r.getComponent(a);if(!i){const t=e.getErrorManager();return n(e.createReturnObject(t.FAILED,{description:`Impossible to retrieve the component (${a})`}))}if(!i[d._private._action._func]){const t=e.getErrorManager();return n(e.createReturnObject(t.FAILED,{description:`No function ${d._private._action._func} exposed by ${a}`}))}return t(i[d._private._action._func].bind(i))})),_.then((function(e){let n=Object.create(null);if(n.cb=l,n.actionHandler=d,!(c=d.getHandlerComponent()))throw new Error("There is no HandlerComponent related to this ActionHandler",d);let a=Object.create(null);d._private._implementationType!==i.ImplementationTypes.COMPONENT_METHOD&&(a.executionContext=c.getExecutionContext().exposedApi),a.args=t.computeArgs(d,r.args);const o=c.getEventChannel();if(!o)throw new Error("Retrieved eventChannel is undefined");const h=d.getId();if(!h)throw new Error("handlerIdentfier has to be a non empty string.");o.publish({event:h+"/BEGIN"});const p=s.bind(n);d._private._implementationType===i.ImplementationTypes.EXPORTED_FUNCTION?e(p,a):e(a).then(p).catch(p)}),(function(t){if(t)if(l)l(t);else if(!e.hasSucceeded(t))throw t.getError()}))},i})),define("DS/WAfrHandlers/mod_ActionHandler",["DS/WAfrHandlers/private/private_Utilities","DS/WAfrHandlers/private/private_ActionHandlerUtilities","DS/WAfrHandlers/mod_LeafHandler","DS/WAfrHandlers/mod_HandlerComponent"],(function(e,t,n){"use strict";let r=Object.create(null);const a=n.LeafHandler,i=n.StandaloneLeafHandlerState,o="ACTION_HANDLER";e.registerLeafHandler(o,{executeFunc:t.executeActionHandler}),r.LifeCycleEvents={BEGIN:"BEGIN",END:"END"},r.ImplementationTypes=t.ImplementationTypes;class s extends i{constructor(e){super(e)}execute(e){const n=e?e.cb:void 0,r=e?e.args:void 0;return t.executeActionHandler({handler:this._handler,cb:n,args:r})}}return r.ActionHandler=class extends a{constructor(t){if(super(t),this._private||(this._private=Object.create(null)),!t)throw new Error("parameters has to be defined");if(this._private._type=e.enums.HandlerType[o],this._private._action=Object.create(null),this._private._implementationType=r.ImplementationTypes.EXPORTED_FUNCTION,void 0!==t.implementationType){if(n=t.implementationType,!Boolean(n)||!r.ImplementationTypes.hasOwnProperty(n))throw new Error(`parameters.implementationType value is not a valid one. (${t.implementationType})`);this._private._implementationType=t.implementationType}var n;if(this._private._implementationType===r.ImplementationTypes.EXPORTED_FUNCTION){if(!t.module||"string"!=typeof t.module)throw new Error('parameters.module has to be defined and to be a non empty string in case of "EXPORTED_FUNCTION"');this._private._action._module=t.module}else{if(!t.component||"string"!=typeof t.component)throw new Error('parameters.component has to be defined and to be a non empty string in case of "COMPONENT_METHOD"');this._private._action._component=t.component}if(!t.func||"string"!=typeof t.func)throw new Error("parameters.func has to be defined and to be a non empty string");this._private._action._func=t.func,this._private._handlerState=new s(this)}makeStandalone(){if(this._private._handlerState instanceof s)throw new Error("Call makeStandalone method on an ActionHandler which is already a standalone item");this._private._handlerState=new s(this)}execute(e){super.execute(e)}setHandlerComponent(e){return this._private._handlerState.setHandlerComponent(e)}getHandlerComponent(){return this._private._handlerState.getHandlerComponent()}onLifeCycleEvent(e,t){if(!e)throw new Error("identifier has to be a non empty string");const n=e.toUpperCase();if(!function(e){return Boolean(e)&&r.LifeCycleEvents.hasOwnProperty(e)}(n))throw new Error("The given identifier is not supported by an ActionHandler",e);if(!t||"function"!=typeof t)throw new Error("cb has to be a function",t);const a=this.getHandlerComponent();if(!a)throw new Error("There is no HandlerComponent related to this ActionHandler",this);const i=a.getEventChannel();if(!i)throw new Error("Retrieved eventChannel is undefined");const o=this.getId();if(!o)throw new Error("handlerIdentfier has to be a non empty string.");return i.subscribe({event:o+"/"+n},t)}removeLifeCycleEventSubscription(e){if(void 0===e)throw new Error("token has to be defined");const t=this.getHandlerComponent();if(!t)throw new Error("There is no HandlerComponent related to this ActionHandler",this);const n=t.getEventChannel();if(!n)throw new Error("Retrieved eventChannel is undefined");if(!this.getId())throw new Error("handlerIdentfier has to be a non empty string.");return n.unsubscribe(e)}},r})),define("DS/WAfrHandlers/mod_CheckHandler",["DS/CoreUtilities/ErrorManagement","DS/WAfrHandlers/private/private_Utilities","DS/WAfrHandlers/private/private_CheckHandlerUtilities","DS/WAfrHandlers/mod_Handler","DS/WAfrHandlers/mod_ActionHandler","DS/WAfrHandlers/mod_CommandHandler"],(function(e,t,n,r,a,i){"use strict";const o=r.Handler,s=a.ActionHandler,d=i.CommandHandler;let l=Object.create(null);function c(e,t){let n=!1;return(e.beingInitialized()||t===e._private._check&&!e._private._isChecked||t===e._private._uncheck&&e._private._isChecked)&&(n=!0),n}function h(e){let t=!1;var n=!0;return(e._private._check&&!e._private._check.isAvailable()||e._private._uncheck&&!e._private._uncheck.isAvailable())&&(n=!1),e.isAvailable()!==n&&(e._private._currentAvailability=n,t=!0),t}l.StateEvents={CHECK:"CHECK",UNCHECK:"UNCHECK"};class p{constructor(e,t){if(!e||!t)throw new Error("manageable and handlerManager have to be define");this._checkHandler=e,this._manager=t}handleExecute(t){if(!t)throw new Error("Wrong parameters");{const n=t.cb,r=t.manageable,a=t.args;if(r!==this._checkHandler._private._check&&r!==this._checkHandler._private._uncheck)throw new Error("Internal error. The manageable calling handle is not managed by this manager.");c(this._checkHandler,r)?this._manager.handleExecute({cb:t.cb,manageable:this._checkHandler,action:!this._checkHandler._private._isChecked,args:a}):n&&"function"==typeof n&&setTimeout((function(){const t=e.getErrorManager();n(e.createReturnObject(t.SUCCEEDED))}),0)}}handleOnAvailabilityChanged(e){const t=this._checkHandler,n=this._manager;h(t)&&(e.args.newValue=t.isAvailable(),e.manageable=t,n.handleOnAvailabilityChanged(e))}isExecutable(){return this.handleIsExecutable()}handleIsExecutable(){return this._manager.handleIsExecutable({manageable:this._checkHandler})}setState(){throw new Error("You can not directly change the state of a CheckHandler which is managed")}setHandlerComponent(){return console.warn("Impossible to set a HandlerComponent to a CheckHandler which is managed."),!1}getHandlerComponent(){return this._manager.getHandlerComponent()}disable(){throw new Error("Impossible to disable a Managed Handler")}enable(){throw new Error("Impossible to enable a Managed Handler")}onIsEnabledChangeEvent(){throw new Error("Impossible to subscribe to isEnabledChangeEvent from a Managed Handler")}removeIsEnabledChangeEventSubscription(){throw new Error("Impossible to unsubscribe to isEnabledChangeEvent from a Managed Handler")}}class u{constructor(e){if(!e)throw new Error("checkHandler has to be defined");this._checkHandler=e}handleExecute(t){if(!t)throw new Error("Wrong parameters");{const r=t.cb,a=t.manageable,i=t.args;if(a!==this._checkHandler._private._check&&a!==this._checkHandler._private._uncheck)throw new Error("Internal error. The manageable calling handleExecute is not managed by this manager.");c(this._checkHandler,a)?n.executeCheckHandler(this._checkHandler,{cb:r,action:!this._checkHandler._private._isChecked,args:i}):r&&"function"==typeof r&&setTimeout((function(){const t=e.getErrorManager();r(e.createReturnObject(t.SUCCEEDED))}),0)}}setState(t){const n=t.state,r=t.cb,a=t.args;if(n!==this._checkHandler._private._isChecked){let e;e=this._checkHandler._private._isChecked?this._checkHandler._private._uncheck:this._checkHandler._private._check,this.handleExecute({cb:r,manageable:e,args:a})}else setTimeout((function(){const t=e.getErrorManager();r(e.createReturnObject(t.SUCCEEDED))}),0)}setHandlerComponent(e){if(void 0===e)throw new Error("component has to be defined");return this._checkHandler._private._handlerComponent=e,!0}getHandlerComponent(){return this._checkHandler._private._handlerComponent}handleOnAvailabilityChanged(){const e=this._checkHandler;h(e)&&t.publishHandlerAvailability(e)}isExecutable(){return this.handleIsExecutable()}handleIsExecutable(){return o.prototype.isExecutable.call(this._checkHandler)}disable(...e){return o.prototype.disable.call(this._checkHandler,...e)}enable(...e){return o.prototype.enable.call(this._checkHandler,...e)}onIsEnabledChangeEvent(...e){return o.prototype.onIsEnabledChangeEvent.call(this._checkHandler,...e)}removeIsEnabledChangeEventSubscription(...e){return o.prototype.removeIsEnabledChangeEventSubscription.call(this._checkHandler,...e)}}return l.CheckHandler=class extends o{constructor(e){if(super(e),this._private._check=null,this._private._uncheck=null,!e||!e.id)throw new Error("Wrong parameters");this._private._id=e.id,this._private._isChecked=!1,this._private._handlerState=new u(this)}makeStandalone(){if(this._private._handlerState instanceof u)throw new Error("Call makeStandalone method on an CheckHandler which is already a standalone item");this._private._handlerState=new u(this)}makeManaged(e){if(this._private._handlerState instanceof p)throw new Error("Call makeManaged method on an CheckHandler which is already managed");this._private._handlerState=new p(this,e),delete this._private._handlerComponent}validateElement(e){return e instanceof s||e instanceof d}addElement(e,t){let n=!1;if(!e||!t||!t.state||"check"!==t.state&&"uncheck"!==t.state)throw new Error("Imcompatible parameters");const r="_"+t.state;return this.validateElement(e)&&!this._private[r]&&(this._private[r]=e,e.makeManaged(this),this._private._handlerState.handleOnAvailabilityChanged({manageable:this,args:{newValue:e.isAvailable()}}),n=!0),n}handleExecute(e){return this._private._handlerState.handleExecute(e)}isExecutable(){return this._private._handlerState.isExecutable()}handleIsExecutable(e){if(!e||!e.manageable)throw new Error("Wrong parameters");if(e.manageable!==this._private._check&&e.manageable!==this._private._uncheck)throw new Error("The given manageable is not managed by this CheckHandler");return this._private._handlerState.handleIsExecutable()}getCheckHandler(){return this._private._check}getUncheckHandler(){return this._private._uncheck}setState(t){if(this.isExecutable())this._private._handlerState.setState(t);else{const n=e.getErrorManager(),r=e.createReturnObject(n.NOT_EXECUTABLE,{description:"This CheckHandler is not executable"});if(!t||!t.cb)throw r.getError();setTimeout((function(){t.cb(r)}),0)}}getState(){return this._private._isChecked}setHandlerComponent(e){return this._private._handlerState.setHandlerComponent(e)}getHandlerComponent(){return this._private._handlerState.getHandlerComponent()}handleOnAvailabilityChanged(e){if(!e||!e.manageable||!e.args||void 0===e.args.newValue)throw new Error("handleExecute was called using wrong parameters",e);return this._private._handlerState.handleOnAvailabilityChanged(e)}onStateEvent(e,t){if(!e)throw new Error("identifier has to be a non empty string");const n=e.toUpperCase();if(!function(e){return Boolean(e)&&l.StateEvents.hasOwnProperty(e)}(n))throw new Error("The given identifier is not supported by a CheckHandler",e);if(!t||"function"!=typeof t)throw new Error("cb has to be a function",t);const r=this.getHandlerComponent();if(!r)throw new Error("There is no HandlerComponent related to this CheckHandler",this);const a=r.getEventChannel();if(!a)throw new Error("Retrieved eventChannel is undefined");const i=this.getId();if(!i)throw new Error("handlerIdentfier has to be a non empty string.");return a.subscribe({event:i+"/"+n},t)}removeStateEventSubscription(e){if(void 0===e)throw new Error("token has to be defined");const t=this.getHandlerComponent();if(!t)throw new Error("There is no HandlerComponent related to this CheckHandler",this);const n=t.getEventChannel();if(!n)throw new Error("Retrieved eventChannel is undefined");if(!this.getId())throw new Error("handlerIdentifier has to be a non empty string.");return n.unsubscribe(e)}disable(){return this._private._handlerState.disable()}enable(){return this._private._handlerState.enable()}onIsEnabledChangeEvent(e){return this._private._handlerState.onIsEnabledChangeEvent(e)}removeIsEnabledChangeEventSubscription(e){return this._private._handlerState.removeIsEnabledChangeEventSubscription(e)}destroy(){super.destroy(),this._private._check&&this._private._check.destroy(),this._private._uncheck&&this._private._uncheck.destroy()}},l})),define("DS/WAfrHandlers/mod_RadioHandler",["DS/CoreUtilities/ErrorManagement","DS/WAfrHandlers/private/private_Utilities","DS/WAfrHandlers/mod_Handler","DS/WAfrHandlers/mod_CheckHandler"],(function(e,t,n,r){"use strict";const a=n.Handler,i=r.CheckHandler;let o=Object.create(null);o.ItemStateEvents={SELECT:"SELECT",UNSELECT:"UNSELECT"};return o.RadioHandler=class extends a{constructor(e){super(e),this._private._checkedElement=null,this._private._elements=[]}validateElement(e){return e instanceof i}addElement(e){let t=!1;if(!e||e===this||!e.makeManaged||"function"!=typeof e.makeManaged)throw new Error;if(!this.validateElement(e))throw new Error("elt is not a valide element to add to a RadioHandler");return this._private._elements.push(e),e.makeManaged(this),this.handleOnAvailabilityChanged({manageable:this,args:{newValue:e.isAvailable()}}),t=!0,t}getElements(){if(!this._private||!this._private._elements||!Array.isArray(this._private._elements))throw new Error("Internal error");return this._private._elements}getElementById(e){const t=this._private._elements.length;let n=0,r=!1,a=null;for(;!r&&n<t;){const t=this._private._elements[n];t.getId()===e&&(r=!0,a=t),++n}return a}getSelectedItem(){let e=null;const t=this.getSelectedItemId();return t&&(e=this.getElementById(t)),e}setRadioItemState(t){const n=t.radioHdlrItemId,r=t.state,a=t.cb,i=t.args,o=e.getErrorManager();let s,d,l=0;const c=this._private._elements.length;for(l=0;l<c;++l)this._private._elements[l].getId()===n&&(d=this._private._elements[l]);if(d)if(this.isExecutable()){let e=Object.create(null);e.cb=a,e.manageable=d,e.action=r,e.args=i,this.handleExecute(e)}else{if(s=e.createReturnObject(o.NOT_EXECUTABLE,{description:"This RadioHandler is not executable"}),!t||!t.cb)throw s;setTimeout((function(){a(s)}),0)}else{if(s=e.createReturnObject(o.FAILED,{description:"Unknown item: "+n}),!a)throw s.getError();setTimeout((function(){a(s)}),0)}}getRadioItemState(e){if(!e||"string"!=typeof e)throw new Error("itemId has to be a non empty string");let t;const n=this._private._elements.length;for(let r=0;r<n;++r)this._private._elements[r].getId()===e&&(t=this._private._elements[r].getState());if(void 0===t)throw new Error("This item does not belong to this RadioHandler");return t}getSelectedItemId(){let e;return this._private._checkedElement&&(e=this._private._checkedElement.getId()),e}setHandlerComponent(e){if(void 0===e)throw new Error("component has to be define");return this._private._handlerComponent=e,!0}getHandlerComponent(){return this._private._handlerComponent}handleOnAvailabilityChanged(e){if(!e||!e.manageable||!e.args||void 0===e.args.newValue)throw new Error("handleExecute was called using wrong parameters",e);(function(e){for(var t=!1,n=!0,r=e._private._elements,a=r.length,i=0;i<a&&n;)n=r[i].isAvailable(),++i;return n!==e.isAvailable()&&(e._private._currentAvailability=n,t=!0),t})(this)&&t.publishHandlerAvailability(this)}handleIsExecutable(e){if(!e||!e.manageable)throw new Error("Wrong parameters");return this.isExecutable()}onItemStateEvent(e,t,n){if(!e)throw new Error("identifier has to be a non empty string");if(!t)throw new Error("itemIdentifier has to be a non empty string");const r=e.toUpperCase();if(!function(e){return Boolean(e)&&o.ItemStateEvents.hasOwnProperty(e)}(r))throw new Error("The given identifier is not supported by an RadioHandler",e);if(!n||"function"!=typeof n)throw new Error("cb has to be a function",n);const a=this.getHandlerComponent();if(!a)throw new Error("There is no HandlerComponent related to this RadioHandler",this);const i=a.getEventChannel();if(!i)throw new Error("Retrieved eventChannel is undefined");const s=this.getId();if(!s)throw new Error("handlerIdentfier has to be a non empty string.");return i.subscribe({event:s+"/"+t+"/"+r},n)}removeItemStateEventSubscription(e){if(void 0===e)throw new Error("token has to be defined");const t=this.getHandlerComponent();if(!t)throw new Error("There is no HandlerComponent related to this RadioHandler",this);const n=t.getEventChannel();if(!n)throw new Error("Retrieved eventChannel is undefined");if(!this.getId())throw new Error("handlerIdentifier has to be a non empty string.");return n.unsubscribe(e)}destroy(){super.destroy();const e=this._private._elements,t=this._private._elements.length;for(var n=0;n<t;++n)e[n].destroy()}},o})),define("DS/WAfrHandlers/mod_RadioHandlerZERO",["DS/WAfrHandlers/private/private_CheckHandlerUtilities","DS/WAfrHandlers/private/private_RadioHandlerUtilities","DS/WAfrHandlers/mod_RadioHandler"],(function(e,t,n){"use strict";const r=n.RadioHandler;let a=Object.create(null);return a.RadioHandlerZERO=class extends r{constructor(e){super(e)}isUnselectAuthorized(){return!0}handleExecute(n){if(!n||!n.manageable)throw new Error("Wrong parameters");{const r=n.manageable;if(!t.isManagedByRadioHandler(r,this))throw new Error("Internal error. The manageable calling handleExecute is not managed by this RadioHandler.");if(n.action)if(this._private._checkedElement){if(this._private._checkedElement!==n.manageable){let r=Object.create(null);r.cb=n.cb,r.manager=this,r.manageable=n.manageable,r.args=n.args,t.fireEvent(this,this._private._checkedElement.getId(),!1),e.executeCheckHandler(this._private._checkedElement,{cb:t.checkOnUncheck.bind(r),action:!1}),this._private._checkedElement=n.manageable}}else t.fireEvent(this,n.manageable.getId(),n.action),e.executeCheckHandler(n.manageable,{cb:n.cb,action:n.action,args:n.args}),this._private._checkedElement=n.manageable;else n.manageable.getState()!==n.action&&(t.fireEvent(this,n.manageable.getId(),n.action),e.executeCheckHandler(n.manageable,{cb:n.cb,action:n.action,args:n.args}),this._private._checkedElement=null)}}},a})),define("DS/WAfrHandlers/mod_RadioHandlerONE",["DS/CoreUtilities/ErrorManagement","DS/WAfrHandlers/private/private_CheckHandlerUtilities","DS/WAfrHandlers/private/private_RadioHandlerUtilities","DS/WAfrHandlers/mod_RadioHandler"],(function(e,t,n,r){"use strict";const a=r.RadioHandler;let i=Object.create(null);return i.RadioHandlerONE=class extends a{constructor(e){super(e)}isUnselectAuthorized(){return!1}handleExecute(r){if(!r||!r.manageable)throw new Error("Wrong parameters");{const a=r.manageable;if(!n.isManagedByRadioHandler(a,this))throw new Error("Internal error. The manageable calling handleExecute is not managed by this RadioHandler.");if(!r.action){const t=e.getErrorManager(),n=e.createReturnObject(t.FAILED,{description:"It is impossible to uncheck the checked element for RadioHandler of type ONE"});if(!r.cb||"function"!=typeof r.cb)throw n.getError();setTimeout((function(){r.cb(n)}),0)}if(this._private._checkedElement)if(r.manageable!==this._private._checkedElement){let e=Object.create(null);e.cb=r.cb,e.manageable=r.manageable,e.manager=this,e.args=r.args,n.fireEvent(this,this._private._checkedElement.getId(),!1),t.executeCheckHandler(this._private._checkedElement,{cb:n.checkOnUncheck.bind(e),action:!1}),this._private._checkedElement=r.manageable}else this.beingInitialized()&&(n.fireEvent(this,r.manageable.getId(),!0),t.executeCheckHandler(r.manageable,{cb:r.cb,action:!0,args:r.args}),this._private._checkedElement=r.manageable);else n.fireEvent(this,r.manageable.getId(),!0),t.executeCheckHandler(r.manageable,{cb:r.cb,action:!0,args:r.args}),this._private._checkedElement=r.manageable}}},i})),define("DS/WAfrHandlers/mod_HandlerInterpreter",["DS/WAfrHandlers/mod_ActionHandler","DS/WAfrHandlers/mod_CommandHandler","DS/WAfrHandlers/mod_CheckHandler","DS/WAfrHandlers/mod_RadioHandlerZERO","DS/WAfrHandlers/mod_RadioHandlerONE","DS/WAfrHandlers/mod_HandlerComponent","DS/WAfrAvailabilityModes/mod_AvailabilityModesComponent","DS/WAfrUtils/mod_PromiseUtils","DS/WAfrUtils/mod_ConcatenationUtils"],(function(e,t,n,r,a,i,o,s,d){"use strict";var l=e.ActionHandler,c=t.CommandHandler,h=n.CheckHandler,p=r.RadioHandlerZERO,u=a.RadioHandlerONE;const m=s.promisifiedRequire,f=d.getConfigurationFor,_={AC_NOT_FOUND:"AC_NOT_FOUND"};var E={};let b=!1;const v=localStorage.getItem("DEBUG_AFR_I18N");null!==v&&("string"==typeof v&&"true"===v||"boolean"==typeof v&&v)&&(console.warn("[DEBUG] DS/WAfrHandlers/mod_HandlerInterpreter: I18N Debug mode activated.","\n[DEBUG] DO NOT USE IN PRODUCTION.",'\n[DEBUG] Be sure to activate "Verbose" level in the DevTools to see all logs.'),b=!0);const g="font-weight:bold;",C="color:#368EC4;",H="color:#EA4F37;";function w(e,t,n){const r="internationalization",a=e[r],i=e.identifier;let o=Promise.resolve();return a&&a.path&&(b&&console.debug(`%c[mod_HandlerInterpreter~computeLeafHandlerI18n][I18N]%c  Compute I18n (runtime) for%c ${i}%c in%c ${t}%c filtered with the following array%c [${n?n.join(", "):"en"}]`,`${g} ${C}`,`${C}`,`${g} ${C}`,`${C}`,`${g} ${C}`,`${C}`,`${g} ${C}`),o=function(e,t,n){let r=Promise.resolve();if("string"==typeof e)if(void 0===n||n.includes(t))r=m("i18n!"+e);else{b&&console.debug(`%c[mod_HandlerInterpreter~getI18nFromPath][I18N]%c  Fallback I18n (runtime) for%c ${e}%c to %cen%c. Requested%c ${t}%c but filtered by%c [${n?n.join(", "):"en"}]`,`${g} ${C}`,`${C}`,`${g} ${C}`,`${C}`,`${g} ${C}`,`${C}`,`${g} ${C}`,`${C}`,`${g} ${C}`);const a="text!"+e+"_en.json";r=m(a).then((t=>{try{return JSON.parse(t)}catch(t){const n=new Error(`Internal Error. ${e} content is not a valid JSON.`);return b&&console.debug(`%c[mod_HandlerInterpreter~getI18nFromPath][I18N]%c  Error computing I18n for%c ${a}%c. The content is not a valid JSON]`,`${g} ${H}`,`${H}`,`${g} ${H}`,`${H}`),Promise.reject(n)}}))}else r=Promise.reject(new Error("path is not a string"));return r}(a.path,t,n).then((e=>function(e,t){const n={};if(e){const r=t+".";let a=r+"Title";e.hasOwnProperty(a)&&(n.title=e[a]),a=r+"ShortHelp",e.hasOwnProperty(a)&&(n.shortHelp=e[a]),a=r+"ShortHelpImage",e.hasOwnProperty(a)&&(n.shortHelpImage=e[a]),a=r+"LongHelp",e.hasOwnProperty(a)&&(n.longHelp=e[a]),a=r+"LongHelpImage",e.hasOwnProperty(a)&&(n.longHelpImage=e[a]);for(const[t,a]of Object.entries(e))(t.startsWith(r+"WebHelp")||t.startsWith(r+"PanelHelp"))&&(n[t.replace(r,"")]=a)}return n}(e,i))).then((t=>{e[r]=t,b&&console.debug(`%c[mod_HandlerInterpreter~computeLeafHandlerI18n][I18N]%c  Retrieved I18n for%c ${i}%c.`,`${g} ${C}`,`${C}`,`${g} ${C}`,`${C}`,t)})).catch((e=>(console.error(e),b&&console.debug(`%c[mod_HandlerInterpreter~computeLeafHandlerI18n][I18N]%c  Error computing I18n for%c ${i}%c.`,`${g} ${H}`,`${H}`,`${g} ${H}`,`${H}`,e),Promise.resolve())))),o}function y(e){return{id:e.identifier,i18n:e.internationalization,icon:e.icon,availabilityMode:e.availability,accelerator:e.accelerator}}function I(e){return{id:e.identifier,i18n:e.internationalization,icon:e.icon,availabilityMode:e.availability,accelerator:e.accelerator}}function S(n,r,a){var i,o=null;if(r.declerr&&Array.isArray(r.declerr))for(let e=0,t=r.declerr,n=t.length;e<n;++e){let n=t[e];if(n.id===_.AC_NOT_FOUND)throw new Error(`[HandlerInterpreter] ${n.args.itemName} was not found.`)}if("Action"===r.type)i=function(t,n){var r=n(t);return r.implementationType=t.code.type,void 0===r.implementationType||r.implementationType===e.ImplementationTypes.EXPORTED_FUNCTION?r.module=t.code.module:r.component=t.code.component,r.func=t.code.func,r.args=t.argument,r}(r,a),o=new l(i);else{if("Command"!==r.type)throw new Error("Unknown handler type",r.type);i=function(e,n,r){var a=r(n);a.module=n.code.module;var i=e.getComponent("AFR_CommandsManager");return a.cmdsManager=i,a.cmdMode=t.CmdMode[n.mode],a.repeatMode=t.RepeatMode[n.repeatability],a.args=n.argument,a.computeServer=n.computeServer,a.dynamicModeModule=n.code.dynamicModeMod,a.dynamicModeFunction=n.code.dynamicModeFun,a}(n,r,a),o=new c(i)}return i&&i.args&&o.setArgs(i.args),o}function A(e,t){let n=o.DEFAULT_COMPONENT_NAME;return t&&t[o.DEFAULT_COMPONENT_NAME]&&(n=t[o.DEFAULT_COMPONENT_NAME]),e.getComponent(n)}class M{constructor(){this._initializationValues=[],this._handler=[],this._chkHandler=[],this._radioHandler=[]}addInitializationValue(e){if(void 0===this._initializationValues)throw new Error("Cannot add a new initialization value. Verify interpreter lifecycle.");this._initializationValues.push(e)}createLeafHandler(e,t,n){return S(e,t,n)}createCheckHandler(e,t){return function(e,t){const n=new h({id:t.identifier});t.accelerator&&(t.check.accelerator=t.accelerator,t.uncheck.accelerator=t.accelerator);const r=S(e,t.check,I);n.addElement(r,{state:"check"});const a=S(e,t.uncheck,I);let i;if(n.addElement(a,{state:"uncheck"}),void 0!==t.defaultState&&"string"==typeof t.defaultState&&(t.defaultState="true"===t.defaultState),void 0!==t.defaultState&&t.defaultState){let e=!1;void 0!==t.isA2X&&(e=t.isA2X),e?console.error("The HandlerInterpreter used in not the one dedicated to A2X."):i={type:"CheckHandler",id:t.identifier,state:!0}}return{handler:n,check:r,uncheck:a,initializationValue:i}}(e,t)}createRadioHandler(e,t){return function(e,t){let n,r,a={id:t.identifier};if("ONE"===t.radioType)n=new u(a);else{if("ZERO"!==t.radioType)throw new Error("Unsupported radioType");n=new p(a)}let i,o,s,d,l=0,c=t.items,m=c.length;for(l=0;l<m;++l)o=c[l],i=new h({id:o.identifier}),o.accelerator&&(o.check.accelerator=o.accelerator,o.uncheck.accelerator=o.accelerator),o.check&&(s=S(e,o.check,I),i.addElement(s,{state:"check"})),o.uncheck&&(d=S(e,o.uncheck,I),i.addElement(d,{state:"uncheck"})),n.addElement(i);return t.default&&(r={type:"RadioHandler",id:t.default,radioId:t.identifier,state:!0}),{radioHandler:n,initializationValue:r}}(e,t)}interpretLeafHandler(e,t){if(!t)return;const n=t.length;let r,a;for(let i=0;i<n;++i)r=t[i],a=this.createLeafHandler(e,r,y),this._handler.push(a),this.addToAvailabilityModesSubscribers(a)}interpretCheckHandler(e,t){if(!t)return;const n=t.length;let r;for(let a=0;a<n;++a){r=t[a];const{handler:n,check:i,uncheck:o,initializationValue:s}=this.createCheckHandler(e,r);this.addToAvailabilityModesSubscribers(i),this.addToAvailabilityModesSubscribers(o),this._chkHandler.push(n),s&&this._initializationValues.push(s)}}interpretRadioHandler(e,t){if(!t)return;const n=t.items;if(!Array.isArray(n))return;if(0===n.length)return;const r=n.length;let a,i,o,s,d,l,c,h=0;for(h=0;h<r;++h){a=n[h];const{radioHandler:t,initializationValue:r}=this.createRadioHandler(e,a);for(i=t.getElements(),s=i.length,o=0;o<s;++o)d=i[o],l=d.getCheckHandler(),l&&this.addToAvailabilityModesSubscribers(l),c=d.getUncheckHandler(),c&&this.addToAvailabilityModesSubscribers(c);this._radioHandler.push(t),r&&this._initializationValues.push(r)}}computeRuntimeI18n(e,t){const n=e&&e.internationalization?e.internationalization:void 0;b&&console.debug(`%c[mod_HandlerInterpreter.interpret][I18N]%c Environment current lang:%c ${t}`,`${g} ${C}`,`${C}`,`${g} ${C}`);const r=[];if(e&&e.handlers){if(e.handlers.default){const a=e.handlers.default;for(const e of a)if(e.hasOwnProperty("internationalization")){const a=e;r.push(w(a,t,n))}}if(e.handlers.check){const a=e.handlers.check;for(const e of a){const a=e.check;a&&r.push(w(a,t,n));const i=e.uncheck;i&&r.push(w(i,t,n))}}}if(e&&e.radioGroup&&e.radioGroup.items){const a=e.radioGroup.items;for(const e of a)if(e.items){const a=e.items;for(const e of a){if(e.check){const a=e.check;r.push(w(a,t,n))}if(e.uncheck){const a=e.uncheck;r.push(w(a,t,n))}}}}return Promise.all(r)}interpret(e,t,n){if(!e||!t)throw new Error("Missing parameters");var r=i.DEFAULT_COMPONENT_NAME;if(n&&n.componentId?r=n.componentId:console.warn("Caution! You are using the default component name. This is not recommended"),this._executionContext=t,this._handlerComponent=t.getComponent(r),!this._handlerComponent)throw new Error("HandlerComponent not found");let a=Promise.resolve();const o=f(e,"i18n");if(!o||o&&"runtime"===o){const t=window.widget?window.widget.lang:"en";a=this.computeRuntimeI18n(e,t)}return a.then((()=>{if(e){if(e.handlers){if(e.handlers&&e.handlers.default){var n=e.handlers.default;this.interpretLeafHandler(t,n)}if(e.handlers&&e.handlers.check){var r=e.handlers.check;this.interpretCheckHandler(t,r)}e.handlers.defaultCommand&&(this._defaultCommandIdentifier=e.handlers.defaultCommand)}if(e.radioGroup){var a=e.radioGroup;this.interpretRadioHandler(t,a)}}})),a}commitHandlers(){let e=this._handler.length,t=0,n=null;for(t=0;t<e;++t)n=this._handler[t],this._handlerComponent.addHandler(n);for(this._handler.splice(0,e),delete this._handler,e=this._chkHandler.length,t=0;t<e;++t)n=this._chkHandler[t],this._handlerComponent.addCheckHandler(n);for(this._chkHandler.splice(0,e),delete this._chkHandler,e=this._radioHandler.length,t=0;t<e;++t)n=this._radioHandler[t],this._handlerComponent.addRadioHandler(n);this._radioHandler.splice(0,e),delete this._radioHandler}commit(e){this.commitHandlers(),this._handlerComponent.setInitializationData(this._initializationValues),this._defaultCommandIdentifier&&this._handlerComponent.setInitializationDefaultCommand(this._defaultCommandIdentifier);let t=Promise.resolve();const n=A(this._executionContext,e);return n&&(this._handlerComponent.setAvailabilityModesComponent(n),this._availabilityModesSubscribers&&this._availabilityModesSubscribers.length>0&&(t=this.commitAvailabilityModesSubscribers())),t.then((()=>{delete this._handlerComponent,delete this._executionContext,delete this._initializationValues,delete this._availabilityModesSubscribers}))}commitEnrich(e){this.commitHandlers(),this._handlerComponent.addInitializationData(this._initializationValues);let t=Promise.resolve();return A(this._executionContext,e)&&(t=this.commitAvailabilityModesSubscribers()),t.then((()=>{delete this._handlerComponent,delete this._executionContext,delete this._initializationValues,delete this._availabilityModesSubscribers}))}enrich(e,t,n){if(void 0!==this._handler||void 0!==this._chkHandler||void 0!==this._radioHandler||void 0!==this._executionContext||void 0!==this._handlerComponent||void 0!==this._initializationValues||void 0!==this._availabilityModesSubscribers)throw new Error('Enrich was called whereas internal variables are still defined. Possible cause: enrich was called before an "interpret"-"commit" sequence.');return this._enrich(e,t,n)}_enrich(e,t,n){if(!e||!t)throw new Error("Missing parameters");return this._handler=[],this._chkHandler=[],this._radioHandler=[],this._initializationValues=[],this.interpret(e,t).then(this.commitEnrich.bind(this,n)).then((()=>{delete this._handler,delete this._chkHandler,delete this._radioHandler,delete this._handlerComponent,delete this._executionContext,delete this._initializationValues,delete this._availabilityModesSubscribers}))}addToAvailabilityModesSubscribers(e){if(!e||!this._executionContext)throw new Error("element and this._executionContext has to be defined");this._availabilityModesSubscribers||(this._availabilityModesSubscribers=[]),this._availabilityModesSubscribers.push(e)}commitAvailabilityModesSubscribers(){let e=[],t=0,n=0,r=null;if(this._availabilityModesSubscribers)for(n=this._availabilityModesSubscribers.length,t=0;t<n;++t)r=this._availabilityModesSubscribers[t],e.push(r.initAvailabilityModesSubscription());return Promise.all(e)}}function k(e){let t=M;return void 0!==E[e]&&(t=E[e]),new t}var R=Object.create(null);return R.generateInterpreter=function(e,t){let n;return n=void 0!==t?new Promise(((n,r)=>{if(!t.a2x)return n(k(e));require(["DS/WAfrControlledHandlers/mod_ControlledHandlerInterpreter"],(e=>{const t=e.ControlledHandlerInterpreter;return t?n(new t):r("Impossible to find the Handler interpreter constructor.")}),r)})):Promise.resolve(k(e)),n},R.DefaultHandlerInterpreter=M,R}));